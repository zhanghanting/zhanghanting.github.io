<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>linux中java web的服务注册流程</title>
    <url>/2021/01/18/linux%E4%B8%ADjava-web%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>资料参考链接：<a href="https://zhuanlan.zhihu.com/p/81527659" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/81527659</a></p>
<p>步骤如下：</p>
<p>1.创建可执行的shell脚本执行java web程序 start.sh</p>
<p>shell脚本的绝对路径为：/home/redpeak/shanmei/largeScreen/merge/start.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/jdk64/jdk1.8.0_112</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">nohup java -jar /home/redpeak/shanmei/largeScreen/merge/customer-analysis-0.0.1-SNAPSHOT.jar 1&gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>2.注册服务</p>
<p>vim /etc/systemd/system/shanmeilargeScreen.service</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Java web shanmei largeScreen service</span><br><span class="line"></span><br><span class="line">After=nerwork.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line"></span><br><span class="line">ExecStart=/bin/bash /home/redpeak/shanmei/largeScreen/merge/start.sh</span><br><span class="line">ExecStop=/bin/kill -s QUIT $MAINPID</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>3.设置服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">systemctl daemon-reload</span></span><br><span class="line"><span class="meta">#</span><span class="bash">systemctl start shanmeilargeScreen.service</span></span><br><span class="line"><span class="meta">#</span><span class="bash">systemctl <span class="built_in">enable</span> shanmeilargeScreen.service</span></span><br><span class="line"><span class="meta">#</span><span class="bash">systemctl status shanmeilargeScreen.service</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>4.Flink任务调度原理</title>
    <url>/2021/01/08/flink/4.Flink%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="任务调度原理"><a href="#任务调度原理" class="headerlink" title="任务调度原理"></a>任务调度原理</h1><p><img src="https://i.loli.net/2021/01/08/fAl7MEDvPsinOHX.png" alt="image-20210108192445820"></p>
<p> 1）怎么实现并行计算？</p>
<p>多线程，不同的任务在不同的线程上运行</p>
<p>2）并行的任务需要多少个slot？</p>
<p>跟最大并行度有关</p>
<p>3）一个流处理程序，到底包含多少个任务？</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>flink</category>
      </categories>
  </entry>
  <entry>
    <title>3.flink任务提交流程</title>
    <url>/2021/01/07/flink/3.flink%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-Flink任务提交流程（YARN）"><a href="#1-Flink任务提交流程（YARN）" class="headerlink" title="1.Flink任务提交流程（YARN）"></a>1.Flink任务提交流程（YARN）</h1><p>1）Flink client向Dispatcher提交应用程序</p>
<p>2）Dispatcher将应用程序转发给JobManager</p>
<p>3）JobManager向Flink ResourceManager申请运行作业需要的资源</p>
<p>4）Flink ResourceManager向资源管理框架YARN的resourceManager申请任务运行需要的资源</p>
<p>5）YARN ResourceManager到可用的NodeManager上启动container，启动applicationMaster</p>
<p>6）再到可用的NodeManager上启动taskManager，taskManager向YARN ResourceManager注册启动的资源</p>
<p>7）启动的taskManager向JobManager提供slot资源</p>
<p>8）JobManager将任务提交到taskManager上运行</p>
<p><img src="https://i.loli.net/2021/01/08/igS9TfpWl5zaNuq.png" alt="image-20210108190528386"></p>
<p><img src="https://i.loli.net/2021/01/08/IuWiBVHSjQ81MeG.png" alt="image-20210108190635964"></p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>flink</category>
      </categories>
  </entry>
  <entry>
    <title>2.flink运行时架构</title>
    <url>/2021/01/07/flink/2.flink%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="1-Flink运行架构"><a href="#1-Flink运行架构" class="headerlink" title="1.Flink运行架构"></a>1.Flink运行架构</h1><h2 id="1-1-Flink运行时组件"><a href="#1-1-Flink运行时组件" class="headerlink" title="1.1 Flink运行时组件"></a>1.1 Flink运行时组件</h2><p><img src="https://i.loli.net/2021/01/07/JLigmDrAGUHS2s9.png" alt="image-20210107200452768"></p>
<p>1）JobManager</p>
<pre><code>控制一个应用程序执行的主进程，也就是说，每个应用程序都会被一个不同的JobManager所控制执行。</code></pre><p>​    JobManager会先接收到需要执行的应用程序，这个应用程序会包括：作业图（JobGraph）,逻辑数据流图(logical dataflow graph)和打包了所有的类，库和其它资源的JAR包。</p>
<p>​    JobManager会把JobGraph转换成一个物理层面的数据流图-ExecutionGraph，包含了所有可以并发执行的任务。    </p>
<p>​    JobManager会向资源管理器请求执行任务必要的资源，也就是taskManager的slot。一旦它获取了足够的资源，就会将executionGraph分发到真正运行它们的taskManager上。在运行过程中，JobManager会负责所有需要中央协调的操作，比如说检查点的协调。</p>
<p>2）TaskManager</p>
<p>​    taskManager是flink中的工作进程，通常在flink中会有多个taskManager运行，每一个taskManager都包含了一定数量的插槽（slots）。插槽数量限制了taskManager能够执行的任务数量。</p>
<p>​    在taskManager启动之后，taskManager会向资源管理器注册它的插槽；收到资源管理器的指令后，taskManager就会将一个或多个插槽供给JobManager调用。JobManager就可以向插槽分配任务(task)来执行了。</p>
<p>​    在执行过程中，一个taskManager可以跟其它运行同一应用程序的taskManager交换数据。</p>
<p>3）ResourceManager</p>
<pre><code>主要负责管理taskManager的slot。taskManager的slot是flink中定义的处理资源单元。</code></pre><p>​    Flink为不同的环境和资源管理工具提供了不同资源管理器，比如YARN，Mesos,K8s,以及standalone部署</p>
<p>​    当JobManager申请slot资源时，resourceManager会将有空闲插槽的taskManager分配给JobManager。如果resourceManager没有足够的slot来满足JobManager的请求，它还可以向资源提供平台发起会话，以提供启动taskManager的容器</p>
<p>4）Dispatcher</p>
<pre><code>为应用提交提供了REST接口。当一个应用被提交执行时，分发器就会启动并将应用移交给一个JobManager。Dispatcher也会启动一个Web UI，用来方便地展示和监控作业执行的信息。</code></pre><p>​    Dispatcher在架构中可能并不是必需的，这取决于应用提交运行的方式。</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>flink</category>
      </categories>
  </entry>
  <entry>
    <title>采销分析</title>
    <url>/2021/01/07/hongshan/shanmei/%E9%87%87%E9%94%80%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>客户分析</title>
    <url>/2021/01/07/hongshan/shanmei/%E5%AE%A2%E6%88%B7%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>1.flink入门</title>
    <url>/2021/01/06/flink/1.flink%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="第一章-flink概述"><a href="#第一章-flink概述" class="headerlink" title="第一章 flink概述"></a>第一章 flink概述</h1><h2 id="1-1-什么是flink"><a href="#1-1-什么是flink" class="headerlink" title="1.1 什么是flink"></a>1.1 什么是flink</h2><p>apache flink是一个同时具备低延迟、高吞吐、高性能基于事件驱动的的分布式流式处理引擎，在2014年12月份成为apache基金会的顶级项目</p>
<h2 id="1-2-flink特点"><a href="#1-2-flink特点" class="headerlink" title="1.2 flink特点"></a>1.2 flink特点</h2><p>1）低延迟、高吞吐、高性能</p>
<p>2）支持事件时间</p>
<p>3）支持有状态计算</p>
<p>4）支持exactly once精准一次行消费</p>
<p>5）基于轻量级分布式快照实现的容错</p>
<h1 id="第二章-flink部署"><a href="#第二章-flink部署" class="headerlink" title="第二章 flink部署"></a>第二章 flink部署</h1><h2 id="2-1-local"><a href="#2-1-local" class="headerlink" title="2.1 local"></a>2.1 local</h2><h2 id="2-2-standalone"><a href="#2-2-standalone" class="headerlink" title="2.2 standalone"></a>2.2 standalone</h2><h2 id="2-3-yarn"><a href="#2-3-yarn" class="headerlink" title="2.3 yarn"></a>2.3 yarn</h2><p>1）session-cluster模式</p>
<p><img src="https://i.loli.net/2021/01/06/AWiIRVxyrsTgNLE.png" alt="image-20210106200804148"></p>
<p>基于当前的yarn session会话创建的flink集群，所有提交的job都是基于当前的会话提交到同一个集群中，资源永远保持不变，如果资源满了，下一个job就无法提交，只能等到yarn中的其中一个作业执行完成后，释放了资源，下个作业才会正常提交。所有作业共享Dispatcher和ResourceManager；共享资源；适合规模小执行时间短的作业。</p>
<p>启动yarn-session</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">./yarn-session.sh -n <span class="number">2</span> -s <span class="number">2</span> -jm <span class="number">1024</span> -tm <span class="number">1024</span> -nm test -d</span><br><span class="line">其中：</span><br><span class="line">-n(--container)：<span class="type">TaskManager</span>的数量。</span><br><span class="line">-s(--slots)：	每个<span class="type">TaskManager</span>的slot数量，默认一个slot一个core，默认每个taskmanager的slot的个数为<span class="number">1</span>，有时可以多一些taskmanager，做冗余。</span><br><span class="line">-jm：<span class="type">JobManager</span>的内存（单位<span class="type">MB</span>)。</span><br><span class="line">-tm：每个taskmanager的内存（单位<span class="type">MB</span>)。</span><br><span class="line">-nm：yarn 的appName(现在yarn的ui上的名字)。 </span><br><span class="line">-d：后台执行。</span><br></pre></td></tr></table></figure>

<p>执行任务</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">/flink run -c com.atguigu.wc.<span class="type">StreamWordCount</span>  <span class="type">FlinkTutorial</span><span class="number">-1.0</span>-<span class="type">SNAPSHOT</span>-jar-<span class="keyword">with</span>-dependencies.jar</span><br></pre></td></tr></table></figure>

<p>取消yarn session</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">yarn application --kill application_1577588252906_0001</span><br></pre></td></tr></table></figure>



<p>2）per-job-cluster</p>
<p><img src="https://i.loli.net/2021/01/06/QJ8SdBlN2GZAYRc.png" alt="image-20210106200848099"></p>
<p>一个Job会对应一个集群，每提交一个作业会根据自身的情况，都会单独向yarn申请资源，直到作业执行完成，一个作业的失败不会影响到其它作业。独享Dispatcher和ResourceManager，按需接收资源申请；适合规模大长时间运行的作业。任务之间互不影响方便管理。适合大规模长时间占用资源的作用。</p>
<p>不用启动yarn-session，直接执行job</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">./flink run –m yarn-cluster -c com.atguigu.wc.<span class="type">StreamWordCount</span>  <span class="type">FlinkTutorial</span><span class="number">-1.0</span>-<span class="type">SNAPSHOT</span>-jar-<span class="keyword">with</span>-dependencies.jar</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
        <category>flink</category>
      </categories>
  </entry>
  <entry>
    <title>登录状态的环境变量</title>
    <url>/2020/06/29/%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>登录脚本的执行顺序【注：仅适用于bash shell】</p>
<h1 id="1-Login-Shell"><a href="#1-Login-Shell" class="headerlink" title="1.Login Shell"></a>1.Login Shell</h1><p>​    是指登录时，需要提供用户名密码的shell，如 su - user1,图形登录，ctrl+alt+F2-6进入的登录界面</p>
<p>​    这种Login shell执行脚本的顺序：</p>
<p>①/etc/profile 【全局profile文件；它定义了LoginUser的PATH，USER，LOGNAME（登录使用者账号）】</p>
<p>②/etc/profile.d/目录下的脚本</p>
<p>③~/.bash_profile【搜索命令的路径——登录级别  环境变量配置文件】</p>
<p>④~/.bashrc 【存储用户设定的别名和函数—-shell级别  环境变量配置文件】</p>
<p>⑤/etc/bashrc 【全局bashrc文件；它主要定义一些Function和Alias；更改/etc/bashrc会影响到所有用户，由root用户管理】</p>
<h1 id="2-Non-Login-shell"><a href="#2-Non-Login-shell" class="headerlink" title="2.Non-Login shell"></a>2.Non-Login shell</h1><p>登录终端后，使用ssh登录其它机器</p>
<p>​    非登录shell指的是，不需要输入用户名密码的shell，如图形化界面中右键terminal打开的shell</p>
<p>​    这种Non-Login shell执行登录脚本的顺序：</p>
<p>​    ①~/.bashrc</p>
<p>​    ②/etc/bashrc    </p>
<p>​    ③/etc/profile.d/目录下的脚本</p>
<p>每次开启shell时，系统都会加载一些预先定义的脚本，这些脚本中有一些预先定义的变量！</p>
<p>可以在  用户家目录/.bashrc文件中添加：</p>
<p>source /etc/profile</p>
<p>在No-Login shell,多见于集群的群起命令，中可以读取到/etc/profile配置的变量！</p>
]]></content>
      <categories>
        <category>Hadoop生态</category>
      </categories>
  </entry>
  <entry>
    <title>Scala</title>
    <url>/2020/06/28/Scala/</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-Scala简介"><a href="#1-Scala简介" class="headerlink" title="1.Scala简介"></a>1.Scala简介</h2>]]></content>
      <categories>
        <category>Hadoop生态</category>
      </categories>
  </entry>
  <entry>
    <title>HBase</title>
    <url>/2020/06/22/HBase/</url>
    <content><![CDATA[<h1 id="一、NoSQL简介"><a href="#一、NoSQL简介" class="headerlink" title="一、NoSQL简介"></a>一、NoSQL简介</h1><p>​    是什么？</p>
<p>​        NoSQL是Not Only SQL三个单词的缩写！目前泛指非关系型数据库！</p>
<p>​        NoSQL数据库通常是一个分布式系统，基于CAP定理设计，性能通常比关系型数据库要强悍！但是在一致性上，一般情况下，为了性能会牺牲部分一致性！大部分NoSQL都是最终一致性！</p>
<p>​        CAP定理：任何分布式系统只能在强一致性，高可用性，分区容错性中选择其中的两个优势进行开发，无法三者兼顾！</p>
<p>​        NoSQL和关系型数据库相辅相成，各自有各自的使用场景，谁也不能完全替代谁！</p>
<h1 id="二、HBase简介"><a href="#二、HBase简介" class="headerlink" title="二、HBase简介"></a>二、HBase简介</h1><h2 id="1-由来"><a href="#1-由来" class="headerlink" title="1.由来"></a>1.由来</h2><p>​    由Google的BigTable论文实现而来，是Hadoop生态的一部分！</p>
<h2 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2.介绍"></a>2.介绍</h2><p>​    HBase是一个分布式，可扩展的基于版本号的，大数据存储的NoSQL数据库！</p>
<p>​    HBase基于HDFS！</p>
<p>​    使用场景：当需要对十亿行*百万列的表，进行实时和随机读写！</p>
<h2 id="3-随机读写"><a href="#3-随机读写" class="headerlink" title="3.随机读写"></a>3.随机读写</h2><p>​    HDFS只支持追加写，不支持随机写！</p>
<p>​    insert     追加写</p>
<p>​    update+delete     随机写</p>
<p>​    实现随机写的update+delete，需要</p>
<p>​    1）借助hdfs追加操作+时间戳（版本号）</p>
<p>​    2）只允许客户端返回时间戳最新（版本号最大）的数据</p>
<h2 id="4-实时读写"><a href="#4-实时读写" class="headerlink" title="4.实时读写"></a>4.实时读写</h2><p>​    如何做到海量数据的实时读写？</p>
<p>​    1）海量数据，那必须是分布式的</p>
<p>​    2）要快，那就要借助内存，将数据不管是读还是写全部放入内存</p>
<p>​    3）同时还要用到索引     LSMtree</p>
<p>​    4）K-V结构存储</p>
<p>​    5）列式存储（HFile）</p>
<p>​    6）布隆过滤器（在查询时，判断数据库是否一定没有这条数据或者可能有这条数据）</p>
<h1 id="三、安装"><a href="#三、安装" class="headerlink" title="三、安装"></a>三、安装</h1><h2 id="1-环境要求"><a href="#1-环境要求" class="headerlink" title="1.环境要求"></a>1.环境要求</h2><p>1）安装了ZK，启动ZK</p>
<p>2）安装了Hadoop，启动HDFS</p>
<p>3）安装了JDK，配置了JAVA_HOME</p>
<h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h2><p>1）编辑conf/hbase-env.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">不适用HBase自带的zk,使用自己集群安装的</span></span><br><span class="line">export HBASE_MANAGES_ZK=false</span><br></pre></td></tr></table></figure>

<p>2）编辑hbase-site.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--hbase在hdfs上存储的根目录 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span>     </span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span>     </span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop102:9820/HBase<span class="tag">&lt;/<span class="name">value</span>&gt;</span>   </span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--是否以分布式启动hbase --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span>   </span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--hbase使用的zk实例的地址 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span>    </span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	     <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102,hadoop103,hadoop104<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--每个版本的hbase，都是基于自己的hadoop编译的 </span></span><br><span class="line"><span class="comment">	当前版本的hbase 默认对应的是 2.8.5的hadoop</span></span><br><span class="line"><span class="comment">	如果集群的hadoop不是 2.8.5，会报错兼容性问题，加上以下两个参数，否则Master进程无法启动</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	解决： 下载hbase当前版本的源码，在编译时，指定编译的hadoop环境为集群对应的版本(3.1)，就不需要加以下两个参数</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.unsafe.stream.capability.enforce<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.wal.provider<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>filesystem<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="四、启动"><a href="#四、启动" class="headerlink" title="四、启动"></a>四、启动</h1><h2 id="1-单启"><a href="#1-单启" class="headerlink" title="1.单启"></a>1.单启</h2><p>master</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase-daemon.sh start master</span><br></pre></td></tr></table></figure>

<p>regionserver</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase-daemon.sh start regionserver</span><br></pre></td></tr></table></figure>

<h2 id="2-验证启动"><a href="#2-验证启动" class="headerlink" title="2.验证启动"></a>2.验证启动</h2><p>1）jps查看</p>
<p>2）访问web页面</p>
<table>
<thead>
<tr>
<th>进程名</th>
<th>协议</th>
<th>端口</th>
</tr>
</thead>
<tbody><tr>
<td>master</td>
<td>RPC</td>
<td>16000</td>
</tr>
<tr>
<td>master</td>
<td>HTTP</td>
<td>16010</td>
</tr>
<tr>
<td>regionserver</td>
<td>RPC</td>
<td>16020</td>
</tr>
<tr>
<td>regionserver</td>
<td>HTTP</td>
<td>16030</td>
</tr>
</tbody></table>
<h2 id="3-群起"><a href="#3-群起" class="headerlink" title="3.群起"></a>3.群起</h2><p>集群通常是启动一个master，除非是HA，会启动备用的master</p>
<p>通常是regionserver希望群起多个！</p>
<p>实现：希望在哪个机器上运行群起命令，就编辑哪个机器的conf/regionservers文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/hbase-daemons.sh start regionserver</span><br></pre></td></tr></table></figure>

<h2 id="4-一键启动"><a href="#4-一键启动" class="headerlink" title="4.一键启动"></a>4.一键启动</h2><p>以下命令停止当前机器的master进程，停止所有的regionserver，以下命令在master进程所在的机器上使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stop-hbase.sh</span><br></pre></td></tr></table></figure>

<p>执行以下脚本时，会启动当前机器的master，再读取conf/regionservers，启动文件中配置的节点的regionserver!</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start-hbase.sh</span><br></pre></td></tr></table></figure>



<h1 id="五、核心概念"><a href="#五、核心概念" class="headerlink" title="五、核心概念"></a>五、核心概念</h1><p>namespace：hbase中的库，在hdfs上就是一个目录！</p>
<p>table：hbase中的表，在hdfs上就是库下的一层子目录！</p>
<p>region：region是表目录下的子目录！</p>
<p>column family：列族是region下的一层目录</p>
<p>数据：数据以文件的形式存储在列族的目录下！每个文件称为一个StoreFile！文件的格式是HFile格式！</p>
<p>​    </p>
<h1 id="六、使用HBase"><a href="#六、使用HBase" class="headerlink" title="六、使用HBase"></a>六、使用HBase</h1><h2 id="1-同步集群时间"><a href="#1-同步集群时间" class="headerlink" title="1.同步集群时间"></a>1.同步集群时间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xcall.sh sudo ntpdate -u 'ntp1.alliyun.com'</span><br></pre></td></tr></table></figure>



<h2 id="2-使用hbase-shell"><a href="#2-使用hbase-shell" class="headerlink" title="2.使用hbase shell"></a>2.使用hbase shell</h2><p>注意：1）命令后不跟分号</p>
<p>​            2）如果误输入分号，需要两下’（单引号）结束</p>
<p>​            3）help ‘命令’：查看某个命令的帮助</p>
<p>​            4）不支持中文</p>
<h1 id="七、读写流程"><a href="#七、读写流程" class="headerlink" title="七、读写流程"></a>七、读写流程</h1><h2 id="1-读流程"><a href="#1-读流程" class="headerlink" title="1.读流程"></a>1.读流程</h2><p>get可以由scan一条记录实现，其实get都会转化为scan</p>
<p>get ‘t1’,’r1’,’cf1’,’name’</p>
<p>数据可能存在以下三个地方，列族的memstore中,HFile (Store File)中，BlockCache中，读请求需要RegionServer来进行处理！</p>
<p>请求哪个regionserver？</p>
<p>①1个region对应一个regionserver，先确定要查询的数据到底在哪个region中</p>
<p>​    在查询时，根据要查询数据所在的表名，就可以查到这个表有哪些region！</p>
<p>​    再根据要查询数据的rowkey，参考region的startkey和endkey就可以确定当前数据所在的region！</p>
<p>②再找到这个region对应的regionserver</p>
<p>​    不管是region和regionserver的对应信息，还是region的startkey和endkey，这些都属于表的元数据信息，所有的元数据信息都存储在hbase:meta中</p>
<p>读流程：</p>
<p>①客户端，向hbase所在的zk集群，查询/hbase/meta-region-server,获取hbase-metab表所在的regionserver</p>
<p>②请求，hbase:meta表所在的regionserver，获取hbase中表的元数据信息，将信息缓存到客户端本地，方便之后的查询</p>
<p>③根据hbase中表的元数据信息，获取当前要查询的数据在哪个region，以及这个region对应的regionserver</p>
<p>④向regionserver发送读请求</p>
<p>⑤regionserver处理读请求，从memstore中，HFile（StoreFile）中，BlockCache中取出指定的数据，将数据合并后，只返回指定时间戳或最新时间戳的数据。</p>
<p>​    regionserver在处理读请求时，根据所查询的store，初始化两种扫描器</p>
<p>​            MemstoreScanner：负责扫描store的memstore</p>
<p>​            StoreFileScanner：负责扫描列族下的storefile文件！在扫描StoreFile文件时，先查看blockcache中返回数据，无需再扫描storefile文件！</p>
<p>​            如果blockcache中没有数据，只能扫描storefile，将扫描到的数据放入到blockcache,供下次查询！</p>
<p>​            blockcache默认占用Regionserver所在堆的40%，blockcache默认会采用LRU(less recent use)的回收策略</p>
<p>，对符合条件的对象进行回收！blockcache在storefile中的数据更新时，缓存也会自动失效！</p>
<h2 id="2-写流程"><a href="#2-写流程" class="headerlink" title="2.写流程"></a>2.写流程</h2><h3 id="2-1写流程概述"><a href="#2-1写流程概述" class="headerlink" title="2.1写流程概述"></a>2.1写流程概述</h3><p>put ‘t1’,’r1’,’cf1:name’,”jack”</p>
<p>①数据要写入哪个region</p>
<p>②这个region由哪个regionserver</p>
<p>写流程：</p>
<p>①客户端，向hbase所在的zk集群，查询/hbase/meta-region-server，获取hbase-meta表所在的regionserver</p>
<p>②请求，hbase:meta表所在regionserver，获取hbase中表的元数据信息，将信息缓存到客户端本地，方便之后的查询</p>
<p>③根据hbase中表的元数据信息，获取当前要写的数据要写入哪个region，以及这个region对应的regionserver</p>
<p>④向regionserver发送写请求</p>
<p>⑤写请求会被当前regionserver的wal对象，将写的信息持久化到wal Logs中</p>
<p>⑥将数据写入到指定region所对应的store对象的memstore中</p>
<p>⑦响应客户端，写入完成！</p>
<h3 id="2-2-写流程源码"><a href="#2-2-写流程源码" class="headerlink" title="2.2 写流程源码"></a>2.2 写流程源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doMiniBatchMutate</span><span class="params">(BatchOperation&lt;?&gt; batchOp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// STEP 1. 尝试获取尽可能多的写入操作需要使用的锁</span></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      <span class="comment">// STEP 2.如果插入的value没有指定时间戳，尝试使用服务器(regionserver所在机器)上最新的时间戳作为value的时间戳</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">      <span class="comment">// STEP 3. 构建一个WAL Edit对象</span></span><br><span class="line">     </span><br><span class="line">      <span class="comment">// STEP 4. 将最新的写操作的信息，封装到一个WALEdit对象中，将对象追加到</span></span><br><span class="line">        <span class="comment">// WALEdits集合中，再sync(将对象中的数据持久化到磁盘的log文件中).</span></span><br><span class="line">     </span><br><span class="line">      <span class="comment">// STEP 5. 将数据写入到列族的memstore中</span></span><br><span class="line">      <span class="comment">// <span class="doctag">NOTE:</span> writeEntry can be null here</span></span><br><span class="line">      writeEntry = batchOp.writeMiniBatchOperationsToMemStore(miniBatchOp, writeEntry);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// STEP 6. CP ： Cooprocessor（协处理器，类似Mysql中的触发器）</span></span><br><span class="line">        <span class="comment">// 在最后，WAL对象sync操作(将数据持久化到磁盘时),如果发生错误，就执行后续处理</span></span><br><span class="line">       </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h1 id="八、hbase的其它操作"><a href="#八、hbase的其它操作" class="headerlink" title="八、hbase的其它操作"></a>八、hbase的其它操作</h1><h2 id="1-flush"><a href="#1-flush" class="headerlink" title="1.flush"></a>1.flush</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>flush：将memstore中的数据，刷写到StoreFile文件中</p>
<h3 id="1-2-意义"><a href="#1-2-意义" class="headerlink" title="1.2 意义"></a>1.2 意义</h3><p>①memstore将写入的数据缓存在内存中，一旦内存满了，一定要刷写</p>
<p>②在刷写时，hbase还会将一些无用的数据，进行舍弃，节省磁盘空间</p>
<p>③在刷写时，还会对memstore中的rowkey进行排序，方面后面检索</p>
<p>列族的{NAME =&gt; ‘cf1’,VERSIONS=’3’}属性，代表每个StoreFile中最多存3个版本</p>
<h3 id="1-3-手动刷写"><a href="#1-3-手动刷写" class="headerlink" title="1.3 手动刷写"></a>1.3 手动刷写</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush &#39;表名&#39;</span><br><span class="line">flush &#39;region&#39;</span><br></pre></td></tr></table></figure>

<p>通过以下命令查看书写的HFile文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase org.apache.hadoop.hbase.io.hfile.HFile -p -f ‘hdfs路径’</span><br></pre></td></tr></table></figure>

<h3 id="1-4自动刷写"><a href="#1-4自动刷写" class="headerlink" title="1.4自动刷写"></a>1.4自动刷写</h3><h4 id="①基于memstore的刷写"><a href="#①基于memstore的刷写" class="headerlink" title="①基于memstore的刷写"></a>①基于memstore的刷写</h4><p>​    当某个memstore的大小达到了hbase.hregion.memstore.flush.size(默认128M)，其所在region的所有memstore都会被刷写。</p>
<p>​    这也是HBase不建议设置过多列族的原因之一，因为列族过多，刷写时，系统的IO压力越大！</p>
<p>​    当memstore的大小达到了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase.hregion.memstore.flush.size（默认值128M）</span><br><span class="line">*</span><br><span class="line">hbase.hregion.memstore.block.multiplier（默认值4）</span><br></pre></td></tr></table></figure>

<p>时，会阻止继续往该memstore写数据</p>
<h4 id="②基于RegionServer的刷写"><a href="#②基于RegionServer的刷写" class="headerlink" title="②基于RegionServer的刷写"></a>②基于RegionServer的刷写</h4><p>一旦一个RegionServer所负责的多个region的memstore的总大小总和超过以下值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java_heapsize</span><br><span class="line">*hbase.regionserver.global.memstore.size（默认值0.4）</span><br><span class="line">*hbase.regionserver.global.memstore.size.lower.limit（默认值0.95）</span><br></pre></td></tr></table></figure>

<p>整个RegionServer所负责的所有memstore由大到小，依次刷写，直到低于上述值</p>
<p>当一个RegionServer所负责的多个Region的memstore大小总和超过以下值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java_heapsize</span><br><span class="line">*hbase.regionserver.global.memstore.size（默认值0.4）</span><br></pre></td></tr></table></figure>

<p>当前regionserver的所有memstore都会阻塞</p>
<h4 id="③基于默认刷写时间的刷写"><a href="#③基于默认刷写时间的刷写" class="headerlink" title="③基于默认刷写时间的刷写"></a>③基于默认刷写时间的刷写</h4><p>默认每</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase.regionserver.optionalcacheflushinterval（默认1小时）</span><br></pre></td></tr></table></figure>

<h4 id="④基于wal文件的刷写"><a href="#④基于wal文件的刷写" class="headerlink" title="④基于wal文件的刷写"></a>④基于wal文件的刷写</h4><p>​    当前wal文件的数量超过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase.regionserver.max.logs</span><br></pre></td></tr></table></figure>

<p>​    也会触发memstore的刷写！</p>
<h2 id="2-Compaction"><a href="#2-Compaction" class="headerlink" title="2.Compaction"></a>2.Compaction</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>​    HBase需要借助hdfs进行存储！数据以HFile(StoreFile)的形式存储在hdfs上！</p>
<p>​    HDFS不适合存储大量的小文件，会降低NameNode服役能力！</p>
<p>现象：每次flush，都会生成一个文件，不是所有memstore flush时，都是满足128M才触发的！</p>
<p>解决：hbase会定期自动执行compact合并，将多个小文件，合并重写为1个文件！</p>
<h3 id="2-2-分类"><a href="#2-2-分类" class="headerlink" title="2.2 分类"></a>2.2 分类</h3><p>minorCompaction: 小合并</p>
<p>majorCompaction: 主合并</p>
<p>majorCompaction会将整个列族目录中所有的StoreFile都进行运算，合并，并且会清理掉过期和删除的数据！</p>
<p>minorCompaction每次只会合并一定数量（默认是10个）的HFile合并成一个较大HFile，但不会清理过期和删除的数据！</p>
<h3 id="2-3-手动合并"><a href="#2-3-手动合并" class="headerlink" title="2.3 手动合并"></a>2.3 手动合并</h3><p>minorcompact</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compact</span><br></pre></td></tr></table></figure>

<p>majorcompact</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">major_compact</span><br></pre></td></tr></table></figure>



<h2 id="3-RegionSplit"><a href="#3-RegionSplit" class="headerlink" title="3.RegionSplit"></a>3.RegionSplit</h2><p>​    每张表，一开始只有一个region，一旦region中的数据，不断增多，达到一定条件，hbase会自动切割region!切割后，将region一分为二，将region交给不同的regionserver，目的是负载均衡！</p>
<p>​    当前2.2.4使用org.apache.hadoop.hbase.regionserver.SteppingSplitPolicy作为切分策略！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">getSizeToCheck</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> tableRegionsCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tableRegionsCount == <span class="number">1</span>  ? <span class="keyword">this</span>.initialSize : getDesiredMaxFileSize();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​    regionserver调用getSizeToChec()，来检查当前region是否达到切分的条件！</p>
<p>​    tableRegionsCount： 为当前Region Server中属于该Table的region的个数。</p>
<p>​        策略： 如果当前Region Server中属于该Table的region的个数为1，那么一旦这个region大小达到initialSize时，就切分。否则，只要Region Server中属于该Table的region的个数不为1，那么就尝试获取hbase.hregion.max.filesize所配置的参数值，如果没有配置，默认为10G。</p>
<p>initialSize如何确定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureForRegion</span><span class="params">(HRegion region)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.configureForRegion(region);</span><br><span class="line">    Configuration conf = getConf();</span><br><span class="line">    <span class="comment">//从配置中读取hbase.increasing.policy.initial.size，如果没有配置，默认为-1</span></span><br><span class="line">    <span class="comment">// 如果用户配置了此参数， initialSize=用户定义的值</span></span><br><span class="line">    initialSize = conf.getLong(<span class="string">"hbase.increasing.policy.initial.size"</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (initialSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取region对应的表的描述</span></span><br><span class="line">    TableDescriptor desc = region.getTableDescriptor();</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取表memstore刷写的大小 * 2 </span></span><br><span class="line">      initialSize = <span class="number">2</span> * desc.getMemStoreFlushSize();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果自己配的值非法</span></span><br><span class="line">    <span class="keyword">if</span> (initialSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 重新赋值为2*128M</span></span><br><span class="line">      initialSize = <span class="number">2</span> * conf.getLong(HConstants.HREGION_MEMSTORE_FLUSH_SIZE,</span><br><span class="line">                                     TableDescriptorBuilder.DEFAULT_MEMSTORE_FLUSH_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>initialSize 如果不定义，默认就为256M！</p>
<p>T3表，一开始只有1个Region,由regionserver 102 负责，</p>
<p>一旦这个region，默认在256M时，一分为二。</p>
<p>情形一： region1 由102负责</p>
<p>​                region2 由103负责</p>
<p>​        下次102的region1达到256M,再自动切分！</p>
<p>情形二： region1 由102负责</p>
<p>​                region2 由102负责</p>
<p>​        下次region1 /region2 其中一个达到10G时，再切分！</p>
<h1 id="九、API"><a href="#九、API" class="headerlink" title="九、API"></a>九、API</h1><h2 id="1-Connection"><a href="#1-Connection" class="headerlink" title="1.Connection"></a>1.Connection</h2><p>​    Connection会产生一个低级别的直连hbase的连接，还包含一个连接zk集群的连接</p>
<p>可以通过以下方式创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection connection = ConnectionFactory.createConnection(configuration);</span><br></pre></td></tr></table></figure>

<p>​    Connection的生命周期由调用者管理，执行close关闭连接，释放资源！</p>
<p>​    Connection可以自动连接master，定位region等！这些功能以及集群的连接，可以被Connection创建出的Table和Admin实例共享！</p>
<p>​    Connection的创建是重量级的，不建议经常创建，通常一个客户端创建一次即可！Connection是线程安全的，可以在不同的线程中共享一个实例！</p>
<p>​    Admin和Table是轻量级的，不是线程安全的，因此每个线程都有自己的Table和Admin对象，不建议池化或缓存！</p>
<h2 id="2-Table"><a href="#2-Table" class="headerlink" title="2.Table"></a>2.Table</h2><p>​    Table是和hbase的某个表进行交流的实例，可以使用Table对象，进行put，get，scan，delete等操作！</p>
<p>​    获取Table：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection.getTable()</span><br></pre></td></tr></table></figure>

<p>​    关闭：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Table.close()</span><br></pre></td></tr></table></figure>

<h2 id="3-Admin"><a href="#3-Admin" class="headerlink" title="3.Admin"></a>3.Admin</h2><p>​    Admin负责进行list,create,alter,enable等管理性的操作</p>
<p>​    创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection.getAdmin()</span><br></pre></td></tr></table></figure>

<p>​    关闭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Admin.close()</span><br></pre></td></tr></table></figure>

<h2 id="4-NameSpaceDescriptor"><a href="#4-NameSpaceDescriptor" class="headerlink" title="4.NameSpaceDescriptor"></a>4.NameSpaceDescriptor</h2><p>​    NameSpaceDescriptor代表一个namespace的描述对象，这个对象中记录了NameSpace所有的属性，例如库名，库的属性等！</p>
<h2 id="5-HTableDescriptor"><a href="#5-HTableDescriptor" class="headerlink" title="5.HTableDescriptor"></a>5.HTableDescriptor</h2><p>​    HTableDescriptor代表了一个表的描述！</p>
<h1 id="十、整合Hive"><a href="#十、整合Hive" class="headerlink" title="十、整合Hive"></a>十、整合Hive</h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h2><p>HBase:本质是数据库，主要用于大表的实时读写</p>
<p>Hive：数据仓库中的数据分析软件，将HQL语句翻译为Map Reduce程序，对HDFS上已经存储的结构化数据进行计算！计算之前，需要根据HDFS上数据的形态进行建表映射！</p>
<p>Hive和HBase集成的目的是，使用Hive来分析HBase存储的数据</p>
<p>HBase本质上是一个NoSQL数据库，不支持使用SQL进行查询，数据分析工程师最熟悉和最常使用的就是SQL！如果没有Hive，可以自己编写MR程序对HBase上的数据进行一些复杂逻辑的分析！</p>
<h2 id="2-配置环境"><a href="#2-配置环境" class="headerlink" title="2.配置环境"></a>2.配置环境</h2><p>​    Hive默认只能分析HDFS上的数据，现在需要让Hive可以可以访问HBase！Hive作为客户端，读写HBase的数据，需要使用ZK信息。在hive-site.xml中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102,hadoop103,hadoop104<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>The list of ZooKeeper servers to talk to. This is only needed for read/write locks.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.zookeeper.client.port<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>The port of ZooKeeper servers to talk to. This is only needed for read/write locks.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3.使用场景"></a>3.使用场景</h2><h3 id="3-1-场景一"><a href="#3-1-场景一" class="headerlink" title="3.1 场景一"></a>3.1 场景一</h3><p>​    还没有将数据导入到hbase中，需要通过hive，将数据导入到hbase中！</p>
<p>​    建表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TABLE</span> ns2_person(</span><br><span class="line"> <span class="keyword">id</span> <span class="keyword">string</span>,</span><br><span class="line"> age <span class="built_in">int</span>,</span><br><span class="line"> <span class="keyword">name</span> <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">STORED</span> <span class="keyword">BY</span> <span class="string">'org.apache.hadoop.hive.hbase.HBaseStorageHandler'</span></span><br><span class="line"><span class="keyword">WITH</span> SERDEPROPERTIES (<span class="string">"hbase.columns.mapping"</span> = <span class="string">":key,info:age,cf1:name"</span>)</span><br><span class="line">TBLPROPERTIES (<span class="string">"hbase.table.name"</span> = <span class="string">"ns2:person"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-2-场景2"><a href="#3-2-场景2" class="headerlink" title="3.2 场景2"></a>3.2 场景2</h3><p>​    数据已经导入到hbase中，只需要在Hive上建表，映射，在hive上操作数据！</p>
<p>建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> ns2_t2(</span><br><span class="line"> <span class="keyword">id</span> <span class="keyword">string</span>,</span><br><span class="line"> age <span class="built_in">int</span>,</span><br><span class="line"> <span class="keyword">name</span> <span class="keyword">string</span>,</span><br><span class="line"> <span class="keyword">num</span> <span class="built_in">int</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">STORED</span> <span class="keyword">BY</span> <span class="string">'org.apache.hadoop.hive.hbase.HBaseStorageHandler'</span></span><br><span class="line"><span class="keyword">WITH</span> SERDEPROPERTIES (<span class="string">"hbase.columns.mapping"</span> = <span class="string">":key,cf1:age,cf1:name,cf1:num"</span>)</span><br><span class="line">TBLPROPERTIES (<span class="string">"hbase.table.name"</span> = <span class="string">"ns2:t2"</span>);</span><br></pre></td></tr></table></figure>



<p>注意：①hive的表名可以任意</p>
<p>​            ②hive中列的数量要和hbase表列的数据一致（rowkey是一个特殊的列）</p>
<p>​            ③hive中字段的数据类型，必须和hbase中的数据类型兼容</p>
<p>​            ④stored by ‘类名’是固定写法。stored by的含义是使用指定的类帮助完成数据的读写</p>
<p>​            ⑤hbase.columns.mapping代表hbase和hive中表字段的关系映射</p>
<p>​                hive中字段的顺序，要和映射关系中映射的字段顺序一致</p>
<p>​            ⑥hbase.table.name代表hive表要映射的hbase表的表名</p>
<p>​            ⑦目前的数据是存储在hbase上，如果是内部表，代表hive负责数据的生命周期。只能创建外部表</p>
<p>本地表和非本地表</p>
<p>​    本地表：hive表中的数据是直接存储在hdfs上，可以指定row format,指定store as</p>
<p>​    非本地表：hive表中的数据不是直接存储在hdfs上</p>
<p>​        不能写row format,不能写store as ,因为不同的存储设备对存储的格式是有不同的要求的，需要写 store by ‘类名’（这个类名，如果是去hbase中读取数据，就写hbase相应的类名，如果是去kafka中读数据，就写kafka对应的类名）</p>
<h1 id="十一、优化"><a href="#十一、优化" class="headerlink" title="十一、优化"></a>十一、优化</h1><h1 id="十二、Phoenix"><a href="#十二、Phoenix" class="headerlink" title="十二、Phoenix"></a>十二、Phoenix</h1><h2 id="1-表关系映射"><a href="#1-表关系映射" class="headerlink" title="1.表关系映射"></a>1.表关系映射</h2><table>
<thead>
<tr>
<th>Phoenix</th>
<th>HBase</th>
</tr>
</thead>
<tbody><tr>
<td>database</td>
<td>namespace</td>
</tr>
<tr>
<td>table</td>
<td>table</td>
</tr>
<tr>
<td>主键列</td>
<td>rowkey</td>
</tr>
<tr>
<td>其它列</td>
<td>cf:cq</td>
</tr>
</tbody></table>
<p>如果Phoenix中的主键是联合主键，联合主键整体拼接后和hbase的rowkey映射！</p>
<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><p>第一种情形：数据还没有在hbase中存储，希望通过Phoenix来创建一个表，使用Phoenix的语句向表中插入数据！</p>
<p>建表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> us_population(</span><br><span class="line">state <span class="built_in">char</span>(<span class="number">2</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">city <span class="built_in">varchar</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">population <span class="built_in">bigint</span>,</span><br><span class="line"><span class="keyword">constraint</span> my_pk primary <span class="keyword">key</span>(state,city)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>操作：</p>
<p>增/改：</p>
<p>upsert into us_population values(‘NY’,’abc’,10000);</p>
<p>删：</p>
<p>delete from us_population where population &gt; 10000;</p>
<p>查：</p>
<p>select * from us_population;</p>
<p>注意：</p>
<p>sqlline.py默认会将小写自动转为大写！如果不希望转换，可使用双引号！</p>
<p>如果在建表时，没有指定列族，hbase会自动创建名称为0的列族！</p>
<p>第二种情形：数据已经在hbase中（有表），希望通过Phoenix创建一个表来映射HBase中的表，执行操作！</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Hadoop生态</category>
      </categories>
  </entry>
  <entry>
    <title>Ganglia</title>
    <url>/2020/06/10/Ganglia/</url>
    <content><![CDATA[<h3 id="1-Ganglia基本概述"><a href="#1-Ganglia基本概述" class="headerlink" title="1. Ganglia基本概述"></a>1. Ganglia基本概述</h3><p>​    Ganglia由gmond,gmetad和gweb组成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gmon(Ganglia Monitoring Daemon)是一种轻量级服务，需要安装在每台需要收集指标数据的节点主机上。使用gmond,可以很容易收集很多系统指标数据，如CPU，内存，磁盘，网络和活跃进程的数据等。</span><br><span class="line">gmetad(Ganglia Meta Daemon)整合所有信息，并将其以RRD格式存储至磁盘的服务。</span><br><span class="line">gweb(Ganglia Web)Ganglia可视化工具，gweb是一种利用浏览器显示gmetad所存储数据的PHP前端。在Web界面中以图表方式展现集群的运行状态下收集的多种不同的指标数据。</span><br></pre></td></tr></table></figure>



<h3 id="2-安装部署"><a href="#2-安装部署" class="headerlink" title="2. 安装部署"></a>2. 安装部署</h3><h4 id="1）安装Ganglia"><a href="#1）安装Ganglia" class="headerlink" title="1）安装Ganglia"></a>1）安装Ganglia</h4><p>（1）规划</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop102:     web  gmetad gmod </span><br><span class="line">hadoop103:     gmod</span><br><span class="line">hadoop104:     gmod</span><br></pre></td></tr></table></figure>

<p>（2）在102 103 104分别安装epel-release  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 flume]$ sudo yum -y install epel-release</span><br></pre></td></tr></table></figure>

<p>（3）在102上安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 flume]$ sudo yum -y install ganglia-gmetad ganglia-web ganglia-gmond</span><br></pre></td></tr></table></figure>

<p>（4）在103和104安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 flume]$ sudo yum -y install ganglia-gmond</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Hadoop生态</category>
        <category>数据流监控（监控Flume）</category>
      </categories>
  </entry>
  <entry>
    <title>kafka</title>
    <url>/2020/06/10/kafka/</url>
    <content><![CDATA[<h3 id="第1章-kafka概述"><a href="#第1章-kafka概述" class="headerlink" title="第1章 kafka概述"></a>第1章 kafka概述</h3><h4 id="1-1-kafka的定义"><a href="#1-1-kafka的定义" class="headerlink" title="1.1 kafka的定义"></a>1.1 kafka的定义</h4><p>​    kafka是一个分布式的基于发布/订阅模式的消息队列，主要应用于大数据实时处理领域。</p>
<h4 id="1-2-消息队列"><a href="#1-2-消息队列" class="headerlink" title="1.2 消息队列"></a>1.2 消息队列</h4><h4 id="1-3-kafka基础架构"><a href="#1-3-kafka基础架构" class="headerlink" title="1.3 kafka基础架构"></a>1.3 kafka基础架构</h4><h5 id="1-3-1-重点综述"><a href="#1-3-1-重点综述" class="headerlink" title="1.3.1 重点综述"></a>1.3.1 重点综述</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）kafka集群</span><br><span class="line">	kafka集群可以有N台奇迹，每台称之为broker，每台机器都有自己的id，因此kafka集群中的N机器为：broker1,broker2,broker3...brokern</span><br><span class="line">2）Topic</span><br><span class="line">	kafka集群中可以创建N个Topic</span><br><span class="line">	每个Topic可以有多个分区（partition）</span><br><span class="line">	每个topic的每个分区可以有多个副本（replication），一个是leader，其它副本都是follower</span><br><span class="line">	同一个topic的多个分区可以存在于kafka集群的一个机器，但是同一个topic的同一个分区的多个副本不能存在于kafka集群的一个机器上</span><br><span class="line"></span><br><span class="line">3）消费者组</span><br><span class="line">	kafka是以消费者组为单位进行消息消费的</span><br><span class="line">	一个消费者组可以有一个或多个消费者</span><br><span class="line">4）Topic和消费者组</span><br><span class="line">	一个消费者组中的一个消费者可以同时消费一个topic中的多个分区的数据		</span><br><span class="line">	一个topic中的一个分区只能被同一个消费者组中的一个消费者消费</span><br><span class="line">	但是可以同时被多个消费者组中的一个消费者消费</span><br><span class="line">5）zookeeper</span><br><span class="line">	kafka集群工作需要基于zk</span><br><span class="line">	kafka的topic，partition，热评里餐厅等需要存储在zk中</span><br><span class="line">	在kafka0.9版本之前，消费者组的offset（消息队列读取消息的偏移量）也需要维护在zk中</span><br><span class="line">	但是0.9版本之后建议维护到kafka本地，当前2.4.1版本中已经不再支持zk维护offset</span><br></pre></td></tr></table></figure>



<h3 id="第2章-kafka架构深入"><a href="#第2章-kafka架构深入" class="headerlink" title="第2章 kafka架构深入"></a>第2章 kafka架构深入</h3><h4 id="2-1-kafka工作流程及文件存储机制"><a href="#2-1-kafka工作流程及文件存储机制" class="headerlink" title="2.1 kafka工作流程及文件存储机制"></a>2.1 kafka工作流程及文件存储机制</h4><p>​    Kafka中消息是以<strong>topic</strong>进行分类的，生产者生产消息，消费者消费消息，都是面向topic的。</p>
<p>​    topic是逻辑上的概念，而partition是物理上的概念，每个对应于一个目录，该目录中存储的就是生产的数据。生产的数据会被不断追加到该文件末端，且每条数据都有自己的。消费者组中的每个消费者，都会实时记录自己消费到了哪个，以便出错恢复时，从上次的位置继续消费。</p>
<p>​    由于生产者生产的消息会不断追加到log文件末尾，为防止log文件过大导致数据定位效率低下，Kafka采取了<strong>分片</strong>和<strong>索引</strong>机制，将每个partition分为多个segment。每个segment对应两个文件——“.index”文件和“.log”文件。这些文件位于一个文件夹下，该文件夹的命名规则为：topic名称+分区序号。例如，first这个topic有三个分区，则其对应的文件夹为first-0,first-1,first-2。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000000000000000.index</span><br><span class="line">00000000000000000000.log</span><br><span class="line">00000000000000170410.index</span><br><span class="line">00000000000000170410.log</span><br><span class="line">00000000000000239430.index</span><br><span class="line">00000000000000239430.log</span><br></pre></td></tr></table></figure>

<p>​    index和log文件以当前segment的第一条消息的offset命名。 “.index”文件存储大量的索引信息，“.log”文件存储大量的数据，索引文件中的元数据指向对应数据文件中message的物理偏移地址。  </p>
<h4 id="2-2-kafka生产者"><a href="#2-2-kafka生产者" class="headerlink" title="2.2 kafka生产者"></a>2.2 kafka生产者</h4><h5 id="2-2-1-分区策略"><a href="#2-2-1-分区策略" class="headerlink" title="2.2.1 分区策略"></a>2.2.1 分区策略</h5><p>1）分区的原因</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）方便在集群中扩展。topic是由多个分区组成的，分区是可以扩展的，因此整个集群就可以适应任意大小的数据了</span><br><span class="line">（2）可以提高并发。因为一个topic可以有partition组成，那么一个消费者组就可以同时对一个topic的不同分区进行消费了</span><br></pre></td></tr></table></figure>



<p>2）分区的原则</p>
<p>​    首先在producer发送数据的时候需要先将数据封装为一个ProducerRecorder对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）在构造ProducerRecord对象(topic,partition,value)  &#x2F; (topic,partition,key,value)</span><br><span class="line">	因为具体指定过partition, 消息会发布到指定的partition中.</span><br><span class="line">        </span><br><span class="line">（2）在构造ProducerRecord对象(topic,key,value)</span><br><span class="line">	没有具体指定partition,但是提供了key, kafka会按照key的hash值对partition的个数取余，</span><br><span class="line">	得出当前消息发布到哪个partition</span><br><span class="line">（3）在构造ProducerRecord对象(topic,value)</span><br><span class="line">        在老版本中:  第一次随机生成一个数字N，对partition的个数取余，得出发布到哪个partition，后续每次会执行N++的操作，再对partition的个数取余，得出发布到哪个partition。实际上就是轮询的效果.</span><br><span class="line">该效果在老版本中是通过DefaultPartition类来实现的.在当前版本中,是通过RoundRobinPartitioner类实现的.</span><br><span class="line"></span><br><span class="line">        在当前版本中:   既没有 partition 值又没有 key 值的情况下， kafka采用Sticky Partition(黏性分区器)，会随机一个分区, 然后尽可能一直使用该分区，待该分区的缓冲区(batch)满或者 超过指定时间后，会重新随机一个分区来使用.该效果在当前版本中是通过DefaultPartition类来实现的</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-数据可靠性保证"><a href="#2-2-2-数据可靠性保证" class="headerlink" title="2.2.2 数据可靠性保证"></a>2.2.2 数据可靠性保证</h5><p>1）生产者发送数据到topic partition的可靠性保证</p>
<p>​    为保证producer发送的数据，能可靠的发送到指定的topic，topic的每个partition收到producer发送的数据后，都需要向producer发送ack（acknowledgement确认收到），如果producer收到ack，就会进行下一轮的发送，否则重新发送数据。</p>
<p>2）Topic partition存储数据的可靠性保证</p>
<p>（1）<strong>副本数据同步策略</strong></p>
<table>
<thead>
<tr>
<th><strong>方案</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>半数以上完成同步，就发送ack</strong></td>
<td>延迟低</td>
<td>选举新的leader时，容忍n台节点的故障，需要2n+1个副本</td>
</tr>
<tr>
<td><strong>全部完成同步，才发送ack</strong></td>
<td>选举新的leader时，容忍n台节点的故障，需要n+1个副本</td>
<td>延迟高</td>
</tr>
</tbody></table>
<p>Kafka选择了第二种方案，原因如下：</p>
<p>​    （a）同样为了容忍n台节点的故障，第一种方案需要2n+1个副本，而第二种方案只需要n+1个副本，而Kafka的每个分区都有大量的数据，第一种方案会造成大量数据的冗余。</p>
<p>​    （b）虽然第二种方案的网络延迟会比较高，但网络延迟对Kafka的影响较小。</p>
<p>（2）ISR</p>
<p>​    采用第二种方案之后，设想以下情景：leader收到数据，所有follower都开始同步数据，但有一个follower，因为某种故障，迟迟不能与leader进行同步，那leader就要一直等下去，直到它完成同步，才能发送ack。这个问题怎么解决呢？</p>
<p>​    Leader维护了一个动态的，意为和保持同步的集合。当中的完成数据的同步之后，就会给发送。如果长时间未向同步数据，则该将被踢出，该时间阈值由参数设定。发生故障之后，就会从中选举新的。</p>
<p>（3）ack应答机制</p>
<p>​    对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失，所以没必要等ISR中的follower全部接收成功。  </p>
<p>​    所以Kafka为用户提供了<strong>三种可靠性级别，</strong>用户根据对可靠性和延迟的要求进行权衡，选择以下的配置。</p>
<p><strong><em>ack的参数配置</em></strong></p>
<p><strong>acks</strong>：</p>
<p>0：这一操作提供了一个最低的延迟，partition的leader接收到消息还没有写入磁盘就已经返回ack，当leader故障时有可能丢失数据（返回ack后在将数据写入磁盘前故障了，数据就丢失了，但是producer收到了ack就会以为收到了不会再发了）；</p>
<p>1： partition的leader落盘成功后返回ack，如果在follower同步成功之前leader故障，那么将会丢失数据（在follow同步leader的数据前leader故障了，会重新选举leader，之前的还未同步的数据就丢失了）；</p>
<p>-1（all）： partition的leader和follower全部落盘成功后才返回ack。但是如果在follower同步完成后，broker发送ack之前，leader发生故障，那么会造成<strong>数据重复</strong>。（数据全部落盘了，leader返回ack之前，leader故障，producer未收到应答，则会重新发送数据，则会造成数据重复）</p>
<p>3）leader和follower故障处理细节</p>
<p>​    首先有两个概念：LEO(Log End Offset)是指每个副本中的最后一个offset，HW(High Watermark)是值所有副本中最小的LEO，HW之前的数据才对Consumer可见</p>
<p><strong>LEO</strong>：指的是每个副本最大的offset；</p>
<p><strong>HW</strong>：指的是消费者能见到的最大的offset，ISR队列中最小的LEO。</p>
<p>（1）follower故障</p>
<p>follower发生故障后会被临时踢出ISR，待该follower恢复后，follower会读取本地磁盘记录的上次的HW，并将log文件高于HW的部分截取掉，从HW开始向leader进行同步。等该<strong>follower**</strong>的LEO<strong><strong>大于等于该Partition</strong></strong>的HW**，即follower追上leader之后，就可以重新加入ISR了。</p>
<p>（2）leader故障</p>
<p>leader发生故障之后，会从ISR中选出一个新的leader，之后，为保证多个副本之间的数据一致性，其余的follower会先将各自的log文件高于HW的部分截掉，然后从新的leader同步数据。</p>
<p>注意：这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</p>
<h5 id="2-2-3-Exactly-Once语义"><a href="#2-2-3-Exactly-Once语义" class="headerlink" title="2.2.3 Exactly Once语义"></a>2.2.3 Exactly Once语义</h5><p>​    将服务器的ACK级别设置为-1，可以保证Producer到Server之间不会丢失数据，即At Least Once语义。相对的，将服务器ACK级别设置为0，可以保证生产者每条消息只会被发送一次，即At Most Once语义。</p>
<p>​    At Least Once可以保证数据不丢失，但是不能保证数据不重复；相对的，At Least Once可以保证数据不重复，但是不能保证数据不丢失。但是，对于一些非常重要的信息，比如说交易数据，下游数据消费者要求数据既不重复也不丢失，即Exactly Once语义。在0.11版本以前的Kafka，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。</p>
<p>0.11版本的Kafka，引入了一项重大特性<strong>：幂等性</strong>。所谓的幂等性就是指Producer不论向Server发送多少次重复数据，Server端都只会持久化一条。幂等性结合At Least Once语义，就构成了Kafka的Exactly Once语义。即：<strong>At Least Once +</strong> <strong>幂等性 = Exactly Once</strong></p>
<p>​    要启用幂等性，只需要将Producer的参数中<strong>enable.idompotence</strong>设置为true即可。Kafka的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的Producer在初始化的时候会被分配一个PID，发往同一Partition的消息会附带Sequence Number。而Broker端会对&lt;PID, Partition, SeqNumber&gt;做缓存，当具有相同主键的消息提交时，Broker只会持久化一条。</p>
<p>​    但是PID重启就会变化，同时不同的Partition也具有不同主键，所以幂等性无法保证跨分区跨会话的Exactly Once（可以通过事务来解决这个问题）。</p>
<h4 id="2-3-kafka消费者"><a href="#2-3-kafka消费者" class="headerlink" title="2.3 kafka消费者"></a>2.3 kafka消费者</h4><h5 id="2-3-1-消费方式"><a href="#2-3-1-消费方式" class="headerlink" title="2.3.1 消费方式"></a>2.3.1 消费方式</h5><p>​    consumer采用pull（拉）模式从broker中读取数据。</p>
<p>​    push（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。它的目标是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而pull模式则可以根据consumer的消费能力以适当的速率消费消息。</p>
<p>​    pull模式不足之处是，如果kafka没有数据，消费者可能会陷入循环中，一直返回空数据。针对这一点，Kafka的消费者在消费数据时会传入一个时长参数timeout，如果当前没有数据可供消费，consumer会等待一段时间之后再返回，这段时长即为timeout。</p>
<h5 id="2-3-2-分区分配策略"><a href="#2-3-2-分区分配策略" class="headerlink" title="2.3.2 分区分配策略"></a>2.3.2 分区分配策略</h5><p>​    一个consumer group中有多个consumer，一个 topic有多个partition，所以必然会涉及到partition的分配问题，即确定那个partition由哪个consumer来消费。</p>
<p>​    Kafka有两种分配策略，一种是RoundRobin，一种是Range。</p>
<h5 id="2-3-3-offset的维护"><a href="#2-3-3-offset的维护" class="headerlink" title="2.3.3 offset的维护"></a>2.3.3 offset的维护</h5><p>​    由于consumer在消费过程中可能会出现断电宕机等故障，consumer恢复后，需要从故障前的位置的继续消费，所以consumer需要实时记录自己消费到了哪个offset，以便故障恢复后继续消费。</p>
<p>​    Kafka 0.9版本之前，consumer默认将offset保存在Zookeeper中，从0.9版本开始，consumer默认将offset保存在Kafka一个内置的topic中，该topic为<strong>__consumer_offsets</strong>。</p>
<h4 id="2-4-kafka高效读数据"><a href="#2-4-kafka高效读数据" class="headerlink" title="2.4 kafka高效读数据"></a>2.4 kafka高效读数据</h4><h4 id="2-5-Zookeeper在kafka中的作用"><a href="#2-5-Zookeeper在kafka中的作用" class="headerlink" title="2.5 Zookeeper在kafka中的作用"></a>2.5 Zookeeper在kafka中的作用</h4><h4 id="2-6-kafka事务"><a href="#2-6-kafka事务" class="headerlink" title="2.6 kafka事务"></a>2.6 kafka事务</h4><p>​    Kafka从0.11版本开始引入了事务支持。事务可以保证Kafka在Exactly Once语义的基础上，生产和消费可以跨分区和会话，要么全部成功，要么全部失败。</p>
<h5 id="2-6-1-Producer事务"><a href="#2-6-1-Producer事务" class="headerlink" title="2.6.1 Producer事务"></a>2.6.1 Producer事务</h5><p>​    为了实现跨分区会话的事务，需要引入一个全局唯一的TranactionID，并将Producer获得的PID和Tranaction ID绑定。这样当Producer重启后就可以通过正在进行的Transaction ID获得原来的PID。</p>
<p>​    为了管理Tranaction，Kafka引入了一个新的组件Tranaction Coordinator。Producer就是通过和Tranaction Coordinator交互获得Tranaction ID对应的任务状态。Tranaction Coordinator还负责将事务所有写入kafka的一个内部Topic，这样，即使重启，由于事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。</p>
<h5 id="2-6-2-Consumer事务（精准一次性消费）"><a href="#2-6-2-Consumer事务（精准一次性消费）" class="headerlink" title="2.6.2 Consumer事务（精准一次性消费）"></a>2.6.2 Consumer事务（精准一次性消费）</h5><p>​    上述事务机制主要是从Producer方面考虑，对于Consumer而言，事务的保证就会相对较弱，尤其时无法保证Commit的信息被精确消费。这是由于Consumer可以通过offset访问任意信息，而且不同的Segment File生命周期不同，同一事务的消息可能会出现重启后被删除的情况。</p>
<p>​    如果想完成Consumer端的精准一次性消费，那么需要kafka消费端将消费过程和提交offset过程做原子绑定（如果在消费了数据后提交offset的时候consumer故障了，那offset未提交成功，可能后面就会导致重新消费，所以需要将消费过程和提交offset的过程做原子绑定）。此时我们需要将kafka的offset保存到支持事务的自定义介质（比如mysql）。这部分知识会在后续项目部分涉及。</p>
]]></content>
      <categories>
        <category>Hadoop生态</category>
      </categories>
  </entry>
  <entry>
    <title>flume</title>
    <url>/2020/06/08/flume/</url>
    <content><![CDATA[<h3 id="第1章-flume概述"><a href="#第1章-flume概述" class="headerlink" title="第1章 flume概述"></a>第1章 flume概述</h3><h4 id="1-1-Flume定义"><a href="#1-1-Flume定义" class="headerlink" title="1.1 Flume定义"></a>1.1 Flume定义</h4><p>​    Flume是Cloudera提供的一个高可用的，高可靠的，分布式的海量日志采集，聚合和传输的系统。Flume基于流式架构，灵活简单。Flume最主要的作用就是，实时读取服务器日志数据，然后将数据写入到HDFS</p>
<h4 id="1-2-Flume基础架构"><a href="#1-2-Flume基础架构" class="headerlink" title="1.2 Flume基础架构"></a>1.2 Flume基础架构</h4><h5 id="1-2-1-Agent"><a href="#1-2-1-Agent" class="headerlink" title="1.2.1 Agent"></a>1.2.1 Agent</h5><p>​    Agent是一个JVM进程，一个Agent可以看作是一个flume进程，它以事件的形式将数据从源头送至目的地。</p>
<p>​    Agent主要有3个部分组成，Source，Channel，Sink</p>
<h5 id="1-2-2-Source"><a href="#1-2-2-Source" class="headerlink" title="1.2.2 Source"></a>1.2.2 Source</h5><p>​    Source是负责接收数据到Flume Agent的组件。Source组件可以处理各种类型，各种格式的数据，包括avro,thrift,exec,jms,spooling directory,netcat,sequence generator,syslog,http,legacy</p>
<h5 id="1-2-3-Sink"><a href="#1-2-3-Sink" class="headerlink" title="1.2.3 Sink"></a>1.2.3 Sink</h5><p>​    Sink不断地轮询Channel中的事件并且批量地移除（处理）它们，并将这些事件批量写入到存储或索引系统，或者被发送给另一个Flume Agent</p>
<p>​    Sink组件目的地包括hdfs，logger,avro,thrift,ipc,file,HBase,solr,自定义。    </p>
<h5 id="1-2-4-Channel"><a href="#1-2-4-Channel" class="headerlink" title="1.2.4 Channel"></a>1.2.4 Channel</h5><p>​    Channel是位于Source和Sink之间的缓冲区。因此，Channel允许Source和Sink    运作在不同的速率上。Channel是线程安全的，可以同时处理几个source的写入操作和几个Sink的读取操作。</p>
<p>​    Flume自带两种Channel：Memory Channel和File Channel</p>
<p>​    Memory Channel是内存中的队列。Memory Channel在不需要关心数据丢失的情景下适用。如果需要关心数据丢失，那么Memory Channel就不应该使用，因为程序死亡、机器宕机或者重启都会导致数据丢失。</p>
<p>​    File Channel将所有事件写到磁盘。因此在程序关闭或机器宕机的情况下不会丢失数据。</p>
<h5 id="1-2-5-Event"><a href="#1-2-5-Event" class="headerlink" title="1.2.5 Event"></a>1.2.5 Event</h5><p>​    传输单元，Flume数据传输的基本单元，以Event的形式将数据从源头送至目的地。Event由Header和Body两部分组成。Header用来存放该event的一些属性，为K-V结构，Body用来存放该数据，形式为字节数组。</p>
<h3 id="第2章-Flume的入门"><a href="#第2章-Flume的入门" class="headerlink" title="第2章 Flume的入门"></a>第2章 Flume的入门</h3><h4 id="2-1-Flume安装部署"><a href="#2-1-Flume安装部署" class="headerlink" title="2.1 Flume安装部署"></a>2.1 Flume安装部署</h4><h4 id="2-2-Flume入门案例"><a href="#2-2-Flume入门案例" class="headerlink" title="2.2 Flume入门案例"></a>2.2 Flume入门案例</h4><h3 id="第3章-Flume进阶"><a href="#第3章-Flume进阶" class="headerlink" title="第3章 Flume进阶"></a>第3章 Flume进阶</h3><h4 id="3-1-Flume事务"><a href="#3-1-Flume事务" class="headerlink" title="3.1 Flume事务"></a>3.1 Flume事务</h4><h4 id="3-2-FlumeAgent-内部原理"><a href="#3-2-FlumeAgent-内部原理" class="headerlink" title="3.2 FlumeAgent 内部原理"></a>3.2 FlumeAgent 内部原理</h4><h4 id="3-3-Flume拓扑结构"><a href="#3-3-Flume拓扑结构" class="headerlink" title="3.3  Flume拓扑结构"></a>3.3  Flume拓扑结构</h4><h4 id="3-4-Flume企业开发案例"><a href="#3-4-Flume企业开发案例" class="headerlink" title="3.4 Flume企业开发案例"></a>3.4 Flume企业开发案例</h4><h4 id="3-5-自定义Interceptor"><a href="#3-5-自定义Interceptor" class="headerlink" title="3.5 自定义Interceptor"></a>3.5 自定义Interceptor</h4><h4 id="3-6-自定义Source"><a href="#3-6-自定义Source" class="headerlink" title="3.6 自定义Source"></a>3.6 自定义Source</h4><h4 id="3-7-自定义Sink"><a href="#3-7-自定义Sink" class="headerlink" title="3.7 自定义Sink"></a>3.7 自定义Sink</h4><h4 id="3-8-Flume数据流监控"><a href="#3-8-Flume数据流监控" class="headerlink" title="3.8 Flume数据流监控"></a>3.8 Flume数据流监控</h4><h3 id="第4章-知识点小结"><a href="#第4章-知识点小结" class="headerlink" title="第4章 知识点小结"></a>第4章 知识点小结</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1.Flume是分布式的，高可用的，用于海量日志的收集，聚合，传输的框架</span><br><span class="line"> </span><br><span class="line"> 2.Flume架构：</span><br><span class="line"> 	Agent：jvm进程，可以看作是一个flume</span><br><span class="line"> 	source：对接日志的来源（采集日志）</span><br><span class="line"> 	channel：用于source到sink的缓冲</span><br><span class="line"> 	sink：对接日志的去向（比如传输到hdfs）</span><br><span class="line"> </span><br><span class="line"> 3.Source的类型</span><br><span class="line"> 	常用的有以下几种：</span><br><span class="line"> 	netstat source：从端口采集日志数据</span><br><span class="line"> 	exec source：从执行的Linux命令结果中采集数据。一般都是tail -F，从某个文件中采集数据</span><br><span class="line"> 	spooling directory source（重要，常用）：从某个目录下的多个文件中采集数据，用于监控新文件，没有断电续传功能</span><br><span class="line"> 	tail dir source（重要，常用）：从某个目录下的多个文件中采集数据，支持断点续传</span><br><span class="line"> 	avro source（重要，常用）：从avro sink中采集数据</span><br><span class="line"> 	</span><br><span class="line"> 4.Channel的类型</span><br><span class="line"> 	Memory channel（常用）：event数据存储在内存中</span><br><span class="line"> 	File channel：event数据存储在磁盘中</span><br><span class="line"> </span><br><span class="line"> 5.Sink的类型</span><br><span class="line">	Logger sink：通过日志的方式打印采集到的日志数据</span><br><span class="line">   Hdfs sink（重要，常用）：将日志数据写到hdfs中</span><br><span class="line">   Avro sink（重要，常用）：对接Avro source</span><br><span class="line">   File_roll sink：将采集到的日志数据往本地磁盘写</span><br><span class="line">   </span><br><span class="line">6.channel selector（一个source对接多个channel）</span><br><span class="line">	replicating channel selector:副本&#x2F;复制</span><br><span class="line">	multiplexing channel selector:多路复用</span><br><span class="line"> </span><br><span class="line"> 7.Sink processor（一个channel对接多个sink）</span><br><span class="line"> 		DefaultSinkProcessor：默认的，只对接一个sink</span><br><span class="line"> 			LoadBalancingSinkProcessor：负载均衡，可以配置轮询或随机策略（round_bin&#x2F;random）</span><br><span class="line"> 			FilaOverSinkProcessor：故障转移，可以配置sink的优先级，优先级高的有数据时优先获取，故障时会有退避时间（这个时间内故障的机器不能继续服务，退避时间过后机器正常可以再继续服务），退避时间内其它优先级低sink的可以暂时取代优先级高的sink服务。</span><br><span class="line"> 			</span><br><span class="line">8.Flume Agent的内部流程</span><br><span class="line">	日志--&gt;source（将日志数据封装为event）--&gt; channel processor --&gt; 将事件传递给interceptor--&gt;</span><br><span class="line">	将每个event都交给 channel selector --&gt; 告诉channel processor应该选择哪个channel处理 --&gt;</span><br><span class="line">	channel --&gt; sinkprocessor --&gt; sink --&gt; 例如HDFS</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Hadoop生态</category>
      </categories>
  </entry>
  <entry>
    <title>Hive实战</title>
    <url>/2020/06/06/Hive%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>hive</title>
    <url>/2020/06/01/hive/</url>
    <content><![CDATA[<h3 id="0-前置知识"><a href="#0-前置知识" class="headerlink" title="0.前置知识"></a>0.前置知识</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）SQL技能：如MySQL</span><br><span class="line">2）Hadoop框架：HDFS + MapReduce</span><br></pre></td></tr></table></figure>

<h3 id="1-Hive是什么"><a href="#1-Hive是什么" class="headerlink" title="1. Hive是什么"></a>1. Hive是什么</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hive是FaceBook开源的海量结构化数据的分析框架，Hive的本质是将结构化的数据映射为一张表，最终表将翻译成MR程序，底层还是通过MR作为计算引擎，HDFS作为存储，YARN作为资源调度</span><br></pre></td></tr></table></figure>

<h3 id="2-Hive的架构"><a href="#2-Hive的架构" class="headerlink" title="2. Hive的架构"></a>2. Hive的架构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hive计算的数据存储在HDFS中，Hive的元数据信息（表的信息）存储在第三方的数据库中，默认使用的是Derby，可以切换成其它数据库，如MySQL</span><br></pre></td></tr></table></figure>

<h4 id="2-1-架构原理"><a href="#2-1-架构原理" class="headerlink" title="2.1 架构原理"></a>2.1 架构原理</h4><p>​    Hive通过给用户提供一系列交互接口，接受到用户的指令（SQL），使用自己的Driver，结合元数据（MetaStore），将这些指令翻译成MapReduce，提交到Hadoop中执行，最后将执行返回的结果输出到用户交互接口。</p>
<h3 id="3-Hive数据类型"><a href="#3-Hive数据类型" class="headerlink" title="3. Hive数据类型"></a>3. Hive数据类型</h3><h4 id="3-1基本数据类型"><a href="#3-1基本数据类型" class="headerlink" title="3.1基本数据类型"></a>3.1基本数据类型</h4><table>
<thead>
<tr>
<th>Hive数据类型</th>
<th>Java数据类型</th>
<th>长度</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>byte</td>
<td>1byte有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>SAMLLINT</td>
<td>short</td>
<td>2byte有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>INT</td>
<td>int</td>
<td>4byte有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>BIGINT</td>
<td>long</td>
<td>8byte有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>BOOLEAN</td>
<td>boolean</td>
<td>布尔类型true or false</td>
<td>TRUE</td>
</tr>
<tr>
<td>FLOAT</td>
<td>float</td>
<td>单精度浮点数</td>
<td>3.12</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>double</td>
<td>双精度浮点数</td>
<td>3.1524</td>
</tr>
<tr>
<td>STRING</td>
<td>string</td>
<td>字符系列。可以指定字符集。可以使用单引号或者双引号</td>
<td>‘now is the time’ “for all good men”</td>
</tr>
<tr>
<td>TIMSTAMP</td>
<td></td>
<td>时间类型</td>
<td></td>
</tr>
<tr>
<td>BINARY</td>
<td></td>
<td>字节数组</td>
<td></td>
</tr>
</tbody></table>
<p>​         对于Hive的String类型相当于数据库的varchar类型，该类型是一个可变的字符串，不过它不能声明其中最多能存储多少个字符，理论上它可以存储2GB的字符数。  </p>
<h4 id="3-2集合数据类型"><a href="#3-2集合数据类型" class="headerlink" title="3.2集合数据类型"></a>3.2集合数据类型</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>语法示例</th>
</tr>
</thead>
<tbody><tr>
<td>STRUCT</td>
<td>和C语言中的struct类似，都可以通过点符号访问元素内容。例如，如果某个列的数据类型是STRUTCT{first STRING,last STRING}，那么第1个元素可以通过字段.first来引用，struct的item就是指里面的属性</td>
<td><code>struct&lt;street:string,city:string&gt;</code></td>
</tr>
<tr>
<td>MAP</td>
<td>MAP是一组键-值对组集合，使用数组表示法可以访问数据。例如，如果某个列的数据类型是MAP，其中键-&gt;值是’first’-&gt;’John’和’last’-&gt;’Doe’，那么可以通过字段[‘last’]获取最后一个元素</td>
<td><code>map&lt;string,int&gt;</code></td>
</tr>
<tr>
<td>ARRAY</td>
<td>数组是一组具有相同类型和名称的变量的集合。这些变量称为数组的元素，每个数组元素都有一个编号，编号从零开始。例如，数组值为[‘John’,’Doe’]，那么第2个元素可以通过数组名[1]进行引用</td>
<td><code>array&lt;string&gt;</code></td>
</tr>
</tbody></table>
<h3 id="4-DDL数据定义"><a href="#4-DDL数据定义" class="headerlink" title="4. DDL数据定义"></a>4. DDL数据定义</h3><h3 id="5-DML数据操作"><a href="#5-DML数据操作" class="headerlink" title="5. DML数据操作"></a>5. DML数据操作</h3><h3 id="6-查询"><a href="#6-查询" class="headerlink" title="6. 查询"></a>6. 查询</h3><h4 id="6-1-全局排序"><a href="#6-1-全局排序" class="headerlink" title="6.1 全局排序"></a>6.1 全局排序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">order by：全局排序，只有一个reducer</span><br><span class="line">ASC：升序（默认）</span><br><span class="line">DESC：降序</span><br></pre></td></tr></table></figure>

<h4 id="6-2-每个MapReduce内部排序-Sort-by"><a href="#6-2-每个MapReduce内部排序-Sort-by" class="headerlink" title="6.2 每个MapReduce内部排序(Sort by)"></a>6.2 每个MapReduce内部排序(Sort by)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sort by:对于大规模的数据集order by的效率非常低。在很多情况下。并不需要全局排序，此时可以使用sort by</span><br><span class="line">sort by为每个reducer产生一个排序文件。每个reducer内部进行排序</span><br><span class="line"></span><br><span class="line"> 关注点: 有多个reducer，也就是有多个分区</span><br><span class="line"> 注意点: 有多个reducer,单独使用sort by, 数据会被随机分到每个reducer中，在每个reducer中sort by会将数据排序。</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）设置reduce个数</span><br><span class="line">hive (default)&gt; set mapreduce.job.reduces&#x3D;3;</span><br><span class="line">2）根据部门编号降序查看员工信息</span><br><span class="line">hive (default)&gt; select * from emp sort by deptno desc;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-分区排序（Distribute-by）"><a href="#6-3-分区排序（Distribute-by）" class="headerlink" title="6.3 分区排序（Distribute by）"></a>6.3 分区排序（Distribute by）</h4><p>​    Distribute By：在有些情况下，我们需要控制某个特定行应该要到哪个reducer，通常是为了进行后续的聚集操作。distribute by字句可以做这件事。distribute by类似MR中的partition（自定义分区），进行分区，结合sort by使用。</p>
<p>​    对于distribute by进行测试，一定要分配多reduce处理，否则无法看到distribute by的效果</p>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from emp distribute by deptno  sort by  empno desc ;</span><br></pre></td></tr></table></figure>

<h4 id="6-4-cluster-by-分区排序"><a href="#6-4-cluster-by-分区排序" class="headerlink" title="6.4 cluster by 分区排序"></a>6.4 cluster by 分区排序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关注点: 相当于distribute by 和sort by同时用， 并且分区和排序的字段是同一个，并且排序是升序的情况.</span><br><span class="line"></span><br><span class="line">select * from emp distribute by deptno sort by deptno asc ; </span><br><span class="line">等同于</span><br><span class="line">select * from emp cluster by deptno ;</span><br></pre></td></tr></table></figure>



<h3 id="7-分区表和分桶表"><a href="#7-分区表和分桶表" class="headerlink" title="7. 分区表和分桶表"></a>7. 分区表和分桶表</h3><h4 id="7-1-分区表"><a href="#7-1-分区表" class="headerlink" title="7.1 分区表"></a>7.1 分区表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分区表实际就是对应一个HDFS文件系统上的独立的文件夹，该文件夹下是该分区所有的数据文件。Hive分区表的分区其实就是分目录，把一个大的数据集根据业务需求分割成小的数据集。在查询时通过where子句中的表达式选择查询所需要的指定分区，就不用暴力扫描所有的数据了，这样查询效率会提高很多。</span><br></pre></td></tr></table></figure>

<h4 id="7-1-1-分区表基本操作"><a href="#7-1-1-分区表基本操作" class="headerlink" title="7.1.1 分区表基本操作"></a>7.1.1 分区表基本操作</h4><p>1）引入分区表的数据（需求是根据日志对日志进行管理，通过部门信息模拟）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dept_20200401.log</span><br><span class="line">dept_20200402.log</span><br><span class="line">dept_20200403.log</span><br></pre></td></tr></table></figure>

<p>2）创建分区表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt;create table dept_partition(deptno int,dname string,loc string) </span><br><span class="line">partitioned by(day string)</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;;</span><br></pre></td></tr></table></figure>

<p>3）加载数据到分区表中</p>
<p>（1）数据准备</p>
<p>dept_20200401.log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10	ACCOUNTING	1700</span><br><span class="line">20	RESEARCH	1800</span><br></pre></td></tr></table></figure>

<p>dept_20200402.log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30	SALES	1900</span><br><span class="line">40	OPERATIONS	1700</span><br></pre></td></tr></table></figure>

<p>dept_20200403.log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">50	TEST	2000</span><br><span class="line">60	DEV	1900</span><br></pre></td></tr></table></figure>



<p>（2）加载数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;dept_20200401.log&#39; into table dept_partition partition(day&#x3D;&#39;20200401&#39;);</span><br><span class="line"></span><br><span class="line">hive (default)&gt; load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;dept_20200402.log&#39; into table dept_partition partition(day&#x3D;&#39;20200402&#39;);</span><br><span class="line"></span><br><span class="line">hive (default)&gt; load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;dept_20200403.log&#39; into table dept_partition partition(day&#x3D;&#39;20200403&#39;);</span><br></pre></td></tr></table></figure>



<p>4）</p>
<p>单分区查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; select * from dept_partition where day&#x3D;&#39;20200401&#39;;</span><br></pre></td></tr></table></figure>



<p>多分区联合查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; select * from dept_partition where day&#x3D;&#39;20200401&#39;</span><br><span class="line">              union</span><br><span class="line">              select * from dept_partition where day&#x3D;&#39;20200402&#39;</span><br><span class="line">              union</span><br><span class="line">              select * from dept_partition where day&#x3D;&#39;20200403&#39;;</span><br><span class="line">              </span><br><span class="line">hive (default)&gt; select * from dept_partition where day&#x3D;&#39;20200401&#39; or</span><br><span class="line">                day&#x3D;&#39;20200402&#39; or day&#x3D;&#39;20200403&#39; ;</span><br></pre></td></tr></table></figure>



<p>5）增加分区</p>
<p>创建单个分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; alter table dept_partition add partition(day&#x3D;&#39;20200404&#39;);</span><br></pre></td></tr></table></figure>

<p>同时创建多个分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; alter table dept_partition add partition(day&#x3D;&#39;20200405&#39;) partition(day&#x3D;&#39;20200406&#39;);</span><br></pre></td></tr></table></figure>

<p>6）删除分区</p>
<p>删除单个分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; alter table dept_partition drop partition(day&#x3D;&#39;20200404&#39;);</span><br></pre></td></tr></table></figure>

<p>删除多个分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt;alter table dept_partition drop partition(day&#x3D;&#39;20200405&#39;),parition(day&#x3D;&#39;20200406&#39;);</span><br></pre></td></tr></table></figure>

<p>7）查看分区表有多少分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt;show partitions dept_partition;</span><br></pre></td></tr></table></figure>

<p>8）查看分区表结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; desc formatted dept_partition;</span><br></pre></td></tr></table></figure>

<h4 id="7-1-2-分区表注意事项"><a href="#7-1-2-分区表注意事项" class="headerlink" title="7.1.2 分区表注意事项"></a>7.1.2 分区表注意事项</h4><p>如果一天的日志数据量很大，也是可以创建二级分区表的</p>
<p>1）创建二级分区表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; create table dept_parition2(deptno int,dname string,loc string)</span><br><span class="line">partitioned by (day string,hour string)</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;;</span><br></pre></td></tr></table></figure>

<p>2）正常的加载数据</p>
<p>（1）加载数据到二级分区表中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt;load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;dept_20200401.log&#39; into table dept_parition2 partition(day&#x3D;&#39;20200401&#39;,hour&#x3D;&#39;12&#39;);</span><br></pre></td></tr></table></figure>

<p>（2）查询分区数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; select * from dept_partition2 where day&#x3D;&#39;20200401&#39; and hour &#x3D; &#39;12&#39;;</span><br></pre></td></tr></table></figure>

<p>3）把数据上传到分区目录上，让分区表和数据产生关联的三种方式</p>
<p>（1）方式一：上传数据后修复</p>
<p>上传数据到HDFS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; dfs -mkdir -p</span><br><span class="line"> &#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;mydb.db&#x2F;dept_partition2&#x2F;day&#x3D;20200401&#x2F;hour&#x3D;13;</span><br><span class="line"> </span><br><span class="line">hive (default)&gt; dfs -put &#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;dept_20200401.log  </span><br><span class="line">&#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;mydb.db&#x2F;dept_partition2&#x2F;day&#x3D;20200401&#x2F;hour&#x3D;13;</span><br></pre></td></tr></table></figure>

<p>查询数据（查询不到刚上传的数据，因为没有相应的元数据信息）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; select * from dept_partition2 where day&#x3D;&#39;20200401&#39; and hour&#x3D;&#39;13&#39;;</span><br></pre></td></tr></table></figure>

<p>执行修复命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; msck repair table dept_partition2;</span><br></pre></td></tr></table></figure>

<p>再次查询数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; select * from dept_partition2 where day&#x3D;&#39;20200401&#39; and hour&#x3D;&#39;13&#39;;</span><br></pre></td></tr></table></figure>



<p>（2）方式二：上传数据后添加分区</p>
<p>上传数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; dfs -mkdir -p</span><br><span class="line"> &#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;mydb.db&#x2F;dept_partition2&#x2F;day&#x3D;20200401&#x2F;hour&#x3D;14;</span><br><span class="line"> </span><br><span class="line">hive (default)&gt; dfs -put &#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;dept_20200401.log  &#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;mydb.db&#x2F;dept_partition2&#x2F;day&#x3D;20200401&#x2F;hour&#x3D;14;</span><br></pre></td></tr></table></figure>

<p>执行添加分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; alter table dept_partition2 add partition(day&#x3D;&#39;201709&#39;,hour&#x3D;&#39;14&#39;);</span><br></pre></td></tr></table></figure>

<p>查询数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; select * from dept_partition2 where day&#x3D;&#39;20200401&#39; and hour&#x3D;&#39;14&#39;;</span><br></pre></td></tr></table></figure>

<h4 id="7-1-3-动态分区调整"><a href="#7-1-3-动态分区调整" class="headerlink" title="7.1.3 动态分区调整"></a>7.1.3 动态分区调整</h4><p>​    关系型数据库中，对分区表Insert数据时候，数据库自动会根据分区字段的值，将数据插入到相应的分区中，Hive中也提供了类似的机制，即动态分区(Dynamic Partition)，只不过，使用Hive的动态分区，需要进行相应的配置。</p>
<p>1）开启动态分区参数设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）开启动态分区功能（默认true，开启）</span><br><span class="line">hive.exec.dynamic.partition&#x3D;true</span><br><span class="line">（2）设置为非严格模式（动态分区的模式，默认strict，表示必须指定至少一个分区为静态分区，nonstrict模式表示允许所有的分区字段都可以使用动态分区。）</span><br><span class="line">hive.exec.dynamic.partition.mode&#x3D;nonstrict</span><br><span class="line">（3）在所有执行MR的节点上，最大一共可以创建多少个动态分区。默认1000</span><br><span class="line">hive.exec.max.dynamic.partitions&#x3D;1000</span><br><span class="line">（4）在每个执行MR的节点上，最大可以创建多少个动态分区。该参数需要根据实际的数据来设定。比如：源数据中包含了一年的数据，即day字段有365个值，那么该参数就需要设置成大于365，如果使用默认值100，则会报错。</span><br><span class="line">hive.exec.max.dynamic.partitions.pernode&#x3D;100</span><br><span class="line">（5）整个MR Job中，最大可以创建多少个HDFS文件。默认100000</span><br><span class="line">hive.exec.max.created.files&#x3D;100000</span><br><span class="line">（6）当有空分区生成时，是否抛出异常。一般不需要设置。默认false</span><br><span class="line">hive.error.on.empty.partition&#x3D;false</span><br></pre></td></tr></table></figure>

<p>2）案例实操</p>
<p>​    需求：将dept表中的数据按照地区（loc字段），插入到目标表dept_partition的相应分区中。</p>
<p>（1）创建目标分区表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; create table dept_partition_dy(id int,name string)</span><br><span class="line">partitioned by(loc int)</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;;</span><br></pre></td></tr></table></figure>

<p>（2）设置动态分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set hive.exec.dynamic.partition.mode &#x3D; nonstrict;</span><br><span class="line">hive(default)&gt; insert into table dept_partition_dy partition(loc) </span><br><span class="line">select deptno,dname,loc from dept;</span><br></pre></td></tr></table></figure>



<h3 id="7-2-分桶表"><a href="#7-2-分桶表" class="headerlink" title="7.2 分桶表"></a>7.2 分桶表</h3><p>​    分区表提供一个隔离数据和优化查询的便利方式。不过，并非所有的数据集都可以形成合力的分区。对于一张表或分区，Hive可进一步组织成桶，也就是更细粒度的数据范围划分。</p>
<p>​    分桶是将数据集分解成更容易管理的若干部分的另一个技术。</p>
<p>​    分区针对的是数据的存储路径，分为多个目录，而分桶针对是数据文件，会把原来的文件根据分桶规则将数据分到不同的数据文件。</p>
<p>1）先创建分桶表，通过直接导入数据文件的方式</p>
<p>（1）数据准备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1001	ss1</span><br><span class="line">1002	ss2</span><br><span class="line">1003	ss3</span><br><span class="line">1004	ss4</span><br><span class="line">1005	ss5</span><br><span class="line">1006	ss6</span><br><span class="line">1007	ss7</span><br><span class="line">1008	ss8</span><br><span class="line">1009	ss9</span><br><span class="line">1010	ss10</span><br><span class="line">1011	ss11</span><br><span class="line">1012	ss12</span><br><span class="line">1013	ss13</span><br><span class="line">1014	ss14</span><br><span class="line">1015	ss15</span><br><span class="line">1016	ss16</span><br></pre></td></tr></table></figure>

<p>（2）创建分桶表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table stu_buck(id int,name string)</span><br><span class="line">clustered by(id)</span><br><span class="line">into 4 buckets</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;;</span><br></pre></td></tr></table></figure>

<p>（3）查看表结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default) &gt; desc formatted stu_buck;</span><br></pre></td></tr></table></figure>

<p>（4）导入数据到分桶表中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;dive&#x2F;datas&#x2F;student.txt&#39; into table stu_buck;</span><br></pre></td></tr></table></figure>

<p>（5）通过web到对应的目录下查看创建的分通表中是否分为4个桶</p>
<p>（6）查询分桶的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; select * from stu_buck;</span><br></pre></td></tr></table></figure>

<p>分桶规则：HIve的分桶采用对分桶字段的值进行哈希，然后除以桶的个数取余的方式决定该条记录存放在哪个桶当中</p>
<h3 id="7-3-抽样查询"><a href="#7-3-抽样查询" class="headerlink" title="7.3 抽样查询"></a>7.3 抽样查询</h3><p>​    对于非常大的数据集，有时用户需要使用的是一个具有代表性的查询结果而不是全部结果。可以通过对表进行抽样来满足这个需求。</p>
<p>​    查询表stu_buck中的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; select * from stu_buck tablesample(bucket 1 out of 4 on id);</span><br></pre></td></tr></table></figure>

<p>注：tablesample是抽样语句，语法：tablesample(bucket x out of y)</p>
<p>y必须是table总bucket数的倍数或者因子。hive根据y的大小，决定抽象的比例。例如：table总共分了4份，当y=2时，抽取（4/2）=2个bucket 的数据，当y=8时，抽取（4/8）=1/个bucket的数据。</p>
<p>x表示从哪个bucket开始抽取，如果需要取多个分区，以后的分区号为当前分区号加上y。例如，table总bucket数为4。</p>
<p>x的值必须小于y的值</p>
<h3 id="8-函数"><a href="#8-函数" class="headerlink" title="8. 函数"></a>8. 函数</h3><h4 id="8-1-系统内置函数"><a href="#8-1-系统内置函数" class="headerlink" title="8.1 系统内置函数"></a>8.1 系统内置函数</h4><p>1）查看系统自带的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive &gt; show functions;</span><br></pre></td></tr></table></figure>

<p>2）显示自带函数的用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive &gt; desc function upper;</span><br></pre></td></tr></table></figure>

<p>3）详细显示自带的函数的用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive &gt; desc function extended upper;</span><br></pre></td></tr></table></figure>



<h4 id="8-2-常用内置函数"><a href="#8-2-常用内置函数" class="headerlink" title="8.2 常用内置函数"></a>8.2 常用内置函数</h4><h5 id="8-2-1-空字段复制"><a href="#8-2-1-空字段复制" class="headerlink" title="8.2.1 空字段复制"></a>8.2.1 空字段复制</h5><h5 id="8-2-2-CASE-WHEN"><a href="#8-2-2-CASE-WHEN" class="headerlink" title="8.2.2 CASE WHEN"></a>8.2.2 CASE WHEN</h5><h5 id="8-2-3-行转列"><a href="#8-2-3-行转列" class="headerlink" title="8.2.3 行转列"></a>8.2.3 行转列</h5><p>1）相关函数说明</p>
<p>​    CONCAT(string A/col, string B/col…)：返回输入字符串连接后的结果，支持任意个输入字符串。</p>
<p>​    CONCAT_WS(separator, str1, str2,…)：它是一个特殊形式的 CONCAT()。第一个参数剩余参数间的分隔符。分隔符可以是与剩余参数一样的字符串。如果分隔符是 NULL，返回值也将为 NULL。这个函数会跳过分隔符参数后的任何 NULL 和空字符串。分隔符将被加到被连接的字符串之间。</p>
<p>​    COLLECT_SET(col)：函数只接受基本数据类型，它的主要作用是将某字段的值进行去重汇总，产生array类型字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="8-2-4-列转行"><a href="#8-2-4-列转行" class="headerlink" title="8.2.4 列转行"></a>8.2.4 列转行</h5><p>1）函数说明</p>
<p>​    split()：将给定的字符串，通过给定的分隔符进行分割，返回array</p>
<p>​    explode()：将一列中的array或者map等拆分成多行</p>
<p>​    lateral view：侧写</p>
<p>2）数据准备</p>
<p>表6-7 数据准备</p>
<table>
<thead>
<tr>
<th>movie</th>
<th>category</th>
</tr>
</thead>
<tbody><tr>
<td>《疑犯追踪》</td>
<td>悬疑,动作,科幻,剧情</td>
</tr>
<tr>
<td>《Lie to me》</td>
<td>悬疑,警匪,动作,心理,剧情</td>
</tr>
<tr>
<td>《战狼2》</td>
<td>战争,动作,灾难</td>
</tr>
</tbody></table>
<p>3）需求</p>
<p>​    将电影分类中的数组数据展开，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">《疑犯追踪》      悬疑</span><br><span class="line">《疑犯追踪》      动作</span><br><span class="line">《疑犯追踪》      科幻</span><br><span class="line">《疑犯追踪》      剧情</span><br><span class="line">《Lie to me》   悬疑</span><br><span class="line">《Lie to me》   警匪</span><br><span class="line">《Lie to me》   动作</span><br><span class="line">《Lie to me》   心理</span><br><span class="line">《Lie to me》   剧情</span><br><span class="line">《战狼2》        战争</span><br><span class="line">《战狼2》        动作</span><br><span class="line">《战狼2》        灾难</span><br></pre></td></tr></table></figure>

<p>4）创建本地movie.txt，导入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">atguigu@hadoop102 datas]$ vi movie_info.txt</span><br><span class="line">《疑犯追踪》	悬疑,动作,科幻,剧情</span><br><span class="line">《Lie to me》	悬疑,警匪,动作,心理,剧情</span><br><span class="line">《战狼2》	战争,动作,灾难</span><br></pre></td></tr></table></figure>

<p>5）创建hive表并导入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table movie_info(</span><br><span class="line">    movie string, </span><br><span class="line">    category string) </span><br><span class="line">row format delimited fields terminated by &quot;\t&quot;;</span><br><span class="line">load data local inpath &quot;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;movie_info.txt&quot; into table movie_info;</span><br></pre></td></tr></table></figure>

<p>6）按需求查询数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select movie,category_name</span><br><span class="line">from movie_info</span><br><span class="line">lateral view</span><br><span class="line">explode(split(category,&quot;,&quot;))movie_info_tpm as category_name;</span><br></pre></td></tr></table></figure>



<h5 id="8-2-5-窗口函数"><a href="#8-2-5-窗口函数" class="headerlink" title="8.2.5 窗口函数"></a>8.2.5 窗口函数</h5><p>1）相关函数说明</p>
<p>​    over():指定分析函数工作的数据窗口大小，这个数据窗口的大小可能会随着行的变化而变化</p>
<p>​    current row：当前行</p>
<p>​    n preceding：往前n行数据</p>
<p>​    n following：往后n行数据</p>
<p>​    unbounded：起点</p>
<p>​        unbounded preceding 表示从前面的起点</p>
<p>​        unbounded following 表示到后面的终点</p>
<p>​    lag(col,n,default_val)：往前第n行数据，没有数据则用默认值代替</p>
<p>​    lead(col,default_val)：往后第n行数据，没有数据则用默认值代替</p>
<p>​    ntile(n)：把有序窗口的行分发到指定数据的组中，各个组有编号，编号从1开始，对于每一行，ntile返回此行所属的组的编号。其中n必须为Int类型</p>
<p>2）数据准备：name，orderdate，cost</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jack,2017-01-01,10</span><br><span class="line">tony,2017-01-02,15</span><br><span class="line">jack,2017-02-03,23</span><br><span class="line">tony,2017-01-04,29</span><br><span class="line">jack,2017-01-05,46</span><br><span class="line">jack,2017-04-06,42</span><br><span class="line">tony,2017-01-07,50</span><br><span class="line">jack,2017-01-08,55</span><br><span class="line">mart,2017-04-08,62</span><br><span class="line">mart,2017-04-09,68</span><br><span class="line">neil,2017-05-10,12</span><br><span class="line">mart,2017-04-11,75</span><br><span class="line">neil,2017-06-12,80</span><br><span class="line">mart,2017-04-13,94</span><br></pre></td></tr></table></figure>

<p>3）创建本地business.txt，导入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ vim business.txt</span><br></pre></td></tr></table></figure>

<p>4）创建hive表并导入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table business(</span><br><span class="line">name string, </span><br><span class="line">orderdate string,</span><br><span class="line">cost int</span><br><span class="line">) ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;,&#39;;</span><br><span class="line">create table business(</span><br><span class="line">name string, </span><br><span class="line">orderdate string,</span><br><span class="line">cost int</span><br><span class="line">) ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;,&#39;;</span><br><span class="line">load data local inpath &quot;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;business.txt&quot; into table business;</span><br></pre></td></tr></table></figure>

<p>6）按需求查询数据<br>（1）查询在2017年4月份购买过的顾客及总人数,输出如下<br>     NAME    total<br>     jack     2<br>     tony     2</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--分析：</span></span><br><span class="line"><span class="comment">--a.首先将2017年4月份的数据查出来</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span> <span class="keyword">from</span> business <span class="keyword">where</span> orderdate <span class="keyword">like</span> <span class="string">'2017-04%'</span>;</span><br><span class="line"><span class="comment">--或者</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span> <span class="keyword">from</span> business <span class="keyword">where</span> <span class="keyword">MONTH</span>(orderdate) = <span class="string">'04'</span>;</span><br><span class="line"><span class="comment">--b.然后将4月份的数据总人数通过开窗函数查出来(这里是对字表t1的数据开窗)</span></span><br><span class="line"><span class="keyword">select</span> t1.name,<span class="keyword">count</span>(t1.name) <span class="keyword">over</span>()</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span> <span class="keyword">from</span> business <span class="keyword">where</span> <span class="keyword">MONTH</span>(orderdate) = <span class="string">'04'</span>)t1</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t1.name;</span><br></pre></td></tr></table></figure>

<p>（2）查询顾客的购买明细及月购买总额（这里是指所有顾客的月购买总额）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">month</span>(orderdate)) allcustomer_month_sum_cost</span><br><span class="line"><span class="keyword">from</span> business;</span><br></pre></td></tr></table></figure>

<p>（3）查询顾客的购买明细及月购买总额（这里指每个顾客的月购买总额）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span>,<span class="keyword">month</span>(orderdate)) current_customer_month_costs</span><br><span class="line"><span class="keyword">from</span> business;</span><br></pre></td></tr></table></figure>

<p>（4）每个顾客的购买明细，及所有顾客的cost按照日期进行累加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--分析：为每条数据的开窗的大小为：从结果集开始的位置到当前行</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span></span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate)sum_cost</span><br><span class="line"><span class="keyword">from</span> business;</span><br><span class="line"><span class="comment">--等同于</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">current</span> <span class="keyword">row</span>)sum_cost</span><br><span class="line"><span class="keyword">from</span> business;</span><br></pre></td></tr></table></figure>

<p>（5）每个顾客的购买明细    及  </p>
<p>​        所有顾客的cost按照日期累加</p>
<p>​        所有顾客的cost按照日期上一行与当前行的累加</p>
<p>​        所有顾客的cost按照日期当前行与下一行的累加</p>
<p>​        所有顾客的cost按照日期上一行 当前行 下一行的累加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">current</span> <span class="keyword">row</span>) sum_costs1,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">current</span> <span class="keyword">row</span>) sum_cost2,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">current</span> <span class="keyword">row</span> <span class="keyword">and</span> <span class="number">1</span> <span class="keyword">following</span>) sum_cost3,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="number">1</span> <span class="keyword">following</span>) sum_cost4</span><br><span class="line"><span class="keyword">from</span> business;</span><br></pre></td></tr></table></figure>

<p>（6）每个顾客的购买明细 及</p>
<p>​        所有顾客的cost按照日期    上一行与下一行的累加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--分析</span></span><br><span class="line"><span class="comment">--a.将每条数据的上一行和下一行的cost提取到当前行</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span>,</span><br><span class="line">lag(<span class="keyword">cost</span>,<span class="number">1</span>,<span class="number">0</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate) prev_cost,</span><br><span class="line"><span class="keyword">lead</span>(<span class="keyword">cost</span>,<span class="number">1</span>,<span class="number">0</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate) next_cost</span><br><span class="line"><span class="keyword">from</span> business;            <span class="comment">-----&gt; t1</span></span><br><span class="line"><span class="comment">--b.求prev_cost和next_cost的和</span></span><br><span class="line"><span class="keyword">select</span> t1.name,t1.orderdate,t1.cost,t1.prev_cost,t1.next_cost,t1.prev_cost+t1.next_cost p_n_cost</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span>,</span><br><span class="line">lag(<span class="keyword">cost</span>,<span class="number">1</span>,<span class="number">0</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate) prev_cost,</span><br><span class="line"><span class="keyword">lead</span>(<span class="keyword">cost</span>,<span class="number">1</span>,<span class="number">0</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate) next_cost</span><br><span class="line"><span class="keyword">from</span> business)t1;</span><br></pre></td></tr></table></figure>

<p>（7）查询每个顾客上次的购买时间和下次的购买时间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,<span class="keyword">cost</span>,orderdate current_od,</span><br><span class="line">lag(orderdate,<span class="number">1</span>,<span class="string">'1970-01-01'</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate) prev_od,</span><br><span class="line"><span class="keyword">lead</span>(orderdate,<span class="number">1</span>,<span class="string">'9999-01-01'</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate) next_od</span><br><span class="line"><span class="keyword">from</span> business;</span><br></pre></td></tr></table></figure>

<p>（8）查询每个顾客上次的购买时间和下次的购买时间 及每个顾客的cost按照日期累加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,<span class="keyword">cost</span>,orderdate current_od,</span><br><span class="line">lag(orderdate,<span class="number">1</span>,<span class="string">'1970-01-01'</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate) prev_od,</span><br><span class="line"><span class="keyword">lead</span>(orderdate,<span class="number">1</span>,<span class="string">'9999-01-01'</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate) next_od,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate) sum_cost</span><br><span class="line"><span class="keyword">from</span> business;</span><br></pre></td></tr></table></figure>

<p>（9）查询前20%时间的订单信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--按订单时间排序，分为5组然后取第一组</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span>,</span><br><span class="line">ntile(<span class="number">5</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate) gid</span><br><span class="line"><span class="keyword">from</span> business;          <span class="comment">----&gt;t1</span></span><br><span class="line"><span class="comment">--取5组里面的第一组数据，即前20%的数据</span></span><br><span class="line"><span class="keyword">select</span> t1.name,t1.orderdate,t1.cost</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span>,</span><br><span class="line">ntile(<span class="number">5</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate) gid</span><br><span class="line"><span class="keyword">from</span> business)t1</span><br><span class="line"><span class="keyword">where</span> t1.gid = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<h5 id="8-2-6-Rank"><a href="#8-2-6-Rank" class="headerlink" title="8.2.6 Rank"></a>8.2.6 Rank</h5><p>1）相关函数说明</p>
<p>​    rank()：考虑并列情况，总数不会变</p>
<p>​    dense_rank()：考虑并列情况，总数会较少</p>
<p>​    row_number()：按照顺序排序</p>
<p>2）数据准备</p>
<table>
<thead>
<tr>
<th>name</th>
<th>subject</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>孙悟空</td>
<td>语文</td>
<td>87</td>
</tr>
<tr>
<td>孙悟空</td>
<td>数学</td>
<td>95</td>
</tr>
<tr>
<td>孙悟空</td>
<td>英语</td>
<td>68</td>
</tr>
<tr>
<td>大海</td>
<td>语文</td>
<td>94</td>
</tr>
<tr>
<td>大海</td>
<td>数学</td>
<td>56</td>
</tr>
<tr>
<td>大海</td>
<td>英语</td>
<td>84</td>
</tr>
<tr>
<td>宋宋</td>
<td>语文</td>
<td>64</td>
</tr>
<tr>
<td>宋宋</td>
<td>数学</td>
<td>86</td>
</tr>
<tr>
<td>宋宋</td>
<td>英语</td>
<td>84</td>
</tr>
<tr>
<td>婷婷</td>
<td>语文</td>
<td>65</td>
</tr>
<tr>
<td>婷婷</td>
<td>数学</td>
<td>85</td>
</tr>
<tr>
<td>婷婷</td>
<td>英语</td>
<td>78</td>
</tr>
</tbody></table>
<p>4）创建本地score.txt,导入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ vim score.txt</span><br></pre></td></tr></table></figure>

<p>5）创建hive表并导入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table score(</span><br><span class="line">name string,</span><br><span class="line">subject string, </span><br><span class="line">score int) </span><br><span class="line">row format delimited fields terminated by &quot;\t&quot;;</span><br><span class="line">load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;score.txt&#39; into table score;</span><br></pre></td></tr></table></figure>

<p>6）需求：计算每科成绩排名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,subject,score,</span><br><span class="line"><span class="keyword">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> subject <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) rk,</span><br><span class="line"><span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> subject <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) drk,</span><br><span class="line">row_number() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> subject <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) rn</span><br><span class="line"><span class="keyword">from</span> score;</span><br></pre></td></tr></table></figure>



<h5 id="8-2-7-其它常用函数"><a href="#8-2-7-其它常用函数" class="headerlink" title="8.2.7 其它常用函数"></a>8.2.7 其它常用函数</h5><h4 id="8-3-自定义函数"><a href="#8-3-自定义函数" class="headerlink" title="8.3 自定义函数"></a>8.3 自定义函数</h4><p>1）Hive 自带了一些函数，比如：max/min等，但是数量有限，自己可以通过自定义UDF来方便的扩展。</p>
<p>2）此时就可以考虑使用用户自定义函数（UDF：user-defined function）。</p>
<p>3）根据用户自定义函数类别分为以下三种</p>
<p>（1）UDF（User-Defined Function）</p>
<p>​    一进一出</p>
<p>（2）UDAF（User-Defined Aggregation Function）</p>
<p>​    聚集函数：多进一出 类似于 count/max/min</p>
<p>（3）UDTF（User-Defined Table_Generating Functions）</p>
<p>​    一进多出  如lateral view explode()</p>
<p>4）官方文档地址</p>
<p>5）编程步骤</p>
<p>（1）继承Hive提供的类</p>
<p>​    org.apache.hadoop.hive.ql.udf.generic.GenericUDF</p>
<p>​    org.apache.hadoop.hive.ql.udf.generic.GenericUDTF;</p>
<p>（2）实现类中的抽象方法</p>
<p>（3）在hive的命令行窗口创建函数</p>
<p>添加jar</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add jar linux_jar_path</span><br></pre></td></tr></table></figure>

<p>创建function和刚添加的jar关联起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create [temporary] function [dbname.]function name as class_name;</span><br></pre></td></tr></table></figure>

<p>（4）在hive的命令行窗口删除函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop [temporary] function [if exists] [dbname.]function name;</span><br></pre></td></tr></table></figure>





<h4 id="8-4-自定义UDF函数"><a href="#8-4-自定义UDF函数" class="headerlink" title="8.4 自定义UDF函数"></a>8.4 自定义UDF函数</h4><p>0）需求：</p>
<p>​    自定义一个UDF实现计算给定字符串的长度，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; select my_len(&quot;abcd&quot;);</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>1）创建一个maven工程hive</p>
<p>2）导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hive<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive-exec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3）创建一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.hive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDFArgumentException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDFArgumentLengthException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDFArgumentTypeException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.metadata.HiveException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.udf.generic.GenericUDF;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	自定义UDF函数，需要继承GenericUDF类</span></span><br><span class="line"><span class="comment">*	需求：计算指定字符串的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStringLength</span> <span class="keyword">extends</span> <span class="title">GenericUDF</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arguments 输入参数类型的鉴别器对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回值类型的鉴别器对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UDFArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectInspector <span class="title">initialize</span><span class="params">(ObjectInspector[] arguments)</span><span class="keyword">throws</span> UDFArgumentException</span>&#123;</span><br><span class="line">        <span class="comment">//判断输入参数的个数</span></span><br><span class="line">        <span class="keyword">if</span>(arguments.length != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UDFArgumentLegthException(<span class="string">"Input Args Length Error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断输入参数的类型</span></span><br><span class="line">        <span class="keyword">if</span>(!argument[<span class="number">0</span>].getCategory().equals(ObjectInspector.Category.PRIMITIVE))&#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> UDFArgumentTypeException(<span class="number">0</span>,<span class="string">"Input Args Type Error!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//函数本身返回值为int,需要返回int类型鉴别器对象</span></span><br><span class="line">        <span class="keyword">return</span> PrimitiveObjectInspectorFactory.javaIntObjectInspector;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 函数的逻辑处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arguments 输入的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> HiveException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">evaluate</span><span class="params">(DeferedObject[] arguments)</span><span class="keyword">throws</span> HiveException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arguments[<span class="number">0</span>].get() == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> argument[<span class="number">0</span>].get.toString().length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDisplayString</span><span class="params">(String[] children)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）打成jar包上传到服务器/opt/module/hive/datas/myudf.jar</p>
<p>5）将jar包添加到hive的classpath</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; add jar &#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;myudf.jar</span><br></pre></td></tr></table></figure>

<p>6）创建临时函数与开发好的java class关联</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; create temporary function my_len as &quot;com.atguigu.hive.MyStringLength&quot;;</span><br></pre></td></tr></table></figure>

<p>7）即可在hql使用自定义的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; select my_len(&#39;abcd&#39;);</span><br><span class="line">4</span><br></pre></td></tr></table></figure>



<h4 id="8-5-自定义UDTF函数"><a href="#8-5-自定义UDTF函数" class="headerlink" title="8.5 自定义UDTF函数"></a>8.5 自定义UDTF函数</h4><p>0）需求</p>
<p>自定义一个UDTF实现将一个任意分隔符的字符串切割成独立的单词，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; select myudtf(&quot;hello,world,hadoop,hive&quot;, &quot;,&quot;);</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hadoop</span><br><span class="line">hive</span><br></pre></td></tr></table></figure>

<p>1）代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.hive.udtf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDFArgumentException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.metadata.HiveException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.udf.generic.GenericUDTF;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.StructField;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义UDTF函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 需要继承 GenericUDTF类，并重写抽象方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 函数的使用: select myudtf('hive,hadoop,flume,kafka',',');</span></span><br><span class="line"><span class="comment"> *      结果:  word</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *            hive</span></span><br><span class="line"><span class="comment"> *            hadoop</span></span><br><span class="line"><span class="comment"> *            flume</span></span><br><span class="line"><span class="comment"> *            kafka</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  扩展:</span></span><br><span class="line"><span class="comment"> *  select myudtf2('hadoop-niupi,java-lihai,songsong-kuai,dahai-lang',',','-');</span></span><br><span class="line"><span class="comment"> *  结果: word1    word2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       hadoop   niupi</span></span><br><span class="line"><span class="comment"> *       java     lihai</span></span><br><span class="line"><span class="comment"> *       songsong kuai</span></span><br><span class="line"><span class="comment"> *       dahai    lang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringSplitUDTF</span> <span class="keyword">extends</span> <span class="title">GenericUDTF</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">private</span> ArrayList&lt;String&gt; outList  = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法  约定函数的返回值类型  和 函数的返回值列名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> argOIs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UDFArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> StructObjectInspector <span class="title">initialize</span><span class="params">(StructObjectInspector argOIs)</span><span class="keyword">throws</span> UDFArgumentException</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//基本判断</span></span><br><span class="line">        List&lt;? extends StructField&gt; fieldRefs = argOIs.getAllStructFieldRefs();</span><br><span class="line">		<span class="keyword">if</span>(fieldRefs.size()!=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UDFArgumentException(<span class="string">"Input Args Length Error!!！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//约定函数返回的列的名字</span></span><br><span class="line">        ArrayList&lt;String&gt; fieldNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    	fieldNames.add(<span class="string">"word"</span>);</span><br><span class="line">        <span class="comment">//约定函数返回的列的类型</span></span><br><span class="line">         ArrayList&lt;ObjectInspector&gt; fieldOIs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         fieldOIs.add(PrimitiveObjectInspectorFactory.javaStringObjectInspector);</span><br><span class="line">         <span class="keyword">return</span> ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames, fieldOIs);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 函数的逻辑处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> HiveException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        String argsData =  args[<span class="number">0</span>].toString();</span><br><span class="line">        String argsSplit = args[<span class="number">1</span>].toString();</span><br><span class="line">        <span class="comment">//切分数据</span></span><br><span class="line">        String[] words = argsData.split(argsSplit);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写出数据 每个单词一行</span></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="comment">//因为集合是重用的，所以每次要先清空</span></span><br><span class="line">            outList.clear();</span><br><span class="line">            <span class="comment">//将当前的单词放到集合中</span></span><br><span class="line">            outList.add(word);</span><br><span class="line">            <span class="comment">//将当前的单词作为一行写出去</span></span><br><span class="line">            forward(outList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需求扩展</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select myudtf2(&#39;hadoop-niupi,java-lihai,songsong-kuai,dahai-lang&#39;,&#39;,&#39;,&#39;-&#39;);</span><br><span class="line"> 结果: word1    word2</span><br><span class="line">      hadoop   niupi</span><br><span class="line">      java     lihai</span><br><span class="line">      songsong kuai</span><br><span class="line">      dahai    lang</span><br></pre></td></tr></table></figure>

<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringSplitUDTF2</span> <span class="keyword">extends</span> <span class="title">GenericUDTF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; outList  = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法  约定函数的返回值类型  和 函数的返回值列名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> argOIs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UDFArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StructObjectInspector <span class="title">initialize</span><span class="params">(StructObjectInspector argOIs)</span> <span class="keyword">throws</span> UDFArgumentException </span>&#123;</span><br><span class="line">        <span class="comment">//基本判断</span></span><br><span class="line">        List&lt;? extends StructField&gt; fieldRefs = argOIs.getAllStructFieldRefs();</span><br><span class="line">        <span class="keyword">if</span>(fieldRefs.size()!=<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UDFArgumentException(<span class="string">"Input Args Length Error!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//约定函数返回的列的名字</span></span><br><span class="line">        ArrayList&lt;String&gt; fieldNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        fieldNames.add(<span class="string">"word1"</span>);</span><br><span class="line">        fieldNames.add(<span class="string">"word2"</span>);</span><br><span class="line">        <span class="comment">//约定函数返回的列的类型</span></span><br><span class="line">        ArrayList&lt;ObjectInspector&gt; fieldOIs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        fieldOIs.add(PrimitiveObjectInspectorFactory.javaStringObjectInspector);</span><br><span class="line">        fieldOIs.add(PrimitiveObjectInspectorFactory.javaStringObjectInspector);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames, fieldOIs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 函数的逻辑处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> HiveException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line">        <span class="comment">//获取参数</span></span><br><span class="line">        String argsData = args[<span class="number">0</span>].toString(); <span class="comment">// hadoop-niupi,java-lihai,songsong-kuai,dahai-lang</span></span><br><span class="line">        String rowSplit = args[<span class="number">1</span>].toString(); <span class="comment">// ,</span></span><br><span class="line">        String colSplit = args[<span class="number">2</span>].toString(); <span class="comment">// -</span></span><br><span class="line">        <span class="comment">//切分数据</span></span><br><span class="line">        String[] rows = argsData.split(rowSplit);</span><br><span class="line">        <span class="keyword">for</span> (String row : rows) &#123;</span><br><span class="line">            <span class="comment">//因为集合是复用的，使用前先清空</span></span><br><span class="line">            outList.clear();</span><br><span class="line">            <span class="comment">// row : hadoop-niupi</span></span><br><span class="line">            String[] cols = row.split(colSplit);</span><br><span class="line">            <span class="keyword">for</span> (String word : cols) &#123;</span><br><span class="line">                outList.add(word);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//写出</span></span><br><span class="line">            forward(outList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-压缩和存储"><a href="#9-压缩和存储" class="headerlink" title="9. 压缩和存储"></a>9. 压缩和存储</h3><h4 id="9-1-Hadoop压缩配置"><a href="#9-1-Hadoop压缩配置" class="headerlink" title="9.1 Hadoop压缩配置"></a>9.1 Hadoop压缩配置</h4><h5 id="9-1-1-MR支持的压缩编码"><a href="#9-1-1-MR支持的压缩编码" class="headerlink" title="9.1.1 MR支持的压缩编码"></a>9.1.1 MR支持的压缩编码</h5><table>
<thead>
<tr>
<th>压缩格式</th>
<th>算法</th>
<th>文件扩展名</th>
<th>是否可切分</th>
</tr>
</thead>
<tbody><tr>
<td>DEFLATE</td>
<td>DEFLATE</td>
<td>.deflate</td>
<td>否</td>
</tr>
<tr>
<td>Gzip</td>
<td>DEFLATE</td>
<td>.gz</td>
<td>否</td>
</tr>
<tr>
<td>bzip2</td>
<td>bzip2</td>
<td>.bz2</td>
<td>是</td>
</tr>
<tr>
<td>LZO</td>
<td>LZO</td>
<td>.lzo</td>
<td>是</td>
</tr>
<tr>
<td>Snappy</td>
<td>Snappy</td>
<td>.snappy</td>
<td>否</td>
</tr>
</tbody></table>
<p>为了支持多种压缩/解压缩算法，Hadoop引入了编码/解码器，如下表所示：</p>
<table>
<thead>
<tr>
<th>压缩格式</th>
<th>对应的编码/解码器</th>
</tr>
</thead>
<tbody><tr>
<td>DEFLATE</td>
<td>org.apache.hadoop.io.compress.DefaultCodec</td>
</tr>
<tr>
<td>gzip</td>
<td>org.apache.hadoop.io.compress.GzipCodec</td>
</tr>
<tr>
<td>bzip2</td>
<td>org.apache.hadoop.io.compress.BZip2Codec</td>
</tr>
<tr>
<td>LZO</td>
<td>com.hadoop.compression.lzo.LzopCodec</td>
</tr>
<tr>
<td>Snappy</td>
<td>org.apache.hadoop.io.compress.SnappyCodec</td>
</tr>
</tbody></table>
<p>压缩性能的比较：</p>
<table>
<thead>
<tr>
<th>压缩算法</th>
<th>原始文件大小</th>
<th>压缩文件大小</th>
<th>压缩速度</th>
<th>解压速度</th>
</tr>
</thead>
<tbody><tr>
<td>gzip</td>
<td>8.3GB</td>
<td>1.8GB</td>
<td>17.5MB/s</td>
<td>58MB/s</td>
</tr>
<tr>
<td>bzip2</td>
<td>8.3GB</td>
<td>1.1GB</td>
<td>2.4MB/s</td>
<td>9.5MB/s</td>
</tr>
<tr>
<td>LZO</td>
<td>8.3GB</td>
<td>2.9GB</td>
<td>49.3MB/s</td>
<td>74.6MB/s</td>
</tr>
</tbody></table>
<p><a href="http://google.github.io/snappy/" target="_blank" rel="noopener">http://google.github.io/snappy/</a></p>
<p>On a single core of a Core i7 processor in 64-bit mode, Snappy compresses at about 250 MB/sec or more and decompresses at about 500 MB/sec or more.</p>
<p>用到比较多的是snappy和lzo</p>
<h5 id="9-1-2-压缩参数配置"><a href="#9-1-2-压缩参数配置" class="headerlink" title="9.1.2 压缩参数配置"></a>9.1.2 压缩参数配置</h5><p>​    要在Hadoop中启用压缩，可以配置如下参数（mapred-site.xml文件中）</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>默认值</th>
<th>阶段</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td>io.compression.codecs    （在core-site.xml中配置）</td>
<td>org.apache.hadoop.io.compress.DefaultCodec, org.apache.hadoop.io.compress.GzipCodec,  org.apache.hadoop.io.compress.BZip2Codec,  org.apache.hadoop.io.compress.Lz4Codec</td>
<td>输入压缩</td>
<td>Hadoop使用文件扩展名判断是否支持某种编解码器</td>
</tr>
<tr>
<td>mapreduce.map.output.compress</td>
<td>false</td>
<td>mapper输出</td>
<td>这个参数设为true启用压缩</td>
</tr>
<tr>
<td>mapreduce.map.output.compress.codec</td>
<td>org.apache.hadoop.io.compress.DefaultCodec</td>
<td>mapper输出</td>
<td>使用LZO、LZ4或snappy编解码器在此阶段压缩数据</td>
</tr>
<tr>
<td>mapreduce.output.fileoutputformat.compress</td>
<td>false</td>
<td>reducer输出</td>
<td>这个参数设为true启用压缩</td>
</tr>
<tr>
<td>mapreduce.output.fileoutputformat.compress.codec</td>
<td>org.apache.hadoop.io.compress. DefaultCodec</td>
<td>reducer输出</td>
<td>使用标准工具或者编解码器，如gzip和bzip2</td>
</tr>
<tr>
<td>mapreduce.output.fileoutputformat.compress.type</td>
<td>RECORD</td>
<td>reducer输出</td>
<td>SequenceFile输出使用的压缩类型：NONE和BLOCK</td>
</tr>
</tbody></table>
<h4 id="9-2-开启Map端输出阶段压缩（MR引擎）"><a href="#9-2-开启Map端输出阶段压缩（MR引擎）" class="headerlink" title="9.2 开启Map端输出阶段压缩（MR引擎）"></a>9.2 开启Map端输出阶段压缩（MR引擎）</h4><p>​    开启map输出阶段压缩可以减少job中map和ReduceTask间的数据传输率。具体配置如下</p>
<p>1）案例实操</p>
<p>（1）开启hive中间传输数据压缩功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt;set hive.exec.compress.intermediate&#x3D;true;</span><br></pre></td></tr></table></figure>

<p>（2）开启MapReduce中map输出压缩功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt;set mapreduce.map.output.compress&#x3D;true;</span><br></pre></td></tr></table></figure>

<p>（3）设置MapReduce中map输出数据的压缩方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt;set mapreduce.map.output.compress.codec&#x3D;</span><br><span class="line"> org.apache.hadoop.io.compress.SnappyCodec;</span><br></pre></td></tr></table></figure>

<p>（4）执行查询语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; select count(ename) name from emp;</span><br></pre></td></tr></table></figure>



<h4 id="9-3-开启Reduce输出阶段压缩"><a href="#9-3-开启Reduce输出阶段压缩" class="headerlink" title="9.3 开启Reduce输出阶段压缩"></a>9.3 开启Reduce输出阶段压缩</h4><p>​    当Hive将输出写到表中时，输出内容同样可以进行压缩。属性hive.exec.compress.output控制着这个功能。用户可能需要保持默认设置文件中的默认值false，这样默认的输出就是非压缩的纯文本文件了。用户可以通过在查询语句或执行脚本中设置这个值为true，来开启输出结果压缩功能。</p>
<p>1）案例实操</p>
<p>（1）开启hive最终输出数据压缩功能  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt;set hive.exec.compress.output&#x3D;true;</span><br></pre></td></tr></table></figure>

<p>（2）开启mapreduce最终输出数据压缩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt;set mapreduce.output.fileoutputformat.compress&#x3D;true;</span><br></pre></td></tr></table></figure>

<p>（3）设置mapreduce最终数据输出压缩方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; set mapreduce.output.fileoutputformat.compress.codec &#x3D;</span><br><span class="line"> org.apache.hadoop.io.compress.SnappyCodec;</span><br></pre></td></tr></table></figure>

<p>（4）设置mapreduce最终数据输出压缩为块压缩  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; set mapreduce.output.fileoutputformat.compress.type&#x3D;BLOCK;</span><br></pre></td></tr></table></figure>

<p>（5）测试一下输出结果是否是压缩文件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; insert overwrite local directory</span><br><span class="line"> &#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;distribute-result&#39; select * from emp distribute by deptno sort by empno desc;</span><br></pre></td></tr></table></figure>

<h4 id="9-4-文件存储格式"><a href="#9-4-文件存储格式" class="headerlink" title="9.4 文件存储格式"></a>9.4 文件存储格式</h4><p>​    HIve支持的存储数据的格式有：TEXTFILE,SEQUENCEFILE,QRC,PARQUET。</p>
<h4 id="9-4-1-列式存储和行式存储"><a href="#9-4-1-列式存储和行式存储" class="headerlink" title="9.4.1 列式存储和行式存储"></a>9.4.1 列式存储和行式存储</h4><p>1）行存储的特点</p>
<p>​    查询满足条件的一整行数据的时候，列存储则需要去每个聚集的字段找到对应的每个列的值，行存储只需要找到其中一个值，其余的值都在相邻地方，所以此时行存储查询的速度更快。</p>
<p>2）列存储的特点</p>
<p>​    因为每个字段的数据聚集存储，在查询只需要少数几个字段的时候，能大大减少读取的数据量；每个字段的数据类型一定是相同的，列式存储可以针对性的设计更好的设计压缩算法。</p>
<p>​    TEXTFIlE和SEQUENCEFILE的存储格式都是基于行存储的</p>
<p>​    ORC和PARQUET是基于列式存储的</p>
<p>​    因为通常查询的时候大多数情况都不会去查询所有的字段，而是查询某些属性，或对某几个字段进行计算，所以大多数情况还是列式存储，这样查询效率会更快一点。</p>
<h5 id="9-4-2-TextFile格式"><a href="#9-4-2-TextFile格式" class="headerlink" title="9.4.2 TextFile格式"></a>9.4.2 TextFile格式</h5><p>​    默认格式，数据不做压缩，磁盘开销大，磁盘开销大，数据解析开销大。可结合Gzip和Bzip2使用，但是用Gzip这种方式，hive不会对数据进行切分，从而无法对数据进行并行操作。</p>
<h4 id="9-4-3-Orc格式"><a href="#9-4-3-Orc格式" class="headerlink" title="9.4.3 Orc格式"></a>9.4.3 Orc格式</h4><p>​    Orc(Optimized Row Columnar)是Hive0.11版里引入的新的存储格式。</p>
<p>​    每个Orc文件由1个或多个stripe组成，每个stripe一般为HDFS的块大小，每一个stripe包含多条记录，这些记录按照列进行独立存储，对应到Parquet中的row group的概念。每个Stripe里有三部分组成，分别是Index Data，Row Data，Stripe Footer。</p>
<p>1）Index Data：一个轻量级的index，默认是每隔1W行做一个索引。这里做的索引应该只是记录某行的各字段在Row Data中的offset。</p>
<p>2）Row Data：存的是具体的数据，先取部分行，然后对这些行按列进行存储。对每个列进行了编码，分成多个Stream来存储。</p>
<p>3）Stripe Footer：存的是各个Stream的类型，长度等信息。</p>
<p>​    每个文件有一个File Footer，这里面存的是每个Stripe的行数，每个Column的数据类型信息等；每个文件的尾部是一个PostScript，这里面记录了整个文件的压缩类型以及FileFooter的长度信息等。在读取文件时，会seek到文件尾部读PostScript，从里面解析到File Footer长度，再读FileFooter，从里面解析到各个Stripe信息，再读各个Stripe，即从后往前读。</p>
<h5 id="9-4-4-Parquet格式"><a href="#9-4-4-Parquet格式" class="headerlink" title="9.4.4 Parquet格式"></a>9.4.4 Parquet格式</h5><p>​    Parquet文件是以二进制方式存储的，所以是不可以直接读取的，文件中包括该文件的数据和元数据，因此Parquet格式是自解析的。</p>
<p>（1）行组(Row Group)：每一个行组包含一定的行数，在一个HDFS文件中至少存储一个行组，类似于orc的stripe的概念  </p>
<p>（2）列块(Column Chunk)：在一个行组中每一列保存在一个列块中，行组中的所有列连续的存储在这个行组文件中。一个列块中的值都是相同类型的，不同的列块可能使用不同的算法进行压缩。</p>
<p>（3）页(Page)：每一个列块划分为多个页，一个页是最小的编码的单位，在同一个列块的不同页可能使用不同的编码方式。  </p>
<p>​    通常情况下，在存储Parquet数据的时候会按照Block大小设置行组的大小，由于一般情况下每一个Mapper任务处理数据的最小单位是一个Block，这样可以把每一个行组由一个Mapper任务处理，增大任务执行并行度。</p>
<h5 id="9-4-5-主流文件存储格式对比试验"><a href="#9-4-5-主流文件存储格式对比试验" class="headerlink" title="9.4.5 主流文件存储格式对比试验"></a>9.4.5 主流文件存储格式对比试验</h5><p>1）准备测试数据</p>
<p>2）TextFile</p>
<p>（1）创建表，存储数据格式为TEXTFILE</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> log_text (</span><br><span class="line">track_time <span class="keyword">string</span>,</span><br><span class="line"><span class="keyword">url</span> <span class="keyword">string</span>,</span><br><span class="line">session_id <span class="keyword">string</span>,</span><br><span class="line">referer <span class="keyword">string</span>,</span><br><span class="line">ip <span class="keyword">string</span>,</span><br><span class="line">end_user_id <span class="keyword">string</span>,</span><br><span class="line">city_id <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span></span><br><span class="line"><span class="keyword">stored</span> <span class="keyword">as</span> textfile;</span><br></pre></td></tr></table></figure>

<p>（2）向表中加载数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;log.data&#39; into table log_text ;</span><br></pre></td></tr></table></figure>

<p>（3）查看表中数据大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; dfs -du -h &#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;log_text;</span><br></pre></td></tr></table></figure>

<p>3）ORC</p>
<p>（11）创建表，存储数据格式为ORC</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> log_orc(</span><br><span class="line">track_time <span class="keyword">string</span>,</span><br><span class="line"><span class="keyword">url</span> <span class="keyword">string</span>,</span><br><span class="line">session_id <span class="keyword">string</span>,</span><br><span class="line">referer <span class="keyword">string</span>,</span><br><span class="line">ip <span class="keyword">string</span>,</span><br><span class="line">end_user_id <span class="keyword">string</span>,</span><br><span class="line">city_id <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span></span><br><span class="line"><span class="keyword">stored</span> <span class="keyword">as</span> orc</span><br><span class="line">tblproperties(<span class="string">"orc.compress"</span> = <span class="string">"NONE"</span>);<span class="comment">--设置ORC存储不能使用压缩</span></span><br></pre></td></tr></table></figure>

<p>（2）向表中加载数据</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; insert into table log_orc select * from log_text ;</span><br></pre></td></tr></table></figure>

<p>（3）查看表中数据大小</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; dfs -du -h /user/hive/warehouse/log_orc/ ;</span><br></pre></td></tr></table></figure>

<p>4）Parquet</p>
<p>（1）创建表，存储数据格式为parquet</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table log_parquet(</span><br><span class="line">track_time string,</span><br><span class="line">url string,</span><br><span class="line">session_id string,</span><br><span class="line">referer string,</span><br><span class="line">ip string,</span><br><span class="line">end_user_id string,</span><br><span class="line">city_id string</span><br><span class="line">)</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;</span><br><span class="line">stored as parquet;</span><br></pre></td></tr></table></figure>

<p>（2）向表中加载数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; insert into table log_parquet select * from log_text ;</span><br></pre></td></tr></table></figure>

<p>（3）查看表中数据大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; dfs -du -h &#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;log_parquet&#x2F; ;</span><br></pre></td></tr></table></figure>

<p>存储文件的对比总结：</p>
<p>ORC &gt; Parquet &gt; textFile</p>
<p>可以通过测试发现这三种格式存储的文件查询速度相近</p>
<h4 id="9-5-存储和压缩结合"><a href="#9-5-存储和压缩结合" class="headerlink" title="9.5 存储和压缩结合"></a>9.5 存储和压缩结合</h4><h4 id="9-5-1-测试存储和压缩"><a href="#9-5-1-测试存储和压缩" class="headerlink" title="9.5.1 测试存储和压缩"></a>9.5.1 测试存储和压缩</h4><p>官网：<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+ORC" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+ORC</a></p>
<p>ORC存储方式的压缩</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Default</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>orc.compress</td>
<td>ZLIB</td>
<td>high level  compression (one of NONE, ZLIB, SNAPPY)</td>
</tr>
<tr>
<td>orc.compress.size</td>
<td>262,144</td>
<td>number of bytes  in each compression chunk</td>
</tr>
<tr>
<td>orc.stripe.size</td>
<td>268,435,456</td>
<td>number of bytes in each stripe</td>
</tr>
<tr>
<td>orc.row.index.stride</td>
<td>10,000</td>
<td>number of rows between index entries (must be &gt;= 1000)</td>
</tr>
<tr>
<td>orc.create.index</td>
<td>true</td>
<td>whether to create  row indexes</td>
</tr>
<tr>
<td>orc.bloom.filter.columns</td>
<td>“”</td>
<td>comma separated list of column names for which bloom filter should be  created</td>
</tr>
<tr>
<td>orc.bloom.filter.fpp</td>
<td>0.05</td>
<td>false positive probability for bloom filter (must &gt;0.0 and &lt;1.0)</td>
</tr>
</tbody></table>
<p>​    注意：所有关于ORCFile的参数都是在HQL语句的TBLPROPERTIES字段里面出现</p>
<p>1）创建一个ZLIB压缩的ORC存储方式</p>
<p>（1）建表语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table log_orc_zlib(</span><br><span class="line">track_time string,</span><br><span class="line">url string,</span><br><span class="line">session_id string,</span><br><span class="line">referer string,</span><br><span class="line">ip string,</span><br><span class="line">end_user_id string,</span><br><span class="line">city_id string</span><br><span class="line">)</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;</span><br><span class="line">stored as orc</span><br><span class="line">tblproperties(&quot;orc.compress&quot;&#x3D;&quot;ZLIB&quot;);</span><br></pre></td></tr></table></figure>

<p>（2）插入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into log_orc_zlib select * from log_text;</span><br></pre></td></tr></table></figure>

<p>（3）查看插入后数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; dfs -du -h &#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;log_orc_zlib&#x2F; ;</span><br></pre></td></tr></table></figure>

<p>2）创建一个snappy压缩的ORC存储方式</p>
<p>（1）建表语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table log_orc_snappy(</span><br><span class="line">track_time string,</span><br><span class="line">url string,</span><br><span class="line">session_id string,</span><br><span class="line">referer string,</span><br><span class="line">ip string,</span><br><span class="line">end_user_id string,</span><br><span class="line">city_id string</span><br><span class="line">)</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;</span><br><span class="line">stored as orc</span><br><span class="line">tblproperties(&quot;orc.compress&quot;&#x3D;&quot;SNAPPY&quot;);</span><br></pre></td></tr></table></figure>

<p>（2）插入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into log_orc_snappy select * from log_text;</span><br></pre></td></tr></table></figure>

<p>（3）查看插入后数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; dfs -du -h &#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;log_orc_snappy&#x2F; ;</span><br></pre></td></tr></table></figure>

<p>……</p>
<p>4）存储方式和压缩总结</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在实际的项目开发当中，hive表的数据存储格式一般选择：orc或parquet。压缩方式一般选择snappy，lzo。</span><br></pre></td></tr></table></figure>



<h3 id="10-企业级调优"><a href="#10-企业级调优" class="headerlink" title="10 . 企业级调优"></a>10 . 企业级调优</h3><h3 id="11-Hive实战"><a href="#11-Hive实战" class="headerlink" title="11. Hive实战"></a>11. Hive实战</h3><h4 id="11-1-需求描述"><a href="#11-1-需求描述" class="headerlink" title="11.1 需求描述"></a>11.1 需求描述</h4><p>统计硅谷影音视频网站的常规指标，各种TopN指标：</p>
<p>– 统计视频观看数Top10</p>
<p>– 统计视频类别热度Top10</p>
<p>– 统计出视频观看数最高的20个视频的所属类别以及类别包含Top20视频的个数</p>
<p>– 统计视频观看数Top50所关联视频的所属类别Rank</p>
<p>– 统计每个类别中的视频热度Top10,以Music为例</p>
<p>– 统计每个类别视频观看数Top10</p>
<p>– 统计上传视频最多的用户Top10以及他们上传的视频观看次数在前20的视频 </p>
<h4 id="11-2-数据结构"><a href="#11-2-数据结构" class="headerlink" title="11.2 数据结构"></a>11.2 数据结构</h4><p>1）视频表</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>备注</th>
<th>详细描述</th>
</tr>
</thead>
<tbody><tr>
<td>videoId</td>
<td>视频唯一id（String）</td>
<td>11位字符串</td>
</tr>
<tr>
<td>uploader</td>
<td>视频上传者（String）</td>
<td>上传视频的用户名String</td>
</tr>
<tr>
<td>age</td>
<td>视频年龄（int）</td>
<td>视频在平台上的整数天</td>
</tr>
<tr>
<td>category</td>
<td>视频类别（Array<String>）</td>
<td>上传视频指定的视频分类</td>
</tr>
<tr>
<td>length</td>
<td>视频长度（Int）</td>
<td>整形数字标识的视频长度</td>
</tr>
<tr>
<td>views</td>
<td>观看次数（Int）</td>
<td>视频被浏览的次数</td>
</tr>
<tr>
<td>rate</td>
<td>视频评分（Double）</td>
<td>满分5分</td>
</tr>
<tr>
<td>Ratings</td>
<td>流量（Int）</td>
<td>视频的流量，整型数字</td>
</tr>
<tr>
<td>conments</td>
<td>评论数（Int）</td>
<td>一个视频的整数评论数</td>
</tr>
<tr>
<td>relatedId</td>
<td>相关视频id（Array<String>）</td>
<td>相关视频的id，最多20个</td>
</tr>
</tbody></table>
<p>2）用户表</p>
<table>
<thead>
<tr>
<th><strong>字段</strong></th>
<th><strong>备注</strong></th>
<th><strong>字段类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td>uploader</td>
<td>上传者用户名</td>
<td>string</td>
</tr>
<tr>
<td>videos</td>
<td>上传视频数</td>
<td>int</td>
</tr>
<tr>
<td>friends</td>
<td>朋友数量  （关注的人）</td>
<td>int</td>
</tr>
</tbody></table>
<h4 id="11-3-准备工作"><a href="#11-3-准备工作" class="headerlink" title="11.3 准备工作"></a>11.3 准备工作</h4><h5 id="11-3-1-ETL"><a href="#11-3-1-ETL" class="headerlink" title="11.3.1 ETL"></a>11.3.1 ETL</h5><p>​    通过观察原始数据形式，可以发现，视频可以有多个所属分类，每个所属分类用&amp;符号分割，且分割的两边有空格字符，同时相关视频也是可以有多个元素，多个相关视频又用“\t”进行分割。为了分析数据时方便对存在多个子元素的数据进行操作，我们首先进行数据重组清洗操作。即：将所有的类别用“&amp;”分割，同时去掉两边空格，多个相关视频id也使用“&amp;”进行分割。</p>
<p>1）ETL之封装工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ETLUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	* 数据清洗方法</span></span><br><span class="line"><span class="comment"> 	*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String  <span class="title">etlData</span><span class="params">(String srcData)</span></span>&#123;</span><br><span class="line">        StringBuffer resultData = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">//1. 先将数据通过\t 切割</span></span><br><span class="line">        String[] datas = srcData.split(<span class="string">"\t"</span>);</span><br><span class="line">        <span class="comment">//2. 判断长度是否小于9</span></span><br><span class="line">        <span class="keyword">if</span>(datas.length &lt;<span class="number">9</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 将数据中的视频类别的空格去掉</span></span><br><span class="line">        datas[<span class="number">3</span>]=datas[<span class="number">3</span>].replaceAll(<span class="string">" "</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="comment">//4. 将数据中的关联视频id通过&amp;拼接</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; datas.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">9</span>)&#123;</span><br><span class="line">                <span class="comment">//4.1 没有关联视频的情况</span></span><br><span class="line">                <span class="keyword">if</span>(i == datas.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    resultData.append(datas[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    resultData.append(datas[i]).append(<span class="string">"\t"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//4.2 有关联视频的情况</span></span><br><span class="line">                <span class="keyword">if</span>(i == datas.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    resultData.append(datas[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    resultData.append(datas[i]).append(<span class="string">"&amp;"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultData.toString();</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2）ETL之Mapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清洗谷粒影音的原始数据</span></span><br><span class="line"><span class="comment"> * 清洗规则</span></span><br><span class="line"><span class="comment"> *  1. 将数据长度小于9的清洗掉</span></span><br><span class="line"><span class="comment"> *  2. 将数据中的视频类别中间的空格去掉   People &amp; Blogs</span></span><br><span class="line"><span class="comment"> *  3. 将数据中的关联视频id通过&amp;符号拼接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EtlMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>,<span class="title">Text</span>, <span class="title">NullWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Text k = <span class="keyword">new</span> Text();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">       <span class="comment">//获取一行</span></span><br><span class="line">        String line = value.toString();</span><br><span class="line">        <span class="comment">//清洗</span></span><br><span class="line">        String resultData = ETLUtil.etlData(line);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(resultData != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//写出</span></span><br><span class="line">            k.set(resultData);</span><br><span class="line">            context.write(k,NullWritable.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）ETL之Driver</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.atguigu.gulivideo.etl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.NullWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EtlDriver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job  = Job.getInstance(conf);</span><br><span class="line">        job.setJarByClass(EtlDriver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapperClass(EtlMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(NullWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(NullWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setNumReduceTasks(<span class="number">0</span>);</span><br><span class="line">        FileInputFormat.setInputPaths(job,<span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job,<span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">        job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）将ETL程序打包为etl.jar并上传到Linux的/opt/module/hive/datas目录下</p>
<p>5）上传原始数据到HDFS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 datas] pwd</span><br><span class="line">&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas</span><br><span class="line">[atguigu@hadoop102 datas] hadoop fs -mkdir -p  &#x2F;gulivideo&#x2F;video</span><br><span class="line">[atguigu@hadoop102 datas] hadoop fs -mkdir -p  &#x2F;gulivideo&#x2F;user</span><br><span class="line">[atguigu@hadoop102 datas] hadoop fs -put gulivideo&#x2F;user&#x2F;user.txt   &#x2F;gulivideo&#x2F;user</span><br><span class="line">[atguigu@hadoop102 datas] hadoop fs -put gulivideo&#x2F;video&#x2F;*.txt   &#x2F;gulivideo&#x2F;video</span><br></pre></td></tr></table></figure>

<p>6）ETL数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 datas] hadoop jar  etl.jar  com.atguigu.hive.etl.EtlDriver &#x2F;gulivideo&#x2F;video &#x2F;gulivideo&#x2F;video&#x2F;output</span><br></pre></td></tr></table></figure>

<h5 id="11-3-2-准备表"><a href="#11-3-2-准备表" class="headerlink" title="11.3.2 准备表"></a>11.3.2 准备表</h5><p>​    1）需要准备的表</p>
<p>​    2）创建原始数据表</p>
<p>​    3）创建ORC存储格式带snappy压缩的表</p>
<h5 id="11-3-3-安装Tez引擎"><a href="#11-3-3-安装Tez引擎" class="headerlink" title="11.3.3 安装Tez引擎"></a>11.3.3 安装Tez引擎</h5>]]></content>
      <categories>
        <category>Hadoop生态</category>
      </categories>
  </entry>
  <entry>
    <title>Hadoop HA</title>
    <url>/2020/05/30/Hadoop-HA/</url>
    <content><![CDATA[<h3 id="Hadoop-HA高可用"><a href="#Hadoop-HA高可用" class="headerlink" title="Hadoop HA高可用"></a>Hadoop HA高可用</h3><ol start="0">
<li><p>问题引入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目前Hadoop集群存在的问题:</span><br><span class="line">如果NameNode故障后，应该怎么办?</span><br><span class="line">      </span><br><span class="line">1)因为NameNode是HDFS的中心.所有的DN都要围绕着NN工作,如果NN故障后，整个HDFS不能在正常进行服务.</span><br><span class="line">      </span><br><span class="line">2)如上的问题就是比较典型的单点故障.</span><br><span class="line">      </span><br><span class="line">3)解决办法是: 搭建多个NameNode,其中一个是Active状态，就是正常对外提供服务.其他的NameNode都是standby状态,是不能对外提供服务的.只有当Active的NN故障后,StandBy状态的NN才有机会上位，代替之前的NN对外提供服务.</span><br><span class="line">4)待解决问题:</span><br><span class="line">a. 多个StandBy NN 如何保证与 Active NN 中的数据保持一致?</span><br><span class="line">	使用journalNode做为共享存储， ActiveNN 将edits写到JN中， StandByNN 从JN中读取edits在内存中进行重构，重构完后，就能保障StantByNN 和ActiveNN元数据一致.</span><br><span class="line">	   </span><br><span class="line">b. 多个StandBy NN 之间的争夺上位问题 </span><br><span class="line">脑裂问题: 一个集群中出现多个Active的NN</span><br><span class="line">手动故障转移: 完全由开发人员控制.</span><br><span class="line"></span><br><span class="line">	自动故障转移: 争抢. 每个NN都对应一个ZKFC进程(由hadoop提供的，可以访问Zookeeper的客户端对象), ZKFC负责监控NN的健康状态以及故障转移. ZKFC会在自己所维护的NN为健康状态的情况下，到ZK中争抢znode锁，如果获取锁成功，则将自己所维护的NN切换为Active状态.如果ZKFC所维护的NN为Active状态，当NN不健康后(ZKFC认为的),zkfc会断开与zk的连接,这样的话，在zk中拥有的锁也就释放，别的ZKFC发现没有别的ZKFC拥有锁的情况下，会尝试获取Znode锁，如果获取成功，则将自己所维护的NN切换为Active状态. 从而实现自动故障转移.</span><br><span class="line"></span><br><span class="line">	自动故障转移如何解决脑裂问题:</span><br><span class="line">	一个ZKFC所负责的NN为Active状态,当ZKFC认为NN不健康后，会触发自动故障转移,此时，其他的ZKFC会尝试获取znode锁，假如获取成功, 为了保证不出现脑裂问题，会SSH到原先ActiveNN的机器，执行Kill Namenode的命令. 扫清一切障碍后,然后才会将自己负责的NN切换为Active状态.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.2  如果ResourceManager故障后，应该怎么办?</span><br><span class="line">	跟NameNode处理类似</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol>
<li><p>HA概述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）所谓HA（High Availability），即高可用（7*24小时不中断服务）</span><br><span class="line">2）实现高可用的关键的策略是消除单点故障（单个重要节点出现问题，整个集群都可不用）。HA严格来说应该分为各个组件的HA机制：HDFS的HA和YARN的HA</span><br><span class="line">3）Hadoop2.0之前，在HDFS集群中NameNode存在单点故障SPOF（Single Points Of Failure）</span><br><span class="line">4）NameNode主要在以下两个方面影响HDFS集群</span><br><span class="line">	NameNode机器发生意外，如宕机，集群将无法使用，直到管理员重启</span><br><span class="line">	NameNode机器需要升级，包括软件，硬件升级，此时集群将无法使用</span><br><span class="line">	HDFS HA功能通过配置Active&#x2F;Standby两个NameNodes实现在集群中对NameNode的热备来解决上述问题。如果出现故障，如机器崩溃或机器需要实现维护升级，这时可通过此种方式将NameNode很快的切换到另外一台机器。</span><br></pre></td></tr></table></figure>
</li>
<li><p>HDFS HA搭建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）安装Hadoop，根据参考文档修改配置文件</span><br><span class="line">2）修改环境变量HADOOP_HOME，配置化为ha集群的位置，例如HADOOP_HOME&#x3D;&#x2F;opt&#x2F;module&#x2F;ha&#x2F;hadoop-3.1.3</span><br><span class="line">3）为了避免一些不必要的问题，删除每台机器&#x2F;tmp目录下的内容</span><br><span class="line">4）分发配置好的ha</span><br><span class="line">5）在每台机器上启动JN</span><br><span class="line">	hdfs --daemon start journalnode</span><br><span class="line">6）在任意一台nn上进行格式化操作，例如nn1</span><br><span class="line">	nn1: hdfs namenode -format</span><br><span class="line">7）启动nn1,然后其它namenode同步nn1的数据</span><br><span class="line">	nn1: hdfs --daemon start namenode</span><br><span class="line">	nn2: hdfs namenode -bootstrapStandBy</span><br><span class="line">	nn3: hdfs namenode -bootstrapStandBy</span><br><span class="line">8）启动nn2,nn3</span><br><span class="line">	nn2: hdfs --daemon start namenode</span><br><span class="line">	nn3: hdfs --daemon start namenode</span><br><span class="line">9）在每台机器上启动DN</span><br><span class="line">	hdfs --daemon start datenode</span><br><span class="line">10）将其中一个nn切换为Active状态</span><br><span class="line">	hdfs haadmin -transitionToActive nn1</span><br><span class="line">按照上面的步骤就配好了，可以从浏览器中访问NameNode查看各自的状态，但是这里不会自动进行故障转移处理</span><br><span class="line">自动故障转移还需要下面的配置</span><br><span class="line">自动故障转移HDFS HA集群规划(Zookeeper的搭建跟HA没关系，只要配置文件中配置了Zookeeper的位置，可以通过Hadoop提供的ZKFC客户端能连接到Zookeeper使用就可以了)：</span><br><span class="line">hadoop102: NameNode DataNode JournalNode ZKFC Zookeeper</span><br><span class="line">hadoop103: NameNode DataNode JournalNode ZKFC Zookeeper</span><br><span class="line">hadoop104: NameNOde DataNode JournalNode ZKFC Zookeeper</span><br><span class="line">	</span><br><span class="line">自动故障转移HDFSHA搭建</span><br><span class="line">1）根据参考文档添加相应的配置</span><br><span class="line">2）搭建Zookeeper集群并启动</span><br><span class="line">3）关闭hdfs服务</span><br><span class="line">	stop-dfs.sh</span><br><span class="line">4）初始化HA在zk中的状态</span><br><span class="line">	hdfs zkfc -formatZK</span><br><span class="line">5）启动hdfs服务</span><br><span class="line">	start-dfs.sh</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>YARN HA搭建  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YARN HA集群规划</span><br><span class="line">hadoop102 :   Namenode  Datanode JournalNode   ZKFC  ZK  ResourceManager  NodeManager</span><br><span class="line">hadoop103 :   Namenode  Datanode JournalNode   ZKFC  ZK  ResourceManager  NodeManager</span><br><span class="line">hadoop104 :   Namenode  Datanode JournalNode   ZKFC  ZK  ResourceManager  NodeManager</span><br><span class="line"></span><br><span class="line">YARN HA 搭建过程</span><br><span class="line">1）根据参考文档添加相应的配置</span><br><span class="line">2）启动</span><br><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>可能遇到的问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）搭建好HA后，通过start-dfs.sh启动集群,发现NameNode会掉.但是重新启动NameNode后，就正常运行，这是因为在HA集群中,NameNode启动后，需要找到JN，但是start-dfs.sh脚本启动的顺序是先起NN，后起JN，因此可能因为NN启动后，尝试连接JN，但是JN还没有启动起来. 超时以后，NN自动掉了. </span><br><span class="line">相关的两个配置</span><br><span class="line">1) 最大重试次数</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">	&lt;name&gt;ipc.client.connect.max.retries&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;value&gt;10&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">  2) 每次重试的间隔</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">      &lt;name&gt;ipc.client.connect.retry.interval&lt;&#x2F;name&gt;</span><br><span class="line">      &lt;value&gt;1000&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>Hadoop生态</category>
      </categories>
  </entry>
  <entry>
    <title>zookeeper基本介绍</title>
    <url>/2020/05/29/zookeeper%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.  基本介绍"></a>1.  基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Zookeeper是一个开源的分布式，为分布式应用提供协调服务的Apache。</span><br><span class="line">Zookeeper从设计模式角度来理解，是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生了变化，Zookeeper就负责通知已经在Zookeeper上注册的那些观察者做出相应的反应.</span><br><span class="line">Zookeeper &#x3D; 文件系统 + 通知机制</span><br></pre></td></tr></table></figure>

<h4 id="1-1-Zookeeper特点"><a href="#1-1-Zookeeper特点" class="headerlink" title="1.1 Zookeeper特点"></a>1.1 Zookeeper特点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）Zookeeper：由一个Leader，多个Follower组成的集群</span><br><span class="line">2）集群中只要有半数以上的节点存活，Zookeeper集群就能正常服务</span><br><span class="line">3）全局数据一致；每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的</span><br><span class="line">4）更新要求顺序进行，来自同一个Client的更新请求按其发送顺序依次执行</span><br><span class="line">5）数据更新原子性，一次数据要么更新成功，要么失败</span><br><span class="line">6）实时性，在一定时间范围内，Client能读到最新数据</span><br></pre></td></tr></table></figure>



<h4 id="1-2-数据结构"><a href="#1-2-数据结构" class="headerlink" title="1.2 数据结构"></a>1.2 数据结构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Zookeeper数据模型的结构与Linux文件系统很类似，整体上可以看作是一棵树，每个节点称作为一个ZNode，每一个ZNode默认能够存储1MB的数据，每个ZNode都可以通过唯一路径进行标识。</span><br></pre></td></tr></table></figure>

<h4 id="1-3-应用场景"><a href="#1-3-应用场景" class="headerlink" title="1.3 应用场景"></a>1.3 应用场景</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提供更多服务包括：统一命名服务，统一配置管理，统一集群管理，服务器节点动态上下线，软负载均衡等。</span><br></pre></td></tr></table></figure>



<h4 id="1-4-下载地址"><a href="#1-4-下载地址" class="headerlink" title="1.4 下载地址"></a>1.4 下载地址</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;zookeeper.apache.org</span><br></pre></td></tr></table></figure>



<h3 id="2-Zookeeper内部原理"><a href="#2-Zookeeper内部原理" class="headerlink" title="2. Zookeeper内部原理"></a>2. Zookeeper内部原理</h3><h4 id="2-1-节点类型"><a href="#2-1-节点类型" class="headerlink" title="2.1 节点类型"></a>2.1 节点类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）持久节点：客户端和zk服务断开连接后，持久节点不会被删除（除非手动删除）</span><br><span class="line">	（1）普通持久节点</span><br><span class="line">	（2）带序号的短暂节点（序号是Zookeeper自己维护的）</span><br><span class="line">2）短暂节点：客户端与zk服务断开连接后，短暂节点会自动删除</span><br><span class="line">	（1）普通短暂节点</span><br><span class="line">	（2）带序号的短暂节点（序号是Zookeeper自己维护的）</span><br></pre></td></tr></table></figure>

<h4 id="2-2-监听器原理"><a href="#2-2-监听器原理" class="headerlink" title="2.2 监听器原理"></a>2.2 监听器原理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）创建Zk客户端对象时，会对应着创建两个线程，一个是connect线程，一个是listener线程</span><br><span class="line">2）connect线程：负责zk客户端与zk服务的通信，例如心跳等等</span><br><span class="line">3）listener线程：负责监听的事情。当zk客户端在zk服务中心注册的监听事件发生后，zk服务会通知到listener线程，listener线程会调用内部的process方法做出相应</span><br></pre></td></tr></table></figure>

<h4 id="2-3-Zookeeper选举机制"><a href="#2-3-Zookeeper选举机制" class="headerlink" title="2.3 Zookeeper选举机制"></a>2.3 Zookeeper选举机制</h4><h5 id="2-3-1-基于ZAB协议"><a href="#2-3-1-基于ZAB协议" class="headerlink" title="2.3.1 基于ZAB协议"></a>2.3.1 基于ZAB协议</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基于消息传递且保证数据一致性的一种算法（协议）</span><br><span class="line">ZAB协议的目标：</span><br><span class="line">1）没有leader的情况选取leader</span><br><span class="line">2）有leader的情况，去尽可能保证数据一致</span><br></pre></td></tr></table></figure>

<h5 id="2-3-2-半数机制"><a href="#2-3-2-半数机制" class="headerlink" title="2.3.2  半数机制"></a>2.3.2  半数机制</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">整个Zookeeper集群中，只有有半数以上的机器存活，Zookeeper集群就能够对外提供服务，也就意味着在启动Zookeeper集群时，只要启动的机器超过半数，leader也就能选举出来</span><br></pre></td></tr></table></figure>

<h5 id="2-3-2-Zookeeper集群中的机器角色"><a href="#2-3-2-Zookeeper集群中的机器角色" class="headerlink" title="2.3.2 Zookeeper集群中的机器角色"></a>2.3.2 Zookeeper集群中的机器角色</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）leader：领导者（只有一个）</span><br><span class="line">2）follower：跟随者（可有多个）</span><br></pre></td></tr></table></figure>

<h5 id="2-3-3-leader选举过程"><a href="#2-3-3-leader选举过程" class="headerlink" title="2.3.3 leader选举过程"></a>2.3.3 leader选举过程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1) 新的集群启动: </span><br><span class="line">          </span><br><span class="line">	  关注点: 集群中的每台机器中都没有存储任何数据(生来平等:zxid都一样)</span><br><span class="line">	 </span><br><span class="line">	  选择过程:   有5台机器,分别给5台机器进行编号(myid)，例如: 1 2 3 4 5 ， </span><br><span class="line">	              假设按照1 2 3 4 5 的顺序启动机器(且假设真正启动起来的顺序也是1 2 3 4 5 )</span><br><span class="line">	  </span><br><span class="line">	  投票: 自私原则 ，墙头草随风倒.</span><br><span class="line">         </span><br><span class="line">	  启动server1: 第一票投给自己(1,zxid),此时，机器数没有达到半数,leader未选举</span><br><span class="line">	  启动server2: 第一票投给自己(2,zxid), </span><br><span class="line">	           server2将(2,zxid)投给server1， server1将(1,zxid)投给server2，</span><br><span class="line">		       server2比较自己的投票(2,zxid) 与 server1的投票(1,zxid)， 2 &gt;1 , 则server2保持自己的投票</span><br><span class="line">		       server1比较自己的投票(1,zxid) 与 server2的投票(2,zxid）  1 &lt;2 , 技不如人，改变投票，server1改投(2,zxid)</span><br><span class="line">		       因此最终server2有两票. 但是机器数没有达到半数，leader未选举</span><br><span class="line"></span><br><span class="line">      启动server3: 第一票投给自己(3,zxid)</span><br><span class="line">	           server3接收到server1的(1,zxid), server2的(2,zxid) ,3 &gt; 2 &gt;1  ，server3保持自己的投票(3,zxid)</span><br><span class="line">		       server2接收到server3的(3,zxid), serser1的(1,zxid) , 2 &lt; 3 ,   改变投票为(3,zxid)</span><br><span class="line">		       server1接收到server3的(3,zxid), server2的(2,zxid) , 1 &lt; 2&lt; 3, 改变投票为(3,zxid)</span><br><span class="line">		       因此最终server3有3票, 机器数也达到半数， server3当选为leader, server1 和 server2 为follower</span><br><span class="line">          </span><br><span class="line">	  启动server4: 因为集群已经有leader存在， server4注定就是follower </span><br><span class="line">	  启动server5: 因为集群已经有leader存在， server5注定就是follower</span><br><span class="line">	  </span><br><span class="line"></span><br><span class="line">2) 集群工作中，leader故障后的选举: </span><br><span class="line">          </span><br><span class="line">	  当集群工作中，leader故障后，只要剩下的机器数大于半数， 集群能够正常工作，但是需要重新选举leader。</span><br><span class="line"></span><br><span class="line">	  选举的过程还是进行投票, 因为集群是在工作中，因此每台机器的zxid有可能不同.</span><br><span class="line">	  那么每次投出的票(myid,zxid) , 先比较zxid，再比较myid，因此集群中剩余的机器中zxid最大的当选为leader,</span><br><span class="line">	  如果zxid都一样，理论情况下myid最大的当选leader.</span><br><span class="line"></span><br><span class="line">	  zxid: 某种意义上，可以表示当前机器中存储的数据的完整度.</span><br></pre></td></tr></table></figure>

<h4 id="2-4-写数据流程"><a href="#2-4-写数据流程" class="headerlink" title="2.4 写数据流程"></a>2.4 写数据流程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）客户端连接Zookeeper集群的任意一台机器，发送写请求</span><br><span class="line">2）如果客户端连接的Zookeeper集群不是leader，则当前这台机器会将客户端的写请求转发给leader</span><br><span class="line">3）当leader接收到写请求后，会将当次的写操作构建成一个事务，对应一个zxid，然后将写的操作广播给每个follower</span><br><span class="line">4）每个follower接受到写操作后，先将写操作存入队列中（FIFO队列），并向leader反馈表示自己可以执行当前的写操作</span><br><span class="line">5）当leader接受到集群中半数以上的follower的反馈，则代表本次的写操作可以正常进行，leader会再次广播给各个follower，让follower将写操作进行commit（真正写数据）</span><br><span class="line">6）各个follower将写操作成功commit以后，再次向leader反馈写操作完成</span><br><span class="line">7）当leader接受到集群中半数以上的的反馈，，表示此次写操作成功</span><br><span class="line">8）最后由客户端所连接的Zookeeper集群中的机器，向客户端发送响应，说数据写成功</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
  </entry>
  <entry>
    <title>Yarn资源调度器</title>
    <url>/2020/05/28/Yarn%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
    <content><![CDATA[<h3 id="Yarn资源调度器"><a href="#Yarn资源调度器" class="headerlink" title="Yarn资源调度器"></a>Yarn资源调度器</h3><ol>
<li><p>基本介绍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yarn是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台，而MapReduce等运算程序则相当于操作系统之上的应用程序。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Yarn的基本架构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YARN主要有ResourceManager，NodeManager，ApplicationMaster和Container等组件构成</span><br></pre></td></tr></table></figure>
</li>
<li><p>作业提交的全过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）作业提交</span><br><span class="line">	第1步：Client调用job.waitForCompletion方法，向整个集群提交MapReduce作业</span><br><span class="line">	第2步：Client向RM申请一个作业id</span><br><span class="line">	第3步：RM给client返回该job资源的提交路径和作业id</span><br><span class="line">	第4步：client提交jar包，切片信息和配置文件到指定的资源提交路径</span><br><span class="line">	第5步：Client提交完资源后，向RM申请运行MrAppMaster</span><br><span class="line">（2）作业初始化</span><br><span class="line">	第6步：当RM收到Client的请求后，将该job添加到容量调度器中</span><br><span class="line">	第7步：某一个空闲的NM领取到该job</span><br><span class="line">	第8步：该NM创建Container，并产生MrAppMaster</span><br><span class="line">	第9步：下载Client提交的资源到本地</span><br><span class="line">（3）任务分配</span><br><span class="line">	第10步：MrAPPMaster向RM申请运行多个MaTask任务资源</span><br><span class="line">	第11步：RM将运行MapTask任务分配给另外的NodeManager，领导MapTask任务的NodeManager创建容器</span><br><span class="line">（4）任务运行</span><br><span class="line">	第12步：MrAppMaster向接受到任务的NodeManager发送程序启动脚本，接受到任务的NodeManager分别启动MapTask，MapTask对数据分区排序</span><br><span class="line">	第13步：MrAPPMaster等待所有MapTask运行完毕后，向RM申请容器，运行ReduceTask</span><br><span class="line">	第14步：ReduceTask向MapTask获取相应分区的数据</span><br><span class="line">	第15步：程序运行完毕后，MR会向RM申请注销自己</span><br><span class="line">（5）进度和状态更新</span><br><span class="line">	YARN中的任务将其进度和状态（包括counter）返回给应用管理器，客户端每秒（通过mapreduce.client.progressmonitor.pollinterval设置）向应用管理器请求进度更新，展示给客户</span><br><span class="line">（6）作业完成</span><br><span class="line">	除了向应用管理器请求作业进度外，客户端每5秒都会通过调用waitForCompletion（）来检查作业是否完成。时间间隔可以通过通过mapreduce.client.progressmonitor.pollinterval设置。作业完成之后，应用管理器和Container会清理工作状态。作业的信息会被历史服务器存储以备用户核查</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>资源调度器</p>
<p>目前Hadoop作业调度器主要有3中：FIFO，Capacity Scheduler，Fair Scheduler。Hadoop3.1.3默认的资源调度器是Capacity Scheduler</p>
<p>具体设置详见yarn-default.xml文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;description&gt;The <span class="class"><span class="keyword">class</span> <span class="title">to</span> <span class="title">use</span> <span class="title">as</span> <span class="title">the</span> <span class="title">resource</span> <span class="title">scheduler</span>.&lt;/<span class="title">description</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">name</span>&gt;<span class="title">yarn</span>.<span class="title">resourcemanager</span>.<span class="title">scheduler</span>.<span class="title">class</span>&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">value</span>&gt;<span class="title">org</span>.<span class="title">apache</span>.<span class="title">hadoop</span>.<span class="title">yarn</span>.<span class="title">server</span>.<span class="title">resourcemanager</span>.<span class="title">scheduler</span>.</span></span><br><span class="line"><span class="class">        <span class="title">capacity</span>.<span class="title">CapacityScheduler</span>&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">property</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   4.1 FIFO 先进先出调度器</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  Hadoop最初设计目的是支持大数据批处理作业，如日志挖掘、Web索引等作业，为此，Hadoop仅提供了一个非常简单的调度机制：FIFO，即先来先服务，在该调度机制下，所有作业被统一提交到一个队列中，Hadoop按照提交顺序依次运行这些作业。</span><br><span class="line">  但随着Hadoop的普及，单个Hadoop集群的用户量越来越大，不同用户提交的应用程序往往具有不同的服务质量要求，典型的应用有以下几种：</span><br><span class="line">1.批处理作业：这种作业往往耗时较长，对时间完成一般没有严格要求，如数据挖掘、机器学习等方面的应用程序。</span><br><span class="line">2.交互式作业：这种作业期望能及时返回结果，如SQL查询（Hive）等。</span><br><span class="line">3.生产性作业：这种作业要求有一定量的资源保证，如统计值计算、垃圾数据分析等。</span><br><span class="line">  此外，这些应用程序对硬件资源需求量也是不同的，如过滤、统计类作业一般为CPU密集型作业，而数据挖掘、机器学习作业一般为I&#x2F;O密集型作业。因此，简单的FIFO调度策略不仅不能满足多样化需求，也不能充分利用硬件资源.</span><br></pre></td></tr></table></figure>



<pre><code>4.2 Capacity Scheduler</code></pre>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">容量调度器有以下特点</span><br><span class="line">1）支持多个队列，每个队列可配置一定的资源量，每个队列采用FIFO调度策略</span><br><span class="line">2）为了防止同一个用户的作业独占队列中的资源，该调度器会对同一用户提交的作业所占资源量进行限制</span><br><span class="line">3）首先，计算每个队列中正在运行的任务数与其应该分得的计算资源之间的比值，选择一个最小的队列，即最闲的队列</span><br><span class="line">4）其次，按照作业优先级和提交时间排序，同时考虑用户资源量限制和内存限制对队列内任务排序</span><br><span class="line"></span><br><span class="line">	Capacity Scheduler 是Yahoo开发的多用户调度器，它以队列为单位划分资源，每个队列可设定一定比例的资源最低保证和使用上限，同时，每个用户也可设定一定的资源使用上限以防止资源滥用。而当一个队列的资源有剩余时，可暂时将剩余资源共享给其他队列。</span><br><span class="line"></span><br><span class="line">	总结：</span><br><span class="line">1）可以配置多条队列，每条队列可以设置资源占比</span><br><span class="line">2）每条队列的队首的job可以同时执行（从侧面解决了大Job拖慢小job完成时间的问题）</span><br><span class="line">3）每条队列的空闲资源可临时借调给别的队列使用.</span><br><span class="line">4）每条队列可以设置最小和最大资源占比 </span><br><span class="line">5）每条队列可以控制访问用户</span><br></pre></td></tr></table></figure>



<p>   4.3 Fair Scheduler</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fair Scheduler是Facebook开发的多用户调度器</span><br><span class="line">	公平调度器的目的是让所有的作业随着时间的推移，都能平均地获取等同的共享资源！当有作业提交上来，系统会将空闲的资源分配给新的作业！每个任务大致上会获取平等数量的资源！和传统的调度策略不同的是</span><br><span class="line">它会让小的任务在合理的时间完成，同时不会让需要长时间运行的耗费大量资源的应用挨饿！</span><br><span class="line">	</span><br><span class="line">	同Capacity Scheduler类似，它以队列为单位划分资源，每个队列可设定一定比例的资源最低保证和使用上限，同时，每个用户也可设定一定的资源使用上限以防止资源滥用；当一个队列的资源有剩余时，可暂时将剩余资源共享给其他队列。</span><br><span class="line">	当然，Fair Scheduler也存在很多与Capacity Scheduler不同之处，这主要体现在以下几个方面</span><br><span class="line">	资源公平共享。在每个队列中，Fair Scheduler 可选择按照FIFO、Fair或DRF策略为应用程序分配资源。其中，Fair 策略(默认)是一种基于最大最小公平算法实现的资源多路复用方式，默认情况下，每个队列内部采用该方式分配资源。这意味着，如果一个队列中有两个应用程序同时运行，则每个应用程序可得到1&#x2F;2的资源；如果三个应用程序同时运行，则每个应用程序可得到1&#x2F;3的资源</span><br><span class="line">	</span><br><span class="line">最大最小公平算法：</span><br><span class="line">	</span><br><span class="line">	1）不加权</span><br><span class="line">	有一四个用户的集合,资源需求分别是2, 2.6 , 4, 5,其资源总能力为10,为其计算最大最小公平分配</span><br><span class="line">解决方法:</span><br><span class="line">我们通过几轮的计算来计算最大最小公平分配.</span><br><span class="line">第一轮,我们暂时将资源划分成4个大小为2.5的.由于这超过了用户1的需求,这使得剩了0.5个均匀的分配给剩下的3个人资源,给予他们每个2.66.这又超过了用户2的需求,所以我们拥有额外的0.066…来分配给剩下的两个用户,给予每个用户2.5+0.66…+0.033…&#x3D;2.7.因此公平分配是:用户1得到2,用户2得到2.6,用户3和用户4每个都得到2.7.</span><br><span class="line"></span><br><span class="line">	2）加权</span><br><span class="line">	有一四个用户的集合,资源需求分别是4,2,10,4,权重分别是2.5,4,0.5,1,资源总能力是16,为其计算最大最小公平分配.</span><br><span class="line">解决方法:</span><br><span class="line">第一步是标准化权重,将最小的权重设置为1.这样权重集合更新为5,8,1,2.这样需要的资源是5+8+1+2&#x3D;16份.因此将资源划分成16份.在资源分配的每一轮,我们按照权重的比例来划分资源,因此,在第一轮,,用户分别获得5,8,1,2单元的资源,用户1得到了5个资源,但是只需要4,所以多了1个资源,同样的,用户2多了6个资源.用户3和用户4拖欠了,因为他们的配额低于需求.现在我们有7个资源可以分配给用户3和用户4.他们的权重分别是1和2,给予用户3额外的7 × 1&#x2F;3资源和用户4额外的7 × 2&#x2F;3资源.这会导致用户4的配额达到了2 + 7 × 2&#x2F;3 &#x3D; 6.666,超过了需求.所以我们将额外的2.666单元给用户3,最终获得1 + 7&#x2F;3 + 2.666 &#x3D; 6单元.最终的分配是,4,2,6,4,这就是带权重的最大最小公平分配.</span><br><span class="line"></span><br><span class="line">DRF</span><br><span class="line">DRF(Dominant Resource Fairness)。我们之前说的资源，都是单一标准，例如只考虑内存(也是yarn默认的情况)。但是很多时候我们资源有很多种，例如内存，CPU，网络带宽等，这样我们很难衡量两个应用应用应该分配的资源比例</span><br><span class="line">那么在YARN中，我们用DRF来决定如何调度：假设集群有10T mem和100 CPU，而应用A需要(2 CPU, 300GB)，应用B需要(6 CPU, 100GB)。则两种应用分别需要系统(2%, 3%)和(6%, 1%)的资源，这就意味着A是mem主导的, B是CPU主导的，并且它俩的比例是3% : 6% &#x3D; 1:2。这样两者就按照1:2的比例去分配资源。</span><br><span class="line"></span><br><span class="line">	支持资源抢占。当某个队列中有剩余资源时，调度器会将这些资源共享给其他队列，而当该队列中有新的应用程序提交时，调度器要为它回收资源。为了尽可能降低不必要的计算浪费，调度器采用了先等待再强制回收的策略，即如果等待一段时间后尚有未归还的资源，则会进行资源抢占：从那些超额使用资源的队列中杀死一部分任务，进而释放资源。</span><br><span class="line">yarn.scheduler.fair.preemption&#x3D;true 通过该配置开启资源抢占。</span><br><span class="line">	负载均衡。Fair Scheduler提供了一个基于任务数目的负载均衡机制，该机制尽可能将系统中的任务均匀分配到各个节点上。此外，用户也可以根据自己的需要设计负载均衡机制。</span><br><span class="line">	调度策略配置灵活。Fair Scheduler允许管理员为每个队列单独设置调度策略（当前支持FIFO、Fair或DRF三种）。</span><br><span class="line">	提高小应用程序响应时间。由于采用了最大最小公平算法，小作业可以快速获取资源并运行完成</span><br></pre></td></tr></table></figure>







<ol start="5">
<li>任务的推测执行</li>
</ol>
]]></content>
      <categories>
        <category>Hadoop生态</category>
      </categories>
  </entry>
  <entry>
    <title>MapReduce</title>
    <url>/2020/05/22/MapReduce/</url>
    <content><![CDATA[<h3 id="第1章-MapReduce概述"><a href="#第1章-MapReduce概述" class="headerlink" title="第1章 MapReduce概述"></a>第1章 MapReduce概述</h3><h3 id="第2章-Hadoop序列化"><a href="#第2章-Hadoop序列化" class="headerlink" title="第2章 Hadoop序列化"></a>第2章 Hadoop序列化</h3><h3 id="第3章-MapReduce框架原理"><a href="#第3章-MapReduce框架原理" class="headerlink" title="第3章 MapReduce框架原理"></a>第3章 MapReduce框架原理</h3><p>MapReduce的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.数据流：</span><br><span class="line">	输入数据---&gt;InputFormat---&gt;Mapper---&gt;shuffle---&gt;Reducer---&gt;OutputFormat---&gt;输出数据</span><br><span class="line"><span class="number">2</span>.过程</span><br><span class="line">	简单划分：Map阶段 shuffle阶段 Reduce阶段</span><br><span class="line"><span class="number">3</span>.代码角度划分</span><br><span class="line"><span class="number">1</span>）MapTask中的run()：MapTask：map(<span class="number">67</span>%)  sort(<span class="number">33</span>%)</span><br><span class="line"> <span class="keyword">if</span> (isMapTask()) &#123;</span><br><span class="line">        <span class="comment">// If there are no reducers then there won't be any sort. Hence the map </span></span><br><span class="line">        <span class="comment">// phase will govern the entire attempt's progress.</span></span><br><span class="line">      <span class="keyword">if</span> (conf.getNumReduceTasks() == <span class="number">0</span>) &#123;</span><br><span class="line">        mapPhase = getProgress().addPhase(<span class="string">"map"</span>, <span class="number">1.0f</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If there are reducers then the entire attempt's progress will be </span></span><br><span class="line">        <span class="comment">// split between the map phase (67%) and the sort phase (33%).</span></span><br><span class="line">        mapPhase = getProgress().addPhase(<span class="string">"map"</span>, <span class="number">0.667f</span>);</span><br><span class="line">        sortPhase  = getProgress().addPhase(<span class="string">"sort"</span>, <span class="number">0.333f</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="number">2</span>）ReduceTask类中的run():  ReduceTask :  copy   sort   reduce </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isMapOrReduce()) &#123;</span><br><span class="line">        copyPhase = getProgress().addPhase(<span class="string">"copy"</span>);</span><br><span class="line">        sortPhase  = getProgress().addPhase(<span class="string">"sort"</span>);</span><br><span class="line">        reducePhase = getProgress().addPhase(<span class="string">"reduce"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="number">3</span>）MapReduce的代码角度得到的过程结果为：</span><br><span class="line">    map--&gt;sort--&gt;copy--&gt;sort--&gt;reduce</span><br></pre></td></tr></table></figure>



<h4 id="3-1-InputFormat数据输入"><a href="#3-1-InputFormat数据输入" class="headerlink" title="3.1 InputFormat数据输入"></a>3.1 InputFormat数据输入</h4><h5 id="3-1-1-重要的类和方法"><a href="#3-1-1-重要的类和方法" class="headerlink" title="3.1.1 重要的类和方法"></a>3.1.1 重要的类和方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.重要的方法</span><br><span class="line">getSpilts()：生成切片的方法</span><br><span class="line">createRecordReader()：创建RecordReader对象，真正负责数据读取的对象</span><br><span class="line">2.重要的子抽象类 FileInputFormat</span><br><span class="line">getSpilts(): 做出了具体的实现</span><br><span class="line">createRecordReader(): 没有做任何的改动</span><br><span class="line">isSplitable(): 当前数据的数据集是否可以切分</span><br><span class="line">3.FileInputFormat的具体实现类</span><br><span class="line">TextInputFormat：MapReduce默认使用的InputFormat</span><br><span class="line">CombineTextInputFormat</span><br></pre></td></tr></table></figure>

<h5 id="3-1-2-切片"><a href="#3-1-2-切片" class="headerlink" title="3.1.2 切片"></a>3.1.2 切片</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.相关的两个概念</span><br><span class="line">	块：HDFS存数据的基本单位，是把要存储到HDFS的文件以设置好的块的大小，对文件进行物理切分然后分块存储</span><br><span class="line">	切片：MapReduce计算数据的单位，是把要在Map中计算的数据从逻辑上按照切片的大小划分为N个切片</span><br><span class="line">2.切片的大小</span><br><span class="line">	切片的大小默认情况是等于块的大小</span><br><span class="line">3.切片的源码解读</span><br><span class="line">FileInputFormat的getSpilts方法：</span><br><span class="line">1） long minSize &#x3D; Math.max(getFormatMinSplitSize(), getMinSplitSize(job));   &#x2F;&#x2F; 1 </span><br><span class="line">相关配置项:   &quot;mapreduce.input.fileinputformat.split.minsize&quot;&#x3D;&quot;0&quot;   </span><br><span class="line">long maxSize &#x3D; getMaxSplitSize(job);  &#x2F;&#x2F; Long.MAX_VALUE</span><br><span class="line">相关配置项:   &quot;mapreduce.input.fileinputformat.split.maxsize&quot;  默认没有配置这一项</span><br><span class="line">2）  long blockSize &#x3D; file.getBlockSize();  &#x2F;&#x2F;获取文件的块大小   </span><br><span class="line">如果是集群环境，获取到的就是集群中设置的块大小，如果是本地环境，本地默认的块大小32M (33554432)</span><br><span class="line">3）                                   32M        1      Long.MAX_VALUE</span><br><span class="line">   long splitSize &#x3D; computeSplitSize(blockSize, minSize, maxSize);</span><br><span class="line">   &#x3D;&#x3D;&gt;return Math.max(minSize, Math.min(maxSize, blockSize));</span><br><span class="line">4） while (((double) bytesRemaining)&#x2F;splitSize &gt; SPLIT_SLOP)  &#x2F;&#x2F; SPLIT_SLOP &#x3D; 1.1 </span><br><span class="line">如果剩余待切片的数据除以块大小，大于1.1，才会继续切片，如果不大于，则直接将剩余的数据进行切片</span><br><span class="line"></span><br><span class="line">切片的总结：</span><br><span class="line">	1）每个切片都需要由一个MapTask来处理</span><br><span class="line">	2）切片的大小默认情况下等于块的大小</span><br><span class="line">	3）切片的时候每个文件单独切片，不会整体切片</span><br><span class="line">	4）切片的个数不是越多越好，也不是越少越好，按照实际情况，处理成合适的切片数（通过改变splitSize）</span><br></pre></td></tr></table></figure>

<h5 id="3-1-3-TextInputFormat：默认使用的InputFormat类"><a href="#3-1-3-TextInputFormat：默认使用的InputFormat类" class="headerlink" title="3.1.3 TextInputFormat：默认使用的InputFormat类"></a>3.1.3 TextInputFormat：默认使用的InputFormat类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">切片的规则：用的就是父类FileInputFormat中的切片规则</span><br><span class="line">读取数据：LineRecordReader 按行读取数据</span><br></pre></td></tr></table></figure>

<h5 id="3-1-4-CombineTextInputFormat"><a href="#3-1-4-CombineTextInputFormat" class="headerlink" title="3.1.4 CombineTextInputFormat"></a>3.1.4 CombineTextInputFormat</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）用户处理小文件过多的场景，解决过多的小文件最终生成太多的切片的问题</span><br><span class="line">2）在Driver中设置</span><br><span class="line">job.setInputFormatClass(CombinTextInputFormat.class)</span><br><span class="line">CombineTextInputFormat.setMaxInputSplitSize(job,20911520);&#x2F;&#x2F;20M</span><br><span class="line">3）会按照设置的虚拟存储大小进行数据数据的逻辑上的规划</span><br><span class="line">如果文件的大小小于MaxInputSplitSize，则文件规划成一个</span><br><span class="line">如果文件的大小大于MaxInputSplitSize，但是小于MaxInputSplitSize*2，则文件规划成两个（数据对半分）</span><br><span class="line">如果文件的大小大于MaxInputSplitSize*2，先按照MaxInputSplitSize的大小先规划成一个，剩余的再进行规划</span><br><span class="line">最终按照MaxInputSplitSize大小来生成切片</span><br><span class="line">将规划好的每个虚拟文件逐个累加，只要不超过MaxInputSplitSize大小，则都是规划到一个切片中</span><br></pre></td></tr></table></figure>



<h4 id="3-2-MapReduce工作流程"><a href="#3-2-MapReduce工作流程" class="headerlink" title="3.2 MapReduce工作流程"></a>3.2 MapReduce工作流程</h4><h4 id="3-3-Shuffle机制"><a href="#3-3-Shuffle机制" class="headerlink" title="3.3 Shuffle机制"></a>3.3 Shuffle机制</h4><h5 id="3-3-1-shuffle关键点"><a href="#3-3-1-shuffle关键点" class="headerlink" title="3.3.1 shuffle关键点"></a>3.3.1 shuffle关键点</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）map方法之后，reduce方法之前的处理过程就是shuffle过程</span><br><span class="line">2）map方法写出去的kv，会被一个收集线程收集到缓冲区中</span><br><span class="line">3）缓冲区的大小默认是100M，达到80%发生溢写（将数据写入硬盘）</span><br><span class="line">4）缓冲区中记录的是kv,kv的下标，kv的分区等信息</span><br><span class="line">5）溢写的时候，是按照kv的分区进行排序（快排，只拍索引），再按照分区溢写 ---&gt; map端的第一次排序</span><br><span class="line">6）每个MapTask有可能发生多次有可能发生多次溢写，最终需要将多次溢写的文件归并成一个大的文件---&gt;map端的第二次排序</span><br><span class="line">7）溢写和归并过程中，都可以采用combiner</span><br><span class="line">8）每个ReduceTask按照所需处理的分区，到每个MapTask中拷贝对应的分区的数据，拷贝过程中，先放内存，放不下写硬盘，等数据全部都拷贝过来后，进行归并排序 ---&gt;reduce端的排序</span><br><span class="line">9）reduce端排好序的数据进行分组，然后进入reduce方法进行业务处理</span><br></pre></td></tr></table></figure>



<h5 id="3-3-2-分区"><a href="#3-3-2-分区" class="headerlink" title="3.3.2 分区"></a>3.3.2 分区</h5><ol>
<li><p>分区的概念</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将数据按照条件输出到多个文件中</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么设置reduce的个数可以实现分区的效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）在MapTask类中的NewOutputCollector()方法中</span><br><span class="line">partitions = jobContext.getNumReduceTasks();<span class="comment">//获取哦reduce的个数。reduce的个数是在driver中设置的</span></span><br><span class="line"><span class="keyword">if</span>(partitions &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果说reducce的个数大于1， 会尝试获取一个分区器类,通过mapreduce.job.partitioner.class参数获取  ，</span></span><br><span class="line">    <span class="comment">// 默认mapreduce.job.partitioner.class没有配置，则直接返回HashPartitioner.class 。</span></span><br><span class="line">    <span class="comment">// 当然还有一种可能就是我们自己设置过分区器类，则此处会获取到我们自己设置的分区器类。</span></span><br><span class="line">   partitioner = (org.apache.hadoop.mapreduce.Partitioner&lt;K,V&gt;)</span><br><span class="line">   ReflectionUtils.newInstance(jobContext.getPartitionerClass(), job);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//如果reduce的个数不大于1，最终的分区号就是固定的0号分区</span></span><br><span class="line">     partitioner = <span class="keyword">new</span> org.apache.hadoop.mapreduce.Partitioner&lt;K,V&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(K key, V value, <span class="keyword">int</span> numPartitions)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> partitions - <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>）获取到的分区器在哪里使用？</span><br><span class="line">    在MapTask中的NewOutputCollector内部类中的write方法</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(K key, V value)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">           collector.collect(key, value,partitioner.getPartition(key, value, partitions)); <span class="comment">//将kv收集到缓冲区的时候，要计算出来kv对应的分区号</span></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）分区的数据是如何分的？</span><br><span class="line">    （<span class="number">1</span>）数据的分区是由分区器来决定的</span><br><span class="line">    （<span class="number">2</span>）Hadoop由默认的分区器对象HashPartitioner</span><br><span class="line">    HashPartitioner会按照k的hash值对Reduce的个数进行取余操作得到k所对应的分区</span><br><span class="line">    （<span class="number">3</span>）hadoop也支持用户自定义分区器</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>默认的分区器HashPartitioner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>). 默认的分区器就会按照key的hashcode值 先对Integer的最大值做&amp;运算，在对reduce的个数取余，得到分区号。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(K key, V value,<span class="keyword">int</span> numReduceTasks)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> (key.hashCode() &amp; Integer.MAX_VALUE) % numReduceTasks;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）自定义分区类继承Partitioner类，并重写getPartition()</span><br><span class="line">2）在driver类中通过job.setPartitionerClass(xxxPartitioner.class)设置使用的分区</span><br><span class="line">3）设置reduce的个数，正常情况下，根据分区器业务来决定设置多少个，最好是分区器的逻辑会产生多少个分区，就设置好多少个reduce</span><br><span class="line"></span><br><span class="line">分区使用的注意事项：</span><br><span class="line">1）reduce个数的设置：如果不设置，reduce的个数默认为1，如果1&lt;reduce个数&lt;分区数，报错；如果reduce个数&gt;分区数，不报错，多少的reduce会白跑，产生空文件；最佳是reduce的个数就设置为实际的分区数</span><br><span class="line">2）分区号只能从0开始，逐一累加</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="3-3-3-排序"><a href="#3-3-3-排序" class="headerlink" title="3.3.3 排序"></a>3.3.3 排序</h5><ol>
<li><p>排序是MR中最重要的操作之一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在MapTask中有两次排序 ---&gt;溢写前排序，将溢写文件归并成一个大文件的归并排序</span><br><span class="line">在ReduceTask中有一次排序---&gt;归并排序</span><br></pre></td></tr></table></figure>
</li>
<li><p>在MR中，排序是默认的行为，默认会对KV中K进行排序，默认采用字典序进行排序</p>
</li>
<li><p>排序的分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）全排序：所有的数据整体排序，要求只能有一个分区</span><br><span class="line">2）区内排序：每个分区内的数据整体排序</span><br><span class="line">3）辅助排序：分组排序，数据进入reduce之前进行的排序</span><br><span class="line">4）二次排序：比较规则中用到两个条件</span><br></pre></td></tr></table></figure>
</li>
<li><p>排序的前提</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">排序的前提是待排序的数据可以进行比较，需要实现WritableComparable接口</span><br></pre></td></tr></table></figure>
</li>
<li><p>Hadoop排序时是如何比较的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在MapTask中的 MapOutputBuffer 类中的init方法中</span><br><span class="line">       </span><br><span class="line">      comparator = job.getOutputKeyComparator();  <span class="comment">// 获取key的比较器对象</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> RawComparator <span class="title">getOutputKeyComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Class&lt;? extends RawComparator&gt; theClass = getClass(</span><br><span class="line">         JobContext.KEY_COMPARATOR, <span class="keyword">null</span>, RawComparator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	 <span class="comment">// 参数: mapreduce.job.output.key.comparator.class  默认没有配置</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (theClass != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ReflectionUtils.newInstance(theClass, <span class="keyword">this</span>);  <span class="comment">//如果能通过参数获取到，则通过反射创建比较器对象</span></span><br><span class="line">         </span><br><span class="line">	 <span class="comment">//如果通过参数获取不到，则获取到在driver中设置的map的输出的key的类型，</span></span><br><span class="line">	 <span class="comment">// 并判断key的类型是否属于writableComparable类型</span></span><br><span class="line">	 <span class="comment">// 再尝试为key获取比较器对象.</span></span><br><span class="line">         <span class="keyword">return</span> WritableComparator.get(getMapOutputKeyClass().asSubclass(WritableComparable<span class="class">.<span class="keyword">class</span>), <span class="title">this</span>)</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WritableComparator <span class="title">get</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          Class&lt;? extends WritableComparable&gt; c, Configuration conf)</span> </span>&#123;</span><br><span class="line">	   <span class="comment">// 从comparators中尝试获取key的比较器对象</span></span><br><span class="line">	   <span class="comment">// 如果key是我们自己定义的类型，则获取不到</span></span><br><span class="line">	   <span class="comment">// 如果key是hadoop的序列化类型，例如 Text, Intwriable等，则能获取到。</span></span><br><span class="line">           WritableComparator comparator = comparators.get(c);</span><br><span class="line">    <span class="keyword">if</span> (comparator == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// force the static initializers to run</span></span><br><span class="line">      forceInit(c);  <span class="comment">//强制进行类加载,防止因中途进行垃圾回收使得类不再内存中</span></span><br><span class="line">      <span class="comment">// look to see if it is defined now</span></span><br><span class="line">      comparator = comparators.get(c);   <span class="comment">// 再次进行获取</span></span><br><span class="line">      <span class="comment">// if not, use the generic one</span></span><br><span class="line">      <span class="keyword">if</span> (comparator == <span class="keyword">null</span>) &#123; </span><br><span class="line">      <span class="comment">// 如果还获取不到，则直接new一个对象出来。</span></span><br><span class="line">         comparator = <span class="keyword">new</span> WritableComparator(c, conf, <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Newly passed Configuration objects should be used.</span></span><br><span class="line">       ReflectionUtils.setConf(comparator, conf);</span><br><span class="line">       <span class="keyword">return</span> comparator;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  总结：Hadoop自身的序列化类型（比如Text），在类加载时，会把类型以及对应的比较器对象注册到WritableCompartor中的comparators这个Map中，如果key是我们自定义的类型，则我们必须要为该类型提交比较器对象。</span><br><span class="line">  不管是hadoop自身的序列化类型还是我们自己定义的类型，只要作为key来使用，则必须要有对应的比较器对象才能够进行比较，才能实现排序。</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较器WritableComparator</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2): 底层的实现，我们不动，会调用第2个方法</span><br><span class="line">2. public int compare(WritableComparable a, WritableComparable b)： 我们可以重写，实现比较规则，如果不重写，则默认是a.CompareTo(b)</span><br><span class="line">3. public int compare(Object a, Object b): 还是会调用到第2个方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总结：作为key来使用的类型，需要提供比较器对象，还要求key的类型必须是WritableComparable</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较接口WritableComparable</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.要求所有作为key来使用的类型，都需要实现WritableComparable接口</span><br><span class="line">2.该接口中可以通过compareTo定义比较规则</span><br></pre></td></tr></table></figure>
</li>
<li><p>排序大总结</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）一个接口和一个类</span><br><span class="line">	接口：WritableComparable：用于定于默认的比较规则</span><br><span class="line">	类：WritableComparator: 用于定于临时的比较规则</span><br><span class="line">	</span><br><span class="line">2）Hadoop的排序，都是对key的排序，排序时需要比较，比较的时候都是用key类型对应的比较器对象进行比较</span><br><span class="line"></span><br><span class="line">3）对于key的类型来说，如果提供了对应的比较器对象，则使用我们自己提供的；如果没有提供对应的比较器对象，则Hadoop会帮我们创建一个比较器对象</span><br><span class="line"></span><br><span class="line">4）hadoop对key的比较，默认调用的是比较器中的compare（WritableComparable a，WritableComparable b）方法</span><br><span class="line">	第一种情况：如果自定义的比较器中，重写了compare方法，则使用重写后的方法进行比较。</span><br><span class="line">	第二种情况：如果自定义的比较器中，则使用的是WritableComparator中的。compare（WritableComparable a，WritableComparable b）方法，默认的实现是a.compareTo(b),因此会调用到key中的compareTo()方法进行比较。</span><br><span class="line">	第三种情况：如果没有提供比较器队形，则hadoop默认会帮我们创建一个比较器对象，但是hadoop默认创建的比较器对象还是使用WritableComparator中的compare（WritableComparable a，WritableComparable b）方法，因此默认的实现还是a.compareTo(b)，所以最终还是会调用到key中的compareTo()方法进行比较。</span><br><span class="line">	</span><br><span class="line">5）实际使用：</span><br><span class="line">	按照hadoop的设计来说，我们需要提供比较器对象WritableComparator，key需要实现WritableComparable。</span><br><span class="line">	按照我们实际使用(偷懒), 不用提交比较器对象，直接实现WritableComparable接口，重写compareTo即可。</span><br><span class="line">	 一般来讲， WritableComparable是用来定义默认的比较规则的， WritableComparator用来定义临时的比较规则的。</span><br></pre></td></tr></table></figure>
</li>
<li><p>全排序和区内排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">全排序就是将排序的规则定义好，只有一个分区一个reduce，数据整体有序</span><br><span class="line">区内排序就是在全排序的基础之上，加上自定义分区即可.</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<ol start="10">
<li><p>分组排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）数据在进入到reduce方法之前，一定要保证数据是有序的，才可以进行所谓的分组. 最终的效果就是要保证相同key的多个kv对进入到一个reduce方法。</span><br><span class="line"><span class="number">2</span>）hadoop是如何进行分组比较的</span><br><span class="line"> 在ReduceTask中的run方法中 ：</span><br><span class="line">	  RawComparator comparator = job.getOutputValueGroupingComparator();</span><br><span class="line"></span><br><span class="line">	  <span class="function"><span class="keyword">public</span> RawComparator <span class="title">getOutputValueGroupingComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              Class&lt;? extends RawComparator&gt; theClass = getClass(</span><br><span class="line">               JobContext.GROUP_COMPARATOR_CLASS, <span class="keyword">null</span>, RawComparator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	       <span class="comment">//配置项:  mapreduce.job.output.group.comparator.class</span></span><br><span class="line">	               </span><br><span class="line">              <span class="keyword">if</span> (theClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> getOutputKeyComparator();</span><br><span class="line">              &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> ReflectionUtils.newInstance(theClass, <span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line">          </span><br><span class="line">	  <span class="function"><span class="keyword">public</span> RawComparator <span class="title">getOutputKeyComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              Class&lt;? extends RawComparator&gt; theClass = getClass(</span><br><span class="line">              JobContext.KEY_COMPARATOR, <span class="keyword">null</span>, RawComparator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	        配置项:  mapreduce.job.output.key.comparator<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">              <span class="title">if</span> (<span class="title">theClass</span> !</span>= <span class="keyword">null</span>)</span><br><span class="line">                 <span class="keyword">return</span> ReflectionUtils.newInstance(theClass, <span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> WritableComparator.get(getMapOutputKeyClass().asSubclass(WritableComparable<span class="class">.<span class="keyword">class</span>), <span class="title">this</span>)</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>) 真相:  </span><br><span class="line">	在分组比较时， hadoop会获取当前key的类型对应的分组比较器对象，如果获取不到，则</span><br><span class="line">尝试获取当前key的类型对应的排序比较器对象. 如果还获取不到，则hadoop会创建一个比较器对象，最终调用到key的类中的compareTo方法.</span><br></pre></td></tr></table></figure>







</li>
</ol>
<h5 id="3-3-4-OutputFormat数据输出"><a href="#3-3-4-OutputFormat数据输出" class="headerlink" title="3.3.4  OutputFormat数据输出"></a>3.3.4  OutputFormat数据输出</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.相关方法</span><br><span class="line">	getRecorderWriter():获取RecorderWriter对象，负责数据的写出</span><br><span class="line">	checkOutputSpecs():检查输出路径</span><br><span class="line">2.子抽象类FileOutputFormat</span><br><span class="line">	对checkOutputSpecs()做了具体实现，相关异常：&quot;Output directory&quot; + outDir + &quot;already exists&quot;</span><br><span class="line">3.具体实现类</span><br><span class="line">	TextOutputFormat hadoop默认使用的</span><br><span class="line">		LineRecordWriter</span><br><span class="line">	SequenceFileOutputFormat: 最终写出的文件是二进制格式的，所谓的sequenceFile</span><br><span class="line">4.自定义OutputFormat</span><br><span class="line">	1）自定义类继承FileOutputFormat</span><br><span class="line">	2）自定义RecordWriter对象，完成数据的写出操作</span><br></pre></td></tr></table></figure>



<h4 id="3-4-Combiner"><a href="#3-4-Combiner" class="headerlink" title="3.4 Combiner"></a>3.4 Combiner</h4><ol>
<li><p>combiner有什么用呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目的就是在内个MapTask中将输出的kv提前进行合并。能够降低map到reduce传输的数据流以及reduce最终处理的数据流</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>combiner的工作位置</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.工作位置：kv从缓冲区中溢写到磁盘时可以使用combiner（只要设置无条件使用）；每个MapTask的所有数据都从缓冲区写到磁盘后，在进行归并的时候可以使用combiner（满足条件使用，溢写次数&gt;&#x3D;3）</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><p>Combiner使用限制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在不改变业务逻辑的情况下才能使用combiner，比如求和的业务可以，但比如求平均值的业务就不行了，最终可能得到不一样的结果。</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>相关介绍</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.Combiner是MR程序中Mapper和Reducer之外的一种组件，可以选择，并不是常驻组件</span><br><span class="line">2.Combiner组件的父类就是Reducer</span><br><span class="line">3.Combiner和Reducer的区别在于运行的位置</span><br><span class="line">	Combiner是在每一个MapTask所在的节点运行；</span><br><span class="line">	Reducer是接收全局所有Mapper的输出结果</span><br><span class="line">4.Combiner的意思就是对每一个MapTask的输出进行局部汇总，以减小网络传输量</span><br><span class="line">5.Combiner能够应用的前提是不能影响最终的业务逻辑，而且，Combiner输出的kv应该跟Reducer的输入kv类型要对应起来</span><br></pre></td></tr></table></figure>







</li>
</ol>
]]></content>
      <categories>
        <category>Hadoop生态</category>
      </categories>
  </entry>
  <entry>
    <title>hdfs架构</title>
    <url>/2020/05/18/hdfs%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h3 id="第1章-HDFS概述"><a href="#第1章-HDFS概述" class="headerlink" title="第1章 HDFS概述"></a>第1章 HDFS概述</h3><h3 id="第2章-HDFS的Shell操作"><a href="#第2章-HDFS的Shell操作" class="headerlink" title="第2章 HDFS的Shell操作"></a>第2章 HDFS的Shell操作</h3><h3 id="第3章-HDFS的客户端"><a href="#第3章-HDFS的客户端" class="headerlink" title="第3章 HDFS的客户端"></a>第3章 HDFS的客户端</h3><h3 id="第4章-HDFS的数据流"><a href="#第4章-HDFS的数据流" class="headerlink" title="第4章 HDFS的数据流"></a>第4章 HDFS的数据流</h3><h3 id="第5章-NameNode和SecondaryNameNode"><a href="#第5章-NameNode和SecondaryNameNode" class="headerlink" title="第5章 NameNode和SecondaryNameNode"></a>第5章 NameNode和SecondaryNameNode</h3><h4 id="5-1-NN和2NN工作机制"><a href="#5-1-NN和2NN工作机制" class="headerlink" title="5.1 NN和2NN工作机制"></a>5.1 NN和2NN工作机制</h4><h5 id="5-1-1-问题引入"><a href="#5-1-1-问题引入" class="headerlink" title="5.1.1 问题引入"></a>5.1.1 问题引入</h5><ol>
<li><p>NameNode是干啥的？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NameNode最主要的作用就是对HDFS中数据的元数据进行管理</span><br></pre></td></tr></table></figure>
</li>
<li><p>NameNode管理的元数据存在哪里呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">内存+磁盘</span><br><span class="line">分析：考虑数据的安全性跟可靠性，元数据存放在磁盘中比较安全</span><br><span class="line">如果数据维护到磁盘，数据的安全可以保证，但是带来的问题是，访问效率低，因为对HDFS数据的操作或多或少会伴随着元数据修改，元数据的修改在磁盘上效率是很低的。</span><br><span class="line">考虑到效率的问题，元数据存储到内存效率很高，带来的问题是数据不安全。因为内存的数据容易丢失，比如服务器掉电或者故障。</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何在实现高效操作元数据的情况下，还能实现内存+磁盘的维护方案？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HDFS通过fsimage（镜像文件）+edits（编辑日志）的方案来解决问题</span><br><span class="line">镜像文件：某个时刻对NN内存中元数据的一个快照</span><br><span class="line">编辑日志：记录对HDFS的修改操作，只作追加操作效率是很高的</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一直往edits文件中追加内容，该文件会变得非常大，且会越来越大，因此需要隔一段时间或者在合适的时机进行fsimage+edits文件的合并工作，从而生成新的fsimage。新的fsimage = 旧的fsimage+edits。那将fsimage和edits的合并工作交给谁完成呢，由于NameNode本身的负载就高，所以交给SecondaryNameNode来完成这项工作。大致的合并过程如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将NameNode机器对应磁盘上的fsimage和edits文件拉取到SecondaryNameNode机器中，在SecondaryNameNode中将fsimage和edits加到内存中合并，生成新的fsimage,再推送到NameNode机器中的磁盘上，NameNode中旧的fsimage会保留，而新的fsimage作为将要使用的镜像，同时生成新的edits文件。</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h4 id="5-2-Fsimage和Edits解析"><a href="#5-2-Fsimage和Edits解析" class="headerlink" title="5.2 Fsimage和Edits解析"></a>5.2 Fsimage和Edits解析</h4><ol>
<li>Fsimage和Edits概念</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NameNode被格式化之后，将在&#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3&#x2F;data&#x2F;name&#x2F;current目录中产生如下文件</span><br><span class="line">fsimage_000000000000</span><br><span class="line">fsimage_000000000000.md5</span><br><span class="line">seen.txid</span><br><span class="line">VERSION</span><br><span class="line">（1）Fsimage文件：HDFS文件系统元数据的一个永久性的检查点，其中包含HDFS文件系统的所有目录和文件inode的序列化信息</span><br><span class="line">（2）Edits文件：存放HDFS文件系统的所有更新操作，文件系统客户端执行的所有写操作首先会被记录到Edits文件中</span><br><span class="line">（3）seen_txid：文件中保存的是一个数字，就是正在使用的edits_的数字</span><br><span class="line">（4）每次NameNode启动的时候都会将fsimage文件读入内存，加载Edits里面的更新操作，保证内存中的元数据信息是最新的，同步的，可以看成NameNode启动的时候就将fsimage和Edits文件进行了合并</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>ovi查看fsimage文件</p>
<p>1）基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdfs oiv -p 文件类型 -i镜像文件 -o 转换后文件输出路径</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   2）案例实操</p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 current]$ pwd</span><br><span class="line">/opt/module/hadoop-3.1.3/data/tmp/dfs/name/current</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop102 current]$ hdfs oiv -p XML -i fsimage_0000000000000000025 -o /opt/module/hadoop-3.1.3/fsimage.xml</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><p>oev查看Edits文件</p>
<p>1）基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdfs oev -p 文件类型 -i编辑日志 -o 转换后文件输出路径</span><br></pre></td></tr></table></figure>

<p>2）案例实操</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 current]$ hdfs oev -p XML -i edits_0000000000000000012-0000000000000000013 -o /opt/module/hadoop-3.1.3/edits.xml</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop102 current]$ cat /opt/module/hadoop-3.1.3/edits.xml</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="5-3-CheckPoint时间设置"><a href="#5-3-CheckPoint时间设置" class="headerlink" title="5.3 CheckPoint时间设置"></a>5.3 CheckPoint时间设置</h4><ol>
<li><p>通常情况下，SecondaryNameNode每个一个小时执行一次，有必要的话可以修改配置</p>
<p>[hdfs-default.xml]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.namenode.checkpoint.period&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;3600&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>一分钟检查一次操作次数，当操作次数达到一百万时，SecondaryNameNode执行一次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.namenode.checkpoint.txns&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;1000000&lt;&#x2F;value&gt;</span><br><span class="line">&lt;description&gt;操作动作次数&lt;&#x2F;description&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.namenode.checkpoint.check.period&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;60&lt;&#x2F;value&gt;</span><br><span class="line">&lt;description&gt; 1分钟检查一次操作次数&lt;&#x2F;description&gt;</span><br><span class="line">&lt;&#x2F;property &gt;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="5-4-NameNode故障管理"><a href="#5-4-NameNode故障管理" class="headerlink" title="5.4 NameNode故障管理"></a>5.4 NameNode故障管理</h4><p>NameNode故障后，可以采用如下方法恢复数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）将SecondaryNameNode中数据拷贝到NameNode存储数据的目录</span><br><span class="line">（1）kill -9 NameNode进程</span><br><span class="line">（2） 删除NameNode存储的数据（&#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3&#x2F;data&#x2F;name）</span><br><span class="line">[atguigu@hadoop102 hadoop-3.1.3]$ rm -rf &#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3&#x2F;data&#x2F;name&#x2F;*</span><br><span class="line">（3）拷贝SecondaryNameNode中数据到原NameNode存储数据目录</span><br><span class="line">[atguigu@hadoop102 dfs]$ scp -r atguigu@hadoop104:&#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3&#x2F;data&#x2F;tmp&#x2F;dfs&#x2F;namesecondary&#x2F;* .&#x2F;name&#x2F;</span><br><span class="line">（4）重新启动NameNode</span><br><span class="line">[atguigu@hadoop102 hadoop-3.1.3]$ hdfs --daemon start namenode</span><br></pre></td></tr></table></figure>



<h4 id="5-5-集群安全模式"><a href="#5-5-集群安全模式" class="headerlink" title="5.5 集群安全模式"></a>5.5 集群安全模式</h4><h4 id="5-6-NameNode多目录配置"><a href="#5-6-NameNode多目录配置" class="headerlink" title="5.6 NameNode多目录配置"></a>5.6 NameNode多目录配置</h4><h3 id="第6章-DataNode"><a href="#第6章-DataNode" class="headerlink" title="第6章 DataNode"></a>第6章 DataNode</h3><h3 id="第7章-小文件存档"><a href="#第7章-小文件存档" class="headerlink" title="第7章 小文件存档"></a>第7章 小文件存档</h3><h3 id="第8章-回收站"><a href="#第8章-回收站" class="headerlink" title="第8章 回收站"></a>第8章 回收站</h3><h3 id="第9章-纠删码"><a href="#第9章-纠删码" class="headerlink" title="第9章 纠删码"></a>第9章 纠删码</h3>]]></content>
      <categories>
        <category>Hadoop生态</category>
      </categories>
  </entry>
  <entry>
    <title>hadoop</title>
    <url>/2020/05/13/hadoop/</url>
    <content><![CDATA[<h3 id="第1章-大数据概论"><a href="#第1章-大数据概论" class="headerlink" title="第1章 大数据概论"></a>第1章 大数据概论</h3><h3 id="第2章-从Hadoop框架讨论大数据生态"><a href="#第2章-从Hadoop框架讨论大数据生态" class="headerlink" title="第2章 从Hadoop框架讨论大数据生态"></a>第2章 从Hadoop框架讨论大数据生态</h3><p>​    2.1 Hadoop是什么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hadoop是Apache基金会开发的分布式系统架构，主要是用来解决海量数据的存储的和分析计算问题</span><br></pre></td></tr></table></figure>



<p>​    2.2 Hadoop发展历史</p>
<p>​    2.3 Hadoop三大发行版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hadoop三大发行版本：Apache,Cloudera,Hortonworks</span><br><span class="line">Apache版本最原始的版本，对于入门学习最好</span><br><span class="line">Cloudera内部集成了很多大数据框架。对应产品CDH</span><br><span class="line">Hortonworks文档较好。对应产品HDP</span><br></pre></td></tr></table></figure>

<ol>
<li><p>Apache Hadoop</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官网地址：http:&#x2F;&#x2F;hadoop.apache.org&#x2F;releases.html</span><br><span class="line">下载地址：https:&#x2F;&#x2F;archive.apache.org&#x2F;dist&#x2F;hadoop&#x2F;common&#x2F;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>Cloudera Hadoop</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官网地址：https:&#x2F;&#x2F;www.cloudera.com&#x2F;downloads&#x2F;cdh&#x2F;5-10-0.html</span><br><span class="line">下载地址：http:&#x2F;&#x2F;archive-primary.cloudera.com&#x2F;cdh5&#x2F;cdh&#x2F;5&#x2F;</span><br><span class="line">（1）2008年成立的Cloudera是最早将Hadoop商用的公司，为合作伙伴提供Hadoop的商用解决方案，主要是包括支持、咨询服务、培训。</span><br><span class="line">（2）2009年Hadoop的创始人Doug Cutting也加盟Cloudera公司。Cloudera产品主要为CDH，Cloudera Manager，Cloudera Support</span><br><span class="line">（3）CDH是Cloudera的Hadoop发行版，完全开源，比Apache Hadoop在兼容性，安全性，稳定性上有所增强。Cloudera的标价为每年每个节点10000美元。</span><br><span class="line">（4）Cloudera Manager是集群的软件分发及管理监控平台，可以在几个小时内部署好一个Hadoop集群，并对集群的节点及服务进行实时监控。</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>Hortonworks Hadoop</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官网地址：https:&#x2F;&#x2F;hortonworks.com&#x2F;products&#x2F;data-center&#x2F;hdp&#x2F;</span><br><span class="line">下载地址：https:&#x2F;&#x2F;hortonworks.com&#x2F;downloads&#x2F;#data-platform</span><br><span class="line">（1）2011年成立的Hortonworks是雅虎与硅谷风投公司Benchmark Capital合资组建。</span><br><span class="line">（2）公司成立之初就吸纳了大约25名至30名专门研究Hadoop的雅虎工程师，上述工程师均在2005年开始协助雅虎开发Hadoop，贡献了Hadoop80%的代码。</span><br><span class="line">（3）Hortonworks的主打产品是Hortonworks Data Platform（HDP），也同样是100%开源的产品，HDP除常见的项目外还包括了Ambari，一款开源的安装和管理系统。</span><br><span class="line">（4）Hortonworks目前已经被Cloudera公司收购。</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>​    2.4 Hadoop的优势</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）高可靠性：Hadoop底层维护了多个数据副本，所以即使Hadoop某个个计算元素出现存储故障，也不会出现数据的丢失</span><br><span class="line">2）高扩展性：可在集群工作的时候，灵活的往集群中扩展节点</span><br><span class="line">3）高效性：在MapReduce的思想下，Hadoop是并行工作的，以加快任务处理的速度</span><br><span class="line">4）高容错性：能够自动将失败的任务重新分配</span><br></pre></td></tr></table></figure>



<p>​    2.5 Hadoop组成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hadoop的组成：</span><br><span class="line">	hadoop1.x：HDFS（存）+ MapReduce（算+资源（内存，CPU，磁盘，网络...）调度）</span><br><span class="line">	hadoop2.x&#x2F;3.x：HDFS（存）+ MapReduce（算）+ Yarn（资源调度）</span><br></pre></td></tr></table></figure>

<p>​        2.5.1 HDFS架构概述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HDFS是Hadoop分布式文件系统，文件系统是用于对文件进行存储和管理。分布式可以理解为由多台机器共同构成一个完成的文件系统。</span><br><span class="line">NameNode(nn)：负责管理HDFS中所有文件的元数据信息，维护着文件系统树和整棵树内所有的文件和目录。元数据：用于描述真实数据的数据就是元数据。例如：一个真实的数据文件a.txt。它的元数据为：文件名 文件大小 文件权限 文件的目录结构 文件对应的块  在哪个dn存。</span><br><span class="line">注意：要想找到HDFS的真实数据必须通过NameNode所维护的元数据才能定位到DataNode中存储的真实数据。</span><br><span class="line">DataNode（dn）：负责管理HDFS的所有的真实文件数据</span><br><span class="line">SecondaryNameNode（2nn）：辅助的NameNode工作，主要的作用是定期合并空间镜像（fsimage）和编辑日志（edits）</span><br></pre></td></tr></table></figure>

<p>​        2.5.2 YARN架构概述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yarn：资源调度和管理的框架。管理和调度的资源就是整个Hadoop集群的资源</span><br><span class="line">ResourceManager（RM）：是Yarn的大哥，负责管理和调度整个集群的资源。负责处理客户端的请求。负责为Job启动ApplicationMaster。</span><br><span class="line">NodeManager（NM）：是每台机器资源的管理者。实际上只是将本机器的资源对ResourceManager做一个汇报。对于资源的分配必须听从ResourceManager的指令。</span><br><span class="line">ApplicationMaster（AM）：对应每一个Job（MapReduce程序），负责为Job向ResourceManager去申请资源，申请到资源以后，负责告诉NodeManager去运行相应的任务。并且负责监控任务的运行状态和任务的容错。</span><br><span class="line">Container：对多维度资源的封装。方便管理资源及防止资源被侵占</span><br></pre></td></tr></table></figure>

<p>​        简单模拟一个任务的提交过程和资源调度过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 客户端提交Job到ResourceManager</span><br><span class="line">2. ResourceManager 为 Job 启动 ApplicationMaster ,ApplicationMaster的运行也需要资源，因此ApplicationMaster启动起来以后，就会有一个Container封装ApplicationMaster运行所用的资源. 因为资源都是在NodeManager上，所以ApplicationMaster是运行在某一个NodeManager上。</span><br><span class="line">3. ApplicationMaster 会根据Job的情况向 ResourceManager申请资源来运行每个Task，当前Job总共有3个Task，每个Task都是单独运行，因此需要申请3份资源, 也就意味着又有3个Container运行.</span><br><span class="line">4. 所有的资源的分配都是ResourceManager下达指令给NodeManager进行分配的.</span><br><span class="line">5. ApplicationMaster为Job成功申请到资源以后，会告诉NodeManager去运行对应的Task,每个Task可能运行到不同的机器，也有可能多个Task运行到同一个机器，要看当时集群的资源情况.</span><br><span class="line">6. 当Job的每个Task都开始运行，ApplicationMaster负责监控整个Job的状态. 要负责容错相关的事情.</span><br><span class="line">7. 当Job的每个Task都执行成功后，意味着Job运行完成，此时ApplicationMaster会找ResourceMananger申请注销自己，所有为当前Job申请的资源得到释放.</span><br></pre></td></tr></table></figure>

<p>​        2.5.3 MapReduce架构概述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MapReduce将计算过程分为两个阶段：</span><br><span class="line">1）Map阶段并行处理输入数据</span><br><span class="line">2）Reduce阶段对Map结果进行汇总</span><br></pre></td></tr></table></figure>



<p>​    2.6 大数据技术生态体系</p>
<h3 id="第3章-Hadoop运行环境搭建"><a href="#第3章-Hadoop运行环境搭建" class="headerlink" title="第3章 Hadoop运行环境搭建"></a>第3章 Hadoop运行环境搭建</h3><ol>
<li><p>安装JDK</p>
</li>
<li><p>安装Hadoop</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hadoop的下载地址：https:&#x2F;&#x2F;archive.apache.org&#x2F;dist&#x2F;hadoop&#x2F;common&#x2F;hadoop-3.1.3&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置JDK和Hadoop的环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打开&#x2F;etc&#x2F;profile.d&#x2F;my_env.sh</span><br><span class="line">在文件中添加</span><br><span class="line">JAVA_HOME&#x3D;&#x2F;opt&#x2F;module&#x2F;jdk1.8.0_212</span><br><span class="line">HADOOP_HOME&#x3D;&#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$HADOOP_HOME&#x2F;bin:$HADOOP_HOME&#x2F;sbin</span><br><span class="line">export PATH JAVA_HOME HADOOP_HOME</span><br><span class="line"></span><br><span class="line">然后通过java -version</span><br><span class="line">hadoop version 验证安装是否成功</span><br></pre></td></tr></table></figure>
</li>
<li><p>hadoop的几个重要的目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）bin目录： 存放对Hadoop相关服务（HDFS,YARN）进行操作的脚本</span><br><span class="line">（2）etc目录： Hadoop的配置文件目录，存放Hadoop的配置文件</span><br><span class="line">（3）lib 目录： 存放Hadoop的本地库（对数据进行压缩解压缩功能）</span><br><span class="line">（4）sbin目录：存放启动或停止Hadoop相关服务的脚本</span><br><span class="line">（5）share目录：存放Hadoop的依赖jar包、文档、和官方案例</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="第4章-Hadoop运行模式"><a href="#第4章-Hadoop运行模式" class="headerlink" title="第4章 Hadoop运行模式"></a>第4章 Hadoop运行模式</h3><p>Hadoop的运行模式有3种：本地运行模式，伪分布式模式，完全分布式模式</p>
<p>常用的通信端口</p>
<table>
<thead>
<tr>
<th>NameNode</th>
<th>内部通信端口</th>
<th>9820</th>
</tr>
</thead>
<tbody><tr>
<td>NameNode</td>
<td>Web通信端口</td>
<td>9870</td>
</tr>
<tr>
<td><strong>SecondaryNameNode</strong></td>
<td>内部通信端口</td>
<td>9869</td>
</tr>
<tr>
<td>SecondaryNameNode</td>
<td>Web通信端口</td>
<td>9868</td>
</tr>
<tr>
<td><strong>ResourceManager</strong></td>
<td>内部通信端口</td>
<td>8032</td>
</tr>
<tr>
<td>ResourceManager</td>
<td>Web通信端口</td>
<td>8088</td>
</tr>
</tbody></table>
<p>配置文件说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）默认的配置文件：</span><br><span class="line">core-default.xml</span><br><span class="line">hdfs-default.xml</span><br><span class="line">yarn-default.xml</span><br><span class="line">mapred-default.xml</span><br><span class="line">2）用户自定义的配置文件</span><br><span class="line">core-site.xml</span><br><span class="line">hdfs-site.xml</span><br><span class="line">yarn-site.xml</span><br><span class="line">mapred-site.xml</span><br><span class="line"></span><br><span class="line">优先级：</span><br><span class="line">用户自定义的配置文件&gt;默认的配置文件，hadoop启动的时候会先加载xxx-default.xml，再加载xxx-site.xml,配置到xxx-site.xml中的配置会覆盖xxx-default中的配置。</span><br></pre></td></tr></table></figure>





<p>4.1 完全分布式运行模式</p>
<p>4.1.1 搭建集群步骤分析</p>
<ol>
<li>准备好集群的机器</li>
<li>安装JDK，Hadoop，配置环境变量</li>
<li>配置集群</li>
<li>单点启动</li>
<li>配置ssh</li>
<li>群起集群</li>
</ol>
<p>4.1.2 编写集群分发脚本xsync</p>
<ol>
<li>scp（secure copy）安全拷贝</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  （1）scp定义：scp可以实现服务器与服务器之间的数据拷贝。（from server1 to server2）</span><br><span class="line">  （2）基本语法</span><br><span class="line">scp   -r  $pdir&#x2F;$fname          $user@hadoop$host:$pdir&#x2F;$fname</span><br><span class="line">命令  递归  要拷贝的文件路径&#x2F;名称    目的用户@主机:目的路径&#x2F;名称</span><br><span class="line">  （3）案例实操</span><br><span class="line">   前提：在 hadoop102  hadoop103  hadoop104 都已经创建好的 &#x2F;opt&#x2F;module</span><br><span class="line">           &#x2F;opt&#x2F;software 两个目录， 并且已经把这两个目录修改为atgu</span><br><span class="line">  （a）在hadoop101上，将hadoop101中&#x2F;opt&#x2F;module目录下的软件拷贝到hadoop102上igu:atguigu</span><br><span class="line">          [atguigu@hadoop101 &#x2F;]$ scp -r &#x2F;opt&#x2F;module  </span><br><span class="line">  （b）在hadoop103上，将hadoop101服务器上的&#x2F;opt&#x2F;module目录下的软件拷贝到hadoop103上</span><br><span class="line">          [atguigu@hadoop103 opt]$ scp -r atguigu@hadoop101:&#x2F;opt&#x2F;module atguigu@hadoop103:&#x2F;opt&#x2F;module</span><br><span class="line">  （c）在hadoop103上操作将hadoop101中&#x2F;opt&#x2F;module目录下的软件拷贝到hadoop104上</span><br><span class="line">		  [atguigu@hadoop103 opt]$ scp -r atguigu@hadoop101:&#x2F;opt&#x2F;module atguigu@hadoop104:&#x2F;opt&#x2F;module</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>rsync远程同步工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）rsync定义</span><br><span class="line">rsync主要用于备份和镜像。具有速度快、避免复制相同内容和支持符号链接的优点。</span><br><span class="line">rsync和scp区别：用rsync做文件的复制要比scp的速度快，rsync只对差异文件做更新。scp是把所有文件都复制过去。</span><br><span class="line">（2）基本语法</span><br><span class="line">rsync    -av       $pdir&#x2F;$fname              $user@hadoop$host:$pdir&#x2F;$fname</span><br><span class="line">命令   选项参数   要拷贝的文件路径&#x2F;名称    目的用户@主机:目的路径&#x2F;名称</span><br><span class="line">选项参数说明:</span><br><span class="line">-a  归档拷贝</span><br><span class="line">-v	显示复制过程</span><br><span class="line">（3）案例实操</span><br><span class="line">（a）把hadoop101机器上的&#x2F;opt&#x2F;software目录同步到hadoop102服务器的&#x2F;opt&#x2F;software目录下</span><br><span class="line">[atguigu@hadoop101 opt]$ rsync -av &#x2F;opt&#x2F;software&#x2F; atguigu@hadoop102:&#x2F;atguigu &#x2F;software</span><br></pre></td></tr></table></figure>
</li>
<li><p>xsync集群分发脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">（1）需求：循环复制文件到所有节点的相同目录下:</span><br><span class="line">（2）期望脚本：基于rsync技术将文件从一个节点同步到其他所有节点</span><br><span class="line">	xsync  要同步的文件名称  </span><br><span class="line">（3）脚本实现</span><br><span class="line">（a）在/home/atguigu目录下创建bin目录，并在bin目录下创建xsync文件</span><br><span class="line">说明：在/home/atguigu/bin这个目录下存放的脚本，atguigu用户可以在系统任何地方直接执行。因为/home/atguigu/bin在系统的PATH环境变量中</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 bin] vim xsync</span><br><span class="line">在文件中编辑如下代码</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1. 判断参数个数</span></span><br><span class="line">if [ $# -lt 1 ]</span><br><span class="line">then</span><br><span class="line">  echo Not Enough Arguement!</span><br><span class="line">  exit;</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash">2. 遍历集群所有机器</span></span><br><span class="line">for host in hadoop102 hadoop103 hadoop104</span><br><span class="line">do</span><br><span class="line">  echo ====================  $host  ====================</span><br><span class="line"><span class="meta">  #</span><span class="bash">3. 遍历所有目录，挨个发送</span></span><br><span class="line">  for file in $@</span><br><span class="line">  do</span><br><span class="line">    #4 判断文件是否存在</span><br><span class="line">    if [ -e $file ]</span><br><span class="line">    then</span><br><span class="line">      #5. 获取父目录</span><br><span class="line">      pdir=$(cd -P $(dirname $file); pwd)</span><br><span class="line">      #6. 获取当前文件的名称</span><br><span class="line">      fname=$(basename $file)</span><br><span class="line">      ssh $host "mkdir -p $pdir"</span><br><span class="line">      rsync -av $pdir/$fname $host:$pdir</span><br><span class="line">    else</span><br><span class="line">      echo $file does not exists!</span><br><span class="line">    fi</span><br><span class="line">  done</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">（b）修改脚本 xsync 具有执行权限</span><br><span class="line">chmod +x xsync</span><br><span class="line">（c）测试脚本</span><br><span class="line">xsync /home/atguigu/a.txt</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>4.1.2 集群配置</p>
<ol>
<li><p>集群部署规划</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：NameNode和SecondaryNameNode不要安装在同一台服务器</span><br><span class="line">注意：ResourceManager也很消耗内存，不要和NameNode、SecondaryNameNode配置在同一台机器上。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>hadoop102</th>
<th>hadoop103</th>
<th>hadoop104</th>
</tr>
</thead>
<tbody><tr>
<td>HDFS</td>
<td>NameNode DataNode</td>
<td>DataNode</td>
<td>SecondaryNameNode DataNode</td>
</tr>
<tr>
<td>YARN</td>
<td>NodeManager</td>
<td>RecourceManager</td>
<td>NodeManager</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="2">
<li><p>配置集群</p>
<p>（1）在hadoop-env.sh中配置JAVA_HOME路径</p>
<p>（2）核心配置文件core-site.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd $HADOOP_HOME&#x2F;etc&#x2F;hadoop</span><br><span class="line">vim core-site.xml</span><br><span class="line">文件内容如下：</span><br><span class="line">&lt;!-- 指定NameNode的地址 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;hdfs:&#x2F;&#x2F;hadoop102:9820&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;!-- 指定hadoop数据的存储目录官方配置文件中的配置项是hadoop.tmp.dir ,用来指定hadoop数据的存储目录,此次配置用的hadoop.data.dir是自己定义的变量， 因为在hdfs-site.xml中会使用此配置的值来具体指定namenode 和 datanode存储数据的目录</span><br><span class="line">--&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.data.dir&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;&#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3&#x2F;data&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;!-- 下面是兼容性配置，先跳过 --&gt;</span><br><span class="line">&lt;!-- 配置该atguigu(superUser)允许通过代理访问的主机节点 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.proxyuser.atguigu.hosts&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;*&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;!-- 配置该atguigu(superuser)允许代理的用户所属组 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.proxyuser.atguigu.groups&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;*&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;!-- 配置该atguigu(superuser)允许代理的用户--&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.proxyuser.atguigu.users&lt;&#x2F;name&gt;</span><br><span class="line">		&lt;value&gt;*&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure>

<p>（3）HDFS配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 指定副本数  --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;3&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定NameNode数据的存储目录 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.namenode.name.dir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;file:&#x2F;&#x2F;$&#123;hadoop.data.dir&#125;&#x2F;name&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定Datanode数据的存储目录 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.datanode.data.dir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;file:&#x2F;&#x2F;$&#123;hadoop.data.dir&#125;&#x2F;data&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">    </span><br><span class="line">&lt;!-- 指定SecondaryNameNode数据的存储目录 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.namenode.checkpoint.dir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;file:&#x2F;&#x2F;$&#123;hadoop.data.dir&#125;&#x2F;namesecondary&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">   </span><br><span class="line">&lt;!-- 兼容配置，先跳过 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.client.datanode-restart.timeout&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;30s&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- nn web端访问地址--&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.namenode.http-address&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;hadoop102:9870&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 2nn web端访问地址--&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.namenode.secondary.http-address&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;hadoop104:9868&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure>

<p>（4）YARN配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;!-- 指定ResourceManager的地址--&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;hadoop103&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;!-- 环境变量的继承 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.env-whitelist&lt;&#x2F;name&gt;</span><br><span class="line">	                                                     &lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;!--  取消虚拟内存的限制 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;false&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure>

<p>（5）配置mapred-site.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 指定MapReduce程序运行在Yarn上 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.framework.name&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;yarn&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<ol start="3">
<li><p>在集群上分发配置好的hadoop</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xsync &#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li>在其他节点查看文件分发情况</li>
</ol>
<p>4.1.3 集群单点启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）如果集群是第一次启动需要格式化NameNode</span><br><span class="line">hdfs namenode -format</span><br><span class="line">2）在hadoop102上启动NameNode</span><br><span class="line">hdfs --daemon start namenode</span><br><span class="line">3）完成后执行jps命令，看到namenode进程已启动</span><br><span class="line">3461 NameNode</span><br><span class="line">4）在hadoop102，hadoop103以及hadoop上执行如下命令，启动DataNode</span><br><span class="line">hdfs --daemon start datanode</span><br><span class="line">5）在hadoop104上启动SecondaryNameNode</span><br><span class="line">hdfs --daemon start secondnamenode</span><br><span class="line">6）在hadoop103机器上启动ResourceManager</span><br><span class="line">yarn --daemon start resourcemanager</span><br><span class="line">7）在hadoop102,hadoop103以及hadoop104上执行如下命令，启动nodemanager</span><br><span class="line">yarn --daemon start nodemanager</span><br></pre></td></tr></table></figure>

<p>4.1.4 SSH无密登录配置</p>
<p>4.1.5 群起集群</p>
<h3 id="第5章-Hadoop3-x和2-x主要区别"><a href="#第5章-Hadoop3-x和2-x主要区别" class="headerlink" title="第5章 Hadoop3.x和2.x主要区别"></a>第5章 Hadoop3.x和2.x主要区别</h3><p>​    </p>
<h3 id="第6章-Hadoop源码编译"><a href="#第6章-Hadoop源码编译" class="headerlink" title="第6章 Hadoop源码编译"></a>第6章 Hadoop源码编译</h3><h3 id="第7章-常见错误及解决方案"><a href="#第7章-常见错误及解决方案" class="headerlink" title="第7章  常见错误及解决方案"></a>第7章  常见错误及解决方案</h3>]]></content>
      <categories>
        <category>Hadoop生态</category>
      </categories>
  </entry>
  <entry>
    <title>shell</title>
    <url>/2020/05/12/shell/</url>
    <content><![CDATA[<h3 id="第1章-Shell概述"><a href="#第1章-Shell概述" class="headerlink" title="第1章 Shell概述"></a>第1章 Shell概述</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shell是一个命令行解释器，它接受应用程序/用户命令，然后调用操作系统内核。shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性强</span><br></pre></td></tr></table></figure>

<p>可以通过cat /etc/shells查看Linux提供的shell解析器，centos默认的解析器是bash</p>
<h3 id="第2章-shell脚本入门"><a href="#第2章-shell脚本入门" class="headerlink" title="第2章 shell脚本入门"></a>第2章 shell脚本入门</h3><p>1）脚本格式</p>
<p>​    脚本以#!/bin/bash开头（指定解析器）</p>
<p>2）案例实操：创建一个shell脚本，输出helloworld</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ touch helloworld.sh</span><br><span class="line">[root@hadoop101 datas]$ vi helloworld.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "helloworld"</span><br></pre></td></tr></table></figure>

<p>（3）脚本的常用执行方式</p>
<p>第一种：采用bash或sh脚本的相对路径或绝对路径（不用赋予脚本+x权限）</p>
<p>sh+脚本的相对路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ sh helloworld.sh</span><br></pre></td></tr></table></figure>

<p>第二种：采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限+x）</p>
<p>(a)首先要赋予helloworld.sh脚本的+x权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ chmod 744 helloworld.sh</span><br></pre></td></tr></table></figure>

<p>(b)执行脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ ./helloworld.sh</span><br></pre></td></tr></table></figure>

<p>注意：第一种执行方法，本质是bash解析器帮你执行脚本，所以脚本本身不需要执行权限。第二种执行方法，本质是脚本需要自己执行，所以需要执行权限。</p>
<p>第三种：在脚本的路径前加上“.</p>
<h3 id="第3章-变量"><a href="#第3章-变量" class="headerlink" title="第3章 变量"></a>第3章 变量</h3><h4 id="3-1-系统预定义变量"><a href="#3-1-系统预定义变量" class="headerlink" title="3.1 系统预定义变量"></a>3.1 系统预定义变量</h4><p>1）常用系统常量</p>
<p>$HOME,$PWD,$SHELL,$USER</p>
<p>2）案例实操</p>
<p>（1）查看系统变量的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ echo $HOME</span><br></pre></td></tr></table></figure>

<p>（2）显示当前shell中所有变量：set</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ set</span><br><span class="line">BASH=/bin/bash</span><br><span class="line">BASH_ALIASES=()</span><br><span class="line">BASH_ARGC=()</span><br><span class="line">BASH_ARGV=()</span><br></pre></td></tr></table></figure>



<h4 id="3-2-自定义变量"><a href="#3-2-自定义变量" class="headerlink" title="3.2 自定义变量"></a>3.2 自定义变量</h4><h4 id="3-3-特殊变量"><a href="#3-3-特殊变量" class="headerlink" title="3.3 特殊变量"></a>3.3 特殊变量</h4><h3 id="第4章-运算符"><a href="#第4章-运算符" class="headerlink" title="第4章 运算符"></a>第4章 运算符</h3><h3 id="第5章-条件判断"><a href="#第5章-条件判断" class="headerlink" title="第5章 条件判断"></a>第5章 条件判断</h3><h3 id="第6章-流程控制（重点）"><a href="#第6章-流程控制（重点）" class="headerlink" title="第6章 流程控制（重点）"></a>第6章 流程控制（重点）</h3><h3 id="第7章-read读取控制台输入"><a href="#第7章-read读取控制台输入" class="headerlink" title="第7章 read读取控制台输入"></a>第7章 read读取控制台输入</h3><ol>
<li>基本语法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">read(选项)(参数)</span><br><span class="line">选项：</span><br><span class="line">-p：指定读取值时的提示符；</span><br><span class="line">-t：指定读取值时等待的时间（秒）</span><br><span class="line">参数</span><br><span class="line">	变量：指定读取值的变量名</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>案例实操</li>
</ol>
<p>提示7秒内，读取控制台输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ touch read.sh</span><br><span class="line">[root@hadoop101 datas]$ vim read.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">read -t 7 -p &quot;Enter your name in 7 seconds&quot; NAME</span><br><span class="line">echo $NAME</span><br><span class="line">[root@hadoop101 datas]$ .&#x2F;read.sh</span><br></pre></td></tr></table></figure>



<h3 id="第8章-函数"><a href="#第8章-函数" class="headerlink" title="第8章 函数"></a>第8章 函数</h3><h5 id="8-1-系统函数"><a href="#8-1-系统函数" class="headerlink" title="8.1 系统函数"></a>8.1 系统函数</h5><ol>
<li><p>basename</p>
<p>​    1）基本语法</p>
<p>​    basename[string/pathname] [suffix]   功能描述：basename命令会删除所有的前缀包括最后一个/字符，然后将字符串内容显示出来。选项：suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉</p>
<p>​    2）案例实操</p>
<p>​    截取该/home/atguigu/banzhang.txt路径 的文件名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ basename /home/atguigu/banzhang.txt</span><br><span class="line">banzhang.txt</span><br><span class="line">[root@hadoop101 datas]$ basename /home/atguigu/banzhang.txt .txt</span><br><span class="line">banzhang</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>dirname</p>
<p>​    1）基本语法</p>
<p>​    dirname 文件绝对路径    功能描述：从给定的包含绝对路径的文件名中取出文件名（非目录的部分），然后返回剩下的路径（目录的部分）</p>
<p>​    2）案例实操</p>
<p>​    获取banzhang.txt文件的路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ dirname /home/atguigu/banzhang.txt</span><br><span class="line">/home/atguigu</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="8-2-自定义函数"><a href="#8-2-自定义函数" class="headerlink" title="8.2 自定义函数"></a>8.2 自定义函数</h4><p>​    1）基本语法</p>
<p>​        [function] funname[()]</p>
<p>​        {    </p>
<p>​            Action;</p>
<p>​            [return int;]</p>
<p>​        }</p>
<p>​    2）经验技巧</p>
<p>​        （1）必须在调用函数地方之前，先声明函数，shell脚本是逐行解释运行，不会像其它语言一样先编译。</p>
<p>​        （2）函数返回值，只能通过$?系统变量获得，可以显示加：return返回，如果不加，将以最后一条命令运行结果，作为返回值。return后跟数值n（0-255）</p>
<p>​    3）案例实操</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ touch fun.sh</span><br><span class="line">[root@hadoop101 datas]$ vim fun.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">function sum()</span><br><span class="line">&#123;</span><br><span class="line">	s=0</span><br><span class="line">	s=$[ $1 + $2 ]</span><br><span class="line">	echo "$s"</span><br><span class="line">&#125;</span><br><span class="line">read -p "please input the number1: " n1;</span><br><span class="line">read -p "please input the number2: " n2;</span><br><span class="line">sum $n1 $n2;</span><br><span class="line"></span><br><span class="line">[root@hadoop101 datas]$ chmod 777 fun.sh</span><br><span class="line">[root@hadoop101 datas]$ ./fun.sh</span><br></pre></td></tr></table></figure>



<h3 id="第9章-Shell工具（重点）"><a href="#第9章-Shell工具（重点）" class="headerlink" title="第9章 Shell工具（重点）"></a>第9章 Shell工具（重点）</h3><h4 id="9-1-cut"><a href="#9-1-cut" class="headerlink" title="9.1 cut"></a>9.1 cut</h4><h4 id="9-2-sed-了解"><a href="#9-2-sed-了解" class="headerlink" title="9.2 sed(了解)"></a>9.2 sed(了解)</h4><h4 id="9-3-awk"><a href="#9-3-awk" class="headerlink" title="9.3 awk"></a>9.3 awk</h4><p>​    一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。</p>
<p>1）基本用法</p>
<p>​    awk[选项参数]  ‘pattern1{action1} pattern2{action2}…’    filename</p>
<p>​    pattern: 表示awk在数据中查找的内容，就是匹配模式</p>
<p>​    action：在找到匹配内容时所执行的一系列命令</p>
<p>2）选项参数说明</p>
<p>​    </p>
<table>
<thead>
<tr>
<th>选项参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-F</td>
<td>指定输入文件折分隔符</td>
</tr>
<tr>
<td>-v</td>
<td>赋值一个用户定义变量</td>
</tr>
</tbody></table>
<p>3）案例实操</p>
<p>​    （1）数据准备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ sudo cp /etc/passed ./</span><br></pre></td></tr></table></figure>

<p>​    （2）搜索passwd文件以root关键字开头的所有行，并输出该行的第7列</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ awk -F: '/^root/&#123;print $7&#125;' passwd </span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>



<p>​    （3）搜索passwd文件以root关键字开头的所有行，并输出该行的第1列和第7列，中间用“，”分割</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ awk -F: '/^root/&#123;print $1","$7&#125;' passwd </span><br><span class="line">root,/bin/bash</span><br></pre></td></tr></table></figure>

<p>​    （4）只显示/etc/passwd的第一列和第七列，以逗号分割，且在所有行前面添加列名user，shell在最后一行添加”dahaige，/bin/zuishuai”。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ awk -F 'BEGIN&#123;print "user,shell"&#125; &#123;print $1","$7&#125; END&#123;print "dahaige,/bin/zuishuai"&#125;' passwd</span><br></pre></td></tr></table></figure>

<p>注意2：BEGIN在所有数据读取行之前执行;END在所有数据执行之后执行。</p>
<p> （5）将passwd 文件中的用户id增加数值1并输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]awk -v i=1 -F: '&#123;print $3+i&#125;' passwd</span><br></pre></td></tr></table></figure>



<p>4）awk的内置变量</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>FILENAME</td>
<td>文件名</td>
</tr>
<tr>
<td>NR</td>
<td>已读的记录数（已读的行数,可用于显示对应的行号）</td>
</tr>
<tr>
<td>NF</td>
<td>浏览记录的域的个数（切割后，列的个数）</td>
</tr>
</tbody></table>
<p>5）案例实操</p>
<p>​    （1）统计passwd文件名，每行的行号，每行的列数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ awk -F : '&#123;print "filename:" FILENAME  ",linenumber: " NR ",columns:" NF&#125;' passwd</span><br></pre></td></tr></table></figure>

<p>​    （2）切割IP</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ ifconfig | grep "netmask" | awk -F "inet" </span><br><span class="line">'&#123;print $2&#125;' | awk -F " " '&#123;print $1&#125;'</span><br></pre></td></tr></table></figure>

<p>​    （3）查询sed.txt中空行所在的行号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ awk '/^$/&#123;print NR&#125;' sed.txt</span><br></pre></td></tr></table></figure>





<h4 id="9-4-sort"><a href="#9-4-sort" class="headerlink" title="9.4 sort"></a>9.4 sort</h4><h4 id="9-5-wc-word-count"><a href="#9-5-wc-word-count" class="headerlink" title="9.5 wc(word count)"></a>9.5 wc(word count)</h4><p>​    wc命令来计算数字。利用wc指令我们可以计算文件的byte数，字数或是列数。</p>
<p>1）基本语法</p>
<p>wc[选项参数]filename</p>
<table>
<thead>
<tr>
<th>选项参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td>统计文件行数</td>
</tr>
<tr>
<td>-w</td>
<td>统计文件的单词数</td>
</tr>
<tr>
<td>-m</td>
<td>统计文件的字符数</td>
</tr>
</tbody></table>
<p>2）案例实操</p>
<p>统计/etc/profile文件的行数，单词数，字节数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]# wc -l /etc/profile</span><br><span class="line">[root@hadoop101 datas]# wc -w /etc/profile</span><br><span class="line">[root@hadoop101 datas]# wc -m /etc/profile</span><br></pre></td></tr></table></figure>



<h3 id="第10章-正则表达式入门"><a href="#第10章-正则表达式入门" class="headerlink" title="第10章 正则表达式入门"></a>第10章 正则表达式入门</h3><p>​         正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。在Linux中，grep，sed，awk等命令都支持通过正则表达式进行模式匹配。  </p>
<h4 id="10-1常规匹配"><a href="#10-1常规匹配" class="headerlink" title="10.1常规匹配"></a>10.1常规匹配</h4><p>​    一串不包含特殊字符的正则表达式匹配它自己，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]cat /etc/passwd | grep atguigu</span><br></pre></td></tr></table></figure>



<h4 id="10-2常用特殊字符"><a href="#10-2常用特殊字符" class="headerlink" title="10.2常用特殊字符"></a>10.2常用特殊字符</h4><p>​    1）特殊字符：^</p>
<p>​    ^匹配一行的开头，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ cat /etc/passwd | grep ^a</span><br></pre></td></tr></table></figure>

<p>会匹配出所有以a开头的行</p>
<p>​    2）特殊字符：$</p>
<p>​    $匹配一行的结束，例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ cat /etc/passwd | grep t$</span><br></pre></td></tr></table></figure>

<p>会匹配出所有以t结尾的行</p>
<p>​    3）特殊字符：.</p>
<p>.匹配一个任意的字符，例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ cat /etc/passed | grep r..t</span><br></pre></td></tr></table></figure>



<p>​    4）特殊字符：*</p>
<p>​    *不单独使用，他和上一个字符连用，表示匹配上一个字符0次或多次，例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas] cat /etc/passwd | grep ro*t</span><br></pre></td></tr></table></figure>

<p>会匹配rt,rot,root,rooot,roooot等所有行</p>
<p>​    5）特殊字符：[]</p>
<p>​    [ ] 表示匹配某个范围内的一个字符，例如</p>
<p>​    [6,8]——匹配6或者8</p>
<p>​    [a-z]——匹配一个a-z之间的字符</p>
<p>​    [a-z]*—–匹配任意字母字符串</p>
<p>​    [a-c, e-f]-匹配a-c或者e-f之间的任意字符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ cat /etc/passwd | grep r[a,b,c]*t</span><br></pre></td></tr></table></figure>

<p>会匹配rt,rat,rabt,racbt,等所有行</p>
<p>​    6）特殊字符：\</p>
<p>​         \ 表示转义，并不会单独使用。由于所有特殊字符都有其特定匹配模式，当我们想匹配某一特殊字符本身时（例如，我想找出所有包含 ‘$’ 的行），就会碰到困难。此时我们就要将转义字符和特殊字符连用，来表示特殊字符本身，例如  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ cat /etc/passwd | grep a\$b</span><br></pre></td></tr></table></figure>

<p>​         就会匹配所有包含 a$b 的行  </p>
<p>​    </p>
<h4 id="10-3其他特殊字符"><a href="#10-3其他特殊字符" class="headerlink" title="10.3其他特殊字符"></a>10.3其他特殊字符</h4><p>​    参考正则表达式语法</p>
<h3 id="第11章-面试题"><a href="#第11章-面试题" class="headerlink" title="第11章 面试题"></a>第11章 面试题</h3>]]></content>
      <categories>
        <category>shell</category>
      </categories>
  </entry>
  <entry>
    <title>Linux基本介绍</title>
    <url>/2020/05/05/linux%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><h3 id="1-Linux的目录"><a href="#1-Linux的目录" class="headerlink" title="1. Linux的目录"></a>1. Linux的目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F; 根目录</span><br><span class="line">&#x2F;bin 存放Linux的常用命令</span><br><span class="line">&#x2F;root 是root用户的主目录&#x2F;家目录</span><br><span class="line">&#x2F;home 是存放所有普通用户主目录的目录</span><br><span class="line">&#x2F;etc 存放Linux系统配置文件的目录</span><br><span class="line">&#x2F;opt 存放安装软件的目录</span><br><span class="line">&#x2F;tmp 存放临时文件的目录</span><br><span class="line">&#x2F;var 存放文件内容经常扩充变化的目录，习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件</span><br><span class="line">&#x2F;boot 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件，自己的安装别放这里</span><br></pre></td></tr></table></figure>

<h3 id="2-VI-VIM编辑器"><a href="#2-VI-VIM编辑器" class="headerlink" title="2. VI/VIM编辑器"></a>2. VI/VIM编辑器</h3><h4 id="2-1-一般模式"><a href="#2-1-一般模式" class="headerlink" title="2.1 一般模式"></a>2.1 一般模式</h4><p>​    通过vi/vim打开一个文件就直接进入一般模式了（默认模式），在一般模式中，可以通过上下左右按键来移动光标，可以使用删除字符或删除整行来处理档案内容，，也可以使用复制粘贴处理文件数据</p>
<p>常用的语法如下</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>yy</td>
<td>复制光标当前一行</td>
</tr>
<tr>
<td>dd</td>
<td>删除光标当前行</td>
</tr>
<tr>
<td>shift+^</td>
<td>删除一个词</td>
</tr>
<tr>
<td>shift+$</td>
<td>移动到行尾</td>
</tr>
<tr>
<td>数字n+shift+g</td>
<td>移动到目标行</td>
</tr>
<tr>
<td>shift+g</td>
<td>移动到页尾</td>
</tr>
</tbody></table>
<h4 id="2-2-编辑模式"><a href="#2-2-编辑模式" class="headerlink" title="2.2 编辑模式"></a>2.2 编辑模式</h4><p>​    在一般模式下可以进行删除，复制，粘贴等动作，但是却无法编辑文件内容的，要按下【i,a,o,I,A,O】中的任意一个字母才会进入编辑模式。进入编辑模式时，在画面的左下方会出现insert或replace的字样，此时才可以进行编辑。</p>
<p>​    退出编辑模式时按下<code>ESC</code>键即可</p>
<h4 id="2-3-指令模式"><a href="#2-3-指令模式" class="headerlink" title="2.3 指令模式"></a>2.3 指令模式</h4><p>​    在一般模式中，输入【:/?】3个中的任何一个按钮，就可以将光标移动到最底下那一行。在这个模式中，可以提供搜寻资料的工作，而读取，存盘，大量取代字符，离开vi，显示行号等动作是在此模式中达成的。</p>
<p>​    </p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>:w</td>
<td>保存</td>
</tr>
<tr>
<td>:q</td>
<td>退出</td>
</tr>
<tr>
<td>:!</td>
<td>强制执行</td>
</tr>
<tr>
<td>/要查找的词</td>
<td>n查找下一个，N往上查找</td>
</tr>
<tr>
<td>？要查找的词</td>
<td>n是查找上一个，shift+n是往下查找</td>
</tr>
<tr>
<td>:set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>关闭行号</td>
</tr>
<tr>
<td>:%s/old/new/g</td>
<td>替换内容</td>
</tr>
</tbody></table>
<p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:wq! --强制保存退出</span><br></pre></td></tr></table></figure>



<h3 id="3-网络配置和系统管理操作"><a href="#3-网络配置和系统管理操作" class="headerlink" title="3. 网络配置和系统管理操作"></a>3. 网络配置和系统管理操作</h3><h4 id="3-1-配置网络IP地址"><a href="#3-1-配置网络IP地址" class="headerlink" title="3.1 配置网络IP地址"></a>3.1 配置网络IP地址</h4><h5 id="3-1-1-ifconfig-查看网络接口"><a href="#3-1-1-ifconfig-查看网络接口" class="headerlink" title="3.1.1 ifconfig 查看网络接口"></a>3.1.1 ifconfig 查看网络接口</h5><ol>
<li><p>基本语法</p>
<p>ifconfig (功能描述：显示所有网络接口的配置信息)</p>
</li>
<li><p>案例实操</p>
<p>[root@hadoop100 ~]# ifconfig</p>
</li>
</ol>
<h5 id="3-1-2-ping-测试主机之间网络连通性"><a href="#3-1-2-ping-测试主机之间网络连通性" class="headerlink" title="3.1.2 ping 测试主机之间网络连通性"></a>3.1.2 ping 测试主机之间网络连通性</h5><ol>
<li><p>基本语法</p>
<p>ping 目的主机</p>
</li>
</ol>
<h5 id="3-1-3-修改IP地址"><a href="#3-1-3-修改IP地址" class="headerlink" title="3.1.3 修改IP地址"></a>3.1.3 修改IP地址</h5><ol>
<li><p>查看IP配置文件，并作相应修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop100 ~]#vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line">设置以下内容</span><br><span class="line">TYPE="Ethernet"    #网络类型（通常是Ethemet）</span><br><span class="line">PROXY_METHOD="none"</span><br><span class="line">BROWSER_ONLY="no"</span><br><span class="line">BOOTPROTO="static"   #IP的配置方法[none|static|bootp|dhcp]（引导时不 使用协议|静态分配IP|BOOTP协议|DHCP协议）</span><br><span class="line">DEFROUTE="yes"</span><br><span class="line">IPV4_FAILURE_FATAL="no"</span><br><span class="line">IPV6INIT="yes"</span><br><span class="line">IPV6_AUTOCONF="yes"</span><br><span class="line">IPV6_DEFROUTE="yes"</span><br><span class="line">IPV6_FAILURE_FATAL="no"</span><br><span class="line">IPV6_ADDR_GEN_MODE="stable-privacy"</span><br><span class="line">NAME="ens33"   </span><br><span class="line">UUID="e83804c1-3257-4584-81bb-660665ac22f6"   #随机id</span><br><span class="line">DEVICE="ens33"   #接口名（设备,网卡）</span><br><span class="line">ONBOOT="yes"   #系统启动的时候网络接口是否有效（yes/no）</span><br><span class="line"><span class="meta">#</span><span class="bash">IP地址</span></span><br><span class="line">IPADDR=192.168.202.100  </span><br><span class="line"><span class="meta">#</span><span class="bash">网关  </span></span><br><span class="line">GATEWAY=192.168.202.2      </span><br><span class="line"><span class="meta">#</span><span class="bash">域名解析器</span></span><br><span class="line">DNS1=192.168.202.2</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li>执行service network restart 重启网络</li>
</ol>
<h4 id="3-2-配置主机名"><a href="#3-2-配置主机名" class="headerlink" title="3.2 配置主机名"></a>3.2 配置主机名</h4><h5 id="3-2-1-修改主机名称"><a href="#3-2-1-修改主机名称" class="headerlink" title="3.2.1 修改主机名称"></a>3.2.1 修改主机名称</h5><ol>
<li><p>基本语法</p>
<p>hostname （功能描述：查看当前服务器的主机名称）</p>
</li>
<li><p>案例实操</p>
<p>（1） 查看当前服务器主机名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop100 ~]# hostname</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   （2）如果感觉此主机名不合适，可以通过编辑/etc/hostname文件进行修改</p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop100 ~]# vim /etc/hostname</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-修改hosts映射文件"><a href="#3-2-2-修改hosts映射文件" class="headerlink" title="3.2.2 修改hosts映射文件"></a>3.2.2 修改hosts映射文件</h5><ol>
<li><p>修改linux的主机映射文件（hosts文件）后续在hadoop阶段，虚拟机会比较多，配置时通常会采用主机名的方式配置。 比较简单方便。不用刻意记地址。</p>
<p>vim打开/etc/hosts ，添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.202.100 hadoop100</span><br><span class="line">192.168.202.101 hadoop101</span><br><span class="line">192.168.202.102 hadoop102</span><br><span class="line">192.168.202.103 hadoop103</span><br><span class="line">192.168.202.104 hadoop104</span><br><span class="line">192.168.202.105 hadoop105</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>重启设备，查看主机名，已经修改成功</p>
<h4 id="3-3-关闭防火墙"><a href="#3-3-关闭防火墙" class="headerlink" title="3.3 关闭防火墙"></a>3.3 关闭防火墙</h4></li>
</ol>
<h4 id="3-4-关机重启命令"><a href="#3-4-关机重启命令" class="headerlink" title="3.4 关机重启命令"></a>3.4 关机重启命令</h4><h3 id="4-远程登录"><a href="#4-远程登录" class="headerlink" title="4. 远程登录"></a>4. 远程登录</h3><h3 id="5-常用基本命令"><a href="#5-常用基本命令" class="headerlink" title="5. 常用基本命令"></a>5. 常用基本命令</h3><h4 id="5-1-帮助命令"><a href="#5-1-帮助命令" class="headerlink" title="5.1 帮助命令"></a>5.1 帮助命令</h4><h5 id="5-1-1-man获得帮助信息"><a href="#5-1-1-man获得帮助信息" class="headerlink" title="5.1.1 man获得帮助信息"></a>5.1.1 man获得帮助信息</h5><p>1.基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man[命令或配置文件] （功能描述：获得帮助信息）</span><br></pre></td></tr></table></figure>

<p>2.显示说明</p>
<table>
<thead>
<tr>
<th>信息</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>NAME</td>
<td>命令的名称和单行描述</td>
</tr>
<tr>
<td>SYNOPSIS</td>
<td>怎样使用命令</td>
</tr>
<tr>
<td>DESCRIPTION</td>
<td>命令功能的深入讨论</td>
</tr>
<tr>
<td>EXAMPLES</td>
<td>怎样使用命令的例子</td>
</tr>
<tr>
<td>SEE ALSO</td>
<td>相关主题（通常是手册页）</td>
</tr>
</tbody></table>
<p>3.案例实操</p>
<p>（1）查看ls命令的帮助信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# man ls</span><br></pre></td></tr></table></figure>

<h5 id="5-1-2-help获得shell内置命令的帮助信息"><a href="#5-1-2-help获得shell内置命令的帮助信息" class="headerlink" title="5.1.2 help获得shell内置命令的帮助信息"></a>5.1.2 help获得shell内置命令的帮助信息</h5><p>1.基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help 命令  （功能描述：获得shell内置命令的帮助信息）</span><br></pre></td></tr></table></figure>

<p>2.案例实操</p>
<p>（1）查看cd命令的帮助信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# help cd</span><br></pre></td></tr></table></figure>

<h5 id="5-1-3-常用快捷键"><a href="#5-1-3-常用快捷键" class="headerlink" title="5.1.3 常用快捷键"></a>5.1.3 常用快捷键</h5><table>
<thead>
<tr>
<th>常用快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>ctrl+c</td>
<td>停止进程</td>
</tr>
<tr>
<td>ctrl+l</td>
<td>清屏；彻底清屏是：reset</td>
</tr>
<tr>
<td>ctrl+q</td>
<td>退出</td>
</tr>
<tr>
<td>tab键</td>
<td>提示，自动补全</td>
</tr>
<tr>
<td>上下键</td>
<td>查找执行过的命令</td>
</tr>
<tr>
<td>ctrl+alt</td>
<td>linux和Windows之间的切换</td>
</tr>
</tbody></table>
<h4 id="5-2-文件目录类"><a href="#5-2-文件目录类" class="headerlink" title="5.2 文件目录类"></a>5.2 文件目录类</h4><h5 id="5-2-1-pwd-显示当前工作目录的绝对路径"><a href="#5-2-1-pwd-显示当前工作目录的绝对路径" class="headerlink" title="5.2.1 pwd 显示当前工作目录的绝对路径"></a>5.2.1 pwd 显示当前工作目录的绝对路径</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwd:print working directory </span><br><span class="line">1.基本语法</span><br><span class="line">[root@hadoop101~]# pwd</span><br><span class="line">&#x2F;root</span><br></pre></td></tr></table></figure>

<h5 id="5-2-2-ls列出目录的内容"><a href="#5-2-2-ls列出目录的内容" class="headerlink" title="5.2.2 ls列出目录的内容"></a>5.2.2 ls列出目录的内容</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls: list 列出目录内容</span><br></pre></td></tr></table></figure>

<ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls [选项][目录或是文件]</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>全部的文件，连同隐藏（开头为.的文件）一起类出来（常用）</td>
</tr>
<tr>
<td>-l</td>
<td>长数据串列出，包含文件的属性与权限等等详细信息；可简写为ll</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>显示说明</p>
<p>每行列出的信息依次是： 文件类型与权限 链接数 文件属主 文件属组 文件大小用byte来表示 建立或最近修改的时间 名字 </p>
</li>
<li><p>案例实操</p>
<p>（1）查看当前目录的所有内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# ls -al</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="5-2-3-cd-切换目录"><a href="#5-2-3-cd-切换目录" class="headerlink" title="5.2.3 cd 切换目录"></a>5.2.3 cd 切换目录</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd: change directory</span><br></pre></td></tr></table></figure>

<ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd [参数]</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>参数说明</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>cd 绝对路径</td>
<td>切换路径</td>
</tr>
<tr>
<td>cd 相对路径</td>
<td>切换路径</td>
</tr>
<tr>
<td>cd ~或者cd</td>
<td>回到自己家目录</td>
</tr>
<tr>
<td>cd -</td>
<td>回到上一次所在目录</td>
</tr>
<tr>
<td>cd ..</td>
<td>回到当前目录的上一级目录</td>
</tr>
<tr>
<td>cd -p</td>
<td>跳转到实际物理路径，而非快捷方式（软链接）</td>
</tr>
</tbody></table>
</li>
<li><p>案例实操</p>
<p>（1）使用绝对路径切换到root目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# cd &#x2F;root</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   （2）使用相对路径切换到公共的目录</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# cd 公共的&#x2F;</span><br></pre></td></tr></table></figure>



<p>   （3） 回到自己的家目录，及是/root这个目录</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# cd ~</span><br></pre></td></tr></table></figure>



<p>   （4） cd - 回到上一次目录</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# cd -</span><br></pre></td></tr></table></figure>



<p>   （5） 回到当前目录的上一级目录</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# cd ..</span><br></pre></td></tr></table></figure>

<h5 id="5-2-4-mkdir-创建一个新的目录"><a href="#5-2-4-mkdir-创建一个新的目录" class="headerlink" title="5.2.4 mkdir 创建一个新的目录"></a>5.2.4 mkdir 创建一个新的目录</h5><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir: make directory</span><br><span class="line">mkdir[选项] 要创建的目录</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-p</td>
<td>创建多层目录</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<p>（1）创建一个目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# mkdir xiyou</span><br><span class="line">[root@hadoop101~]# mkdir xiyou&#x2F;minjie</span><br></pre></td></tr></table></figure>

<p>（2）创建一个多级目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# mkdir -p a&#x2F;b&#x2F;c</span><br></pre></td></tr></table></figure>

<h5 id="5-2-5-删除一个空目录"><a href="#5-2-5-删除一个空目录" class="headerlink" title="5.2.5 删除一个空目录"></a>5.2.5 删除一个空目录</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmdir: remove directory</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmdir 要删除的空目录</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# rm dir aa&#x2F;b&#x2F;c</span><br></pre></td></tr></table></figure>

<h5 id="5-2-6-创建空文件"><a href="#5-2-6-创建空文件" class="headerlink" title="5.2.6 创建空文件"></a>5.2.6 创建空文件</h5></li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch 文件名称</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# touch aa&#x2F;b.txt</span><br></pre></td></tr></table></figure>

<h5 id="5-2-7-复制文件或目录"><a href="#5-2-7-复制文件或目录" class="headerlink" title="5.2.7 复制文件或目录"></a>5.2.7 复制文件或目录</h5><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp [选项] source dest (功能描述：复制source文件到dest)</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<pre><code>2. 选项说明

   | 选项 | 功能               |
   | ---- | ------------------ |
   | -r   | 递归复制整个文件夹 |



3. 参数说明

   | 参数   | 功能     |
   | ------ | -------- |
   | source | 源文件   |
   | dest   | 目标文件 |



4. 经验技巧

   强制覆盖不提示的方法：\cp

5. 案例实操

   （1）复制文件

   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# cp aa&#x2F;b.txt aa&#x2F;b&#x2F;</span><br></pre></td></tr></table></figure>

   （2）递归复制整个文件夹

   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# cp -r aa&#x2F; .&#x2F;</span><br></pre></td></tr></table></figure></code></pre><h5 id="5-2-8-删除文件或目录"><a href="#5-2-8-删除文件或目录" class="headerlink" title="5.2.8 删除文件或目录"></a>5.2.8 删除文件或目录</h5><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm [选项] deleteFile (功能描述:递归删除目录中的所有内容)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>递归删除目录中的所有内容</td>
</tr>
<tr>
<td>-f</td>
<td>强制执行删除操作，而不提示用于进行确认</td>
</tr>
<tr>
<td>-v</td>
<td>显示指令的详细执行过程</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<p>（1）删除目录中的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# rm aa&#x2F;b&#x2F;b.txt</span><br></pre></td></tr></table></figure>

<p>（2）递归删除目录中的所有内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# rm -rf aa&#x2F;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-9-移动文件与目录或重命名"><a href="#5-2-9-移动文件与目录或重命名" class="headerlink" title="5.2.9 移动文件与目录或重命名"></a>5.2.9 移动文件与目录或重命名</h5></li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）mv oldNameFile newNameFile (功能描述：重命名)</span><br><span class="line">（2）mv &#x2F;temp&#x2F;movefile &#x2F;targetFolder (功能描述：移动文件)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<p>（1）重命名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# mv test.txt test1.txt</span><br></pre></td></tr></table></figure>



</li>
</ol>
<pre><code>（2）移动文件

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# mv test.txt aa&#x2F;</span><br></pre></td></tr></table></figure></code></pre><h5 id="5-2-10-cat-查看文件内容"><a href="#5-2-10-cat-查看文件内容" class="headerlink" title="5.2.10 cat 查看文件内容"></a>5.2.10 cat 查看文件内容</h5><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat [选项] 要查看的文件</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>-n</td>
<td>显示所有行的行号，包含空行</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>经验技巧</p>
<p>一般查看比较小的文件，一屏幕显示全的</p>
</li>
<li><p>案例实操</p>
<p>（1）查看文件内容并显示行号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# cat -n anaconda-ks.cfg</span><br></pre></td></tr></table></figure>

<h5 id="5-2-11-more-文件内容分屏查看器"><a href="#5-2-11-more-文件内容分屏查看器" class="headerlink" title="5.2.11 more 文件内容分屏查看器"></a>5.2.11 more 文件内容分屏查看器</h5><p>​    more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式显示文本文件的内容。more指令中内置了若干快捷键，详细操作参照说明。</p>
</li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">more 要查看的文件</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>操作说明</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>空白键（space）</td>
<td>代表向下翻一页</td>
</tr>
<tr>
<td>enter</td>
<td>代表向下翻一行</td>
</tr>
<tr>
<td>q</td>
<td>代表立即离开more，不再显示该文件内容</td>
</tr>
<tr>
<td>ctrl+F</td>
<td>向下滚动一屏</td>
</tr>
<tr>
<td>ctrl+B</td>
<td>返回上一屏</td>
</tr>
<tr>
<td>=</td>
<td>输出当前行的行号</td>
</tr>
<tr>
<td>:f</td>
<td>输出文件名和当前行的行号</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# more anaconda-ks.cfg</span><br></pre></td></tr></table></figure>

<h5 id="5-2-12-less分屏显示文件内容"><a href="#5-2-12-less分屏显示文件内容" class="headerlink" title="5.2.12 less分屏显示文件内容"></a>5.2.12 less分屏显示文件内容</h5><p>​    less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</p>
</li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less 要查看的文件</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>操作说明</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>空白键</td>
<td>向下翻动一页</td>
</tr>
<tr>
<td>pagedown</td>
<td>向下翻动一页</td>
</tr>
<tr>
<td>pageup</td>
<td>向上翻动一页</td>
</tr>
<tr>
<td>/字串</td>
<td>向下搜寻[字串]的功能：n:向下查找  N:向上查找</td>
</tr>
<tr>
<td>?字串</td>
<td>向上搜寻[字串]的功能：n:向上查找  N:向下查找</td>
</tr>
<tr>
<td>q</td>
<td>退出less查看</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>经验技巧</p>
<p>用secureCRT时pagedown和pageup可能会出现无法识别的问题</p>
</li>
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 ~]# less anaconda-ks.cfg</span><br></pre></td></tr></table></figure>

<h5 id="5-2-13-echo"><a href="#5-2-13-echo" class="headerlink" title="5.2.13 echo"></a>5.2.13 echo</h5><p>echo 输出内容到控制台</p>
</li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo [选项] [输出内容]</span><br></pre></td></tr></table></figure>

<p>​    选项： -e 支持反斜线控制的字符转换</p>
<table>
<thead>
<tr>
<th>控制字符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>输出\本身</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>制表符</td>
</tr>
</tbody></table>
</li>
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 ~]# echo &quot;hello\tworld&quot;</span><br><span class="line">hello\tworld</span><br><span class="line">[root@hadoop101 ~]# echo -e &quot;hello\tworld&quot;</span><br><span class="line">hello	world</span><br></pre></td></tr></table></figure>

<h5 id="5-2-14-head-显示文件头部内容"><a href="#5-2-14-head-显示文件头部内容" class="headerlink" title="5.2.14 head 显示文件头部内容"></a>5.2.14 head 显示文件头部内容</h5><p>​    head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容</p>
</li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head 文件 （功能描述：查看文件头10行内容）</span><br><span class="line">head -n 5 文件（功能描述：查看文件头5行内容）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-n&lt;行数&gt;</td>
<td>指定显示文件头部内容的行数</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 ~]# head -n 2 a.txt</span><br></pre></td></tr></table></figure>

<h5 id="5-2-15-tail输出文件尾部内容"><a href="#5-2-15-tail输出文件尾部内容" class="headerlink" title="5.2.15 tail输出文件尾部内容"></a>5.2.15 tail输出文件尾部内容</h5><p>​    tail用于输出文件中尾部的内容，默认情况下tail指令显示文件的后10行内容</p>
</li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）tail 文件  （功能描述：查看文件尾部10行内容）</span><br><span class="line">（2）tail -n 5 文件  （功能描述：查看文件尾部5行内容）</span><br><span class="line">（3）tail -f 文件  （功能描述：实时追踪该文档的所有更新，常用于查看日志日志文件的更新）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-n&lt;行数&gt;</td>
<td>输出文件尾部n行内容</td>
</tr>
<tr>
<td>-f</td>
<td>显示文件最新追加的内容，监视文件的变化</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）查看文件尾1行内容</span><br><span class="line">[root@hadoop101 ~]# tail -n b.txt</span><br><span class="line">（2）实时追踪该档的所有更新</span><br><span class="line">[root@hadoop101 ~]# tail -f b.txt</span><br></pre></td></tr></table></figure>

<h5 id="5-2-16-gt-输出重定向和-gt-gt-追加"><a href="#5-2-16-gt-输出重定向和-gt-gt-追加" class="headerlink" title="5.2.16 &gt; 输出重定向和 &gt;&gt; 追加"></a>5.2.16 &gt; 输出重定向和 &gt;&gt; 追加</h5></li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   （1） ls -l &gt; 文件 （功能描述：列表的内容写入文件中覆盖写）</span><br><span class="line">（2） ls al &gt;&gt; 文件 （功能描述：列表的内容追加到文件的末尾）</span><br><span class="line">   （3） cat 文件1 &gt; 文件2 （功能描述：将文件1的内容覆盖到文件2中）</span><br><span class="line">（4） echo &quot;内容&quot; &gt;&gt; 文件 （将指定内容追加到文件中）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）将ls查看信息写入到文件中</span><br><span class="line">[root@hadoop101 ~]# ls -l&gt;houge.txt</span><br><span class="line">（2）将ls查看信息追加到文件中</span><br><span class="line">[root@hadoop101 ~]# ls -l&gt;&gt;houge.txt</span><br><span class="line">（3）采用echo将hello单词追加到文件中</span><br><span class="line">[root@hadoop101 ~]# echo hello&gt;&gt;houge.txt</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="5-2-17-In-软链接"><a href="#5-2-17-In-软链接" class="headerlink" title="5.2.17 In 软链接"></a>5.2.17 In 软链接</h5><p>   ​    软链接也称为符号链接，类似于Windows里的快捷方式，有自己的数据库，主要存放了链接其它文件的路径</p>
<ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s [原文件或目录][软链接名]  （功能描述：给原文件创建一个软链接）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>经验技巧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">删除软链接：rm -rf 软链接名，而不是rm -rf 软链接名&#x2F;</span><br><span class="line">查询：通过ll就可以查看，列表属性第1位时1，尾部会有位置指向</span><br></pre></td></tr></table></figure>





</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）创建软链接</span><br><span class="line">[root@hadoop101 ~]# mv text.txt ab&#x2F;b&#x2F;</span><br><span class="line">[root@hadoop101 ~]# ln -s ab&#x2F;b&#x2F;text.txt .&#x2F;lianjie</span><br><span class="line">（2） 删除软链接</span><br><span class="line">[root@hadoop101 ~]# rm -rf lianjie</span><br><span class="line">（3） 进入软链接实际物理路径</span><br><span class="line">[root@hadoop101 ~]# ln -s ab&#x2F;b&#x2F;text.txt .&#x2F;lianjie</span><br><span class="line">[root@hadoop101 ~]# cd -P lianjie&#x2F;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="5-2-18-history-查看已经执行过的历史命令"><a href="#5-2-18-history-查看已经执行过的历史命令" class="headerlink" title="5.2.18 history 查看已经执行过的历史命令"></a>5.2.18 history 查看已经执行过的历史命令</h5><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">history （功能描述：查看已经执行过的历史命令）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）查看已经指令过的历史命令</span><br><span class="line">[root@hadoop101 ~]# history</span><br></pre></td></tr></table></figure>

<h4 id="5-3-时间日期类"><a href="#5-3-时间日期类" class="headerlink" title="5.3 时间日期类"></a>5.3 时间日期类</h4></li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date [option]...[+format]</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-d&lt;时间字符串&gt;</td>
<td>显示指定的“时间字符串”表示的时间，而非当前时间</td>
</tr>
<tr>
<td>-s&lt;日期时间&gt;</td>
<td>设置系统日期时间</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>参数说明</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;+日期时间格式&gt;</td>
<td>指定显示时使用的日期时间格式</td>
</tr>
</tbody></table>
<h4 id="5-3-1-date显示当前时间"><a href="#5-3-1-date显示当前时间" class="headerlink" title="5.3.1 date显示当前时间"></a>5.3.1 date显示当前时间</h4></li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）date  （功能描述：显示当前时间）</span><br><span class="line">（2）date+%Y （功能描述：显示当前月份）</span><br><span class="line">（3）date+%m （功能描述：显示当前月份）</span><br><span class="line">（4）date+%d （功能描述：显示当前是哪一天）</span><br><span class="line">（5）date&quot;+%Y-%m-%d%H:%M:%S&quot; （功能描述：显示年月日时分秒）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）显示当前时间信息</span><br><span class="line">[root@hadoop101~]# date</span><br><span class="line">（2）显示当前时间年月日</span><br><span class="line">[root@hadoop101~]# date +%Y%m%d</span><br><span class="line">（3）显示当前年月日时分秒</span><br><span class="line">[root@hadoop101~]# date &quot;+%Y-%m-%d %H:%M:%S&quot;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-2-date-显示非当前时间"><a href="#5-3-2-date-显示非当前时间" class="headerlink" title="5.3.2 date 显示非当前时间"></a>5.3.2 date 显示非当前时间</h5></li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）date -d &#39;1 days ago&#39; （功能描述：显示其前一天时间）</span><br><span class="line">（2）date -d &#39;-1 days ago&#39; （功能描述：显示明天时间）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# date -d &#39;1 days ago&#39;</span><br><span class="line">[root@hadoop101~]# date -d &#39;-1 days ago&#39;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-4-查看日历"><a href="#5-3-4-查看日历" class="headerlink" title="5.3.4 查看日历"></a>5.3.4 查看日历</h5></li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cal [选项] （功能描述：不加选项，显示本月日历）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>具体某一年</td>
<td>显示这一年的日历</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）查看当前月的日历</span><br><span class="line">[root@hadoop101~]# cal</span><br><span class="line">（2）查看2017年的日历</span><br><span class="line">[root@hadoop101~]# cal 2020</span><br></pre></td></tr></table></figure>

<h4 id="5-4-用户管理命令"><a href="#5-4-用户管理命令" class="headerlink" title="5.4 用户管理命令"></a>5.4 用户管理命令</h4><h5 id="5-4-1-useraddd-添加新用户"><a href="#5-4-1-useraddd-添加新用户" class="headerlink" title="5.4.1 useraddd 添加新用户"></a>5.4.1 useraddd 添加新用户</h5></li>
<li><p>基本用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd 用户名  （功能描述：添加新用户）</span><br><span class="line">useradd -g 组名 用户名  （功能描述： 添加新用户到某个组）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）添加一个用户</span><br><span class="line">[root@hadoop101~]# useradd lisi</span><br><span class="line">[root@hadoop101~]# ll &#x2F;home&#x2F;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="5-4-2-passwd-设置用户密码"><a href="#5-4-2-passwd-设置用户密码" class="headerlink" title="5.4.2 passwd 设置用户密码"></a>5.4.2 passwd 设置用户密码</h5><ol>
<li><p>基本用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd 用户名  （功能描述：设置用户密码）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）设置用户的密码</span><br><span class="line">[root@hadoop101~]# passwd lisi</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="5-4-3-id-查看用户是否存在"><a href="#5-4-3-id-查看用户是否存在" class="headerlink" title="5.4.3 id 查看用户是否存在"></a>5.4.3 id 查看用户是否存在</h5><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id 用户名</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# id lisi</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="5-4-4-cat-etc-passwd-查看创建了哪些用户"><a href="#5-4-4-cat-etc-passwd-查看创建了哪些用户" class="headerlink" title="5.4.4 cat /etc/passwd 查看创建了哪些用户"></a>5.4.4 cat /etc/passwd 查看创建了哪些用户</h5><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# cat &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="5-4-5-su-切换用户"><a href="#5-4-5-su-切换用户" class="headerlink" title="5.4.5 su 切换用户"></a>5.4.5 su 切换用户</h5><pre><code>su : switch user</code></pre><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su 用户名称  （功能描述：切换用户，只能获得用户的执行权限，不能获得环境变量）</span><br><span class="line">su - 用户名称  （功能描述：切换到用户并获得该用户的环境变量及执行权限）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）切换用户</span><br><span class="line">[root@hadoop101~]# su lisi</span><br><span class="line">[root@hadoop101~]# echo $PATH</span><br><span class="line">[root@hadoop101~]# su - lisi</span><br><span class="line">[root@hadoop101~]# echo $PATH</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="5-4-6-userdel-删除用户"><a href="#5-4-6-userdel-删除用户" class="headerlink" title="5.4.6 userdel 删除用户"></a>5.4.6 userdel 删除用户</h5><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）userdel 用户名  （功能描述：删除用户但保存主目录）</span><br><span class="line">（2）userdel -r 用户名 （功能描述：删除用户并且删除与用户相关的所有文件）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>删除用户的同时，删除和用户相关的所有文件</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）删除用户但保存其用户主目录</span><br><span class="line">[root@hadoop101~]# userdel lisi</span><br><span class="line">[root@hadoop101~]# ll &#x2F;home&#x2F;</span><br><span class="line">（2）删除用户和用户主目录，都删除</span><br><span class="line">[root@hadoop101~]# userdel -r atguigu</span><br><span class="line">[root@hadoop101~]# ll &#x2F;home&#x2F;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="5-4-7-who-查看登录用户信息"><a href="#5-4-7-who-查看登录用户信息" class="headerlink" title="5.4.7 who 查看登录用户信息"></a>5.4.7 who 查看登录用户信息</h5><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）whoami  （功能描述：显示自身用户名称）</span><br><span class="line">（2）who am i  （功能描述：显示登录用户的用户名）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# whoami</span><br><span class="line">[root@hadoop101~]# who am i</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="5-4-8-sudo-设置普通用户具有root权限"><a href="#5-4-8-sudo-设置普通用户具有root权限" class="headerlink" title="5.4.8 sudo 设置普通用户具有root权限"></a>5.4.8 sudo 设置普通用户具有root权限</h5><ol>
<li><p>添加atguigu用户，并对其设置密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# useradd atguigu</span><br><span class="line">[root@hadoop101~]# passwd atguigu</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>修改配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# vim /etc/sudoers</span><br><span class="line">修改/etc/sudoers文件，找到下面一行（91行），在root下面添加一行，如下所示</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Allow root to run any commands anywhere</span></span></span><br><span class="line">root ALL=(ALL) ALL</span><br><span class="line">atguigu ALL=(ALL) ALL</span><br><span class="line">或者配置成采用sudo命令时，不需要输入密码</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Allow root to run any commands anywhere</span></span></span><br><span class="line">root      ALL=(ALL)     ALL</span><br><span class="line">atguigu   ALL=(ALL)     NOPASSWD:ALL</span><br><span class="line"></span><br><span class="line">修改完毕，现在可以用atguigu帐号登录，然后用命令 sudo ，即可获得root权限进行操作。</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）用普通用户在&#x2F;opt目录下创建一个文件夹</span><br><span class="line">[atguigu@hadoop101 opt]$ sudo mkdir module</span><br><span class="line">[root@hadoop101 opt]# chown atguigu:atguigu module&#x2F;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="5-4-9-usermod-修改用户"><a href="#5-4-9-usermod-修改用户" class="headerlink" title="5.4.9 usermod 修改用户"></a>5.4.9 usermod 修改用户</h5><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod -g 用户组 用户名</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-g</td>
<td>修改用户的初始登录组，给定的组必须存在。默认组id是1</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<p>（1）将用户加入到用户组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop100 opt]# usermod -g root zhangsan</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="5-5-用户组管理命令"><a href="#5-5-用户组管理命令" class="headerlink" title="5.5 用户组管理命令"></a>5.5 用户组管理命令</h4>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux系统对用户组的规定有所不同。</span><br><span class="line">如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</span><br><span class="line">用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对&#x2F;etc&#x2F;group文件更新。</span><br></pre></td></tr></table></figure>

<h5 id="5-5-1-groupadd-新增组"><a href="#5-5-1-groupadd-新增组" class="headerlink" title="5.5.1 groupadd 新增组"></a>5.5.1 groupadd 新增组</h5><h5 id="5-5-2-groupdel-删除组"><a href="#5-5-2-groupdel-删除组" class="headerlink" title="5.5.2 groupdel 删除组"></a>5.5.2 groupdel 删除组</h5><h5 id="5-5-3-groupmod-修改组"><a href="#5-5-3-groupmod-修改组" class="headerlink" title="5.5.3 groupmod 修改组"></a>5.5.3 groupmod 修改组</h5><h4 id="5-6-文件权限类"><a href="#5-6-文件权限类" class="headerlink" title="5.6 文件权限类"></a>5.6 文件权限类</h4><h4 id="5-7-搜索查找类"><a href="#5-7-搜索查找类" class="headerlink" title="5.7 搜索查找类"></a>5.7 搜索查找类</h4><h4 id="5-8-压缩和解压类"><a href="#5-8-压缩和解压类" class="headerlink" title="5.8 压缩和解压类"></a>5.8 压缩和解压类</h4><h4 id="5-9-磁盘分区类"><a href="#5-9-磁盘分区类" class="headerlink" title="5.9 磁盘分区类"></a>5.9 磁盘分区类</h4><h4 id="5-10-进程线程类"><a href="#5-10-进程线程类" class="headerlink" title="5.10 进程线程类"></a>5.10 进程线程类</h4><h4 id="5-11-crontab-系统定时任务"><a href="#5-11-crontab-系统定时任务" class="headerlink" title="5.11 crontab 系统定时任务"></a>5.11 crontab 系统定时任务</h4><h3 id="6-软件包管理"><a href="#6-软件包管理" class="headerlink" title="6. 软件包管理"></a>6. 软件包管理</h3><h4 id="6-1-RPM"><a href="#6-1-RPM" class="headerlink" title="6.1 RPM"></a>6.1 RPM</h4><h5 id="6-1-1-RPM-概述"><a href="#6-1-1-RPM-概述" class="headerlink" title="6.1.1 RPM 概述"></a>6.1.1 RPM 概述</h5><p>   ​    RPM（RedHat Package Manager）,RedHat软件包管理工具，类似Windows里面的setup.exe是Linux这系列操作系统里面的打包安装工具，它虽然是RedHat的标志，但理念是通用的。</p>
<p>   ​    RPM包的名称格式</p>
<p>   ​    Apache-1.3.23-11.i386.rpm</p>
<pre><code>&quot;apache&quot;    软件名称</code></pre><p>   ​            “1.3.23-11”    软件的版本号，主版本和子版本</p>
<p>   ​            “i386”    是软件所运行的硬件平台，Intel32位微处理器的统称</p>
<p>   ​            “rpm”    文件扩展名，代表RPM包</p>
<p>   ​    </p>
<h5 id="6-1-2-RPM查询命令（rpm-qa）"><a href="#6-1-2-RPM查询命令（rpm-qa）" class="headerlink" title="6.1.2 RPM查询命令（rpm -qa）"></a>6.1.2 RPM查询命令（rpm -qa）</h5><ol>
<li><p>基本语法    （功能描述：查询所安装的所有rpm软件包）</p>
</li>
<li><p>经验技巧</p>
<p>由于软件包比较多，一般都会采取过滤。rpm -qa | grep rpm软件包</p>
</li>
<li><p>案例实操</p>
<p>（1）查询firefox软件安装情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 Packages]# rpm -qa | grep firefox</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="6-1-3-RPM卸载命令-rpm-e"><a href="#6-1-3-RPM卸载命令-rpm-e" class="headerlink" title="6.1.3 RPM卸载命令(rpm -e)"></a>6.1.3 RPM卸载命令(rpm -e)</h5><ol>
<li><p>基本语法</p>
<p>（1）rpm -e RPM软件包</p>
<p>（2）rpm -e –nodeps 软件包</p>
</li>
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-e</td>
<td>卸载软件包</td>
</tr>
<tr>
<td>–nodeps</td>
<td>卸载软件时，不检查依赖。这样的话，那样使用该软件包的软件在此之后可能就不能正常工作了</td>
</tr>
</tbody></table>
</li>
<li><p>案例实操</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop100 Packages]# rpm -e firefox</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="6-1-4RPM安装命令（rpm-ivh）"><a href="#6-1-4RPM安装命令（rpm-ivh）" class="headerlink" title="6.1.4RPM安装命令（rpm -ivh）"></a>6.1.4RPM安装命令（rpm -ivh）</h5><ol>
<li><p>基本语法</p>
<p>rpm -ivh RPM 包全名</p>
</li>
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-i</td>
<td>-i=install 安装</td>
</tr>
<tr>
<td>-v</td>
<td>-v=verbose显示详细信</td>
</tr>
<tr>
<td>-h</td>
<td>-h=hash进度条</td>
</tr>
<tr>
<td>–nodeps</td>
<td>–nodeps不检测依赖进度</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<p>（1）安装Firefox软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 ~]# pwd</span><br><span class="line">[root@hadoop101 ~]# rpm -ivh firefox-45.0.1-1.el6.centos.x86_64.rpm</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="6-2-YUM仓库配置"><a href="#6-2-YUM仓库配置" class="headerlink" title="6.2 YUM仓库配置"></a>6.2 YUM仓库配置</h4><h5 id="6-2-1-YUM概述"><a href="#6-2-1-YUM概述" class="headerlink" title="6.2.1 YUM概述"></a>6.2.1 YUM概述</h5><p>   ​         YUM（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装  。类似Java中的maven工具。</p>
<h5 id="6-2-2-YUM的常用命令"><a href="#6-2-2-YUM的常用命令" class="headerlink" title="6.2.2 YUM的常用命令"></a>6.2.2 YUM的常用命令</h5><ol>
<li><p>基本语法</p>
<p>yum [选项] [参数]</p>
</li>
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-y</td>
<td>对所有提问都回答“yes”</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>参数说明</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>install</td>
<td>安装rpm软件包</td>
</tr>
<tr>
<td>update</td>
<td>更新rpm软件包</td>
</tr>
<tr>
<td>check-update</td>
<td>检查是否有可用的更新rpm软件包</td>
</tr>
<tr>
<td>remove</td>
<td>删除指定的rpm软件包</td>
</tr>
<tr>
<td>list</td>
<td>显示软件包信息</td>
</tr>
<tr>
<td>clean</td>
<td>清理yum过期的缓存</td>
</tr>
<tr>
<td>deplist</td>
<td>显示yum软件包的所有依赖关系</td>
</tr>
</tbody></table>
<h4 id="4-案例实操"><a href="#4-案例实操" class="headerlink" title="4. 案例实操"></a>4. 案例实操</h4><p>（1）采用yum方式安装Firefox</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop100~]#yum -y install firefox.86_64</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="6-2-3-修改网络YUM源"><a href="#6-2-3-修改网络YUM源" class="headerlink" title="6.2.3 修改网络YUM源"></a>6.2.3 修改网络YUM源</h5><h3 id="7-克隆虚拟机"><a href="#7-克隆虚拟机" class="headerlink" title="7. 克隆虚拟机"></a>7. 克隆虚拟机</h3>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>maven介绍</title>
    <url>/2020/05/04/maven%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="1-什么是maven"><a href="#1-什么是maven" class="headerlink" title="1.什么是maven"></a>1.什么是maven</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maven是一款自动化构建工具，专注服务于Java平台的项目构建和依赖管理。</span><br><span class="line">构建：构建就是以我们编写的Java代码，框架配置文件，国际化等其它资源文件，jsp页面和图片等静态资源作为原材料，去生成出一个可以运行的项目的过程。</span><br><span class="line">构建的环节：</span><br><span class="line">1）clean：删除以前的编译结果，为重新编译做准备</span><br><span class="line">2）compile：将Java源程序编译为字节码文件</span><br><span class="line">3）test：针对项目中的关键点进行测试，确保项目在开发过程中关键部分的正确性</span><br><span class="line">4）report：在每一次测试后以标准的格式记录和展示测试结果</span><br><span class="line">5）package：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java工程对应Jar包，web工程对应war包</span><br><span class="line">5）install：在Maven环境下特指将打包的结果--jar包或war包安装到本地仓库中</span><br><span class="line">6）deploy：将打包的结果部署到远程仓库或将war包部署到服务器上运行</span><br></pre></td></tr></table></figure>



<h3 id="2-为什么要用maven"><a href="#2-为什么要用maven" class="headerlink" title="2.为什么要用maven"></a>2.为什么要用maven</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）使用maven后每个jar包只在本地仓库中保存一份，需要jar包的工程只需要维持一个jar包的坐标引用，不用像传统方式那样每个项目中都需要导入jar包</span><br><span class="line">2）maven会自动导入我们所需jar包的依赖jar包，自动管理jar包间的依赖关系</span><br><span class="line">3）会自动处理jar包间的冲突，解决冲突的依赖原则：1.最短路径优先 2.路径相同则先生命者优先</span><br><span class="line">4）可实现项目的分布式部署</span><br></pre></td></tr></table></figure>



<h3 id="3-maven的安装"><a href="#3-maven的安装" class="headerlink" title="3.maven的安装"></a>3.maven的安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）maven是使用Java开发的，首先检查是否配置JAVA_HOME环境变量</span><br><span class="line">2）解压maven的核心程序，如将apache-maven-3.5.4-bin.zip解压到非中文无空格的目录下</span><br><span class="line">3）配置环境变量，MAVEN_HOME和path</span><br><span class="line">4）使用mvn -v 命令检查安装是否正确</span><br></pre></td></tr></table></figure>

<h3 id="4-maven工程的目录结构-Hello项目为例"><a href="#4-maven工程的目录结构-Hello项目为例" class="headerlink" title="4. maven工程的目录结构(Hello项目为例)"></a>4. maven工程的目录结构(Hello项目为例)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line">	src</span><br><span class="line">	--main</span><br><span class="line">	----java</span><br><span class="line">	----resouces</span><br><span class="line">	--test</span><br><span class="line">	----java</span><br><span class="line">	----resources</span><br><span class="line">	pom.xml</span><br></pre></td></tr></table></figure>

<h3 id="5-配置本地仓库"><a href="#5-配置本地仓库" class="headerlink" title="5.配置本地仓库"></a>5.配置本地仓库</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">	maven的核心程序并不包含具体功能，仅负责宏观调度。具体功能由插件来完成。maven核心程序会到本地仓库中查找插件。如果本地仓库中没有就会从远程中央仓库下载。此时如果不能上网则无法执行maven的具体功能。为了解决这个问题，我们可以将maven的本地仓库指向一个在联网情况下下载好的目录。</span><br><span class="line">	maven默认的本地仓库：~\.m2\repository目录，~表示当前用户的家目录</span><br><span class="line">	<span class="number">1</span>.设置本地仓库：找到maven的核心配置文件conf目录下的settings.xml文件，配置本地仓库的位置</span><br><span class="line">&lt;localRepository&gt;准备好的仓库位置，如E:\localRepo&lt;/localRepositroy&gt;</span><br><span class="line">	<span class="number">2</span>.默认的中央仓库在国外，为了以后下载jar包方便，配置阿里云镜像</span><br><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line">    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">    &lt;name&gt;Nexus aliyun&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http:<span class="comment">//maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span></span><br><span class="line">&lt;/mirror&gt;</span><br><span class="line">	<span class="number">3</span>.修改maven编译的版本</span><br><span class="line">&lt;profile&gt;</span><br><span class="line">  &lt;id&gt;jdk-1.8&lt;/id&gt;</span><br><span class="line">  &lt;activation&gt;</span><br><span class="line">	&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">	&lt;jdk&gt;1.8&lt;/jdk&gt;</span><br><span class="line">  &lt;/activation&gt;</span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">	  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">	  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">	  &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line">&lt;/profile&gt;</span><br></pre></td></tr></table></figure>





<h3 id="5-在idea中使用maven"><a href="#5-在idea中使用maven" class="headerlink" title="5.在idea中使用maven"></a>5.在idea中使用maven</h3><h3 id="6-maven的核心概念"><a href="#6-maven的核心概念" class="headerlink" title="6.maven的核心概念"></a>6.maven的核心概念</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）pom</span><br><span class="line">	Project Object Model：项目对象模型。将Java工程的相关信息封装为对象作为便于操作和管理的模型</span><br><span class="line"><span class="number">2</span>）约定的目录结构</span><br><span class="line">	约定&gt;配置&gt;编码。意思就是能用配置解决的问题就不编码，能基于约定的就不进行配置。而maven正是因为指定了文件保存的目录才能对我们的Java工程进行自动化构建</span><br><span class="line"><span class="number">3</span>）坐标</span><br><span class="line">	使用以下<span class="number">3</span>个变量在Maven的仓库中唯一确定一个maven工程</span><br><span class="line">	groupId: 公司或组织的域名倒序+项目名称</span><br><span class="line">	artifactId: 当前项目的模块名称</span><br><span class="line">	version: 当前模块的版本</span><br><span class="line">	如：</span><br><span class="line">	&lt;groupId&gt;com.atguigui.maven&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;Hello&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.1.0SNAPSHOT&lt;/version&gt;</span><br><span class="line">	如何通过坐标到仓库中查找jar包？</span><br><span class="line">	首先将gav三个变量连接起来 com.atgugui.maven + Hello + <span class="number">1.1</span><span class="number">.0</span>SNAPSHOT，然后以连接字来的字符串作为目录结构到仓库中查找com/atguigu/maven/Hello-<span class="number">1.1</span><span class="number">.1</span>SNAPSHOT.jar。需要注意的是我们自己的maven工程必须执行安装操作才会进入仓库,安装命令是mvn install。</span><br><span class="line"><span class="number">4</span>）依赖</span><br><span class="line">	依赖的范围：compile,test,provided,其它的如runtime,<span class="keyword">import</span>,system等，主要是前面<span class="number">3</span>个比较常用</span><br><span class="line">compile: main目录下的家java代码可以访问这个范围的依赖;test目录下的Java代码可以访问这个范围的依赖；由于主程序需要用到这个依赖，所以需要将这个依赖部署到Tomcat服务器上运行时的WEB-INF的lib目录下	 	d</span><br><span class="line">test: main目录下的Java代码不能访问这个范围的依赖；test目录下的Java代码可以访问这个范围的依赖；因为这个依赖仅仅是用于测试，所以不需要部署到Tomcat服务器上的WEB-INF的lib目录下</span><br><span class="line">provided: main目录下的代码可以访问这个范围的依赖；test目录下的Java代码可以访问这个范围的依赖；部署到tomcat服务器上运行时不会放在WEB-INF的lib目录下，因为服务器上会提供</span><br><span class="line">	依赖的传递性：compile依赖范围的jar包是具有依赖的传递性的</span><br><span class="line">	依赖的排除：有的时候为了确保程序正确可以将可能重复的间接依赖排除，示例代码如下</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;OurFriends&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--依赖排除--&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">	依赖jar包版本的统一管理：示例代码如下</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;spring.version&gt;4.0.0.RELEASE&lt;/spring.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"><span class="number">5</span>）仓库</span><br><span class="line">    本地仓库：为当前本机电脑上的所有maven工程服务</span><br><span class="line">    远程仓库：<span class="number">1</span>.私服：架设在当前局域网环境下，为当前局域网范围内的所有maven工程服务 <span class="number">2</span>.中央仓库：架设在Internet上，为全世界所有maven工程服务 <span class="number">3</span>.中央仓库的镜像：架设在各大洲，为中央仓库分担流量。减轻中央仓库的压力，同时更快响应用户的请求。</span><br><span class="line">    仓库中包含以下文件：maven的插件；我们自己开发的项目模块；第三方框架或工具的jar包</span><br><span class="line"><span class="number">6</span>）生命周期</span><br><span class="line">    maven的生命周期定义了各个构建环节的执行顺序，有了这个清单，maven就可以自动化的构建命令了。</span><br><span class="line">    maven有三套相互独立的生命周期，分别是：</span><br><span class="line">    Clean Lifecycle 在进行真正的构建之前进行一些清理工作</span><br><span class="line">    Default Lifecycle 构建的核心部分：编译，测试，打包，安装，部署等待</span><br><span class="line">    Site Lifecycle 生成项目报告，站点，发布站点</span><br><span class="line">    它们是相互独立的，可以仅仅调用clean来清理工作目录，仅仅调用site来生成站点，当然也可以直接运行mvn clean install site运行所有这三套生命周期。</span><br><span class="line">    </span><br><span class="line">clean生命周期</span><br><span class="line">Clean生命周期一共包含了三个阶段：</span><br><span class="line">	pre-clean 执行一些需要在clean之前完成的工作 </span><br><span class="line">clean 移除所有上一次构建生成的文件 </span><br><span class="line">	post-clean 执行一些需要在clean之后立刻完成的工作 </span><br><span class="line">    </span><br><span class="line">Site生命周期</span><br><span class="line">	pre-site 执行一些需要在生成站点文档之前完成的工作</span><br><span class="line">	site 生成项目的站点文档</span><br><span class="line">	post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</span><br><span class="line">	site-deploy 将生成的站点文档部署到特定的服务器上</span><br><span class="line">这里经常用到的是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能，Manager比较喜欢，文档及统计数据自动生成，很好看。</span><br><span class="line"></span><br><span class="line">Default生命周期</span><br><span class="line">Default生命周期是Maven生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段：</span><br><span class="line">    validate</span><br><span class="line">    generate-sources</span><br><span class="line">    process-sources</span><br><span class="line">    generate-resources</span><br><span class="line">    process-resources 复制并处理资源文件，至目标目录，准备打包。</span><br><span class="line">compile 编译项目的源代码。</span><br><span class="line">    process-classes</span><br><span class="line">    generate-test-sources</span><br><span class="line">    process-test-sources</span><br><span class="line">    generate-test-resources</span><br><span class="line">    process-test-resources 复制并处理资源文件，至目标测试目录。</span><br><span class="line">    </span><br><span class="line">test-compile 编译测试源代码。</span><br><span class="line">	process-test-classes</span><br><span class="line">test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。</span><br><span class="line">	prepare-<span class="keyword">package</span></span><br><span class="line"><span class="keyword">package</span> 接受编译好的代码，打包成可发布的格式，如JAR。</span><br><span class="line">    pre-integration-test</span><br><span class="line">    integration-test</span><br><span class="line">    post-integration-test</span><br><span class="line">    verify</span><br><span class="line">install将包安装至本地仓库，以让其它项目依赖。</span><br><span class="line">deploy将最终的包复制到远程的仓库，以让其它开发人员与项目共享或部署到服务器上运行。</span><br><span class="line"><span class="number">7</span>）插件和目标</span><br><span class="line">	Maven的核心仅仅定义了抽象的生命周期，具体的任务都是交由插件完成的。每个插件都能实现多个功能，每个功能就是一个插件目标。Maven的生命周期与插件目标相互绑定，以完成某个具体的构建任务。</span><br><span class="line">	例如：compile就是插件maven-compiler-plugin的一个功能；pre-clean是插件maven-clean-plugin的一个目标。</span><br><span class="line"><span class="number">8</span>）继承</span><br><span class="line">    由于非compile范围的依赖信息是不能在“依赖链”中传递的，所以有需要的工程只能单独配置。假设此时如果项目需要将各个模块的junit版本统一为<span class="number">4.9</span>，那么到各个工程中手动修改无疑是非常不可取的。使用继承机制就可以将这样的依赖信息统一提取到父工程模块中进行统一管理。</span><br><span class="line">首先，创建父工程</span><br><span class="line">    &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;Parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;!--父工程的打包方式为pom  ,只用于配置的管理,不写任何代码--&gt;</span><br><span class="line">	&lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">	&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">然后，在子工程中引用父工程</span><br><span class="line">  	&lt;!--继承--&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;Parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;!--指定从当前pom.xml文件出发寻找父工程的pom.xml文件的相对路径--&gt;</span><br><span class="line">	&lt;relativePath&gt;../Parent/pom.xml&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt; </span><br><span class="line">此时如果子工程的groupId和version如果和父工程重复则可以删除。</span><br><span class="line">    </span><br><span class="line">在父工程中管理依赖（将Parent项目中的dependencies标签，用dependencyManagement标签括起来）</span><br><span class="line"> &lt;!--依赖管理--&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.0&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;   </span><br><span class="line">在子项目中重新指定需要的依赖，删除范围和版本号</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">    </span><br><span class="line">也可以父模块直接定义依赖，子类直接继承即可，如父类中有以下依赖</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.0&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">子模块直接继承即可</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;Parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;!--指定从当前pom.xml文件出发寻找父工程的pom.xml文件的相对路径--&gt;</span><br><span class="line">&lt;relativePath&gt;../Parent/pom.xml&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt;    </span><br><span class="line"><span class="number">9</span>）聚合</span><br><span class="line">   为什么要使用聚合？</span><br><span class="line">将多个工程拆分为模块后，需要手动逐个安装到仓库后依赖才能够生效。修改源码后也需要逐个手动进行clean操作。而使用了聚合之后就可以批量进行Maven工程的安装、清理工作。</span><br><span class="line">    如何配置聚合？</span><br><span class="line">在总的聚合工程中使用modules/<span class="keyword">module</span>标签组合，指定模块工程的相对路径即可</span><br><span class="line">&lt;!--聚合--&gt;</span><br><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;../MakeFriend&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;../OurFriends&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;../HelloFriend&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;../Hello&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure>

<h3 id="7-maven打包插件"><a href="#7-maven打包插件" class="headerlink" title="7. maven打包插件"></a>7. maven打包插件</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">	Maven本身的打包插件不负责将依赖的jar包一并打包到jar包中，如果项目所依赖的jar包在服务器中没有提供，则运行就会ClassNotFound的各种错，因此需要一款能够将项目所依赖的jar包一并导入到jar中的插件来解决这个问题。</span><br><span class="line">	</span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;descriptorRefs&gt;</span><br><span class="line">                    &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;</span><br><span class="line">                &lt;/descriptorRefs&gt;</span><br><span class="line">              &lt;archive&gt;</span><br><span class="line">                    &lt;manifest&gt;</span><br><span class="line">                     &lt;!-- 指定主类 --&gt;</span><br><span class="line">                        &lt;mainClass&gt;xxx.xxx.XXX&lt;/mainClass&gt;</span><br><span class="line">                    &lt;/manifest&gt;</span><br><span class="line">                &lt;/archive&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;make-assembly&lt;/id&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;single&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<h3 id="8-maven常用网站"><a href="#8-maven常用网站" class="headerlink" title="8.maven常用网站"></a>8.maven常用网站</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们可以到http:&#x2F;&#x2F;mvnrepository.com&#x2F;搜索需要的jar包的依赖信息。</span><br><span class="line">http:&#x2F;&#x2F;search.maven.org&#x2F;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Hadoop生态</category>
      </categories>
  </entry>
  <entry>
    <title>sync锁解析</title>
    <url>/2020/05/02/sync%E9%94%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>锁</category>
      </categories>
  </entry>
  <entry>
    <title>数据库连接池</title>
    <url>/2020/05/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<h3 id="JDBC-数据库连接池的必要性"><a href="#JDBC-数据库连接池的必要性" class="headerlink" title="JDBC 数据库连接池的必要性"></a>JDBC 数据库连接池的必要性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：　　</span><br><span class="line">1.在主程序（如servlet、beans）中建立数据库连接</span><br><span class="line">2.进行sql操作</span><br><span class="line">3.断开数据库连接</span><br><span class="line">这种模式开发，存在的问题:</span><br><span class="line">普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用.若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</span><br><span class="line">对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。</span><br><span class="line">这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 </span><br><span class="line">    </span><br><span class="line">数据库连接池 </span><br><span class="line">为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</span><br><span class="line">数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</span><br><span class="line">数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。</span><br><span class="line">数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</span><br></pre></td></tr></table></figure>

<h3 id="数据库连接池的优点"><a href="#数据库连接池的优点" class="headerlink" title="数据库连接池的优点"></a>数据库连接池的优点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.资源重用</span><br><span class="line">由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</span><br><span class="line">2.更快的系统反应速度</span><br><span class="line">数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</span><br><span class="line">3.新的资源分配手段</span><br><span class="line">对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</span><br><span class="line">4.统一的连接管理</span><br><span class="line">在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</span><br></pre></td></tr></table></figure>

<h3 id="常见的几种数据库连接池"><a href="#常见的几种数据库连接池" class="headerlink" title="常见的几种数据库连接池"></a>常见的几种数据库连接池</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.DBCP</span><br><span class="line">2.C3P0</span><br><span class="line">3.druid</span><br></pre></td></tr></table></figure>



<h3 id="druid数据库连接池使用示例"><a href="#druid数据库连接池使用示例" class="headerlink" title="druid数据库连接池使用示例"></a>druid数据库连接池使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*首先需要在项目中引入druid相关的jar包（如druid-1.1.9.jar）</span></span><br><span class="line"><span class="comment">示例代码*/</span></span><br><span class="line"><span class="comment">//1.未用配置文件</span></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">"jdbc:mysql://localhost:3306/jdbc"</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        DruidPooledConnection connection = dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用配置文件</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        InputStream inputStream = getClass().getClassLoader().getResourceAsStream(<span class="string">"druid.properties"</span>);</span><br><span class="line">        properties.load(inputStream);</span><br><span class="line">        DataSource datasource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        Connection connection = datasource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//配置文件主要配置如下</span></span><br><span class="line">driverClassName = com.mysql.jdbc.Driver</span><br><span class="line">url = jdbc:mysql:<span class="comment">//localhost:3306/jdbc</span></span><br><span class="line">username = root</span><br><span class="line">password = <span class="number">123456</span></span><br><span class="line">initialSize = <span class="number">3</span></span><br><span class="line">maxActive = <span class="number">50</span></span><br><span class="line">minIdle = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h1 id="DBUtils工具类"><a href="#DBUtils工具类" class="headerlink" title="DBUtils工具类"></a><code>DBUtils</code>工具类</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将常用的操作数据库的JDBC的类和方法集合在一起，就是DBUtils</span><br><span class="line">首先要先将相关的jar关联到项目中（如commons-dbutils-1.3.jar）</span><br></pre></td></tr></table></figure>

<h3 id="DBUtils使用示例代码"><a href="#DBUtils使用示例代码" class="headerlink" title="DBUtils使用示例代码"></a>DBUtils使用示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ResultSetHandler 作用是处理结果集数据.</span></span><br><span class="line"><span class="comment"> *      BeanListHandler 把结果集全部对象化, 前提 : 必须要有javabean类和表一一对应</span></span><br><span class="line"><span class="comment"> *      BeanHandler 把结果集中的第一条记录对象化, 前提 : 必须要有javabean类和表一一对应</span></span><br><span class="line"><span class="comment"> *      ArrayHandler 把结果集的第一条记录的所有数据取到一个Object[]中</span></span><br><span class="line"><span class="comment"> *      ScalarHandler 把结果集中的第一条记录的第一列的值取出来.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBUtilsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        String sql = <span class="string">"select * from student"</span>;</span><br><span class="line">        BeanListHandler&lt;Student&gt; beanListHandler = <span class="keyword">new</span> BeanListHandler&lt;Student&gt;(Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            List&lt;Student&gt; list = queryRunner.query(connection, sql, beanListHandler);</span><br><span class="line">            list.forEach(System.out::println);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            String sql = <span class="string">"select count(*) from teacher where id &gt; ?"</span>;</span><br><span class="line">            <span class="comment">// query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params)</span></span><br><span class="line">            <span class="comment">// ScalarHandler最简单, 取第一行第一列</span></span><br><span class="line">            ScalarHandler scalarHandler = <span class="keyword">new</span> ScalarHandler(); <span class="comment">// 标量</span></span><br><span class="line">            Object objcet = queryRunner.query(connection, sql, scalarHandler, <span class="number">0</span>);</span><br><span class="line">            System.out.println(objcet);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            String sql = <span class="string">"select name, id , age, salary, phone from teacher where id &gt; ?"</span>;</span><br><span class="line">            <span class="comment">// query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params)</span></span><br><span class="line">            <span class="comment">// ScalarHandler最简单, 取第一行第一列</span></span><br><span class="line">            ScalarHandler scalarHandler = <span class="keyword">new</span> ScalarHandler(); <span class="comment">// 标量</span></span><br><span class="line">            Object objcet = queryRunner.query(connection, sql, scalarHandler, <span class="number">0</span>);</span><br><span class="line">            System.out.println(objcet);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            String sql = <span class="string">"select id, name, age, salary, phone from teacher where id &gt; ?"</span>;</span><br><span class="line">            <span class="comment">// query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params)</span></span><br><span class="line">            <span class="comment">// ArrayHandler把结果集中的第一条记录的所有数据保存在一个Object[]中.</span></span><br><span class="line">            ArrayListHandler arrayListHandler = <span class="keyword">new</span> ArrayListHandler();</span><br><span class="line">            List&lt;Object[]&gt; list = queryRunner.query(connection, sql, arrayListHandler, <span class="number">0</span>);</span><br><span class="line">            Iterator&lt;Object[]&gt; iterator = list.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                Object[] array = iterator.next();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                    System.out.print(array[i] + <span class="string">"\t"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            String sql = <span class="string">"select id, name, age, salary, phone from teacher where id &gt; ?"</span>;</span><br><span class="line">            <span class="comment">// query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params)</span></span><br><span class="line">            <span class="comment">// ArrayHandler把结果集中的第一条记录的所有数据保存在一个Object[]中.</span></span><br><span class="line">            ArrayHandler arrayHandler = <span class="keyword">new</span> ArrayHandler();</span><br><span class="line">            Object[] array = queryRunner.query(connection, sql, arrayHandler, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                System.out.print(array[i] + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            String sql = <span class="string">"select * from teacher where id &gt; ?"</span>;</span><br><span class="line">            <span class="comment">// query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params)</span></span><br><span class="line">            <span class="comment">// BeanListHandler结果集处理器把结果集中的所有记录全部转换为javabean对象, 并保存在一个List集合中</span></span><br><span class="line">            BeanListHandler&lt;Teacher&gt; beanListHandler = <span class="keyword">new</span> BeanListHandler&lt;&gt;(Teacher<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            List&lt;Teacher&gt; list = queryRunner.query(connection, sql, beanListHandler, <span class="number">0</span>);</span><br><span class="line">            list.forEach(System.out::println);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            String sql = <span class="string">"select * from teacher"</span>;</span><br><span class="line">            <span class="comment">// query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params)</span></span><br><span class="line">            <span class="comment">// 把结果集中的第一条记录转换成实体的javabean对象, 对象的类型由构造器指定</span></span><br><span class="line">            BeanHandler&lt;Teacher&gt; beanHandler = <span class="keyword">new</span> BeanHandler&lt;&gt;(Teacher<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">// 需要类模板对象</span></span><br><span class="line">            Teacher t = queryRunner.query(connection, sql, beanHandler);</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            String sql = <span class="string">"select id, name, age, gender, phone from customer where id &gt; ?"</span>;</span><br><span class="line">            <span class="comment">// query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params)</span></span><br><span class="line">            <span class="comment">// BeanHandler处理器作用是把结果集中的第一条记录转换成实体的javabean对象, 对象的类型由构造器指定</span></span><br><span class="line">            BeanHandler&lt;Customer&gt; beanHandler = <span class="keyword">new</span> BeanHandler&lt;&gt;(Customer<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">// 需要类模板对象</span></span><br><span class="line">            Customer customer = queryRunner.query(connection, sql, beanHandler, <span class="number">1</span>);</span><br><span class="line">            System.out.println(customer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        <span class="comment">//update(Connection conn, String sql, Object... params)</span></span><br><span class="line">        Connection connection = JdbcUtil.getConnection();</span><br><span class="line">        <span class="keyword">int</span> n = queryRunner.update(connection, <span class="string">"delete from user where name = ?"</span>, <span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(n + <span class="string">" rows"</span>);</span><br><span class="line">        JdbcUtil.close(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title>数据库事务</title>
    <url>/2020/05/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</span><br><span class="line">事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)到最初状态。</span><br><span class="line">为确保数据库中数据的一致性,数据的操纵应当是离散的成组的逻辑单元:当它全部完成时,数据的一致性可以保持,而当这个单元中的一部分操作失败,整个事务应全部视为错误,所有从起始点以后的操作应全部回退到开始状态。</span><br></pre></td></tr></table></figure>

<h3 id="事务的四个基本特性"><a href="#事务的四个基本特性" class="headerlink" title="事务的四个基本特性"></a>事务的四个基本特性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">事务的ACID(acid)属性    </span><br><span class="line">1. 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </span><br><span class="line">2. 一致性（Consistency）事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</span><br><span class="line">3. 隔离性（Isolation）事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</span><br><span class="line">4. 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响</span><br></pre></td></tr></table></figure>

<h3 id="JDBC-事务处理"><a href="#JDBC-事务处理" class="headerlink" title="JDBC 事务处理"></a>JDBC 事务处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚</span><br><span class="line">为了让多个 SQL 语句作为一个事务执行：</span><br><span class="line">1.调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务</span><br><span class="line">2.在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务</span><br><span class="line">3.在出现异常时，调用 rollback(); 方法回滚事务</span><br><span class="line">4.若此时 Connection 没有被关闭, 则需要恢复其自动提交状态</span><br></pre></td></tr></table></figure>

<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.设置自动提交为false</span></span><br><span class="line">        <span class="comment">//2.多个DML形成一个整体的事务</span></span><br><span class="line">        <span class="comment">//3.结束事务（</span></span><br><span class="line">        <span class="comment">//     3.1提交事务</span></span><br><span class="line">        <span class="comment">//      3.2回滚事务</span></span><br><span class="line">        <span class="comment">// 4.还原设置</span></span><br><span class="line">        <span class="comment">// ）</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            <span class="comment">//1.设置自动提交为false</span></span><br><span class="line">            connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//2.多个DML形成事务</span></span><br><span class="line"></span><br><span class="line">            CommonUtils.update(connection,<span class="string">"delete from country"</span>);</span><br><span class="line">            <span class="comment">//CommonUtils.update(connection,"delete from student");</span></span><br><span class="line">            <span class="comment">//3.提交事务</span></span><br><span class="line">            connection.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.rollback();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//4.还原事务设置</span></span><br><span class="line">                connection.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title>jdbc</title>
    <url>/2020/04/29/jdbc/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统，通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库（java.sql）,使用这个类库可以用一种标准的方法，方便的访问数据库资源，JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。</span><br></pre></td></tr></table></figure>

<p>连接图如下：</p>
<h3 id="JDBC-体系结构"><a href="#JDBC-体系结构" class="headerlink" title="JDBC 体系结构"></a>JDBC 体系结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JDBC接口（API）包括两个层次：</span><br><span class="line">面向应用的API: Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）</span><br><span class="line">面向数据库的API: Java Driver API，供开发商开发数据库驱动程序使用</span><br><span class="line"></span><br><span class="line">JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。不同的数据库厂商，需要针对这套接口，提供不同的实现。不同的实现的集合，即为不同数据库的驱动。--面向接口编程</span><br></pre></td></tr></table></figure>

<h3 id="Driver-接口"><a href="#Driver-接口" class="headerlink" title="Driver 接口"></a>Driver 接口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.sql.Driver接口是所有JDBC驱动程序需要实现的接口，这个接口是提供给数据库厂商使用的，不同的数据库厂商提供不同的实现。</span><br><span class="line">在程序中不需要直接去访问实现了Driver接口的类，而是由驱动程序管理类（java.sql.DriverManager）去调用这些Driver实现。</span><br><span class="line"></span><br><span class="line">Driver实现</span><br><span class="line">-Oracle的驱动：oracle.jdbc.driver.Oracle.OracleDriver</span><br><span class="line">-mySql驱动：com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">比如使用mysql时，需要mysql的驱动程序jar包（比如：mysql-connector-java-5.1.7-bin.jar）导入到项目中</span><br></pre></td></tr></table></figure>

<h3 id="操纵数据库的步骤"><a href="#操纵数据库的步骤" class="headerlink" title="操纵数据库的步骤"></a>操纵数据库的步骤</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.加载与注册JDBC驱动  </span><br><span class="line">方式一：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</span><br><span class="line">Class.forName(“com.mysql.jdbc.Driver”);</span><br><span class="line">方式二：DriverManager 类是驱动程序管理器类，负责管理驱动程序</span><br><span class="line">DriverManager.registerDriver(com.mysql.jdbc.Driver);</span><br><span class="line">通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例</span><br><span class="line">   </span><br><span class="line"><span class="number">2</span>.建立连接</span><br><span class="line">可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</span><br><span class="line">User,password可以用“属性名=属性值”方式告诉数据库；</span><br><span class="line">JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</span><br><span class="line">JDBC URL的标准由三部分组成，各部分间用冒号分隔。 </span><br><span class="line">jdbc:子协议:子名称</span><br><span class="line">协议：JDBC URL中的协议总是jdbc </span><br><span class="line">子协议：子协议用于标识一个数据库驱动程序</span><br><span class="line">子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名</span><br><span class="line"></span><br><span class="line">协议：子协议：自名称</span><br><span class="line">jdbc:mysql:<span class="comment">//localhost:3306/test</span></span><br><span class="line"></span><br><span class="line">对于 Oracle 数据库连接，采用如下形式： </span><br><span class="line">jdbc:oracle:thin:<span class="meta">@localhost</span>:<span class="number">1521</span>:test</span><br><span class="line">对于 SQLServer 数据库连接，采用如下形式：</span><br><span class="line">jdbc:microsoft:sqlserver<span class="comment">//localhost:1433; DatabaseName=sid</span></span><br><span class="line">对于 MYSQL 数据库连接，采用如下形式：   </span><br><span class="line">jdbc:mysql:<span class="comment">//localhost:3306/test</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.通过连接获取sql执行体对象</span><br><span class="line">  <span class="number">1</span>）statement，效率相对比较低，而且由sql注入问题</span><br><span class="line">一旦获取了连接对象Connection, 还不可以执行SQL, 必须要从Connection连接对象获取执行体对象Statement才能执行SQL</span><br><span class="line">Connection connection = getConnection();</span><br><span class="line">Statement state = connection.createStatement();</span><br><span class="line"><span class="keyword">int</span> n = state.executeUpdate(“insert,update,delete…”);</span><br><span class="line">其中n是执行增删改后对表产生的影响的记录数</span><br><span class="line">如果执行一个查询则返回一个ResultSet结果集对象.</span><br><span class="line">  <span class="number">2</span>）PreparedStatement 预处理执行体对象，效率高</span><br><span class="line">可以通过调用 Connection 对象的 preparedStatement() 方法获取 PreparedStatement 对象</span><br><span class="line">PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</span><br><span class="line">PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 <span class="number">1</span> 开始)，第二个是设置的 SQL 语句中的参数的值</span><br><span class="line">    </span><br><span class="line">PreparedStatement vs Statement</span><br><span class="line">代码的可读性和可维护性. </span><br><span class="line">PreparedStatement 能最大可能提高性能：</span><br><span class="line">DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</span><br><span class="line">在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存.这样每执行一次都要对传入的语句编译一次.  </span><br><span class="line">(语法检查，语义检查，翻译成二进制命令，缓存)</span><br><span class="line">PreparedStatement 可以防止 SQL 注入 </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="number">4</span>.执行sql语句</span><br><span class="line">    </span><br><span class="line"><span class="number">5</span>.处理执行结果（ResltSet）</span><br><span class="line">ResultSet的说明：</span><br><span class="line"><span class="number">1</span>）查询需要调用 Statement 的 executeQuery(sql) 方法，查询结果是一个 ResultSet 对象</span><br><span class="line"><span class="number">2</span>）关于 ResultSet：代表结果集</span><br><span class="line">ResultSet: 结果集. 封装了使用 JDBC 进行查询的结果. </span><br><span class="line">调用 Statement 对象的 executeQuery(sql) 可以得到结果集.</span><br><span class="line">ResultSet 返回的实际上就是一张数据表. 有一个指针指向数据表的第一条记录的前面.</span><br><span class="line"><span class="number">3</span>）可以调用 next() 方法检测下一行是否有效. 若有效该方法返回 <span class="keyword">true</span>, 且指针下移. 相当于Iterator 对象的 hasNext() 和 next() 方法的结合体</span><br><span class="line"><span class="number">4</span>）当指针指向一行时, 可以通过调用 getXxx(<span class="keyword">int</span> index) 或 getXxx(<span class="keyword">int</span> columnName) 获取每一列的值. </span><br><span class="line">例如: getInt(<span class="number">1</span>), getString(<span class="string">"name"</span>)</span><br><span class="line"><span class="number">5</span>）ResultSet 当然也需要进行关闭</span><br><span class="line">   </span><br><span class="line">ResultSetMetaData的说明：</span><br><span class="line">可用于获取关于 ResultSet 对象中列的类型和属性信息的对象</span><br><span class="line">ResultSetMetaData meta = rs.getMetaData();</span><br><span class="line"><span class="number">1</span>）getColumnName(<span class="keyword">int</span> column)：获取指定列的名称</span><br><span class="line"><span class="number">2</span>）getColumnLabel(<span class="keyword">int</span> column)：获取指定列的别名</span><br><span class="line"><span class="number">3</span>）getColumnCount()：返回当前 ResultSet 对象中的列数。 </span><br><span class="line"><span class="number">4</span>）getColumnTypeName(<span class="keyword">int</span> column)：检索指定列的数据库特定的类型名称。 </span><br><span class="line"><span class="number">5</span>）getColumnDisplaySize(<span class="keyword">int</span> column)：指示指定列的最大标准宽度，以字符为单位。 </span><br><span class="line"><span class="number">6</span>）isNullable(<span class="keyword">int</span> column)：指示指定列中的值是否可以为 <span class="keyword">null</span>。 </span><br><span class="line"><span class="number">7</span>）isAutoIncrement(<span class="keyword">int</span> column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>.释放资源（close()）</span><br></pre></td></tr></table></figure>

<h3 id="JDBC-API小结"><a href="#JDBC-API小结" class="headerlink" title="JDBC API小结"></a>JDBC API小结</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.sql.DriverManager用来装载驱动程序，获取数据库连接。</span><br><span class="line">java.sql.Connection完成对某一指定数据库的连接</span><br><span class="line">java.sql.Statement在一个给定的连接中作为SQL执行声明的容器，他包含了两个重要的子类型。</span><br><span class="line">Java.sql.PreparedSatement 用于执行预编译的sql声明</span><br><span class="line">Java.sql.CallableStatement用于执行数据库中存储过程的调用</span><br><span class="line">java.sql.ResultSet对于给定声明取得结果的途径</span><br></pre></td></tr></table></figure>

<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement statement = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();<span class="comment">//通过封装的工具类获取连接对象</span></span><br><span class="line">            String sql = <span class="string">"select id,name,age,gender from student where id &gt; ? "</span>;</span><br><span class="line">            statement = connection.prepareStatement(sql);</span><br><span class="line">            statement.setObject(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            resultSet = statement.executeQuery();</span><br><span class="line">            <span class="comment">//想要进一步获取表结构信息，需要用ResultSetMetaData</span></span><br><span class="line">            ResultSetMetaData metaData = resultSet.getMetaData();</span><br><span class="line">            <span class="comment">//获取列标签</span></span><br><span class="line">            <span class="keyword">int</span> columnCount = metaData.getColumnCount();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line">                String columnLabel = metaData.getColumnLabel(i+<span class="number">1</span>);</span><br><span class="line">                System.out.print(columnLabel + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line">                    String columnLabel = metaData.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                    Object value = resultSet.getObject(columnLabel);</span><br><span class="line">                    System.out.print(value + <span class="string">"\t"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(connection,statement,resultSet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement statement = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            String sql = <span class="string">"select id,name ame,age,gender from student where id &gt; ? "</span>;</span><br><span class="line">            statement = connection.prepareStatement(sql);</span><br><span class="line">            statement.setObject(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//第一个？号赋值为0</span></span><br><span class="line">            resultSet = statement.executeQuery();</span><br><span class="line">            <span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line">                <span class="keyword">int</span> id = resultSet.getInt(<span class="string">"id"</span>);</span><br><span class="line">                String name = resultSet.getString(<span class="string">"name"</span>);<span class="comment">//列标签表示的是虚表中的列名</span></span><br><span class="line">                <span class="keyword">int</span> age = resultSet.getInt(<span class="string">"age"</span>);</span><br><span class="line">                String gender = resultSet.getString(<span class="string">"gender"</span>);</span><br><span class="line">                Student student = <span class="keyword">new</span> Student(id,name,age,gender);</span><br><span class="line">                list.add(student);</span><br><span class="line">                <span class="comment">//System.out.println(student);</span></span><br><span class="line">                <span class="comment">//System.out.println("id: " + id + "\tname: " + name + "\tage: " + age + "\tgender: " + gender);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(connection,statement,resultSet);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//list.stream().forEach((s) -&gt; System.out.println(s));</span></span><br><span class="line">        list.stream().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//工具类中主要的获取连接的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        InputStream inputStream = JdbcUtil.class.getClassLoader().getResourceAsStream("jdbc.properties");</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(inputStream);</span><br><span class="line">        String driverClass = properties.getProperty(<span class="string">"driverClass"</span>);</span><br><span class="line">        String url = properties.getProperty(<span class="string">"url"</span>);</span><br><span class="line">        String user = properties.getProperty(<span class="string">"user"</span>);</span><br><span class="line">        String password = properties.getProperty(<span class="string">"password"</span>);</span><br><span class="line">        Class.forName(driverClass);</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">批量处理JDBC语句提高处理速度</span><br><span class="line">当需要成批插入或者更新记录时。可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</span><br><span class="line">JDBC的批量处理语句包括下面两个方法(Statement)：</span><br><span class="line">addBatch(String)：添加需要批量处理的SQL语句或是参数；</span><br><span class="line">executeBatch()：执行批量处理语句；</span><br><span class="line">clearBatch():清空缓存的数据</span><br><span class="line">通常我们会遇到两种批量执行SQL语句的情况：</span><br><span class="line">多条SQL语句的批量处理；</span><br><span class="line">一个SQL语句的批量传参；</span><br><span class="line"></span><br><span class="line">批量处理步骤如下：</span><br><span class="line">...</span><br><span class="line">Statement st = conn.prepareStatement();</span><br><span class="line">st.addBatch(sql1);</span><br><span class="line">st.addBatch(sql2);</span><br><span class="line">st.addBatch(sql3);</span><br><span class="line">...</span><br><span class="line">st.addBatch(s1ln);</span><br><span class="line">st.executeBatch();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title>mysql基本介绍</title>
    <url>/2020/04/27/mysql%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql数据库工作模式是C&#x2F;S架构，mysqld.exe就是服务器，ServerSocket，mysql.exe就是客户端，Socket。通过Socket进行连接，要想连接服务器，必须要提供主机ip地址（-h）,端口号（-P），用户名（-u）,密码（-p）</span><br></pre></td></tr></table></figure>

<p>连接服务器可以编写.bat脚本,然后以管理员身份运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set MYSQL_HOME &#x3D; D:\MyWOrk\MySQL\mysql-5.7.28-winx64</span><br><span class="line">set PATH&#x3D;%MYSQL_HOME%\bin;%PATH%</span><br><span class="line">mysql -h127.0.0.1 -P3306 -uroot -p&quot;123456&quot;</span><br></pre></td></tr></table></figure>

<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）把外部的.sql文件中的数据导入到当前数据库中，右面的文件的路径以实际为准.</span><br><span class="line">source d:&#x2F;company.sql;</span><br><span class="line">2）丢弃数据库</span><br><span class="line">drop database company;</span><br><span class="line">3）查看表结构</span><br><span class="line">desc 库名.表名;（如果是当前库，可省略库名）</span><br><span class="line">4）查看表的建表语句</span><br><span class="line">show create table 表名;</span><br></pre></td></tr></table></figure>

<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">存储引擎：决定表如何存储数据以及如何处理数据......</span><br><span class="line">查询所有引擎：show engines;</span><br><span class="line">InnoDB是默认存储引擎：支持外键，事物等高级特性。</span><br><span class="line">比如下面的建表语句，默认是InnoDB</span><br><span class="line"> CREATE TABLE &#96;city&#96; (</span><br><span class="line">  &#96;ID&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;Name&#96; char(35) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">  &#96;CountryCode&#96; char(3) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">  &#96;District&#96; char(20) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">  &#96;Population&#96; int(11) NOT NULL DEFAULT &#39;0&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;ID&#96;),</span><br><span class="line">  KEY &#96;CountryCode&#96; (&#96;CountryCode&#96;),</span><br><span class="line">  CONSTRAINT &#96;city_ibfk_1&#96; FOREIGN KEY (&#96;CountryCode&#96;) REFERENCES &#96;country&#96; (&#96;Code&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4080 DEFAULT CHARSET&#x3D;latin1 </span><br><span class="line"></span><br><span class="line">其中&#96;表示反引号（或者飘号），专门在数据库中用来包围数据库对象的名称。数据库对象：数据库，表，列，索引等。</span><br><span class="line">MyISAM是mysql早期默认引擎：速度超快，不支持事物</span><br></pre></td></tr></table></figure>

<h3 id="查询语句的执行顺序"><a href="#查询语句的执行顺序" class="headerlink" title="查询语句的执行顺序"></a>查询语句的执行顺序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查询 : </span><br><span class="line">1) from 确定第一基表</span><br><span class="line">2) join 确定第二基表</span><br><span class="line">3) join 是内还是外</span><br><span class="line">4) 有join必须要有on </span><br><span class="line">5) 如果还有, 继续join和on </span><br><span class="line">6) where 针对以上的大基表进行基本的行过滤</span><br><span class="line">7) 是否要分组, 如果要分组, 使用group by, 分组依据的列很重要.</span><br><span class="line">8) 第一时间把分组依据的列放在select后面</span><br><span class="line">9) 继续考虑要选择哪些列..</span><br><span class="line">10) 产生了虚表后, 如果还相再进一步进行过滤,必须使用having </span><br><span class="line">11) 如果要排序, 再排序 order by </span><br><span class="line"></span><br><span class="line">from-&gt;where-&gt;group by-&gt;select-having-&gt;order by</span><br></pre></td></tr></table></figure>

<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-- 创建数据库</span><br><span class="line">create database if not exists 数据库名 charset 字符集;</span><br><span class="line">create database if not exists school charset utf8;</span><br><span class="line">-- 修改数据库:只能修改字符集</span><br><span class="line">alter database school charset gbk;</span><br><span class="line">-- 丢弃数据库</span><br><span class="line">drop database if exists school;</span><br><span class="line"></span><br><span class="line">-- 创建表：</span><br><span class="line">1）全新方式建表：</span><br><span class="line">	create table if not exists 表名（</span><br><span class="line">		列名1 数据类型（长度） 其它选项（列级约束）,</span><br><span class="line">		列名2 数据类型（长度） 其它选项（列级约束）,</span><br><span class="line">		,,,</span><br><span class="line">		表级约束1,</span><br><span class="line">		表级约束2,</span><br><span class="line">		...</span><br><span class="line">	）engine 引擎 charset 字符集</span><br><span class="line">2）基于子查询建表：复制的新表不包含原表的约束</span><br><span class="line">	create table country2 as select * from country;</span><br><span class="line">3）完全复制表结构的建表，包含约束，但是没有数据</span><br><span class="line">	create table 新表 like 已有表;</span><br><span class="line"></span><br><span class="line">-- 修改表 alter table 表名 支持若干子句</span><br><span class="line">-- 添加新列</span><br><span class="line">alter table 表名</span><br><span class="line">add column 新列 数据类型（长度） 其它选项；</span><br><span class="line">alter table teacher</span><br><span class="line">add column phone char(11) not null;--在最后添加列</span><br><span class="line">alter table teacher</span><br><span class="line">add column gender enum(&#39;男&#39;,&#39;女&#39;)default &#39;男&#39; after name;--在指定列后面添加新列</span><br><span class="line">alter table teacher</span><br><span class="line">add column person_id varchar(50) first;--在最前面添加新列</span><br><span class="line"></span><br><span class="line">-- 修改列（列名和其它）</span><br><span class="line">alter table 表名</span><br><span class="line">change 老列名 新列名  新数据类型（长度） 新其它选项</span><br><span class="line"></span><br><span class="line">alter table teacher</span><br><span class="line">change phone mobile varchar(50) not null;</span><br><span class="line"></span><br><span class="line">-- 丢弃列</span><br><span class="line">alter table 表名</span><br><span class="line">drop column 列名;</span><br><span class="line">alter table teacher</span><br><span class="line">drop column person_id;</span><br><span class="line"></span><br><span class="line">-- 修改表名</span><br><span class="line">alter table 表名</span><br><span class="line">rename to 新表名;</span><br><span class="line">alter table student rename to students;</span><br><span class="line"></span><br><span class="line">-- 丢弃表</span><br><span class="line">drop table if exists &#39;表名1&#39;,&#39;表名2&#39;...;</span><br><span class="line">drop table if exists country1,country2;</span><br><span class="line">-- 清空表</span><br><span class="line">truncate table 表名;</span><br><span class="line">delete from table 表名 --可以后悔，所有的操作都会记日志...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 插入数据</span><br><span class="line">1）全新方式插入</span><br><span class="line">insert into  表名(列1，列2...)values(),()...;</span><br><span class="line">insert into  student(id,name)values(1,&#39;jack&#39;),(2,&#39;susan&#39;);</span><br><span class="line">2）基于子查询插入数据</span><br><span class="line">insert into 表名(列1，列2...)select 列1，列2...from 表名 </span><br><span class="line">insert into student(id,name)select id,name from students;</span><br></pre></td></tr></table></figure>

<h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  数据库事物是访问并可能操作各种数据项的一个数据库序列集合，这些操作要么全部执行， 要么全部不执行，是一个不可分割的工作单位。事物由事物开始与事物结束之间的全部数据库操作组成。</span><br><span class="line">  </span><br><span class="line">  启动事务：</span><br><span class="line">  	set autocommit &#x3D; false;-- 如果默认开启事物的话，那每一条语句就独立组成了事务</span><br><span class="line">  事物组成：</span><br><span class="line">  	若干的DML语句</span><br><span class="line">  事物结束：</span><br><span class="line">  	commit（成功）</span><br><span class="line">  	rollback(失败)，回滚到事物前</span><br><span class="line">  	ddl(成功)</span><br><span class="line">  	会话正常结束（成功）</span><br><span class="line">  	异常结束（失败）</span><br><span class="line">  还原设置：</span><br><span class="line">  	set autocommit &#x3D; true;</span><br><span class="line">  数据库事物的四大特性：</span><br><span class="line">  A atomic 原子性：事物中的所有DML语句是一个原子操作，要么全部执行成功，要么全部不执行</span><br><span class="line">  C consistency 一致性：事物保证了数据库从一个有效（正确）状态转移到另一个有效状态</span><br><span class="line">  I isolation 独立性：多个会话之间数据是独立的，一个事物不会读到另一个事物未提交的数据，如果多个会话同时修改数据是不允许的,会上锁</span><br><span class="line">  D duration  持久性：事物提交后，结果才写入硬盘，数据永久生效，并释放锁</span><br><span class="line">  </span><br><span class="line">-- 测试</span><br><span class="line">-- 在事务中删除表中所有数据, 在另外一个客户端中查看数据</span><br><span class="line">-- 回滚事务, 数据还在吗?</span><br><span class="line">-- 提交事务, 会发生什么?</span><br></pre></td></tr></table></figure>

<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySQL服务器支持预处理语句。当想要执行多个查询，而每个查询之间只有很小的差别时，可以把sql编成一个可以执行的执行体，执行的时候去调用这个执行体，而不需要重新输入sql，预编译的sql只在当前会话中有效，会话结束后就销毁。</span><br><span class="line"></span><br><span class="line">-- 格式</span><br><span class="line">prepare 预编译体名 from &#39;SQL&#39;;</span><br><span class="line">prepare p1 from &#39;</span><br><span class="line">	select * from teachers</span><br><span class="line">&#39;;</span><br><span class="line">-- 执行</span><br><span class="line">execute p1;</span><br><span class="line">-- 丢弃</span><br><span class="line">drop prepare p1;</span><br><span class="line"></span><br><span class="line">prepare p2 from &#39;</span><br><span class="line">	insert into user(</span><br><span class="line">		id,</span><br><span class="line">		name</span><br><span class="line">	)values(</span><br><span class="line">		?,</span><br><span class="line">		?</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">&#39;;</span><br><span class="line"></span><br><span class="line">-- 必须使用用户变量进行传参</span><br><span class="line">set @id &#x3D; 1,@name &#x3D; &#39;jack&#39;;-- 定义用户变量@id,@name并赋值</span><br><span class="line"></span><br><span class="line">-- 执行时</span><br><span class="line">execute p2 using @id,@name;</span><br><span class="line"></span><br><span class="line">prepare p3 from &#39;</span><br><span class="line">	delete from user where id &#x3D; ?</span><br><span class="line">&#39;;</span><br><span class="line">set @id &#x3D; 1;</span><br><span class="line">execute p3 using @id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 如果sql中有&#39;&#39;,必须用&#39;&#39;进行转义</span><br><span class="line"></span><br><span class="line">prepare p4 from &#39;</span><br><span class="line">	insert into classes(</span><br><span class="line">		name,</span><br><span class="line">		begin_date,</span><br><span class="line">		master,</span><br><span class="line">		room</span><br><span class="line">	)values(</span><br><span class="line">		?,</span><br><span class="line">		now(),</span><br><span class="line">		?,</span><br><span class="line">		&#39;&#39;303&#39;&#39;</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	约束时保证数据完整性的表级的强制性要求</span><br><span class="line">not null</span><br><span class="line">unique 唯一约束，允许使用null</span><br><span class="line">primary key 主键约束（非空且唯一）</span><br><span class="line">foreign key</span><br><span class="line">check mysql不支持</span><br><span class="line">default 默认值</span><br><span class="line"></span><br><span class="line">create table if not exists classes (</span><br><span class="line">	id int auto_increment,</span><br><span class="line">	name varchar(12) not null,</span><br><span class="line">	begindate date,</span><br><span class="line">	master int,</span><br><span class="line">	room char(3) default &#39;505&#39;,</span><br><span class="line">	primary key(id),</span><br><span class="line">	-- foreign key(本表外键列) references 父表(被引用的列(主键))</span><br><span class="line">	foreign key(master) references teachers(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 丢弃主键 因为一张表只有一个主键, 所以丢弃主键 不需要名字</span><br><span class="line">alter table 表名</span><br><span class="line">drop primary key;</span><br><span class="line"></span><br><span class="line">-- 丢弃外键 , 因为一张表可以有多个外键, 所以丢弃外键时必须指定名字</span><br><span class="line">alter table 表名 </span><br><span class="line">drop foreign key 外键约束名;</span><br><span class="line"></span><br><span class="line">-- 可以先通过 show create table 表名 查看外键名称</span><br><span class="line">alter table classes</span><br><span class="line">drop foreign key classes_ibfk_1;</span><br><span class="line"></span><br><span class="line">-- 添加外键</span><br><span class="line">on delete(是指删除父表中被字表引用的记录时的选项)有以下3种选项</span><br><span class="line">	1）do nothing 当删除父表中被引用的记录时，不允许删除（默认选项）</span><br><span class="line">	2）cascade 当删除父类中被引用的记录时，字表种所有引用该记录的所有记录都会被级联删除</span><br><span class="line">	3）set null 当删除父表中被引用的记录时，字表中所有引用该记录的所有记录的外键值全部置为null</span><br><span class="line"></span><br><span class="line">on update(是指更新父表中被字表引用的记录时的选项)有以下3种选项</span><br><span class="line">	1）do nothing</span><br><span class="line">	2）cascade</span><br><span class="line">	3）set null</span><br><span class="line">	</span><br><span class="line">alter table 表名</span><br><span class="line">add constraint 外键名 foreign key(本表外键列) references 父表(被引用的列) on delete cascade(级联) [do nothing, set null]</span><br><span class="line"></span><br><span class="line">alter table classes </span><br><span class="line">add constraint myfk foreign key(master) references teachers(id) on delete cascade;</span><br><span class="line">alter table classes </span><br><span class="line">add foreign key(master) references teachers(id) on delete set null;</span><br></pre></td></tr></table></figure>

<h3 id="limit-分页"><a href="#limit-分页" class="headerlink" title="limit 分页"></a>limit 分页</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">公式: (当前页数-1)*每页条数，每页条数</span><br><span class="line">select * from table limit (PageNo - 1) * PageSize,PageSize;</span><br><span class="line">注意：limit子句必须放在整个查询语句的最后</span><br><span class="line"></span><br><span class="line">-- 查询前10条记录</span><br><span class="line">	select * from table student 0,10;</span><br><span class="line">-- 查询第11至20条记录</span><br><span class="line">	select * from table student 10,10;-- 第一个参数表示skip前面10条记录，从11开始，第二个参数表示一共查询多少条记录</span><br></pre></td></tr></table></figure>



<h3 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a><code>SQL</code>分类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQL语句分为以下三种类型：</span><br><span class="line">DML: Data Manipulation language</span><br><span class="line">DDL: Data Definition language</span><br><span class="line">DCL: Data Control language</span><br><span class="line"></span><br><span class="line">DML 用于查询与修改数据记录，构造事物的主体（一个事物是由多个DML构成）,包括如下sql语句</span><br><span class="line">-- insert</span><br><span class="line">-- upate</span><br><span class="line">-- delete</span><br><span class="line">-- select</span><br><span class="line"></span><br><span class="line">DDL用于定义数据库的结构，比如创建，修改或删除数据库对象，非正规事物终结者,包括如下SQL语句：</span><br><span class="line">-- create table</span><br><span class="line">-- alter table</span><br><span class="line">-- drop table</span><br><span class="line">-- create index</span><br><span class="line">-- drop index</span><br><span class="line"></span><br><span class="line">DCL 用来控制对数据库的访问，正规事物终结者，包括如下SQL语句</span><br><span class="line">-- grant 授予访问权限</span><br><span class="line">-- revoke 撤回访问权限</span><br><span class="line">-- commit </span><br><span class="line">-- rollback</span><br><span class="line">-- savapoint 设置保存点</span><br><span class="line">-- lock 对数据库的特定部分进行锁定</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式的七大原则-合成复用原则</title>
    <url>/2020/04/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原则是尽量使用合成&#x2F;聚合的方式，而不是使用继承</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>Stream</title>
    <url>/2020/04/26/Stream/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream API(java.util.stream)把真正的函数式编程风格引入到Java中，是目前为止对Java类最好的补充，可以放我们写出更加高效率，干净，简洁的代码。</span><br><span class="line">Stream是Java8处理集合的关键抽象概念，它可以指定我们希望对集合进行的操作，可以执行非常复杂的查找，过滤和映射数据等操作。使用Stream API对集合数据进行操作就类似于使用SQL执行的数据库查询。</span><br><span class="line"></span><br><span class="line">也可以使用Stream API来并行执行操作。简言之，Stream API提供了一种高效且易于使用的处理数据的方式。</span><br><span class="line"></span><br><span class="line">为什么要使用Stream呢？</span><br><span class="line">	实际开发中，项目中数据源多数来自于Mysql,Oracle等。但现在数据源众多，有MongoDB,Redis等，而这些NoSQL的数据就需要Java层面去处理。</span><br></pre></td></tr></table></figure>

<h3 id="1-Stream的特点"><a href="#1-Stream的特点" class="headerlink" title="1. Stream的特点"></a>1. Stream的特点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream不负责数据存储，只负责数据处理，基于集合或数组来处理</span><br><span class="line">特点如下：</span><br><span class="line">1.不是集合，不负责数据存储</span><br><span class="line">2.Stream处理过后，原始数据不会发生改变，相反，会产生持有新结果的新的Stream</span><br><span class="line">3.Stream是延迟执行的，只有当终止操作提交后，所有一系列的普通操作才真的执行</span><br><span class="line">4.Stream只能消费一次，处理一次就不能再用了，再继续用会会产生新的Stream</span><br><span class="line">5.Stream类似迭代器，处理数据也是一次性的，但是可以高并发，提高效率</span><br></pre></td></tr></table></figure>

<h3 id="2-操作Stream的步骤"><a href="#2-操作Stream的步骤" class="headerlink" title="2.操作Stream的步骤"></a>2.操作Stream的步骤</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.创建流</span><br><span class="line">Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：</span><br><span class="line">default Stream&lt;E&gt; stream() : 返回一个顺序流</span><br><span class="line">default Stream&lt;E&gt; parallelStream() : 返回一个并行流</span><br><span class="line"></span><br><span class="line">1)基于集合</span><br><span class="line">	集合对象.stream()</span><br><span class="line">2)基于数组</span><br><span class="line">	Arrays.stream(数组对象)</span><br><span class="line">3)基于散列数据</span><br><span class="line">	Stream.of(T... values)</span><br><span class="line">4)使用供给器</span><br><span class="line">	Stream.generate(供给器)，形成无限流...</span><br><span class="line">		</span><br><span class="line">2.对数据进行处理的中间操作,一系列的中间操作形成流水线</span><br><span class="line">	Stream filter(判定器)让流中的每个对象都经过判定器，判定结果为true的对象则留下，为false则抛弃</span><br><span class="line">	distinct(),根据对象的hashCode()和equals()去重</span><br><span class="line">	limit(long maxSize),截断流，使流中的对象个数不大于maxSize</span><br><span class="line">	skip(long n),处理的时候跳过前n个对象</span><br><span class="line">	map(转换器)映射，把流中每个对象转换为另一种类型的对象（Function&lt;T,R&gt;），新流中全是新类型的对象</span><br><span class="line">	sorted()自然排序</span><br><span class="line">	sorter(比较器)定制排序</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">3.终止操作（最终指令）</span><br><span class="line">	forEach(消费器)</span><br><span class="line">	findFirst()	返回第一个对象</span><br><span class="line">	findAny() 随便返回任意一个对象</span><br><span class="line">	long count() 计数</span><br><span class="line">	reduce(二元运算)缩小，规约，二元运算T test(T t1,T t2)</span><br><span class="line">		第一个对象和第二个对象进行二元运算，返回新的对象，新的对象再和后面的对象进行相同的二元运算，知道最后只有一个结果</span><br></pre></td></tr></table></figure>

<h4 id="3-并行流和串行流"><a href="#3-并行流和串行流" class="headerlink" title="3.并行流和串行流"></a>3.并行流和串行流</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">并行流就是可以把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流</span><br><span class="line">Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。</span><br></pre></td></tr></table></figure>

<h3 id="4-Optional类"><a href="#4-Optional类" class="headerlink" title="4. Optional类"></a>4. Optional类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Optional类的作用是为了最大化地减少空指针异常，Optional实际上是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</span><br><span class="line">常用方法：</span><br><span class="line">Optional.empty() : 创建一个空的 Optional 实例</span><br><span class="line">Optional.of(T t) : 创建一个 Optional 实例</span><br><span class="line">Optional.ofNullable(T t):若 t 不为 null,创建 Optional 实例,否则创建空实例</span><br><span class="line">isPresent() : 判断是否包含值</span><br><span class="line">T get(): 如果调用对象包含值，返回该值，否则抛异常</span><br><span class="line">orElse(T t) :  如果调用对象包含值，返回该值，否则返回t</span><br><span class="line">orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回 s 获取的值</span><br><span class="line">map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty()</span><br><span class="line">flatMap(Function mapper):与 map 类似，要求返回值必须是Optional</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test14</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 求全校总分</span></span><br><span class="line">        Optional&lt;Double&gt; reduce = StudentData.getList().parallelStream().distinct().map(t -&gt; t.getScore()).reduce((t1, t2) -&gt; t1 + t2);</span><br><span class="line">        Double aDouble = reduce.orElse(<span class="number">9999.9999</span>);</span><br><span class="line">        System.out.println(aDouble);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test13</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> count = StudentData.getList().stream().distinct().filter(t -&gt; t.getScore() &lt; <span class="number">60</span>).count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test12</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Optional&lt;Student&gt; first = StudentData.getList().stream().distinct().filter(t -&gt; t.getScore() &gt; <span class="number">96</span>).findFirst();</span><br><span class="line">        <span class="comment">//Student student = first.get(); // 如果内部指针为空, 直接抛异常, 提前暴露空指针!!!</span></span><br><span class="line">        <span class="comment">//System.out.println(student.getName()); // 真的出现空指针</span></span><br><span class="line">        Student student = first.orElse(<span class="keyword">new</span> Student());</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出3年级没有及格的同学,倒序显示前2个....</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exer3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StudentData.getList().stream().distinct()</span><br><span class="line">                .filter(t -&gt; t.getGrade() == <span class="number">3</span>).filter(t -&gt; t.getScore() &lt; <span class="number">60</span>)</span><br><span class="line">                .sorted((t1, t2) -&gt; -(<span class="keyword">int</span>)(t1.getScore() - t2.getScore()))</span><br><span class="line">                .limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StudentData.getList().stream().distinct().sorted((t1, t2) -&gt; -(t1.getGrade() - t2.getGrade())).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印输出所有学生的姓名</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exer2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StudentData.getList().stream().distinct().map(t -&gt; t.getName()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Stream&lt;Double&gt; doubleStream = StudentData.getList().stream().distinct().map(t -&gt; t.getScore());</span></span><br><span class="line">        <span class="comment">//doubleStream.forEach(System.out::println);</span></span><br><span class="line">        StudentData.getList().stream().distinct().map(t -&gt; t.getScore()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StudentData.getList().stream().distinct().skip(<span class="number">10</span>).limit(<span class="number">5</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StudentData.getList().stream().distinct().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找出五年级80分以上的同学</span></span><br><span class="line">        StudentData.getList().stream().filter(t -&gt; t.getGrade() == <span class="number">5</span>).filter(t -&gt; t.getScore() &gt; <span class="number">80</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出所有3年级同学..</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exer1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StudentData.getList().stream().filter(t -&gt; t.getGrade() == <span class="number">3</span>).forEach(t -&gt; System.out.println(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 所有操作都可以在一行完成.</span></span><br><span class="line">        StudentData.getList().stream().filter(t -&gt; t.getScore() &gt; <span class="number">90</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Student&gt; list = StudentData.getList();</span><br><span class="line">        Stream&lt;Student&gt; stream1 = list.stream();</span><br><span class="line">        Stream&lt;Student&gt; stream2 = stream1.filter(t -&gt; t.getScore() &gt; <span class="number">90</span>);</span><br><span class="line">        stream2.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.generate(() -&gt; (<span class="keyword">int</span>) (Math.random() * <span class="number">200</span>));<span class="comment">// 供给器, 无参有返回</span></span><br><span class="line">        stream.limit(<span class="number">100</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"a"</span>, <span class="string">"yy"</span>, <span class="string">"qq"</span>, <span class="string">"132"</span>, <span class="string">"bb"</span>, <span class="string">"99"</span>);</span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer[] arr = &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Stream&lt;Integer&gt; stream = Arrays.stream(arr);</span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Student&gt; list = StudentData.getList();</span><br><span class="line">        Stream&lt;Student&gt; stream = list.stream();</span><br><span class="line">        stream.forEach(System.out::println); <span class="comment">// 让流中的每个对象都经过消费器.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaSE</category>
        <category>Java8新特性</category>
      </categories>
  </entry>
  <entry>
    <title>java8新特性</title>
    <url>/2020/04/25/java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="1-interface扩展"><a href="#1-interface扩展" class="headerlink" title="1.interface扩展"></a>1.interface扩展</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java8以后支持接口中支持静态方法和缺省方法。可能有些接口（比如Collection）中的功能需要升级，但是又不能加抽象方法，因为如果加抽象方法，实现了这个接口的类都需要修改，去实现新加的抽象方法，所以java8之后对接口规范进行了调整，可以有静态方法和缺省方法。</span><br></pre></td></tr></table></figure>

<p>代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java8以后支持静态方法和缺省方法. 向抽象类靠拢</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test3()..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123; <span class="comment">// 为了升级接口的无奈之举.</span></span><br><span class="line">        System.out.println(<span class="string">"test2()...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-lambda表达式"><a href="#2-lambda表达式" class="headerlink" title="2.lambda表达式"></a>2.lambda表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lambbada表达式的作用是为了代替匿名内部类对象，使使用变得简单。</span><br><span class="line">前提：java中越来越成熟的推断机制</span><br><span class="line">省略了new I1()&#123;省略方法的修饰符，方法名&#125;，只留下了方法的输入（参数列表）和方法体</span><br><span class="line"></span><br><span class="line">方法参数列表中数据类型可以省，如果只有一个参数时，()也可以省略</span><br><span class="line">如果方法体中只有一行语句时，方法体的&#123;&#125;也可以省略</span><br><span class="line"></span><br><span class="line">只保留参数列表和方法体，lambda可以省略以上内容时因为编译器知道它的接口类型，可以通过接口来判断</span><br><span class="line"></span><br><span class="line">lambda只适用于接口中只有一个抽象方法的接口，大多数情况一般实现方法也就一条语句(当然也可以有多条语句)</span><br><span class="line"></span><br><span class="line">lambda的目的就是让使用者的关注焦点落在方法上，函数上</span><br><span class="line">函数y&#x3D;f(x),z&#x3D;f(x,y)，有输入有输出</span><br><span class="line">()-&gt;方法体</span><br><span class="line">参数：函数的输入</span><br><span class="line">方法体：函数的输出</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//void test2();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个接口, 包含一个抽象方法, void hello(String)</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(String string)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I3</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">test3</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">double</span> d, String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别使用匿名内部类和lambda完成实现, 并测试这个方法.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        I4 i41 = <span class="keyword">new</span> I4() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">double</span> d, String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"test4"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        I4 i42 = (n, d, s) -&gt; System.out.println(<span class="string">"test4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test32</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        I3 i31 = <span class="keyword">new</span> I3() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">test3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> String.valueOf(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        I3 i32 = n -&gt; String.valueOf(n);</span><br><span class="line"></span><br><span class="line">        String s = i32.test3(<span class="number">200</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        I3 i31 = <span class="keyword">new</span> I3() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">test3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> String.valueOf(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        I3 i32 = (<span class="keyword">int</span> n) -&gt; &#123;<span class="keyword">return</span> String.valueOf(n);&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test22</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        I2 i21 = <span class="keyword">new</span> I2() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">                System.out.println(string);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        i21.hello(<span class="string">"我是字符串"</span>);</span><br><span class="line"></span><br><span class="line">        I2 i22 = str -&gt; System.out.println(str); <span class="comment">// 参数列表中数据类型可以省, 如果方法体中只有一行语句时, 方法体的&#123;&#125;也可以省略</span></span><br><span class="line">        i22.hello(<span class="string">"我也是字符串"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        I2 i21 = <span class="keyword">new</span> I2() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">                System.out.println(string);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        i21.hello(<span class="string">"我是字符串"</span>);</span><br><span class="line"></span><br><span class="line">        I2 i22 = (String str) -&gt; &#123;System.out.println(str);&#125;;</span><br><span class="line">        i22.hello(<span class="string">"我也是字符串"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        I1 i1 = <span class="keyword">new</span> I1() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"匿名内部类实现"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(i1.test());</span><br><span class="line">        I1 i2 = () -&gt; &#123;<span class="keyword">return</span> <span class="string">"我是lambda实现"</span>;&#125;;</span><br><span class="line">        System.out.println(i2.test());</span><br><span class="line">        <span class="comment">//List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); // 右面的泛型可以省略,因为可以推断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1函数式接口"><a href="#2-1函数式接口" class="headerlink" title="2.1函数式接口"></a>2.1函数式接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">只包含一个抽象方法的接口，称为函数式接口(比如Runnable接口，里面只有一个抽象run()方法，Runnable接口就是一个函数式接口)。</span><br><span class="line">可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。</span><br><span class="line">我们可以在一个接口上使用 <span class="meta">@FunctionalInterface</span> 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</span><br><span class="line">在java.util.function包下定义了java <span class="number">8</span> 的丰富的函数式接口</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Java内置的四大核心函数式（关注点：是否有输入，是否有输出）"><a href="#Java内置的四大核心函数式（关注点：是否有输入，是否有输出）" class="headerlink" title="Java内置的四大核心函数式（关注点：是否有输入，是否有输出）"></a>Java内置的四大核心函数式（关注点：是否有输入，是否有输出）</h5><table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer<T>消费型接口</td>
<td>T</td>
<td>void</td>
<td>对类型为T的对象进行操作（消费掉），没有返回值，包含方法： void accept(T t)     比如System.out.println(“”)就是一种典型的消费方法，有输入，没有输出</td>
</tr>
<tr>
<td>Supplier<T>供给型接口</td>
<td>无</td>
<td>T</td>
<td>返回类型为T的对象，包含方法T get()   比如从对象工厂中获取对象实例的时候就属于供给型，无输入有输出</td>
</tr>
<tr>
<td>Function&lt;T,R&gt;函数型接口</td>
<td>T</td>
<td>R</td>
<td>对类型T的对象操作，并返回结果，结果是类型为R的对象。包含方法R apple(T t)  比如Integer.parseInt(“”)方法</td>
</tr>
<tr>
<td>Predicate<T>断定型接口</td>
<td>T</td>
<td>boolean</td>
<td>确定T类型的对象是否满足某约束，并返回boolean值，包含方法boolean test(T t)  比如equals()</td>
</tr>
</tbody></table>
<p>这些是比较常用的。</p>
<p>代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * 函数式接口 : 只有一个抽象方法的接口</span><br><span class="line"> * 关注方法的模式, 是否有输入 , 是否有输出</span><br><span class="line"> *</span><br><span class="line"> * Consumer&lt;T&gt; : 消费器, 消费一个T类型的对象, 没有返回.</span><br><span class="line"> *      <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> 有参无返回.</span></span><br><span class="line"><span class="function"> *</span></span><br><span class="line"><span class="function"> * Supplier&lt;T&gt; : 供给器, 供给一个T类型的对象, 不需要任何输入</span></span><br><span class="line"><span class="function"> *      T <span class="title">get</span><span class="params">()</span> 无参有返回</span></span><br><span class="line"><span class="function"> *</span></span><br><span class="line"><span class="function"> * Function&lt;T, R&gt; : 转换器, 把输入的T类型对象经过处理返回成一个R类型对象</span></span><br><span class="line"><span class="function"> *      R <span class="title">apply</span><span class="params">(T t)</span> 有参有返回</span></span><br><span class="line"><span class="function"> *</span></span><br><span class="line"><span class="function"> * Predicate&lt;T&gt; : 判定器, 判定输入的T对象是否满足某条件, 如果满足返回 <span class="keyword">true</span>, 不满足返回<span class="keyword">false</span></span></span><br><span class="line"><span class="function"> *     <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span> 有参固定返回布尔</span></span><br><span class="line"><span class="function"> *</span></span><br><span class="line"><span class="function"> * 方法引用 : 进一步简化lambda的写法</span></span><br><span class="line"><span class="function"> *      如果实现接口的lambda体中调用的别的方法的模式和接口中的方法模式一致时, 就可以使用方法引用</span></span><br><span class="line"><span class="function"> *      类 :: 方法名</span></span><br><span class="line"><span class="function"> *      对象 :: 方法名</span></span><br><span class="line"><span class="function"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class FunctionalInterfaceTest </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用匿名内部类和lambda分别完成一个判定器, 判断一个学生对象是否是3年级.</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exer4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">"小花"</span>, <span class="number">3</span>, <span class="number">50</span>);</span><br><span class="line">        Predicate&lt;Student&gt; predicate1 = <span class="keyword">new</span> Predicate&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> student.getGrade() == <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(predicate1.test(s));</span><br><span class="line">        Predicate&lt;Student&gt; predicate2 = t -&gt; t.getGrade() == <span class="number">3</span>;</span><br><span class="line">        System.out.println(predicate2.test(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Predicate&lt;String&gt; predicate1 = <span class="keyword">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s.endsWith(<span class="string">".java"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">boolean</span> abc = predicate1.test(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(abc);</span><br><span class="line">        Predicate&lt;String&gt; predicate2 = s -&gt; s.endsWith(<span class="string">".java"</span>);</span><br><span class="line">        System.out.println(predicate2.test(<span class="string">"asfj.java"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用匿名内部类和lambda分别完成一个转换器, 把一个学生对象转换成Double对象.</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exer3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="number">3</span>, <span class="string">"小刚"</span>, <span class="number">5</span>, <span class="number">80</span>);</span><br><span class="line">        Function&lt;Student, Double&gt; function1 = <span class="keyword">new</span> Function&lt;Student, Double&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Double <span class="title">apply</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> student.getScore();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Double apply = function1.apply(s1);</span><br><span class="line">        System.out.println(apply);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Function&lt;Student, Double&gt; function2 = t -&gt; t.getScore();</span></span><br><span class="line">        Function&lt;Student, Double&gt; function2 = Student::getScore;</span><br><span class="line">        System.out.println(function2.apply(s1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Function&lt;String, Integer&gt; function1 = <span class="keyword">new</span> Function&lt;String, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.valueOf(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Integer apply = function1.apply(<span class="string">"239"</span>);</span><br><span class="line">        System.out.println(apply);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Function&lt;String, Integer&gt; function2 = s -&gt; Integer.valueOf(s);</span></span><br><span class="line">        Function&lt;String, Integer&gt; function2 = Integer::valueOf;</span><br><span class="line">        Integer apply1 = function2.apply(<span class="string">"2983"</span>);</span><br><span class="line">        System.out.println(apply1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用匿名内部类和lambda分别完成一个供给器, 供给一个学生对象.</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exer2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Supplier&lt;Student&gt; supplier1 = <span class="keyword">new</span> Supplier&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"小黑"</span>, <span class="number">2</span>, <span class="number">80</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Student student = supplier1.get();</span><br><span class="line">        System.out.println(student);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Supplier&lt;Student&gt; supplier2 = () -&gt; new Student();</span></span><br><span class="line">        Supplier&lt;Student&gt; supplier2 = Student::<span class="keyword">new</span>; <span class="comment">// 引用无参构造器</span></span><br><span class="line">        System.out.println(supplier2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Supplier&lt;Integer&gt; supplier1 = <span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(supplier1.get());</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Integer&gt; supplier2 = () -&gt; (<span class="keyword">int</span>)(Math.random() * <span class="number">100</span>);</span><br><span class="line">        System.out.println(supplier2.get());</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Double&gt; supplier3 = () -&gt; Math.random();</span><br><span class="line">        Supplier&lt;Double&gt; supplier4 = Math::random; <span class="comment">// 和上面一回事</span></span><br><span class="line">        System.out.println(supplier3.get());</span><br><span class="line">        System.out.println(supplier4.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 练习 : 分别写一个消费器, 消费一个Student类型的对象.</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exer1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Consumer&lt;Student&gt; consumer1 = <span class="keyword">new</span> Consumer&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">                System.out.println(student);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Consumer&lt;Student&gt; consumer2 = t -&gt; System.out.println(t);</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"小爱"</span>, <span class="number">5</span>, <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">        consumer1.accept(s1);</span><br><span class="line">        consumer2.accept(s1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; consumer1 = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        consumer1.accept(<span class="string">"alskjdflkajsdf"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Consumer&lt;String&gt; consumer2 = t -&gt; System.out.println(t);</span></span><br><span class="line">        Consumer&lt;String&gt; consumer2 = System.out::println; <span class="comment">// 方法引用, 语法糖</span></span><br><span class="line">        consumer2.accept(<span class="string">"汉字中楞中"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-方法引用和构造器引用"><a href="#2-2-方法引用和构造器引用" class="headerlink" title="2.2 方法引用和构造器引用"></a>2.2 方法引用和构造器引用</h4><h5 id="2-2-1方法引用"><a href="#2-2-1方法引用" class="headerlink" title="2.2.1方法引用"></a>2.2.1方法引用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法引用 : 进一步简化lambda的写法</span><br><span class="line">如果实现接口的lambda体中调用的别的方法的模式和接口中的方法模式一致时, 就可以使用方法引用</span><br><span class="line">类 :: 方法名</span><br><span class="line">对象 :: 方法名</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer = s-&gt;System.out.println(s);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Consumer&lt;String&gt; consumer = System.out::println;</span><br><span class="line"></span><br><span class="line">Comparator&lt;Integer&gt; com = (x,y)-&gt;Integer.compare(x,y);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Comparator&lt;Integer&gt; com = Integer::compare;</span><br><span class="line"><span class="keyword">int</span> value = com.compare(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：当函数式接口方法第一个参数是需要引用方法的调用者，并且第二个参数是需要引用方法的参数（或无参时）：ClassName::methodName;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line">BiPredicate&lt;String,String&gt; bp = (x,y)-&gt;x.equals(y);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">BIpredicate&lt;String,String&gt; bp = String::equals;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-构造器引用"><a href="#2-2-2-构造器引用" class="headerlink" title="2.2.2  构造器引用"></a>2.2.2  构造器引用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：ClassName::new</span><br><span class="line">要求:构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。</span><br></pre></td></tr></table></figure>

<p>代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer,MyClass&gt; fun = n-&gt;<span class="keyword">new</span> MyClass(n);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Function&lt;Integer,MyClass&gt; fun = MyClass::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组引用   type[]::new</span></span><br><span class="line"></span><br><span class="line">Function&lt;Integer,Integer[]&gt; fun = n-&gt;<span class="keyword">new</span> Integer[n];</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Function&lt;Integer,Integer[]&gt; fun = Integer[]::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaSE</category>
        <category>Java8新特性</category>
      </categories>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2020/04/25/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>类加载器</title>
    <url>/2020/04/24/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引导类加载器：BootStrapClassLoader是由C++编写，负责最核心的类的加载，包括的就是JDK&#x2F;jre&#x2F;lib目录下的jar文件的加载</span><br><span class="line">扩展类加载器：ExtendClassLoader负责加载JDK&#x2F;jre&#x2F;lib&#x2F;ext目录下的jar</span><br><span class="line">系统类加载器(应用程序加载器)：负责加载-classpath环境变量中的类，包括导入的jar和src目录自己写的Java文件</span><br></pre></td></tr></table></figure>

<h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">系统类加载器会把所有类加载的任务先委派给扩展类加载器和引导类加载器，扩展类加载器和引导类加载器发现此类不该它们加载时，则拒绝加载，最后由系统类加载器加载。如果要加载的类是核心敏感类，双亲当仁不让，直接加载。</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// 最底层的是BootstrapClassLoader是由C++编写,负责最核心 的类的加载, 包括的就是JDK/jre/lib目录下的jar文件的加载</span></span><br><span class="line">       <span class="comment">// BootstrapClassLoader的上层是扩展类ExtClassLoader, 负责加载JDK/jre/lib/ext目录中的jar</span></span><br><span class="line">       <span class="comment">// ExtClassLoader的上层是系统类加载或应用程序类加载器, 负责加载 -classpath环境变量中的类, 包括导入的jar和src目录</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 双亲委派 : 系统类加载器会把所有类加载的任务先委派扩展类加载器和引导类加载器</span></span><br><span class="line">       <span class="comment">// 扩展类加载器和引导类加载器发现此类不该我加载, 拒绝, 请求驳回, 最后由系统类加载器加载</span></span><br><span class="line">       <span class="comment">// 如果要加载的类是核心敏感类, 双亲当仁不让, 直接加载, 系统类加载器就不加了.</span></span><br><span class="line">       ClassLoader classLoader1 = ClassLoader.getSystemClassLoader();</span><br><span class="line">       System.out.println(classLoader1);</span><br><span class="line">       ClassLoader classLoader2 = classLoader1.getParent();</span><br><span class="line">       System.out.println(classLoader2);</span><br><span class="line">       ClassLoader classLoader3 = classLoader2.getParent();<span class="comment">// 获取引导类加载器</span></span><br><span class="line">       System.out.println(classLoader3);</span><br><span class="line"></span><br><span class="line">       ClassLoader classLoader = Teacher<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">       System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">       ClassLoader classLoader4 = String<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>; <span class="comment">// 引导类加载器加载</span></span><br><span class="line">       System.out.println(classLoader4);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过类加载器加载资源文件"><a href="#通过类加载器加载资源文件" class="headerlink" title="通过类加载器加载资源文件"></a>通过类加载器加载资源文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 加载类路径中的资源文件 classpath</span></span><br><span class="line">        InputStream input = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">"com/sun/corba/se/impl/logging/LogStrings.properties"</span>);</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(input);</span><br><span class="line"></span><br><span class="line">        Enumeration&lt;?&gt; enumeration = properties.propertyNames();</span><br><span class="line">        <span class="keyword">while</span> (enumeration.hasMoreElements()) &#123;</span><br><span class="line">            Object name = enumeration.nextElement();</span><br><span class="line">            Object value = properties.get(name);</span><br><span class="line">            System.out.println(name + <span class="string">" &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; "</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2020/04/24/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h3 id="1-什么是反射？"><a href="#1-什么是反射？" class="headerlink" title="1. 什么是反射？"></a>1. 什么是反射？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反射被视为动态语言的关键，反射机制允许程序在执行期借助Reflection API来取得任意类的内部信息，并能直接操作任意的对象的内部属性和方法。</span><br></pre></td></tr></table></figure>



<h3 id="2-反射有什么用？"><a href="#2-反射有什么用？" class="headerlink" title="2. 反射有什么用？"></a>2. 反射有什么用？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	反射机制提供了以下功能：</span><br><span class="line">1）在运行时判断任意一个对象的所属类</span><br><span class="line">2）在运行时构建任意一个类的对象</span><br><span class="line">3）在运行时可以获取任意一个类的成员变量和方法</span><br><span class="line">4）在运行时调用任意一个类的成员变量和方法</span><br><span class="line">5）生成动态代理</span><br></pre></td></tr></table></figure>



<h3 id="3-反射主要的API"><a href="#3-反射主要的API" class="headerlink" title="3. 反射主要的API"></a>3. 反射主要的API</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.Class:代表一个类</span><br><span class="line">java.lang.reflect.Method:类的方法</span><br><span class="line">java.lang.reflect.Field:类的成员变量</span><br><span class="line">java.lang.reflect.Constructor:类的构造方法</span><br></pre></td></tr></table></figure>

<h3 id="4-Class类"><a href="#4-Class类" class="headerlink" title="4. Class类"></a>4. Class类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Obejct类中有一个方法public final Class getClass()，Class类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射出类的名称</span><br><span class="line">正常方式：引入需要的“包类”名称--&gt;通过new实例化--&gt;取得实例化结果</span><br><span class="line">反射方式：实例化对象--&gt;getClass()方法--&gt;得到完整的“包类”名称</span><br><span class="line">可以从获取到的Class类对象中得知某个类的属性，方法和构造器以及这个类实现了哪些接口。</span><br><span class="line">Class对象只能由系统建立对象</span><br><span class="line">一个类在JVM中只会有一个Class实例</span><br><span class="line">一个Class对象对应的是一个加载到JVM中的.class文件</span><br><span class="line">每个类的实例都会记得自己是由哪个Class实例所生成的</span><br><span class="line">通过Class可以完成地得到一个类中的完整结构</span><br></pre></td></tr></table></figure>

<h3 id="5-Class类的常用方法"><a href="#5-Class类的常用方法" class="headerlink" title="5. Class类的常用方法"></a>5. Class类的常用方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static Class forName(String name)</span><br><span class="line">Object newInstance()</span><br><span class="line">String getName()</span><br><span class="line">Class[] getInterfaces()</span><br><span class="line">ClassLoader getClassLoader()</span><br><span class="line">Class getSuperClass()</span><br><span class="line">Constructor[] getConstructors()</span><br><span class="line">Field[] getDeclaredFields()</span><br><span class="line">Method getMethod(String name,Class...paramTypes)&#x2F;&#x2F;获取本类以及父类中的所有public方法，这里的父类，指的是继承层次中的所有父类。比如说，A继承B，B继承C，那么B和C都属于A的父类。</span><br><span class="line">Method getDeclaredMethod(String name,Class...paramTypes)&#x2F;&#x2F;获取当前类的所有声明的方法，包括public、protected和private修饰的方法。需要注意的是，这些方法一定是在当前类中声明的，从父类中继承的不算，实现接口的方法由于有声明所以包括在内。</span><br></pre></td></tr></table></figure>

<h3 id="6-实例化Class类对象的四种方法"><a href="#6-实例化Class类对象的四种方法" class="headerlink" title="6. 实例化Class类对象的四种方法"></a>6. 实例化Class类对象的四种方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）前提：若已知具体的类，通过类的<span class="class"><span class="keyword">class</span>属性获取，该方法最为安全可靠，程序性能最高</span></span><br><span class="line"><span class="class">       实例：<span class="title">Class</span> <span class="title">clazz</span> </span>= String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="number">2</span>）前提：已知某个类的实例，调用该实例的getClass()方法获取Class对象</span><br><span class="line">       实例：Class clazz = “www.atguigu.com”.getClass();</span><br><span class="line"><span class="number">3</span>）前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException</span><br><span class="line">       实例：Class clazz = Class.forName(“java.lang.String”);</span><br><span class="line"><span class="number">4</span>）其他方式(不做要求)</span><br><span class="line">ClassLoader cl = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">Class clazz4 = cl.loadClass(“类的全类名”);</span><br></pre></td></tr></table></figure>

<h3 id="7-示例代码"><a href="#7-示例代码" class="headerlink" title="7. 示例代码"></a>7. 示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.javase.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射 : 先获取到类模板, 再从类模板展开, 进一步使用对象.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 获取类模板对象的方式 :</span></span><br><span class="line"><span class="comment"> *      1) 已知类, 使用类的静态属性.class来获取, 这种方式最安全,高效..  属于硬编码</span></span><br><span class="line"><span class="comment"> *          Class clazz = Teacher.class;</span></span><br><span class="line"><span class="comment"> *          String.class, int.class, double.class,</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      2) 已经对象, 通过对象的getClass()获取相应的类模板对象. 安全,高效, 硬编码</span></span><br><span class="line"><span class="comment"> *          Class clazz = new Teacher().getClass();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      3) Class clazz = Class.forName("类的全限定名称"); 这是反射的基础, 属性软编码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      4) 通过类加载器对象.loadClass("类的全限定名称")</span></span><br><span class="line"><span class="comment"> *          Class clazz = this.getClass().getClassLoader().loadClass("类的全名");</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) <span class="comment">// 停留期必须到运行时..</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> 10</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "缺省值"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnnotation</span>(<span class="string">"我是一个值"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">ArrayList</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Serializable</span>, <span class="title">Callable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String school = <span class="string">"atguigu"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name, <span class="keyword">int</span> age, String gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Teacher&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", gender='"</span> + gender + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lesson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lesson</span><span class="params">(String content, <span class="keyword">int</span> hours)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" 老师在上["</span> + content + <span class="string">"]课, 共上了["</span> + hours + <span class="string">"]小时"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"我是一个无端的错误"</span>);</span><br><span class="line">        <span class="comment">//return "上课OK";</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test12</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.atguigu.javase.reflect.Teacher"</span>);</span><br><span class="line">        <span class="comment">// 只能反射能处理注解, 并且注解必须停留到Runtime</span></span><br><span class="line">        MyAnnotation annotation = (MyAnnotation)clazz.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(annotation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 静态成员的访问不需要this目标对象.</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.atguigu.javase.reflect.Teacher"</span>);</span><br><span class="line">        Field school = clazz.getField(<span class="string">"school"</span>);</span><br><span class="line">        Object o = school.get(<span class="keyword">null</span>); <span class="comment">// ? 会不会抛出空指针 ?? 静态属性的访问完全忽略参数</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">        Method test = clazz.getMethod(<span class="string">"test"</span>);</span><br><span class="line">        test.invoke(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">"com.atguigu.javase.reflect.Teacher"</span>);</span><br><span class="line">            Object object = clazz.newInstance();</span><br><span class="line">            <span class="comment">// getMethod获取的是本类及从父类继承的所有公共方法</span></span><br><span class="line">            <span class="comment">//Method method = clazz.getMethod("lesson", String.class, int.class);</span></span><br><span class="line">            <span class="comment">// getDeclaredMethod可以获取本类声明的任意方法, 包括私有的.</span></span><br><span class="line">            Method method = clazz.getDeclaredMethod(<span class="string">"lesson"</span>, String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>); <span class="comment">// 突破封装</span></span><br><span class="line">            Object ret = method.invoke(object, <span class="string">"MyBatis"</span>, (<span class="keyword">short</span>)<span class="number">5</span>);</span><br><span class="line">            <span class="comment">//System.out.println(ret);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123; <span class="comment">// 访问私有成员</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123; <span class="comment">// 创建对象时出异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123; <span class="comment">// 方法定位失败</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;<span class="comment">// 调用的目标方法出现异常时</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">"com.atguigu.javase.reflect.Teacher"</span>);</span><br><span class="line">            <span class="comment">//Object o = clazz.newInstance(); // 没有无参构造器时出错</span></span><br><span class="line">            <span class="comment">//public Teacher(String name, int age, String gender) &#123;</span></span><br><span class="line">            Constructor constructor = clazz.getConstructor(Class.forName(<span class="string">"java.lang.String"</span>), <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;<span class="comment">// 形参类型列表</span></span><br><span class="line">            Object obj = constructor.newInstance(<span class="string">"佟刚"</span>, <span class="number">40</span>, <span class="string">"男"</span>); <span class="comment">// 需要实参列表</span></span><br><span class="line">            System.out.println(obj);</span><br><span class="line">            <span class="comment">// 先获取方法对象, 再配合目标this</span></span><br><span class="line">            <span class="comment">//public String lesson(String content, int hours) &#123;</span></span><br><span class="line">            Method lessonMethod = clazz.getMethod(<span class="string">"lesson"</span>, String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span> )</span>;<span class="comment">// 第一个参数是方法名, 后面是形参类型列表</span></span><br><span class="line">            Object retValue = lessonMethod.invoke(obj, <span class="string">"JavaWEB"</span>, <span class="number">3</span>);<span class="comment">//等效于 obj.lesson("javaWeb", 3);</span></span><br><span class="line">            System.out.println(retValue); <span class="comment">// 如果实际调用的方法没有返回值, 这里的返回值就是null</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 加载类路径中的资源文件 classpath</span></span><br><span class="line">        InputStream input = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">"com/sun/corba/se/impl/logging/LogStrings.properties"</span>);</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(input);</span><br><span class="line"></span><br><span class="line">        Enumeration&lt;?&gt; enumeration = properties.propertyNames();</span><br><span class="line">        <span class="keyword">while</span> (enumeration.hasMoreElements()) &#123;</span><br><span class="line">            Object name = enumeration.nextElement();</span><br><span class="line">            Object value = properties.get(name);</span><br><span class="line">            System.out.println(name + <span class="string">" &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; "</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 最底层的是BootstrapClassLoader是由C++编写,负责最核心 的类的加载, 包括的就是JDK/jre/lib目录下的jar文件的加载</span></span><br><span class="line">        <span class="comment">// BootstrapClassLoader的上层是扩展类ExtClassLoader, 负责加载JDK/jre/lib/ext目录中的jar</span></span><br><span class="line">        <span class="comment">// ExtClassLoader的上层是系统类加载或应用程序类加载器, 负责加载 -classpath环境变量中的类, 包括导入的jar和src目录</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双亲委派 : 系统类加载器会把所有类加载的任务先委派扩展类加载器和引导类加载器</span></span><br><span class="line">        <span class="comment">// 扩展类加载器和引导类加载器发现此类不该我加载, 拒绝, 请求驳回, 最后由系统类加载器加载</span></span><br><span class="line">        <span class="comment">// 如果要加载的类是核心敏感类, 双亲当仁不让, 直接加载, 系统类加载器就不加了.</span></span><br><span class="line">        ClassLoader classLoader1 = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(classLoader1);</span><br><span class="line">        ClassLoader classLoader2 = classLoader1.getParent();</span><br><span class="line">        System.out.println(classLoader2);</span><br><span class="line">        ClassLoader classLoader3 = classLoader2.getParent();<span class="comment">// 获取引导类加载器</span></span><br><span class="line">        System.out.println(classLoader3);</span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader = Teacher<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader4 = String<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>; <span class="comment">// 引导类加载器加载</span></span><br><span class="line">        System.out.println(classLoader4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazzI = Integer<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Class clazzi = <span class="keyword">int</span><span class="class">.<span class="keyword">class</span></span>; <span class="comment">// 只要是数据类型, 一定有相应的类模板对象.</span></span><br><span class="line">        System.out.println(clazzI == clazzi); <span class="comment">// 包装类型和基本类型不是同一类型</span></span><br><span class="line">        <span class="comment">//clazzi.newInstance(); // 什么都不能做, 唯一能做的事情就是作为一个标识, 表明它是int类型</span></span><br><span class="line">        System.out.println(clazzi.isPrimitive()); <span class="comment">// 判断类模板表示的类型是否是基本型</span></span><br><span class="line">        System.out.println(clazzI.isPrimitive());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"**************************************************"</span>);</span><br><span class="line"></span><br><span class="line">        Class clazz1 = Teacher<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Class clazz2 = <span class="keyword">new</span> Teacher(<span class="string">"a"</span>, <span class="number">2</span>, <span class="string">"b"</span>).getClass();</span><br><span class="line">        System.out.println(clazz1 == clazz2);</span><br><span class="line">        Class clazz3 = Class.forName(<span class="string">"com.atguigu.javase.reflect.Teacher"</span>);</span><br><span class="line">        System.out.println(clazz1 == clazz3);</span><br><span class="line">        ClassLoader classLoader = <span class="keyword">this</span>.getClass().getClassLoader(); <span class="comment">// 了解</span></span><br><span class="line">        Class clazz4 = classLoader.loadClass(<span class="string">"com.atguigu.javase.reflect.Teacher"</span>);</span><br><span class="line">        System.out.println(clazz3 == clazz4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 有了类模板, 可以获取和这个类相关的所有信息</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.atguigu.javase.reflect.Teacher"</span>);</span><br><span class="line">        Class&lt;?&gt; superclass = clazz.getSuperclass();<span class="comment">// 获取父类类型</span></span><br><span class="line">        System.out.println(superclass);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt;[] interfaces = clazz.getInterfaces();<span class="comment">// 获取实现的所有接口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">            System.out.println(interfaces[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader = clazz.getClassLoader();<span class="comment">// 当前加载类模板的类加器对象</span></span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">"com.atguigu.javase.reflect.Teacher"</span>);</span><br><span class="line">            Object object1 = clazz.newInstance();</span><br><span class="line">            System.out.println(object1);</span><br><span class="line">            <span class="comment">// getField无法获取私有属性定义, 其实它只能获取公共的属性定义, 包括本类的和父类继承的.</span></span><br><span class="line">            <span class="comment">//Field nameField = clazz.getField("name");</span></span><br><span class="line">            Field nameField = clazz.getDeclaredField(<span class="string">"name"</span>); <span class="comment">// 获取本类中声明的任意属性, 当然也包括私有的.</span></span><br><span class="line">            nameField.setAccessible(<span class="keyword">true</span>); <span class="comment">// 设置为可访问, 就可以访问了. 暴力反射!!! 强烈不建议. 突破封装性.</span></span><br><span class="line">            nameField.set(object1, <span class="string">"佟刚"</span>);</span><br><span class="line"></span><br><span class="line">            Field ageField = clazz.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">            ageField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            ageField.set(object1, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">            Field genderField = clazz.getDeclaredField(<span class="string">"gender"</span>);</span><br><span class="line">            genderField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            genderField.set(object1, <span class="string">"男"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(object1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; <span class="comment">// 类名错误或类真的不存在</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123; <span class="comment">// 访问了没有访问权限的成员. 比如访问了私有成员.</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123; <span class="comment">// 在创建对象时构造器定位失败.</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123; <span class="comment">// 查找属性定义时, 属性名错误或属性定义不存在</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">"com.atguigu.javase.reflect.Teacher"</span>);</span><br><span class="line">            Object object1 = clazz.newInstance();</span><br><span class="line">            System.out.println(object1);</span><br><span class="line">            <span class="comment">//((Teacher)object1).name = "佟刚"; // 之前的方式</span></span><br><span class="line">            <span class="comment">// 先找到属性定义对象, 再配合this对象, 完成属性访问</span></span><br><span class="line">            Field nameField = clazz.getField(<span class="string">"name"</span>); <span class="comment">// Field就是属性定义对象</span></span><br><span class="line">            nameField.set(object1, <span class="string">"佟刚"</span>); <span class="comment">// object1.name = "佟刚", 对象属性必须配合this对象, 才能完成访问</span></span><br><span class="line">            System.out.println(nameField.get(object1)); <span class="comment">// 获取属性值 System.out.println(object1.name);</span></span><br><span class="line">            Field ageField = clazz.getField(<span class="string">"age"</span>);</span><br><span class="line">            ageField.set(object1, <span class="number">40</span>);<span class="comment">// 修改age属性</span></span><br><span class="line">            Field genderField = clazz.getField(<span class="string">"gender"</span>);<span class="comment">// 修改gender属性</span></span><br><span class="line">            genderField.set(object1, <span class="string">"男"</span>); <span class="comment">// object.gender = "男"</span></span><br><span class="line">            System.out.println(object1);</span><br><span class="line"></span><br><span class="line">            Object object2 = clazz.newInstance();</span><br><span class="line">            <span class="comment">// 属性定义就一个</span></span><br><span class="line">            nameField.set(object2, <span class="string">"宁姐"</span>); <span class="comment">//object2.name = "宁姐";</span></span><br><span class="line">            ageField.set(object2, <span class="number">20</span>);</span><br><span class="line">            genderField.set(object2, <span class="string">"女"</span>);</span><br><span class="line">            System.out.println(object2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; <span class="comment">// 类名错误或类真的不存在</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123; <span class="comment">// 访问了没有访问权限的成员. 比如访问了私有成员.</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123; <span class="comment">// 在创建对象时构造器定位失败.</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123; <span class="comment">// 查找属性定义时, 属性名错误或属性定义不存在</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 干预类的加载</span></span><br><span class="line">        <span class="comment">//Class clazz = Class.forName("类的全限定名称"); // 结果就是类模板对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 手工加载类模板, 结果就是获取到了类模板对象, 根据类名加载类模板. 动态加载类</span></span><br><span class="line">            <span class="comment">// 编译时不检查, 运行时出问题, 推迟到了运行时, 称为软编码, 类的提供的时机可以延迟到运行时.</span></span><br><span class="line">            Class clazz = Class.forName(<span class="string">"com.atguigu.javase.reflect.Teacher"</span>); <span class="comment">// 结果就是类模板对象, 参数中的类名必须全限定</span></span><br><span class="line">            <span class="comment">// 依据类模板创建对象, 通过方法来创建, 像工厂, 调用了无参构造器创建对象.</span></span><br><span class="line">            Object object1 = clazz.newInstance(); <span class="comment">// clazz是Teacher类模板, 所以创建出来的对象就是Teacher对象</span></span><br><span class="line">            System.out.println(object1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; <span class="comment">// 类名错误或类真的不存在</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123; <span class="comment">// 访问了没有访问权限的成员. 比如访问了私有成员.</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123; <span class="comment">// 在创建对象时构造器定位失败.</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Teacher t1 = new Teacher();// 无参构造方法, 问题暴露在编译时, 对Teacher是一种强依赖, 硬编码..</span></span><br><span class="line">        <span class="comment">//t1.name = "佟刚"; // set</span></span><br><span class="line">        <span class="comment">//t1.age = 40;</span></span><br><span class="line">        <span class="comment">//t1.gender = "男";</span></span><br><span class="line">        <span class="comment">//System.out.println(t1.name); // get</span></span><br><span class="line">        <span class="comment">//System.out.println(t1.age);</span></span><br><span class="line">        <span class="comment">//System.out.println(t1.gender);</span></span><br><span class="line">        <span class="comment">//System.out.println(t1);</span></span><br><span class="line"></span><br><span class="line">        Teacher t2 = <span class="keyword">new</span> Teacher(<span class="string">"宁姐"</span>, <span class="number">20</span>, <span class="string">"女"</span>);</span><br><span class="line">        System.out.println(t2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2020/04/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序：硬盘上保存的可以执行的文件</span><br><span class="line"></span><br><span class="line">进程：运行中的程序，体现多任务，进程之间无法直接传递数据</span><br><span class="line"></span><br><span class="line">线程：进程中的子任务，线程之间可以直接通讯，线程是可以直接由CPU调度的</span><br></pre></td></tr></table></figure>

<h3 id="什么时候需要用到多线程"><a href="#什么时候需要用到多线程" class="headerlink" title="什么时候需要用到多线程"></a>什么时候需要用到多线程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序需要同时执行两个或多个任务。</span><br><span class="line">程序需要实现一些需要等待的任务时，如用户的输入、文件读写操作、网络操作、搜索等。</span><br><span class="line">需要一些后台运行的程序时。</span><br></pre></td></tr></table></figure>

<h3 id="线程的创建和使用"><a href="#线程的创建和使用" class="headerlink" title="线程的创建和使用"></a><em>线程的创建和使用</em></h3><p>创建线程的方式有以下四种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.直接继承Thread类，重写Thread类的run()方法</span><br><span class="line">2.实现Runnable接口，实现run()方法，生成一个Runnable实现类的对象runner,生成一个Thread对象，实参为runner</span><br></pre></td></tr></table></figure>

<p>第一种方式示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">"子线程"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">200</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="string">""</span>)&#123;<span class="comment">//任意对象都可以做锁对象，但必须是所有线程共享的同一个对象，互斥锁,用全局常量即可</span></span><br><span class="line">               counter -= <span class="number">2</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">10</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.print(Thread.currentThread().getName() + <span class="string">":"</span> + counter + <span class="string">" "</span>);</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">10</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Counter counter = <span class="keyword">new</span> Counter();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(counter);</span><br><span class="line">        thread1.setName(<span class="string">"线程1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(counter);</span><br><span class="line">        thread2.setName(<span class="string">"线程2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这两种方法创建线程执行run()方法是没有返回值的，不知道具体的执行情况，下面两种是可以获取到返回值的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.实现Callable接口</span><br><span class="line">1)写一个具体类实现Callable接口，并实现方法call()</span><br><span class="line">2)创建一个FutureTask对象，关联Callable，FutureTask也实现了Runnable接口，相当于Runnable对象	</span><br><span class="line">3）再以FutureTask对象为实参，创建Thread对象</span><br><span class="line">4）调用Thread的start()方法</span><br></pre></td></tr></table></figure>

<p>第三种方式示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Callable callable = <span class="keyword">new</span> Callable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span> + ((<span class="keyword">int</span>) (Math.random() * <span class="number">100</span> + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask(callable);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String s = futureTask.get();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.使用线程池：统一调度线程的创建和使用。Executor，ExecutorService</span><br><span class="line">1)写一个具体类实现Callable接口，实现call()方法</span><br><span class="line">2)通过工具类Executors.newXxx来创建线程池</span><br><span class="line">3)把具体的Callable对象提交给线程池，并获取相应的task对象，用于获取将来的值</span><br><span class="line">4)调用线程的shutdown方法</span><br><span class="line">5)依次从task对象获取将来的值（线程执行后的返回值）</span><br></pre></td></tr></table></figure>

<p>第四种方式示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//1.写一个具体类实现Callable接口</span></span><br><span class="line">      Callable callable = <span class="keyword">new</span> Callable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">":"</span> + ((<span class="keyword">int</span>) (Math.random() * <span class="number">100</span> + <span class="number">1</span>));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">//2.通过工具类Executors获取线程池对象</span></span><br><span class="line">      ExecutorService executorService = Executors.newCachedThreadPool();<span class="comment">//自动缓冲的线程池</span></span><br><span class="line">      <span class="comment">// ExecutorService executorService = Executors.newFixedThreadPool(30);// 固定个数的线程池, 不太好用</span></span><br><span class="line">      <span class="comment">// ExecutorService executorService = Executors.newWorkStealingPool();// 工作窃取线程池, 最好用的.</span></span><br><span class="line">      <span class="comment">//3.把具体的callable对象交给线程池，并获取相应的task对象，用于获取将来的值</span></span><br><span class="line">      List&lt;Future&lt;String&gt;&gt; futureList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">          Future future = executorService.submit(callable);</span><br><span class="line">          futureList.add(future);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.调用线程池的shutdown()方法</span></span><br><span class="line">      executorService.shutdown();<span class="comment">//发出通知，线程池不再添加新任务了，执行当前所有任务后就结束</span></span><br><span class="line">      <span class="comment">//5.依次从future对象中获取将来的值</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; futureList.size(); i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              String s = futureList.get(i).get();<span class="comment">//get()方法是个阻塞方法，可通过下面的代码提高效率</span></span><br><span class="line">              System.out.println(s);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//上面for()的优化</span></span><br><span class="line">      <span class="comment">/*while(futureList.size() &gt; 0)&#123;//任务列表不为空，则一直寻找已经完成的任务</span></span><br><span class="line"><span class="comment">          for (int i = 0; i &lt; futureList.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">              if(futureList.get(i).isDone())&#123;</span></span><br><span class="line"><span class="comment">                  //遍历的作用是优先获取已经完成的任务</span></span><br><span class="line"><span class="comment">                  //表示当前的线程任务已完成，可获取返回值了</span></span><br><span class="line"><span class="comment">                  try &#123;</span></span><br><span class="line"><span class="comment">                      String s = futureList.get(i).get();</span></span><br><span class="line"><span class="comment">                      System.out.println(s);</span></span><br><span class="line"><span class="comment">                  &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                      e.printStackTrace();</span></span><br><span class="line"><span class="comment">                  &#125; catch (ExecutionException e) &#123;</span></span><br><span class="line"><span class="comment">                      e.printStackTrace();</span></span><br><span class="line"><span class="comment">                  &#125;</span></span><br><span class="line"><span class="comment">                  futureList.remove(i);//以访问到返回值，删除减少任务列表</span></span><br><span class="line"><span class="comment">                  break;</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">      &#125;*/</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程池和自己创建线程对比"><a href="#线程池和自己创建线程对比" class="headerlink" title="线程池和自己创建线程对比"></a>线程池和自己创建线程对比</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Thread的弊端</span><br><span class="line">1）线程缺乏统一管理，可能无限制新建线程，相互之间竞争，有可能占用过多系统资源导致死机或者oom</span><br><span class="line">2）功能过于单一，如没有定时执行，定期执行，线程中断</span><br><span class="line"></span><br><span class="line">相比new Thread，线程池的好处：</span><br><span class="line">1）重用存在的线程，减少对象的创建，消亡的开销</span><br><span class="line">2）可有效控制最大最大并发线程数，提高系统资源的利用率，同时避免过多资源竞争，避免堵塞</span><br><span class="line">3）提供定时执行，定期执行，并发控制等功能</span><br></pre></td></tr></table></figure>







<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程有以下5个状态：</span><br><span class="line">1）新建：当一个Thread类或其子类对象被创建时，新生的线程对象处于新建状态</span><br><span class="line">2）就绪：处于新建状态的线程被start()后，将进入线程等待cpu时间片，此时除于就绪状态</span><br><span class="line">3）运行：当就绪的线程被调度并获得处理器资源时，此时线程进入了运行状态，run()方法定义了线程的操作和功能</span><br><span class="line">4）阻塞：在某些特殊情况下，比如执行wait()方法，以及Thread.sleep()方法，以及等待输入输出时，线程会临时终止自己的运行,这个时候就进入了阻塞状态</span><br><span class="line">5）死亡：线程完成了它的全部工作或线程提前被强制性终止</span><br></pre></td></tr></table></figure>

<p>下面是线程状态的转换图</p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt=""></p>
<h3 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a><em>线程的同步</em></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多个线程之间是不能直接传递数据交互的，它们之间的交互需要通过共享变量来实现。多个线程执行的不确定性会引起结果执行的不稳定。所以需要对共享变量的操作包装为原子性操作。可以通过synchronized关键字实现。synchronized修饰静态方法时，锁为当前类对象；synchronized修饰非静态方法时，锁为this对象；synchronized修饰代码块时为同步代码块，可以指定任意对象为锁,最好以常量对象作为锁，比如&quot;&quot;。</span><br><span class="line">每个对象都对应一个可称为“互斥锁”的标记，这个标记用来保证某一时刻，只能有某一线程访问某个对象。</span><br></pre></td></tr></table></figure>

<h3 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wait()与notify()和notifyAll()</span><br><span class="line">wait():令当前线程挂起并释放CPU，等待同步资源，释放锁对象，使别的线程可访问并修改共享数据，需要等待被其它共用同一把锁的线程唤醒</span><br><span class="line">notify():唤醒正在排队等待同步资源的线程中优先级最高者结束等待</span><br><span class="line">notifyAll():唤醒正在排队等待资源的所有线程结束等待</span><br><span class="line"></span><br><span class="line">因为任意对象都可以作为锁对象，所以这3个方法使定义在Java.lang.Object中。这3个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.illegalMonitorStateException.</span><br><span class="line"></span><br><span class="line">调用方式为:锁对象.wait(),锁对象.notify(),锁对象.notifyAll()</span><br></pre></td></tr></table></figure>

<p>线程的同步通信代码示例，下面以存款取款两个线程为例</p>
<p>1.定义账户Account类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String name,<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.定义存钱和取钱的类（均实现了Runnable接口）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deposit</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">private</span> Runnable withdraw;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Deposit</span><span class="params">(Account account,Runnable withdraw)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.withdraw = withdraw;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="string">""</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> money = (<span class="keyword">int</span>)(Math.random()*<span class="number">2000</span> + <span class="number">1</span>);</span><br><span class="line">                account.setMoney(account.getMoney() + money);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"存钱"</span> + money + <span class="string">",余额为："</span> + account.getMoney());</span><br><span class="line">                <span class="keyword">if</span>(((Withdraw)withdraw).getMoney() &lt; account.getMoney())&#123;</span><br><span class="line">                    <span class="comment">//这里是判断账户中的钱是否够取，够则唤醒取钱线程，其实也可以取钱线程那只要钱不够取就循环wait也可以，这里直接notify就不用加判断条件了</span></span><br><span class="line">                    <span class="string">""</span>.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Withdraw</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Withdraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Withdraw</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                 money = ((<span class="keyword">int</span>)(Math.random()*<span class="number">3000</span>)) + <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">synchronized</span> (<span class="string">""</span>)&#123;</span><br><span class="line">                     <span class="keyword">if</span>(money &gt; account.getMoney())&#123;</span><br><span class="line">                         <span class="keyword">try</span> &#123;</span><br><span class="line">                             System.out.println(<span class="string">"余额为"</span> + account.getMoney()  + <span class="string">"，想取"</span> + money +<span class="string">",钱不够取，进入等待状态"</span>);</span><br><span class="line">                             <span class="string">""</span>.wait();</span><br><span class="line">                         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                             e.printStackTrace();</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                         account.setMoney(account.getMoney() - money);</span><br><span class="line">                         System.out.println(Thread.currentThread().getName() + <span class="string">"取钱"</span> + money + <span class="string">",余额为："</span> + account.getMoney());</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main函数如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 让取钱线程每次取随机的钱, 存钱线程也存入随机的钱</span></span><br><span class="line"><span class="comment">保证账号不要负数...</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account(<span class="string">"jack"</span>,<span class="number">5000</span>);</span><br><span class="line">        Withdraw withdraw = <span class="keyword">new</span> Withdraw(account);</span><br><span class="line">        Deposit deposit = <span class="keyword">new</span> Deposit(account,withdraw);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(withdraw);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(deposit);</span><br><span class="line">        thread1.setName(<span class="string">"取钱线程"</span>);</span><br><span class="line">        thread2.setName(<span class="string">"存钱线程"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>File类</title>
    <url>/2020/04/21/File%E7%B1%BB/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>编码</title>
    <url>/2020/04/20/%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">编码表的由来：</span><br><span class="line">计算机只能识别二进制数据，早期由来时电信号。为了方便应用计算机，让它可以识别各个国家的文字。就将各个国家的的文字用数字来表示，并一一对应，形成一张表。这就是编码表</span><br></pre></td></tr></table></figure>

<h4 id="常见的编码表"><a href="#常见的编码表" class="headerlink" title="常见的编码表"></a>常见的编码表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unicode:国际标准码，所有文字都用两个字节来表示，Java语言使用的就是Unicode</span><br><span class="line">UTF-8:通常用三个字节来表示一个字符</span><br><span class="line">GBK：中国的中文编码</span><br><span class="line"></span><br><span class="line">编码：字符串&#x3D;&gt;字节数组</span><br><span class="line">解码：字节数组&#x3D;&gt;字符串</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>hashMap源码分析</title>
    <url>/2020/04/20/hashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>树</title>
    <url>/2020/04/19/%E6%A0%91/</url>
    <content><![CDATA[<h3 id="一、二叉树"><a href="#一、二叉树" class="headerlink" title="一、二叉树"></a>一、二叉树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二叉树是每个节点最多有两个子树的树结构。它有5种基本形态：</span><br><span class="line">1.空二叉树</span><br><span class="line">2.只有根节点，没有左右子树</span><br><span class="line">3.只有左子树</span><br><span class="line">4.只有右子树</span><br><span class="line">5.有左子树跟右子树</span><br></pre></td></tr></table></figure>

<p><img src="http://q7s8mko1o.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%845%E7%A7%8D%E5%BD%A2%E6%80%81.png" alt="二叉树基本形态"></p>
<h4 id="二叉树的基本性质"><a href="#二叉树的基本性质" class="headerlink" title="二叉树的基本性质"></a>二叉树的基本性质</h4><ul>
<li><input disabled="" type="checkbox"> <table>
<thead>
<tr>
<th align="left">性质1</th>
<th>非空二叉树上叶子节点数等于双分支节点数加1</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>性质2</strong></td>
<td>二叉树的第i层最多有2^(i-1)个节点</td>
</tr>
<tr>
<td align="left"><strong>性质3</strong></td>
<td>高度为k的二叉树最多有2^k - 1个节点</td>
</tr>
<tr>
<td align="left"><strong>性质4</strong></td>
<td>给定n个节点，能构成h(n)种不同的二叉树，h(n) = C_{2n}^{n}/n+1</td>
</tr>
<tr>
<td align="left"><strong>性质5</strong></td>
<td>具有n个节点的完全二叉树的高度为<code>【log2n】</code>(向下取整)+ 1</td>
</tr>
</tbody></table>
</li>
</ul>
<p>两个特别的二叉树：完全二叉树，满二叉树</p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt=""></p>
<h4 id="二叉树常见的存储方法"><a href="#二叉树常见的存储方法" class="headerlink" title="二叉树常见的存储方法"></a>二叉树常见的存储方法</h4><p>1.通过数组存储</p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8.png" alt=""></p>
<p>2.通过链表存储</p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.png" alt=""></p>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>1.先序遍历</p>
<p>2.中序遍历</p>
<p>3.后序遍历</p>
<p>4.层次遍历</p>
<h3 id="二、二叉排序树"><a href="#二、二叉排序树" class="headerlink" title="二、二叉排序树"></a>二、二叉排序树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二叉排序树又称为二叉查找树、二叉搜索树。它或者是一颗空树，或者是一颗具有如下性质的二叉树：</span><br><span class="line">1）若左子树不空，则左子树上的所有结点的值均小于根结点的值</span><br><span class="line">2）若右子树不空，则右子树的所有结点的值均大于它的根结点的值</span><br><span class="line">3）左右子树也分别为二叉排序树</span><br></pre></td></tr></table></figure>

<p><img src="http://q7s8mko1o.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91.png" alt=""></p>
<p>其高度和结点的个数n为对数关系，检索的时间跟高度为线性关系，故时间复杂度为O(logn)，但是也有可能检索的时间变成线性的情况</p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/%E7%BA%BF%E6%80%A7%E6%83%85%E5%86%B5.png" alt=""></p>
<h3 id="三、哈夫曼树"><a href="#三、哈夫曼树" class="headerlink" title="三、哈夫曼树"></a>三、哈夫曼树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">哈夫曼树也叫最优二叉树，一种带权路径长度（WPL）最短的二叉树。</span><br><span class="line">树的带权路径长度：树中所有的叶子结点的带权路径（权值乘于其到根结点的路径长度）之和</span><br></pre></td></tr></table></figure>

<p>如何构造哈夫曼树</p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.png" alt=""></p>
<h3 id="四、平衡二叉树"><a href="#四、平衡二叉树" class="headerlink" title="四、平衡二叉树"></a>四、平衡二叉树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二叉树排序树由于可能会出现线性的情况，会大大降低数据的检索效率，所以要避免这种情况的发生，从而发明了平衡二叉排序树，又叫AVL树。</span><br><span class="line">平衡二叉树是一种特殊的二叉排序树，它或者为空树，或者左右子数均为平衡二叉树，而且其左右子数的高度差绝对值不大于1。为了保证平衡性，每次插入元素时都会检查平衡是否被破坏掉了，如果是，则要进行相应的旋转。</span><br></pre></td></tr></table></figure>

<p>平衡因子：左子树高度减去右子树高度的差（-1,0,1）</p>
<h4 id="1-平衡二叉树和非平衡二叉树"><a href="#1-平衡二叉树和非平衡二叉树" class="headerlink" title="1.平衡二叉树和非平衡二叉树"></a>1.平衡二叉树和非平衡二叉树</h4><p><img src="http://q7s8mko1o.bkt.clouddn.com/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%9D%9E%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt=""></p>
<h4 id="2-平衡调整"><a href="#2-平衡调整" class="headerlink" title="2.平衡调整"></a>2.平衡调整</h4><p>​    假定向平衡二叉树中插入一个新结点后破坏了平衡二叉树的平衡性，则首先要找出插入新结点后失去平衡的最小子树，然后再调整这棵子树，使之称为平衡子树。值得注意的是，当失去平衡的最小子树被调整为平衡子树后，无须调整原有其它所有的不平衡子树，整个二叉排序树就会称为一棵平衡二叉树。所谓失去平衡的最小子树是以距离插入结点最近，且以平衡因子绝对值大于1的结点作为根的子树，又称为<strong>最小不平衡子树</strong>。</p>
<ul>
<li><p><strong>LL调整</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如下图所示，因为在A的左孩子的左孩子处插入新的结点，导致A的平衡因子从1变成2，不满足平衡的条件，所以要通过旋转。按照大小的关系，结点B应该作为新的根结点。其余两个结点分为作为B的左右子节点才能维持平衡，看起来是A结点绕B结点顺时针旋转一样。</span><br></pre></td></tr></table></figure>

<p><img src="http://q7s8mko1o.bkt.clouddn.com/LL%E5%9E%8B%E8%B0%83%E6%95%B4.png" alt=""></p>
<p>下图中，当在结点5的左子树中插入结点的时候导致不平衡。这种情况调整如下:首先将元素5的左孩子2提升为新的根结点；然后将原来的根结点作为元素2的右孩子；其它各子树按大小关系连接</p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/LL2.png" alt=""></p>
</li>
<li><p><strong>RR调整</strong></p>
<p> 如下图，因为在元素5的右孩子的右孩子插入新的节点，导致元素5的平衡因子从-1变为-2，不满足平衡特性，所以需要通过旋转。按照大小关系，结点元素7应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡，这样看来，就好像节点元素5绕结点元素7逆时针旋转一样。 </p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/RR1.png" alt=""></p>
<p> RR型调整的一般形式如下图所示，表示节点元素4的右子树5(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡( h 表示子树的深度)。这种情况调整如下： </p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/RR2.png" alt=""></p>
</li>
</ul>
<ul>
<li><p>LR调整</p>
<p> 由于节点元素5的左孩子的右子树上插入新节点，导致不平衡。此时元素5的平衡因子由1变为2。第一张图是LR型的最简单形式。显然，按照大小关系，元素3应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡。 </p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/LR1.png" alt=""></p>
<p> 由于节点元素6增加一个左孩子，导致元素4变得不平衡。先顺时针旋转元素7再逆时针旋转4元素达到平衡。 </p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/LR2.png" alt=""></p>
</li>
<li><p>RL调整</p>
<p> 当在元素5的右孩子的左子树增加一个节点7的时候，会造成不平衡的情况。先逆时针旋转成RR情况，再将元素5顺时针旋转。 </p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/RL1.png" alt=""></p>
<p> 第二种情况方法类似，看起来会复杂一点。当在元素7得左孩子6增加左孩子元素5得时候，导致元素4变得不平衡。那么先顺时针调整元素7，再逆时针调整元素4 </p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/RL2.png" alt=""></p>
</li>
</ul>
<h3 id="五、B树和B-树"><a href="#五、B树和B-树" class="headerlink" title="五、B树和B+树"></a>五、B树和B+树</h3><h4 id="1-B树"><a href="#1-B树" class="headerlink" title="1. B树"></a>1. B树</h4><p>B树又称多路平衡查找树，B树中所有结点的<strong><em>孩子结点数</em></strong>的最大值称为B树的阶</p>
<p>一棵m阶B树或为空树，或为满足如下特性的m叉树：<br>1）树中每个结点最多有m棵子树（即至多含有m-1个关键字）<br>2）若根结点不是叶子节点，则至少有两棵子树<br>3）除根结点外的所有非叶结点至少有[m/2]（向上取整）棵子树（即[m/2]-1个关键字）</p>
<p>4）有n个分支的结点有n-1个关键字，它们按递增顺序排列。</p>
<p>5）每个结点的结构为：</p>
<table>
<thead>
<tr>
<th align="center">n</th>
<th align="center"><code>k1</code></th>
<th align="center"><code>k2</code></th>
<th align="center">…</th>
<th align="center"><code>kn</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>p0</code></td>
<td align="center"><code>p1</code></td>
<td align="center"><code>p2</code></td>
<td align="center">…</td>
<td align="center"><code>pn</code></td>
</tr>
</tbody></table>
<p>其中n为该节点中关键字的个数；ki（1≤i≤n）为该结点的关键字，且满足ki&lt;ki+1,pi为该结点的孩子结点指针且满足pi(0≤i≤n)所指结点上的关键字大于ki小于ki+1，p0所指结点上的关键字小于k1，pn所指结点上的关键字大于kn</p>
<p>6）结点内各关键字互不相等，且按从小到大的顺序排列</p>
<p>7）叶节点除于同一层，并不带任何信息；可以用空指针表示，是查找失败到达的位置</p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/B%E6%A0%91.png" alt=""></p>
<p> 那么在查找搜索的过程中，是怎样的访问过程呢？假设查找元素7 </p>
<ul>
<li><p>与根节点比较，得到指针p1</p>
</li>
<li><p>根据p1来到磁盘2，关键字为(9,15),发现小于9，得到指针p1</p>
</li>
<li><p>根据p1来到磁盘5，关键字为(7,8),发现正好有7</p>
</li>
</ul>
<h4 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2. B+树"></a>2. B+树</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	B+树是对B树的升级，特点如下：</span><br><span class="line">1.B+树的所有非叶子结点只存索引数据</span><br><span class="line">2.B+树的叶子结点包含所有的索引值，并且指向数据</span><br><span class="line">3.B+树的所有关键字都包含在叶子结点中，叶子结点构成有序链表，关键字从小到大或从大到小顺序连接</span><br><span class="line">4.有m个孩子的结点就有m个关键字</span><br></pre></td></tr></table></figure>

<p><img src="http://q7s8mko1o.bkt.clouddn.com/B%2B%E6%A0%91.png" alt=""></p>
<h4 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.因为B+树中间结点没有关键字，所以同样大小的磁盘页可以容纳更多的结点元素，也就是说在相同的情况下，B+树更加的矮胖，这样的话，IO次数就比较少。</span><br><span class="line">2.B+树的查询相比B树更加稳定，因为B+树的查询必须到叶子结点，而B树可能在中间结点，也可能在非中间结点。</span><br><span class="line">3.B+树叶子结点形成了有序链表，更加有利于范围的查询</span><br></pre></td></tr></table></figure>

<h4 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以查询元素13为例：</span><br><span class="line"></span><br><span class="line">1.首先与根节点的关键字(10,18,40)比较，13在10和18之间，此时得到P1指针</span><br><span class="line"></span><br><span class="line">2.磁盘2中的关键字为(10,12,15),这时15大于13，所有磁盘6</span><br><span class="line"></span><br><span class="line">3.关键字为(12,13)，找到13</span><br></pre></td></tr></table></figure>



<h3 id="六、红黑树（自平衡二叉搜索树）"><a href="#六、红黑树（自平衡二叉搜索树）" class="headerlink" title="六、红黑树（自平衡二叉搜索树）"></a>六、红黑树（自平衡二叉搜索树）</h3><h4 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.结点要么是红色，要么是黑色</span><br><span class="line">2.根结点是黑色的</span><br><span class="line">3.每个叶子结点是黑色的且不存储数据</span><br><span class="line">4.每个红色结点的两个子节点一定都是黑色</span><br><span class="line">5.对于任一结点，从该结点到可达的叶子结点的所有路径，其黑色结点的数目相同</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
  </entry>
  <entry>
    <title>IO流</title>
    <url>/2020/04/18/IO%E6%B5%81/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IO流用来处理设备之间的数据传输。</span><br><span class="line"></span><br><span class="line">Java程序中，对于数据的输入&#x2F;输出操作以”流(stream)” 的方式进行。是指从源节点到目标节点的数据流动</span><br><span class="line"></span><br><span class="line">源节点和目标节点可以是文件、网络、内存、键盘、显示器等等。</span><br><span class="line"></span><br><span class="line">java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。</span><br></pre></td></tr></table></figure>

<h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><ul>
<li>按操所<strong><em>数据单位</em></strong>不同分为字节流(<code>8bit</code>)和字符流(<code>16bit</code>)</li>
<li>按数据流的流向分为输入流和输出流</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td><code>InputStream(基类)</code></td>
<td>Reader(基类)</td>
</tr>
<tr>
<td>输出流</td>
<td><code>OutputStream(基类)</code></td>
<td>Writer(基类)</td>
</tr>
<tr>
<td>流中的数据</td>
<td>二进制字节（8位）</td>
<td>Unicode字符（16位）</td>
</tr>
</tbody></table>
<p>Java中的IO流共涉及40多个类，实际上非常规则，都是从这四个抽象基类派生的</p>
<p>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀</p>
<h3 id="读文件步骤"><a href="#读文件步骤" class="headerlink" title="读文件步骤"></a>读文件步骤</h3><p>无论读取文件是二进制文件还是文本文件，当需要读文件数据时，需要完成以下步骤：</p>
<p>1.使用文件输入流打开指定的文件：</p>
<p>​    对于文本文件，应该使用字符输入流<code>FileReader</code>流</p>
<p>​    对于二进制文件，应该使用字节输入流<code>FileInputStream</code>流</p>
<p>2.读取数据</p>
<p>3.关闭输入流</p>
<h3 id="写文件步骤"><a href="#写文件步骤" class="headerlink" title="写文件步骤"></a>写文件步骤</h3><p>无论是文本文件还是二进制文件，当需要将数据写入文件时，需要完成以下步骤：</p>
<p>1.使用文件输出流打开指定文件：</p>
<p>​    对于文本文件，应该使用字符输出流<code>FileWriter</code>流</p>
<p>​    对于二进制文件，应该使用字节输出流<code>FileOutputStream</code>流</p>
<p>2.将数据写入文件</p>
<p>3.关闭输出流</p>
<p>在打开一个现有文件的输出流以准备写入数据时，有两种方式可供选择</p>
<ul>
<li>以清空方式打开</li>
<li>以添加方式打开</li>
</ul>
<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组,缓冲流要套接在节点流上，即内部关联了节点流</span><br><span class="line">根据数据操作单位，可分为：</span><br><span class="line">BufferedInputStream和BufferedOutputStream</span><br><span class="line">BufferedReader和BufferedWriter</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 包装就是对象关联</span></span><br><span class="line">            fileReader = <span class="keyword">new</span> FileReader(<span class="string">"HashMap.java.bak"</span>);</span><br><span class="line">            bufferedReader = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">            String line; <span class="comment">// readLine()方法是最有价值方法！！！！！</span></span><br><span class="line">            <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123; <span class="comment">// 直接从输入 流中读一行字符串</span></span><br><span class="line">                System.out.println(line); <span class="comment">// line中没有了换行。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 只需要关闭高级流， 因为在关闭高级流时，会自动地顺带把低级流关闭了</span></span><br><span class="line">            <span class="keyword">if</span> (bufferedReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bufferedReader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileWriter fileWriter = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter bufferedWriter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileWriter = <span class="keyword">new</span> FileWriter(<span class="string">"使用缓冲流写文本"</span>);</span><br><span class="line">            bufferedWriter = <span class="keyword">new</span> BufferedWriter(fileWriter);</span><br><span class="line">            <span class="comment">// 处理数据</span></span><br><span class="line">            String[] content = &#123;</span><br><span class="line">                                <span class="string">"我是一些内容的字符串1"</span>,</span><br><span class="line">                                <span class="string">"我是一些内容的字符串2"</span>,</span><br><span class="line">                                <span class="string">"我是一些内容的字符串3"</span>,</span><br><span class="line">                                <span class="string">"我是一些内容的字符串4"</span>,</span><br><span class="line">                                <span class="string">"我是一些内容的字符串5"</span>,</span><br><span class="line">                                <span class="string">"我是一些内容的字符串6"</span>,</span><br><span class="line">                                <span class="string">"我是一些内容的字符串7"</span>,</span><br><span class="line">                                <span class="string">"我是一些内容的字符串8"</span>,</span><br><span class="line">                                <span class="string">"213424982374982374892734234"</span>,</span><br><span class="line">                                <span class="string">"falksdflakslskajflkajsdfkljasdf"</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; content.length; i++) &#123;</span><br><span class="line">                bufferedWriter.write(content[i]);</span><br><span class="line">                bufferedWriter.newLine(); <span class="comment">// 写跨平台的换行， 这是最有价值方法***</span></span><br><span class="line">                <span class="comment">/* 使用上面的方法代替</span></span><br><span class="line"><span class="comment">                bufferedWriter.write(13);</span></span><br><span class="line"><span class="comment">                bufferedWriter.write(10);</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bufferedWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bufferedWriter.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectInputStream和ObjectOutputStream.用于存储和读取对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</span><br></pre></td></tr></table></figure>

<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">       BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 二进制文件中保存的数据通常是内存数据的副本。</span></span><br><span class="line">       ObjectOutputStream oos = <span class="keyword">null</span>; <span class="comment">// 字节流一定是处理二进制文件。</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"二进制文件"</span>);</span><br><span class="line">           bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">           oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">           oos.writeInt(<span class="number">10</span>); <span class="comment">// 写4个字节数据</span></span><br><span class="line">           oos.writeBoolean(<span class="keyword">true</span>); <span class="comment">// 写1个字节数据</span></span><br><span class="line">           oos.writeBoolean(<span class="keyword">false</span>);</span><br><span class="line">           oos.writeLong(<span class="number">20</span>); <span class="comment">// 写8字节</span></span><br><span class="line">           oos.writeDouble(<span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">           oos.writeUTF(<span class="string">"abc我和你qqq"</span>); <span class="comment">// UTF8格式的字符串</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (oos != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   oos.close();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">       BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">       ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           fis = <span class="keyword">new</span> FileInputStream(<span class="string">"二进制文件"</span>);</span><br><span class="line">           bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">           ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> i = ois.readInt();</span><br><span class="line">           System.out.println(i);</span><br><span class="line">           <span class="keyword">boolean</span> b1 = ois.readBoolean();</span><br><span class="line">           <span class="keyword">boolean</span> b2 = ois.readBoolean();</span><br><span class="line">           System.out.println(b1);</span><br><span class="line">           System.out.println(b2);</span><br><span class="line">           <span class="keyword">long</span> l = ois.readLong();</span><br><span class="line">           System.out.println(l);</span><br><span class="line">           <span class="keyword">double</span> v = ois.readDouble();</span><br><span class="line">           System.out.println(v);</span><br><span class="line"></span><br><span class="line">           String s = ois.readUTF();</span><br><span class="line">           System.out.println(s);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (ois != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   ois.close();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">转换流：InputStreamReader和OutputStreamWriter</span><br><span class="line">特点：</span><br><span class="line">1.是字符流和字节流之间的桥梁</span><br><span class="line">2.可以用指点的编码方式对字符数据进行读取</span><br></pre></td></tr></table></figure>

<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test20</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//FileReader fileReader = null; // 这个类太烂了, 不能处理其他编码</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        InputStreamReader isr = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader buf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">"ArrayList.java"</span>);</span><br><span class="line">            <span class="comment">//isr = new InputStreamReader(fis); // 使用的还是项目默认编码方式</span></span><br><span class="line">            isr = <span class="keyword">new</span> InputStreamReader(fis, <span class="string">"gbk"</span>); <span class="comment">// 指定编码方式</span></span><br><span class="line">            buf = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">            String s;</span><br><span class="line">            <span class="keyword">while</span> ((s = buf.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (buf != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buf.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test21</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter buf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"转换流写文本"</span>);</span><br><span class="line">            <span class="comment">//osw = new OutputStreamWriter(fos); // 转换时以默认编码方式</span></span><br><span class="line">            osw = <span class="keyword">new</span> OutputStreamWriter(fos, <span class="string">"gbk"</span>); <span class="comment">// 转换时以gbk编码</span></span><br><span class="line">            buf = <span class="keyword">new</span> BufferedWriter(osw);</span><br><span class="line"></span><br><span class="line">            buf.write(<span class="string">"alsdkjfalksjfdlkajsdf"</span>);</span><br><span class="line">            buf.newLine();</span><br><span class="line">            buf.write(<span class="string">"来一些汉字"</span>);</span><br><span class="line">            buf.newLine();</span><br><span class="line">            buf.write(<span class="string">"134234234234234"</span>);</span><br><span class="line">            buf.newLine();</span><br><span class="line">            buf.write(<span class="string">"来一些汉字2"</span>);</span><br><span class="line">            buf.newLine();</span><br><span class="line">            buf.write(<span class="string">"来一些汉字3"</span>);</span><br><span class="line">            buf.newLine();</span><br><span class="line">            buf.write(<span class="string">"来一些汉字4"</span>);</span><br><span class="line">            buf.newLine();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (buf != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buf.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.in是一个输入流</span><br><span class="line">System.out是打印流，也是输出流，但是它可以自动flush</span><br></pre></td></tr></table></figure>

<h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">// 和迭代器一样</span></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123; <span class="comment">// 以行为单位</span></span><br><span class="line">            <span class="keyword">if</span> (scanner.hasNextInt()) &#123;</span><br><span class="line">                <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">                System.out.println(<span class="string">"整数: "</span> + n);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scanner.hasNextDouble()) &#123;</span><br><span class="line">                <span class="keyword">double</span> d = scanner.nextDouble();</span><br><span class="line">                System.out.println(<span class="string">"浮点数 : "</span> + d);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                String next = scanner.nextLine();</span><br><span class="line">                System.out.println(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main2</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream in = System.in;<span class="comment">// 对应的是键盘</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader buf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">            buf = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = buf.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (line.equals(<span class="string">"exit"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (buf != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buf.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="序列化跟反序列化"><a href="#序列化跟反序列化" class="headerlink" title="序列化跟反序列化"></a>序列化跟反序列化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对象的序列化：把对象在GC区中的数据写入输出流ObjectOutputStream WriteObject()，任何想要序列化的对象的类必须实现Serializable接口（标记接口，里面什么方法都没有）。静态属性（类的版本号serialVersionID除外）和transient修饰的成员不能被序列化</span><br><span class="line">对象的反序列化：把输入流中的数据还原成对象</span><br></pre></td></tr></table></figure>

<h4 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.javase.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String school = <span class="string">"atguigu"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">double</span> score; <span class="comment">// 短暂的. 不能被序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> grade, <span class="keyword">double</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", grade="</span> + grade +</span><br><span class="line">                <span class="string">", score="</span> + score +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getGrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGrade</span><span class="params">(<span class="keyword">int</span> grade)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">double</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 对象序列化,其中对象数组和集合都是作为writeObject的参数的</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"对象序列化"</span>);</span><br><span class="line">            objectOutputStream  = <span class="keyword">new</span> ObjectOutputStream(fileOutputStream);</span><br><span class="line">            Student a = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"小明"</span>, <span class="number">1</span>, <span class="number">99</span>);</span><br><span class="line">            Student b = <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">"小红"</span>, <span class="number">1</span>, <span class="number">99</span>);</span><br><span class="line">            Student[] arr = &#123;a,b&#125;;</span><br><span class="line">            objectOutputStream.writeObject(arr);</span><br><span class="line">            <span class="comment">//objectOutputStream.writeObject(a);</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(objectOutputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectOutputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 对象反序列化</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"对象序列化"</span>));</span><br><span class="line">            <span class="comment">//Object o = objectInputStream.readObject();</span></span><br><span class="line">            Student[] students = (Student[])objectInputStream.readObject();</span><br><span class="line">            <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">                System.out.println(student);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(objectInputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectInputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>泛型和通配符</title>
    <url>/2020/04/18/%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?是泛型通配符，表示类型未知</span><br></pre></td></tr></table></figure>

<h3 id="使用类型通配符"><a href="#使用类型通配符" class="headerlink" title="使用类型通配符"></a>使用类型通配符</h3><p>1）无限制的类型通配符</p>
<p>比如：List<?>,Map<?,?>   List&lt;?&gt;中的？表示未知类型，所以是不能往里面添加具体的类型对象的，只有null的类型未知，所以是可以添加null的；但是可以读取元素的，因为无论集合里面的真实类型是什么，都可以用Object接收，代码实例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//List&lt;Number&gt; list = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line">        <span class="comment">// 左面的list可以保存Number及其子类对象, 如果添加Double是可以的</span></span><br><span class="line">        <span class="comment">// 右面的List只能保存Integer， 但是右面实际不允许</span></span><br><span class="line">        <span class="comment">// 所以泛型不能直接多态</span></span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            list1.add((<span class="keyword">int</span>)(Math.random() * <span class="number">20</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">        <span class="comment">// ?是泛型通配符， 表示类型未知。</span></span><br><span class="line">        List&lt;?&gt; list2 = list1; <span class="comment">// ?表示未知。</span></span><br><span class="line">        <span class="comment">// list2中保存未知类型的对象</span></span><br><span class="line">        <span class="comment">//list2.add(200); // 不能添加， 因为200是已知类型</span></span><br><span class="line">        <span class="comment">//list2.add("abc") 添加时类型确定的不能添加</span></span><br><span class="line">        list2.add(<span class="keyword">null</span>); <span class="comment">// 因为null类型不确定。</span></span><br><span class="line">        Object obj = list2.get(<span class="number">0</span>); <span class="comment">// 可以获取元素，但是都是Object类型</span></span><br><span class="line">        List&lt;?&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<p><strong><em>所以对于List&lt;?&gt;只能读，不能写（null除外）</em></strong></p>
<p>2）有限制的类型通配符</p>
<p>&lt;? super Number&gt;//有限的通配符?表示未知，super表示父dan类，即表示Number和其<strong><em>未知</em></strong>父类类型，此类型一定可以兼容Number，下限是Number，可以添加元素，但是只能添加Number及其子类（适用于添加元素，但是不适合获取元素）实例代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 有限的通配符 ? 表示未知 super表示父类</span></span><br><span class="line">      <span class="comment">// Number及其未知父类类型， 此类型一定可以兼容Number</span></span><br><span class="line">      <span class="comment">// 下限是Number, 上限未知。</span></span><br><span class="line">      <span class="comment">// &lt;? super Number&gt; 适用于添加元素，但是不适合取元素</span></span><br><span class="line">      List&lt;? <span class="keyword">super</span> Number&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 可以添加元素，但是只能添加Number及其子类。</span></span><br><span class="line">      list1.add(<span class="number">200</span>); <span class="comment">// 200可以被Number及未知父类兼容</span></span><br><span class="line">      list1.add(<span class="number">3.22</span>);</span><br><span class="line">      <span class="comment">//list1.add(new Object()); Object对象不能添加，因为它是已知父类</span></span><br><span class="line">      Object object = list1.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>&lt;? extends Number&gt;//有限的通配符?表示未知，extends表示子类，即表示Number和其<strong><em>未知</em></strong>子类类型，上限是Number，下限未知（适用于获取元素，但是不适合添加元素）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Number及其未知子类类型</span></span><br><span class="line">    <span class="comment">// 上限是Number下限未知</span></span><br><span class="line">    <span class="comment">// &lt;? extends Number&gt; 不适用于添加元素, 适用于获取元素</span></span><br><span class="line">    List&lt;? extends Number&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//list2.add(200); // 200是已知子类， 不能添加</span></span><br><span class="line">    <span class="comment">//list2.add(3.22); // 3.22也是已知子类，集合要求的是未知子类</span></span><br><span class="line">    Number number = list2.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="通配符使用示例代码"><a href="#通配符使用示例代码" class="headerlink" title="通配符使用示例代码"></a>通配符使用示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Comparable <span class="title">max</span><span class="params">(Collection&lt;? extends Comparable&gt; collection)</span> </span>&#123;</span><br><span class="line">       Iterator&lt;? extends Comparable&gt; iterator = collection.iterator();</span><br><span class="line">       <span class="keyword">if</span> (!iterator.hasNext()) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       Comparable max = iterator.next(); <span class="comment">// 假设第一个元素最大</span></span><br><span class="line">       <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">           Comparable next = iterator.next();</span><br><span class="line">           <span class="keyword">if</span> (next.compareTo(max) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               max = next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           list1.add((<span class="keyword">int</span>) (Math.random() * <span class="number">20</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(list1);</span><br><span class="line">       System.out.println(max(list1));</span><br><span class="line">       List&lt;Double&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           list2.add((Math.random() * <span class="number">20</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(list2);</span><br><span class="line">       System.out.println(max(list2));</span><br><span class="line">       Set&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           set1.add((<span class="keyword">int</span>)(Math.random() *<span class="number">30</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(set1);</span><br><span class="line">       System.out.println(max(set1));</span><br><span class="line"></span><br><span class="line">       Set&lt;String&gt; set2 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">       set2.add(<span class="string">"aaa"</span>);</span><br><span class="line">       set2.add(<span class="string">"cc"</span>);</span><br><span class="line">       set2.add(<span class="string">"113"</span>);</span><br><span class="line">       set2.add(<span class="string">"qqq"</span>);</span><br><span class="line">       set2.add(<span class="string">"32084923"</span>);</span><br><span class="line">       set2.add(<span class="string">"汉字"</span>);</span><br><span class="line">       set2.add(<span class="string">"QQQ"</span>);</span><br><span class="line">       System.out.println(max(set2));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>泛型和继承</title>
    <url>/2020/04/18/%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2020/04/18/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	泛型时JDK1.5新加入的，解决数据类型的安全性问题。其主要原理是在类声明时通过一个标识标识类中某个属性的类型或者方法的返回值及参数类型。这样在类声明或实例化时只要指定要具体的类型即可。Java泛型可以保证代码如果代码在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时代码更加简洁健壮。</span><br><span class="line">1.为什么要有泛型？</span><br><span class="line">	1）解决元素存储的安全性问题</span><br><span class="line">	2）解决获取数据元素时，需要类型强转的问题</span><br></pre></td></tr></table></figure>



<h3 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h3><p>​    1）自定义泛型类Person，然后在测试类中使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//&lt;T&gt;表示某种类型，泛型参数，是隶属于对象的，待创建对象时才会确定具体的数据类型</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> T  info;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, T info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(T info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在测试类中使用泛型类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Person&lt;Integer&gt; person = <span class="keyword">new</span> Person&lt;Integer&gt;(<span class="string">"张三"</span>,<span class="number">123</span>);<span class="comment">//泛型属性在创建对象时指定为Interger类型</span></span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="string">"adf"</span>);<span class="comment">//不用泛型也可以，即泛型兼容Object</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类声明签名中指定的泛型是属于对象的，等到生成具体的实例时才能确定，所以static方法中是不能用的，但是可以声明泛型方法，泛型方法声明示例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span></span>&#123;</span><br><span class="line">    <span class="comment">//泛型方法</span></span><br><span class="line">    <span class="comment">//泛型方法一定要有参数，用于确定泛型类型</span></span><br><span class="line">    <span class="keyword">public</span> &lt;B&gt; <span class="function">B <span class="title">test2</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">        <span class="comment">//B是局部泛型，只能在本方法中用</span></span><br><span class="line">        B b1 = b;</span><br><span class="line">        <span class="keyword">return</span> b1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在测试类中使用泛型方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        GenericMethod genericMethod = <span class="keyword">new</span> GenericMethod();</span><br><span class="line">        String s = genericMethod.test2(<span class="string">"123"</span>);<span class="comment">//调用泛型方法test2()传入类型为String，所以编译器就感知到了返回类型就是String</span></span><br><span class="line">        Object o = genericMethod.test2(<span class="keyword">null</span>);<span class="comment">//null是没有数据类型的，传null无法让方法感知类型，只能用Object接收</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型结合继承"><a href="#泛型结合继承" class="headerlink" title="泛型结合继承"></a>泛型结合继承</h3><p>父类代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T field;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setField</span><span class="params">(T field)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.field = field;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类在继承有泛型的父类时写法有以下三种</p>
<p>1）子类不理会父类的泛型（不推荐这种写法,父类的泛型未得到利用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub1</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>2）指定特定的泛型。泛型是固定的，不会变，缺点是当需要指定不同的类型时，就需要多写几个子类，推荐使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub21</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">String</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub22</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>3）下面的写法最灵活，因为子类的泛型也不固定,也推荐使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub3</span>&lt;<span class="title">A</span>&gt; <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2020/04/17/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java集合类可以用于存储数量不等的多个对象。可以将它简单地看作是一个可变长度的Object数组</span><br></pre></td></tr></table></figure>

<h4 id="Java集合可分为Collection和Map两种体系"><a href="#Java集合可分为Collection和Map两种体系" class="headerlink" title="Java集合可分为Collection和Map两种体系"></a>Java集合可分为Collection和Map两种体系</h4><ul>
<li><h4 id="Collection接口：表示不按添加顺序存放对象的集合，集合内元素可以重复，即无序可重复集合"><a href="#Collection接口：表示不按添加顺序存放对象的集合，集合内元素可以重复，即无序可重复集合" class="headerlink" title="Collection接口：表示不按添加顺序存放对象的集合，集合内元素可以重复，即无序可重复集合"></a>Collection接口：表示不按添加顺序存放对象的集合，集合内元素可以重复，即无序可重复集合</h4><ul>
<li><h5 id="Set接口：元素无序，不可重复的集合"><a href="#Set接口：元素无序，不可重复的集合" class="headerlink" title="Set接口：元素无序，不可重复的集合"></a>Set接口：元素无序，不可重复的集合</h5><ul>
<li><p>Hashset：基于数组,链表使用哈希算法实现</p>
<p>​    优点：检索插入删除性能都好</p>
</li>
<li><p>TreeSet：基于二叉搜索树（红黑树）实现，适用于大量的检索场景</p>
<p>​    优点：对内存要求低，检索速度快</p>
<p>​    缺点：插入和删除速度慢</p>
</li>
</ul>
</li>
<li><h5 id="List接口：元素有序，可重复的集合"><a href="#List接口：元素有序，可重复的集合" class="headerlink" title="List接口：元素有序，可重复的集合"></a>List接口：元素有序，可重复的集合</h5><ul>
<li><p>ArrayList:基于数组实现：适用于存档数据，检索操作多的情况</p>
<p>​    优点：检索速度快，末端插入数据快</p>
<p>​    缺点：对内存要求高，要求连续，非末端删除和插入速度很慢</p>
</li>
<li><p>LinkedList:基于链表实现：适用于频繁修改的情况</p>
<p>​    优点：对内存要求低，不要求连续，插入删除速度快</p>
<p>​    缺点：检索速度慢</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="Map接口：具有映射关系”key-value对”的集合"><a href="#Map接口：具有映射关系”key-value对”的集合" class="headerlink" title="Map接口：具有映射关系”key value对”的集合"></a>Map接口：具有映射关系”key value对”的集合</h4></li>
</ul>
<h3 id="Collction接口继承树"><a href="#Collction接口继承树" class="headerlink" title="Collction接口继承树"></a><code>Collction</code>接口继承树</h3><p>  <img src="http://q7s8mko1o.bkt.clouddn.com/collction%E7%BB%A7%E6%89%BF%E6%A0%91.png?imageView2/2/w/308/h/210/interlace/1/q/100&last_modify=15871067981604308" alt="collction继承树"></p>
<p>  类图</p>
<p>  <img src="http://q7s8mko1o.bkt.clouddn.com/collction%E6%A1%86%E6%9E%B6%E7%B1%BB%E5%9B%BE.png?imageView2/2/w/308/h/210/interlace/1/q/100&last_modify=15871070818640616" alt=""></p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>









































]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>日期处理</title>
    <url>/2020/04/15/%E6%97%A5%E6%9C%9F%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="常用日期类比较"><a href="#常用日期类比较" class="headerlink" title="常用日期类比较"></a>常用日期类比较</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Date可以用来表示日期,也包括时间.缺点是创建对象极其不方便, 因为它处理日期时间有基础值</span><br><span class="line"></span><br><span class="line">Calendar 日历, 内部使用一个大的int[]来保存所有数据访问数据时必须要提供下标, 下标值用常量来表示。缺点 : 月份存储小1, 读取或设置属性都不方便.内容是可以改变的.</span><br><span class="line"></span><br><span class="line">java8中的新API,  所有数据存储都是真实的, 内容不可改变, 所有的修改都会产生新对象.</span><br><span class="line">	LocalDate 处理日期</span><br><span class="line">	LocalTime 处理时间</span><br><span class="line">	LocalDateTime 处理日期时间</span><br><span class="line">	DateTimeFormatter 格式化</span><br></pre></td></tr></table></figure>

<p>所以在处理日期和时间时，用最新的<code>LocalDate，Local Time，LocalDateTime</code>即可，功能比较完善。</p>
]]></content>
      <categories>
        <category>JavaSE</category>
        <category>Java常用类</category>
      </categories>
  </entry>
  <entry>
    <title>包装类</title>
    <url>/2020/04/15/%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">所有的数据类型都有对应包装类型</span><br></pre></td></tr></table></figure>

<h3 id="Integer包装类的经典试题"><a href="#Integer包装类的经典试题" class="headerlink" title="Integer包装类的经典试题"></a>Integer包装类的经典试题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Integer m = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">       Integer n = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">       System.out.println(m == n);<span class="comment">//false</span></span><br><span class="line">       Integer x = <span class="number">1</span>;</span><br><span class="line">       Integer y = <span class="number">1</span>;</span><br><span class="line">       System.out.println(x == y);<span class="comment">//true</span></span><br><span class="line">       Integer a = <span class="number">128</span>;</span><br><span class="line">       Integer b = <span class="number">128</span>;</span><br><span class="line">       System.out.println(a == b);<span class="comment">//false</span></span><br><span class="line">       System.out.println(<span class="number">128</span> == a);<span class="comment">//true,常量跟变量比较，变量自动拆箱，这里其实就是比较128==128</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>分析如下：</p>
<p>​    1）m和n分别指向堆中两个不同的对象，显然m==n是false</p>
<p>​    2）Integer x = 1；Integer y = 1;是一个自动装箱的过程，只要被装箱的数i符合-128&lt;= i &lt;127,则返回Integer内部的一个缓存数组中的值，不会新生产对象，所以x==y是true</p>
<p>​    3）Integer x = 128；128不在-128~127的范围内，会生成新的对象，所以a==b是false</p>
<p>Integer自动装箱的源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">          <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>IntegerCache</code>类的属性定义代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cache[]的初始化如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">h = <span class="number">127</span>;</span><br><span class="line">high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br></pre></td></tr></table></figure>

<p>其它的包装类跟Integer类似</p>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>String,StringBuilder,StringBuffer</title>
    <url>/2020/04/14/String,StringBuffer,StringBuilder/</url>
    <content><![CDATA[<h3 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h3><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String字面量是不允许修改的，String类型的字符串拼接只要有变量参与，则拼接运算就是在GC区中进行的，拼接过程中会在GC区中开辟空间存储新的字符串。如果是多个字面量进行拼接，如&quot;a&quot; + &quot;b&quot;,在编译过程中会直接拼接为&quot;ab&quot;，结果存在常量池中。</span><br></pre></td></tr></table></figure>

<h3 id="2-常用方法介绍"><a href="#2-常用方法介绍" class="headerlink" title="2.常用方法介绍"></a>2.常用方法介绍</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String 字符串 : 内容不可改变的Unicode字符的序列. 内部使用char[]来保存所有字符</span></span><br><span class="line"><span class="comment"> * String s = "abc"; s 指向一个字符串对象</span></span><br><span class="line"><span class="comment"> * s += 200;  // 用原来的内拼接200, 拼接的结果是一个新的字符串对象, 再把新对象地址刷回给s</span></span><br><span class="line"><span class="comment"> * 字符串的任何修改都会产生一个新对象. 对象使用很安全. 缺点是会产生大量对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 字符串常量(字面量)保存在内存中的常量区(jdk8以前常量区是方法区的一部分)</span></span><br><span class="line"><span class="comment"> * 拼接中只要有变量参与, 拼接的新串就一定在GC区.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * String str = new String("abc");</span></span><br><span class="line"><span class="comment"> * "abc"本身在常量区, 内部的char[] 也在常量区</span></span><br><span class="line"><span class="comment"> * str引用指向的String对象在GC区, 对象的属性value指向的char[]在常量区</span></span><br><span class="line"><span class="comment"> *                  0 2  5     11   16       21        27       33    38</span></span><br><span class="line"><span class="comment"> * String string = "  abcABCqq 1234 我喜欢你,你喜欢我吗?我不喜欢你 YYzz  ";</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * public int length() 获取字符串长度, string.length() =&gt; 39</span></span><br><span class="line"><span class="comment"> * public char charAt(int index),获取参数指定下标处的字符, string.charAt(17) =&gt; '喜', string.charAt(3) =&gt; 'b'</span></span><br><span class="line"><span class="comment"> * public char[] toCharArray() 返回字符串内部字符数组的复制品</span></span><br><span class="line"><span class="comment"> *      System.arraycopy(value, 0, result, 0, value.length); 数组的复制</span></span><br><span class="line"><span class="comment"> *      // 第1个参数是源数组对象, 第2个参数是源数组的开始下标, 第3个参数是目标数组对象, 第4个参数是目标数组的开始下标, 第5个参数是复制的元素个数</span></span><br><span class="line"><span class="comment"> * public boolean equals(Object anObject)</span></span><br><span class="line"><span class="comment"> * public int compareTo(String anotherString) // 以字符的Unicode为比较依据</span></span><br><span class="line"><span class="comment"> * public int indexOf(String s) 获取参数中的子串s在当前字符串中首次出现的下标索引</span></span><br><span class="line"><span class="comment"> *          string.indexOf("喜欢") =&gt; 17</span></span><br><span class="line"><span class="comment"> *          string.indexOf("讨厌") =&gt; -1 表示子串不存在.</span></span><br><span class="line"><span class="comment"> * public int indexOf(String s ,int startpoint) // 从第二个参数指定的下标开始搜索子串出现的下标</span></span><br><span class="line"><span class="comment"> *          string.indexOf("喜欢", 18) =&gt; 22</span></span><br><span class="line"><span class="comment"> *          string.indexOf("喜欢", 23) =&gt; 29</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * public int lastIndexOf(String s) 从右向左搜索子串首次出现的下标</span></span><br><span class="line"><span class="comment"> *          string.lastIndexOf("喜欢") =&gt; 29</span></span><br><span class="line"><span class="comment"> * public int lastIndexOf(String s ,int startpoint)</span></span><br><span class="line"><span class="comment"> *          string.lastIndexOf("喜欢", 28) =&gt; 22</span></span><br><span class="line"><span class="comment"> *          string.lastIndexOf("喜欢", 21) =&gt; 17</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * public boolean startsWith(String prefix) 判断当前串是否以参数中的子串为开始</span></span><br><span class="line"><span class="comment"> *          string.startsWith("  abc") =&gt; true</span></span><br><span class="line"><span class="comment"> * public boolean endsWith(String suffix)判断当前串是否以参数中的子串为结束</span></span><br><span class="line"><span class="comment"> *          string.endsWith("YYzz") =&gt; false;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * public String substring(int start,int end) 从当前字符串中截取子串, 以start为开始索引(包含), 以end为结束索引(不包含)</span></span><br><span class="line"><span class="comment"> *          string.substring(16, 20) =&gt; "我喜欢你"</span></span><br><span class="line"><span class="comment"> * public String substring(int startpoint) 从startpoint到最后取子串</span></span><br><span class="line"><span class="comment"> *          string.substring(21) 等价于 string.substring(21, string.length());</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * public String replace(char oldChar,char newChar) 把当前串中的所有的oldChar全部替换为newChar, 返回新串</span></span><br><span class="line"><span class="comment"> *          string.replace(' ', '#');</span></span><br><span class="line"><span class="comment"> * public String replaceAll(String old,String new)</span></span><br><span class="line"><span class="comment"> *          string.replaceAll(" ", "#");</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * public String trim() 修剪字符串首尾的空白字符.(码值小于等于32的都是空白字符)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * public String concat(String str)</span></span><br><span class="line"><span class="comment"> * public String toUpperCase() 变成大写</span></span><br><span class="line"><span class="comment"> * public String toLowerCase() 变成小写</span></span><br><span class="line"><span class="comment"> * public String[] split(String regex) 把字符串切割成多个部分, 参数中的子串为切割器, 切割的结果中不包含切割器</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="StringBuffer类和StringBuilder类"><a href="#StringBuffer类和StringBuilder类" class="headerlink" title="StringBuffer类和StringBuilder类"></a>StringBuffer类和StringBuilder类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">内容可以改变的Unicode字符序列, 内部仍然使用char[]保存字符序列, 可以添加和删除的, 对它的修改不会产生新对象,StringBuffer和StringBuilder类常用方法类似，StringBuilder是最新的替代StringBuffer,速度更快，但是线程不安全；StringBuffer是老的API，速度慢，线程安全。</span><br></pre></td></tr></table></figure>

<p>常用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">append</span><span class="params">(...)</span> <span class="comment">//可以在当前串后面追加任意数据</span></span></span><br><span class="line"><span class="function">StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, ....)</span> <span class="comment">//在指定下标处插入新内容</span></span></span><br><span class="line"><span class="function">StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> <span class="comment">//删除一个区间</span></span></span><br><span class="line"><span class="function">StringBuffer <span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span> ch)</span></span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>JavaSE</category>
        <category>Java常用类</category>
      </categories>
  </entry>
  <entry>
    <title>工厂方法模式</title>
    <url>/2020/04/13/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>​    定义了一个创建对象的抽象方法，由子类决定要实例化的类。<strong><em>工厂方法模式将对象的实例化推迟到子类。</em></strong></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建者类型</category>
      </categories>
  </entry>
  <entry>
    <title>异常</title>
    <url>/2020/04/11/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h3 id="1-异常类型分类"><a href="#1-异常类型分类" class="headerlink" title="1.异常类型分类"></a>1.异常类型分类</h3><p>异常按照类型分为两大类：</p>
<ul>
<li><p>受检异常</p>
<p>受检异常是指程序中必须检查和处理的异常，由Exception类表示（RuntimeException除外）</p>
</li>
<li><p>非受检异常</p>
<p>非受检异常是程序中可以不接受检查和处理（轻微的异常可以不处理），或致命性的异常（致命异常没法处理）</p>
</li>
</ul>
<p>分类如下图所示</p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/%E5%BC%82%E5%B8%B8.png" alt="异常分类"></p>
<h3 id="2-异常捕获"><a href="#2-异常捕获" class="headerlink" title="2.异常捕获"></a>2.异常捕获</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//GC只能释放GC区中的资源，finally中释放的是不在GC区中的资源，通常是像OS申请的硬件资源</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>finally中的代码不管try中是否异常都会执行，当try中有return语句时，会先将return的值保存在临时变量中，然后执行finally代码块，如果finally中有return语句，则以finally中的返回语句为主，否则执行try中的return</p>
<p>实例代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//因为有finally代码块，所以这里会将n的值放到临时空间中，然后去执行finally语句块的代码</span></span><br><span class="line">            <span class="comment">//如果finally有return,则直接return，没有则从try中的return路径返回</span></span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            ++n;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(test());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>



<h3 id="3-异常抛出"><a href="#3-异常抛出" class="headerlink" title="3.异常抛出"></a>3.异常抛出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）在方法签名中使用throws 异常类型   发出异常警告表明方法中可能会抛出某种异常，受检异常一定要在方法签名发出异常警告，RuntimeException这种非受检异常则可以也可以不用通过throws发出异常警告。 </span><br><span class="line">2）在方法中使用throw将异常抛出。</span><br><span class="line">3）也可以捕获后对异常进行包装再抛出，项目中一般都是捕获后包装为自定义异常。</span><br></pre></td></tr></table></figure>

<h3 id="4-自定义异常"><a href="#4-自定义异常" class="headerlink" title="4.自定义异常"></a>4.自定义异常</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）继承Exception</span><br><span class="line">2）提供两个构造器，一个String参数，一个Throwable参数</span><br></pre></td></tr></table></figure>



<h3 id="5-什么时候捕获异常，什么时候捕获异常呢？"><a href="#5-什么时候捕获异常，什么时候捕获异常呢？" class="headerlink" title="5.什么时候捕获异常，什么时候捕获异常呢？"></a>5.什么时候捕获异常，什么时候捕获异常呢？</h3><p>​    当存在异常时，被调用的方法应该抛出异常（它出问题时对栈的影响不大），目的是给调用者一个出问题的信号；入口方法（main）应该捕获异常，因为它一旦抛出异常。会导致栈作废</p>
<h3 id="6-补充"><a href="#6-补充" class="headerlink" title="6.补充"></a>6.补充</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法重写，覆盖的条件</span><br><span class="line">1）方法签名一致：返回值类型（子类返回值类型可以小于等于父类的），方法名，参数列表一致</span><br><span class="line">2）子类方法的访问修饰符要大于等于父类的</span><br><span class="line">3）被覆盖的方法不能由private,static,final修饰</span><br><span class="line">4）子类抛出的异常类型必须小于等于父类的异常类型</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>抽象类跟接口的对比</title>
    <url>/2020/04/11/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%B7%9F%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h3 id="抽象类跟接口的对比"><a href="#抽象类跟接口的对比" class="headerlink" title="抽象类跟接口的对比"></a>抽象类跟接口的对比</h3><table>
<thead>
<tr>
<th></th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>某类不同种事物的抽象定义</td>
<td>不同类不同事物共同行为的抽象定义</td>
</tr>
<tr>
<td>组成</td>
<td>属性，方法，构造器，语句块，抽象方法</td>
<td>全局常量，公共抽象方法</td>
</tr>
<tr>
<td>如何使用</td>
<td>被子类继承extends</td>
<td>被子类实现implements</td>
</tr>
<tr>
<td>两者关系</td>
<td>抽象类可以实现接口</td>
<td>被实现</td>
</tr>
<tr>
<td>常见设计模式</td>
<td>模板设计模式</td>
<td>代理模式，工厂模式</td>
</tr>
<tr>
<td>创建对象</td>
<td>通过多态使用子类对象</td>
<td>通过多态指向子类对象</td>
</tr>
<tr>
<td>局限性</td>
<td>单继承</td>
<td>无</td>
</tr>
<tr>
<td>实际应用</td>
<td>模板</td>
<td>能力，标准规范</td>
</tr>
<tr>
<td>选择</td>
<td>优先选择接口</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2020/04/10/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="代理模式简述"><a href="#代理模式简述" class="headerlink" title="代理模式简述"></a>代理模式简述</h3><p>代理模式其实就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。一般下面两种情况会使用到代理模式</p>
<p>1）使用者无法直接使用到被代理的对象，比如在大城市租房，几乎是没法找到直接房东的，只好找中介代理</p>
<p>2）没法去修改被代理对象的功能，但需要对其中的业务方法进行升级，所以就需要通过代理对象和被代理对象关联起来，进而实现业务方法的增强</p>
<p>以租房代码举例</p>
<p>租房接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HouseRent</span> </span>&#123;</span><br><span class="line">    <span class="comment">//租房</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现租房接口的房东(具备房源)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Landlord</span> <span class="keyword">implements</span> <span class="title">HouseRent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是房东爸爸，月租100，想租请联系12435325"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span> <span class="keyword">implements</span> <span class="title">HouseRent</span> </span>&#123;</span><br><span class="line">    HouseRent landlord = <span class="keyword">new</span> Landlord();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是租房中介：押二付一"</span>);</span><br><span class="line">        landlord.rent();</span><br><span class="line">        System.out.println(<span class="string">"租房完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>租房的测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Landlord</span> <span class="keyword">implements</span> <span class="title">HouseRent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是房东爸爸，月租100，想租请联系12435325"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>枚举</title>
    <url>/2020/04/10/%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>枚举类型是Java5中新增特性的一部分，它是一种特殊的数据类型，之所以特殊是因为它即是一种类类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性，安全性和便捷性。</p>
<h3 id="简单的枚举定义"><a href="#简单的枚举定义" class="headerlink" title="简单的枚举定义"></a>简单的枚举定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Week&#123;</span><br><span class="line">    MON,TUE,WED,THU,FRI,SAT,SUN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.直接访问</span></span><br><span class="line">        System.out.println(Week.MON);</span><br><span class="line">        <span class="keyword">int</span> i = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//访问枚举对象数组</span></span><br><span class="line">        Week[] weeks = Week.values();</span><br><span class="line">        System.out.println(weeks[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举实现原理"><a href="#枚举实现原理" class="headerlink" title="枚举实现原理"></a>枚举实现原理</h3><p>​    实际上在使用关键字<code>enum</code>创建枚举类型并编译后，编译器会为我们生成一个相关的类，这个类继承了Java API中的<code>java.lang.Enum</code>类，也就是说通过关键字<code>enum</code>创建枚举类型在编译后事实也是一个类类型而且该类继承了<code>java.lang.Enum</code>类。在编译后，会生成对应的<code>Week.class</code>文件，通过<code>xjad</code>工具进行反编译，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.</span></span><br><span class="line"><span class="comment">// Jad home page: http://www.kpdus.com/jad.html</span></span><br><span class="line"><span class="comment">// Decompiler options: packimports(3) fieldsfirst ansi space </span></span><br><span class="line"><span class="comment">// Source File Name:   EnumTest.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.javase.enumtest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Week</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week MON;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week TUE;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week WED;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week THU;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week FRI;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week SAT;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week SUN;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Week $VALUES[];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Week[] values()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (Week[])$VALUES.clone();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Week <span class="title">valueOf</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (Week)Enum.valueOf(com/atguigu/javase/enumtest/Week, name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Week</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(s, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> </span><br><span class="line">	&#123;</span><br><span class="line">		MON = <span class="keyword">new</span> Week(<span class="string">"MON"</span>, <span class="number">0</span>);</span><br><span class="line">		TUE = <span class="keyword">new</span> Week(<span class="string">"TUE"</span>, <span class="number">1</span>);</span><br><span class="line">		WED = <span class="keyword">new</span> Week(<span class="string">"WED"</span>, <span class="number">2</span>);</span><br><span class="line">		THU = <span class="keyword">new</span> Week(<span class="string">"THU"</span>, <span class="number">3</span>);</span><br><span class="line">		FRI = <span class="keyword">new</span> Week(<span class="string">"FRI"</span>, <span class="number">4</span>);</span><br><span class="line">		SAT = <span class="keyword">new</span> Week(<span class="string">"SAT"</span>, <span class="number">5</span>);</span><br><span class="line">		SUN = <span class="keyword">new</span> Week(<span class="string">"SUN"</span>, <span class="number">6</span>);</span><br><span class="line">		$VALUES = (<span class="keyword">new</span> Week[] &#123;</span><br><span class="line">			MON, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看出枚举类型就是实实在在的类，且里面定义的都是静态常量对象，可以直接通过类名访问，也可以通过<code>valueof(),values()</code>访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//1.直接访问</span></span><br><span class="line">       System.out.println(Week.MON);</span><br><span class="line">       <span class="keyword">int</span> i = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">       <span class="comment">//访问枚举对象数组</span></span><br><span class="line">       Week[] weeks = Week.values();</span><br><span class="line">       Week mon = Week.valueOf(<span class="string">"MON"</span>);</span><br><span class="line">       System.out.println(mon);</span><br><span class="line">       System.out.println(weeks[i]);</span><br><span class="line">       <span class="comment">//printWeek(weeks[i]);</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>还可以在枚举中自定义属性，自定义构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Week&#123;</span><br><span class="line">    MON(<span class="string">"红色"</span>),TUE(<span class="string">"橙色"</span>),WED(<span class="string">"黄色"</span>),THU(<span class="string">"绿色"</span>),FRI(<span class="string">"青色"</span>),SAT(<span class="string">"蓝色"</span>),SUN(<span class="string">"紫色"</span>);</span><br><span class="line">    String color;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Week</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Week</span><span class="params">(String color)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">",color:"</span> + color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Week[] values = Week.values();</span><br><span class="line">        <span class="keyword">for</span> (Week value : values) &#123;</span><br><span class="line">            System.out.println(value.toString());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MON,color:红色</span><br><span class="line">TUE,color:橙色</span><br><span class="line">WED,color:黄色</span><br><span class="line">THU,color:绿色</span><br><span class="line">FRI,color:青色</span><br><span class="line">SAT,color:蓝色</span><br><span class="line">SUN,color:紫色</span><br></pre></td></tr></table></figure>

<p>默认的无参构造会在编译后变成两个参数(<strong>*String参数s对应的是常量枚举对象的字符串表示，int参数i对应的是常量枚举对象在数组中的顺序</strong>)的构造方法，一个参数的构造方法在编译后会变成三个参数的构造方法，如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.javase.enumtest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Week</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week MON;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week TUE;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week WED;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week THU;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week FRI;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week SAT;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week SUN;</span><br><span class="line">	String color;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Week $VALUES[];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Week[] values()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (Week[])$VALUES.clone();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Week <span class="title">valueOf</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (Week)Enum.valueOf(com/atguigu/javase/enumtest/Week, name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Week</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(s, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Week</span><span class="params">(String s, <span class="keyword">int</span> i, String color)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(s, i);</span><br><span class="line">		<span class="keyword">this</span>.color = color;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">new</span> StringBuilder()).append(<span class="keyword">super</span>.toString()).append(<span class="string">",color:"</span>).append(color).toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> </span><br><span class="line">	&#123;</span><br><span class="line">		MON = <span class="keyword">new</span> Week(<span class="string">"MON"</span>, <span class="number">0</span>, <span class="string">"红色"</span>);</span><br><span class="line">		TUE = <span class="keyword">new</span> Week(<span class="string">"TUE"</span>, <span class="number">1</span>, <span class="string">"橙色"</span>);</span><br><span class="line">		WED = <span class="keyword">new</span> Week(<span class="string">"WED"</span>, <span class="number">2</span>, <span class="string">"黄色"</span>);</span><br><span class="line">		THU = <span class="keyword">new</span> Week(<span class="string">"THU"</span>, <span class="number">3</span>, <span class="string">"绿色"</span>);</span><br><span class="line">		FRI = <span class="keyword">new</span> Week(<span class="string">"FRI"</span>, <span class="number">4</span>, <span class="string">"青色"</span>);</span><br><span class="line">		SAT = <span class="keyword">new</span> Week(<span class="string">"SAT"</span>, <span class="number">5</span>, <span class="string">"蓝色"</span>);</span><br><span class="line">		SUN = <span class="keyword">new</span> Week(<span class="string">"SUN"</span>, <span class="number">6</span>, <span class="string">"紫色"</span>);</span><br><span class="line">		$VALUES = (<span class="keyword">new</span> Week[] &#123;</span><br><span class="line">			MON, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2020/04/10/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">内部类：在类中再定义其它类</span><br></pre></td></tr></table></figure>

<h3 id="1-内部类分类"><a href="#1-内部类分类" class="headerlink" title="1.内部类分类"></a>1.内部类分类</h3><p>​    1）成员内部类：声明在类中方法外的内部类</p>
<ul>
<li><p>普通成员内部类：没有static修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner1</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//普通成员内部类是隶属于外部类对象的,在内部类当中可以随意的访问外部类成员</span></span><br><span class="line">        <span class="comment">//普通的成员内部类中不能由static属性，因为是隶属于外部对象的</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inner1Test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"成员内部类的属性："</span> + Inner1.<span class="keyword">this</span>.num);</span><br><span class="line">            System.out.println(<span class="string">"成员内部类访问外部类的属性："</span> + Outer.<span class="keyword">this</span>.num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outerTest1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类方法"</span>);</span><br><span class="line">        Inner1 inner = <span class="keyword">this</span>.<span class="keyword">new</span> Inner1();</span><br><span class="line">        inner.inner1Test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">outerTest2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类的私有方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在外部想要生成一个内部类对象的话代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">       <span class="comment">//直接在测试类中new一个内部类的对象,需要先生成一个外部类的对象，因为非静态内部类是属于外部类对象的</span></span><br><span class="line">       Outer.Inner1 outerInner = outer.<span class="keyword">new</span> Inner1();</span><br><span class="line">       outerInner.inner1Test1();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>静态成员内部类，被static修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//静态成员内部类，加static修饰，本质上和外部类平行的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner2</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outerTest1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类方法"</span>);</span><br><span class="line">        Inner1 inner = <span class="keyword">this</span>.<span class="keyword">new</span> Inner1();</span><br><span class="line">        inner.inner1Test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">outerTest2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类的私有方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在外部生成静态成员内部类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer.Inner2 inner2 = <span class="keyword">new</span> Outer.Inner2();</span><br><span class="line">        System.out.println(inner2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>​         </p>
<p>​    2）局部内部类：声明在方法中的内部类</p>
<ul>
<li><p>普通局部内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 普通局部内部类, 类的定义写在方法中, 不可以加访问控制修饰</span></span><br><span class="line">        <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner3</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Inner3&#123;"</span> +</span><br><span class="line">                        <span class="string">"id="</span> + id +</span><br><span class="line">                        <span class="string">'&#125;'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Inner3 inner3 = <span class="keyword">new</span> Inner3();</span><br><span class="line">        inner3.id = <span class="number">200</span>;</span><br><span class="line">        System.out.println(inner3);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><h4 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a><strong><em>匿名内部类（重点）</em></strong></h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerclassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 匿名内部类，不能后期创建对象，在声明的同时必须创建唯一对象</span></span><br><span class="line">        <span class="comment">//匿名内部类通常就是和接口配合，接口中的方法通常也不多</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * new 父类|接口（）&#123;</span></span><br><span class="line"><span class="comment">        *   类体部分，类体相当于new后面的父类或者接口的实现子类</span></span><br><span class="line"><span class="comment">        * &#125;</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        MyInterface myInterface = <span class="keyword">new</span> MyInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"我是匿名内部类的方法体"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(myInterface.getInfo());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>简单工厂模式</title>
    <url>/2020/04/09/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>1）简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式。</p>
<p>2）简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为。</p>
<p>3）在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用工厂模式</p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建者类型</category>
      </categories>
  </entry>
  <entry>
    <title>注解概述</title>
    <url>/2020/04/09/%E6%B3%A8%E8%A7%A3%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h3><p>自<code>Java5.0</code>版本引入注解之后，它就成为了Java中非常重要的一部分，下面介绍的内容包含以下几个部分：<br>1）什么是注解<br>2）为什么要引入注解<br>3）注解是如何工作的<br>4）如何编写自定义注解？什么时候可以用注解以及<code>ADF</code>（应用开发框架）</p>
<h3 id="1-什么是注解"><a href="#1-什么是注解" class="headerlink" title="1. 什么是注解"></a>1. 什么是注解</h3><p>  用一个词就可以描述注解，那就是元数据，即一种描述数据的数据。所以，可以说注解就是源代码的元数据。比如，下面这段代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public String toString()&#123;</span><br><span class="line">    return &quot;This is String Representation of current object.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在这段代码中，用到@Override注解，@Override告诉编译器这个方法是一个重写方法，如果父类方法中不存在这个方法，编译器则会报错，提示该方法没有重写父类中的方法。<br>Annotation是一种应用于类，方法，参数，变量，构造器及包声明中的特殊修饰符。它是一种由JSR-175标准选择用来描述元数据的一种工具</p>
<h3 id="2-为什么要引入注解"><a href="#2-为什么要引入注解" class="headerlink" title="2. 为什么要引入注解"></a>2. 为什么要引入注解</h3><p>​    使用Annotation之前（甚至在使用之后），XML被广泛地应用于描述元数据。不知何时开发一些应用开发人员和架构师发现XML的维护越来越糟糕了。他们希望使用一些代码紧耦合的东西，而不是像XML那样和代码是松耦合的（在某些情况下甚至是完全分离的）代码描述。如果你在Google中搜索“XML vs annotations”,会看到许多关于问题的辩论。最有趣的是XML配置其实就是为了分离代码和配置而引入的。上述两种观点可能会让你很疑惑，但皆有利弊。下面通过一个例子来理解这个二者的区别。<br>​    假如你想为应用设置很多的常量或参数，这种情况下，XML是一个很好的选择，因为它不会痛特定的代码相连。如果你想把某个方法声明为服务，那么使用Annotation会更好一些，因为这种情况下需要注解和方法紧密耦合起来，开发人员也必须认识到这点。<br>​    另一个重要的因素是Annotation定义了一种标准的描述元数据的方式，在这之前，开发人员通常使用他们自己的方式定义元数据。例如，使用标记interfaces,注释，transient关键字等待。每个程序员按照自己的方式定义元数据，而不想Annotation这种标注你的方式。<br>​    目前，许多框架将XML和Annotation两种方式结合使用，平衡两者之间的利弊。</p>
<ul>
<li><p><strong><em>Annotation是如何工作的？怎么编写自定义的Annotation？</em></strong></p>
<p>在讲述这部分之前，建议首先下载Annotation的示例代码<code>AnnotationSample.zip</code>放到<code>IDE</code>中进行理解。<br>编写Annotation非常简单，可以将Annotation的定义同接口的定义进行比较。下面看两个例子：一个是标标准的@Override，另一个是用户自定义注解<code>@Todo</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface Override&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于@Override注释你可能有些疑问，它什么都没做，那它是如何检查在父类中有一个同名的函数呢。@Override注解的定义不仅仅只有这么一点代码。这部分内容很重要，不得不再次重复：Annotations仅仅是元数据，和业务逻辑无关。理解起来有点困难，但就是这样。如果Annotations不包含业务逻辑，那么必须有人来实现这些逻辑。元数据的用户来做这些事情。<strong><em>Annotations仅仅提供它定义的属性（类/方法/包/域）的信息。Annotations的用户（同样是一些代码）来读取这些信息并实现必要的逻辑。</em></strong><br>当我们使用Java的标注Annotations（例如@Override）时，<code>JVM</code>就是一个用户，它在字节码层面工作。到这里，应用开发人员还不能控制也不能使用自定义的注解。因此，讲解一下如何编写自定义的Annotations。<br>下面将逐个讲述编写自定义Annotations的要点。上面的例子中，你看到一些注解应用在注解上。</p>
<p><code>J2SE5.0</code>版本在<code>java.lang.annotation</code>提供了四种元注解，专门注解其它的注解：</p>
<pre><code>@Documented -注解是否将包含在`JavaDoc`中
@Retention -什么时候使用该注解
@Target -注解用于什么地方
@Inherited -是否允许子类继承该注解</code></pre><p>@Documented -一个简单的Annotations标记注解，表示是否将注解信息添加在Java文档中。<br>@Retention -定义该注解的生命周期</p>
<pre><code>`RetentionPolicy.SOURCE` -在编译阶段丢弃。这些注解只停留在源码，在编译结束之后就不再有意义，所以他们不会写入字节码。`@Override，@SuppressWarnings`都属于这类注解
`RetentionPolicy.CLASS` -在类加载的时候丢弃。在字节码文件的处理中有用，注解默认使用这种方式。
`RetentionPolicy.RUNTIME` -始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式</code></pre><p>@Target -表示该注解用于什么地方。如果不明确指出，该注解可以放在任何地方。以下是一些可用的参数。需要寿命的是：属性的注解是兼容的，如果你想给6个属性都添加注解，仅仅排除一个属性，那么你需要在定义target包含所有的属性。</p>
<pre><code>`ElementTYpe.TYPE`:用于描述类，接口或`enum`声明
`ElementTYpe.FIELD`:用于描述实例变量
`ElementTYpe.METHOD`</code></pre><p>   <code>ElementTYpe.PARAMETER</code><br>   <code>ElementTYpe.CONSTRUCTOR</code><br>   <code>ElementTYpe.LOCAL_VARIABLE</code></p>
<p>   <code>ElementTYpe.ANNOCATION_TYPE</code>另一个注释<br>   <code>ElementTYpe.PACKAGE</code> 用于记录Java文件的package信息<br>@Inherited -定义该注释和子类的关系</p>
<p>那么，注解的内部到底是如何定义的呢？Annotations只支持基本类型、String、枚举类型。注释中所有的属性被定义成方法，并允许提供默认值。</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> Todo &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Priority &#123;LOW, MEDIUM, HIGH&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Status &#123;STARTED, NOT_STARTED&#125;</span><br><span class="line">    <span class="function">String <span class="title">author</span><span class="params">()</span> <span class="keyword">default</span> "Yash"</span>;</span><br><span class="line">    <span class="function">Priority <span class="title">priority</span><span class="params">()</span> <span class="keyword">default</span> Priority.LOW</span>;</span><br><span class="line">    <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">default</span> Status.NOT_STARTED</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    下面的例子演示了如何使用上面的注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Todo</span>(priority = Todo.Priority.MEDIUM, author = <span class="string">"Yashwant"</span>, status = Todo.Status.STARTED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incompleteMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//Some business logic is written</span></span><br><span class="line"><span class="comment">//But it’s not complete yet</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    但目前为止一切看起来都还不错。我们定义了自己的注解并将其应用在业务逻辑的方法上。现在我们需要写一个用户程序调用我们的注解。这里我们需要使用反射机制。如果你熟悉反射代码，就会知道反射可以提供类名、方法和实例变量对象。所有这些对象都有<code>getAnnotation()</code>这个方法用来返回注解信息。我们需要把这个对象转换为我们自定义的注释(使用 <code>instanceOf()</code>检查之后)，同时也可以调用自定义注释里面的方法。看看以下的实例代码，使用了上面的注解:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class businessLogicClass = BusinessLogic<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="keyword">for</span>(Method method : businessLogicClass.getMethods()) &#123;</span><br><span class="line">        Todo todoAnnotation = (Todo)method.getAnnotation(Todo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span>(todoAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">" Method Name : "</span> + method.getName());</span><br><span class="line">        System.out.println(<span class="string">" Author : "</span> + todoAnnotation.author());</span><br><span class="line">        System.out.println(<span class="string">" Priority : "</span> + todoAnnotation.priority());</span><br><span class="line">        System.out.println(<span class="string">" Status : "</span> + todoAnnotation.status());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-注解用例"><a href="#3-注解用例" class="headerlink" title="3. 注解用例"></a>3. 注解用例</h3><p>  注解的功能很强大，Spring和<code>Hebernate</code>这些框架在日志和有效性中大量使用了注解功能。注解可以应用在使用标记接口的地方。不同的是标记接口用来定义完整的类，但你可以为单个的方法定义注释，例如是否将一个方法暴露为服务。</p>
<p>  在最新的<code>servlet3.0</code>中引入了很多新的注解，尤其是和<code>servlet</code>安全相关的注解。</p>
<p>  <code>HandlesTypes</code> –该注解用来表示一组传递给<code>ServletContainerInitializer</code>的应用类。</p>
<p>  <code>HttpConstraint</code> – 该注解代表所有HTTP方法的应用请求的安全约束，和<code>ServletSecurity</code>注释中定义的<code>HttpMethodConstraint</code>安全约束不同。</p>
<p>  <code>HttpMethodConstraint</code> – 指明不同类型请求的安全约束，和<code>ServletSecurity</code>注解中描述HTTP协议方法类型的注释不同。</p>
<p>  <code>MultipartConfig</code> –该注解标注在<code>Servlet</code>上面，表示该<code>Servlet</code>希望处理的请求的 MIME 类型是 <code>multipart/form-data</code>。</p>
<p> <code>ServletSecurity</code> 该注解标注在<code>Servlet</code>继承类上面，强制该HTTP协议请求遵循安全约束。</p>
<p>  <code>WebFilter</code> – 该注解用来声明一个<code>Server</code>过滤器；</p>
<p> <code>WebInitParam</code> – 该注解用来声明<code>Servlet</code>或是过滤器的中的初始化参数，通常配合 <code>@WebServlet</code>或者 <code>@WebFilter</code>使用。</p>
<p> <code>WebListener</code> –该注解为Web应用程序上下文中不同类型的事件声明监听器。</p>
<p> <code>WebServlet</code> –该注解用来声明一个<code>Servlet</code>的配置。</p>
<h3 id="4-ADF（应用程序开发框架）和-注解"><a href="#4-ADF（应用程序开发框架）和-注解" class="headerlink" title="4. ADF（应用程序开发框架）和 注解"></a>4. <code>ADF</code>（应用程序开发框架）和 注解</h3><p>  现在我们开始讨论文章的最后一部分了。应用程序框架，被称为<code>ADF</code>，由Oracle开发用来创建Oracle融合应用。我们已经了解了注解的优缺点，也知道如何编写自定义的注解，但我们应该将注解应用在<code>ADF</code>的哪部分呢？<code>ADF</code>是否提供了一些朴素的注解？很好的问题，确实在<code>ADF</code>中大量使用注解有一些限制。之前提到的应用框架如Spring和Hibernate使用<code>AOP</code>(面向侧面的程序设计)。在<code>AOP</code>中，框架提供了一种机制，在事件的预处理和后续处理中注入代码。例如：你有一个钩子用来在方法执行之前和之后添加代码，所以你可以在这些地方编写你的用户代码。<code>ADF</code>不使用<code>AOP</code>。如果我们有任何注解的用例可用，我们可能需要通过继承的方式实现。</p>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2020/04/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单例模式即某个类中只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。</span><br></pre></td></tr></table></figure>

<h3 id="2-单例模式实现的8种方式"><a href="#2-单例模式实现的8种方式" class="headerlink" title="2.单例模式实现的8种方式"></a>2.单例模式实现的8种方式</h3><ul>
<li><p>2.1.1<strong><em>饿汉式</em></strong>（静态常量）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 饿汉式（静态变量）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  不会造成多线程的同步问题，但是对象是在类加载的时候就初始化了，如果不用就会造成浪费，最好是确</span></span><br><span class="line"><span class="comment">* *定要用到再去生成实例，但是如果确定这个对象会使用，这种方式也是可以使用的</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>2.1.2  <strong><em>饿汉式</em></strong>（静态代码块）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 饿汉式（静态代码块）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//跟上面的是一样的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2.2.1 <strong><em>懒汉式</em></strong>（线程不安全）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 懒汉式（线程不安全）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1）起到了懒加载的效果，但是只能在单线程下使用</span></span><br><span class="line"><span class="comment">* 2）但是在多线程下，如果线程1进入了if(instance == null)语句块，还未来得及往下执行，另一个线程2也通过了这个判断语句，这个时候则会产生多个实例，所以多线程下不可以使用这种方式。</span></span><br><span class="line"><span class="comment">* 3）综上，开发过程中不能使用这种方式</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2.2.2 <strong><em>懒汉式</em></strong>（线程安全,同步问题）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 懒汉式（线程安全，同步方法）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供一个静态的共有方法，加入同步处理的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1）解决了线程不安全问题</span></span><br><span class="line"><span class="comment"> * 2）效率太低了，每个线程在想获得类的实例的时候，执行getInstance()都要同步，而其实这个方法只执行   *一次实例化代码就够了，后面的想要获得该实例，直接return就可以了。</span></span><br><span class="line"><span class="comment">   3）效率太低，不推荐使用	</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2.3.1 双重检查（保证线程安全并且懒加载）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 双重检查</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1）代码中进行了两次if(instance == null)检查，这样可以保证线程安全	</span></span><br><span class="line"><span class="comment">* 2）这样实例化代码只会执行一次，后面再次访问时，判断if(instance == null)，直接return实例化对象，也避免反复进行方法同步</span></span><br><span class="line"><span class="comment">* 3）线程安全；延迟加载；效率较高</span></span><br><span class="line"><span class="comment">* 4）结论：在实际开发过程中，推荐使用这种单例模式</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2.4.1 使用静态内部类完成单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *通过静态内部类实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">   <span class="comment">//写一个静态内部类额，该类中有一个静态属性Singleton</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//提供一个静态的共有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1）外部类在加载的时候，内部的静态内部类是不会加载的，从而保证了懒加载</span></span><br><span class="line"><span class="comment">* 2）当调用getInstance()获取INSTANCE时，会触发静态内部类Singleton Instance的加载，而类的静态属性只会在第一次加载类的时候初始化，</span></span><br><span class="line"><span class="comment">* JVM在加载类的时候是线程安全的，在类初始化的时候别的线程是无法进入的，所以保证了线程安全的</span></span><br><span class="line"><span class="comment">* 3）推荐使用</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2.5.1 枚举</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    INSTANCE;<span class="comment">//属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.INSTANCE;</span><br><span class="line">        Singleton instance2 = Singleton.INSTANCE;</span><br><span class="line">        System.out.println(instance == instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 1）这借助JDK1.5添加的枚举来实现单例模式，不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象</span></span><br><span class="line"><span class="comment"> *  2）这种方式是Effective Java作者Josh Bloch提倡的方式</span></span><br><span class="line"><span class="comment"> *  3）结论：推荐使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="在JDK中，java-lang-Runtime就是经典的单例模式"><a href="#在JDK中，java-lang-Runtime就是经典的单例模式" class="headerlink" title="在JDK中，java.lang.Runtime就是经典的单例模式"></a><strong><em>在<code>JDK</code>中，<code>java.lang.Runtime</code>就是经典的单例模式</em></strong></h3><h3 id="3-单例模式注意事项和细节说明"><a href="#3-单例模式注意事项和细节说明" class="headerlink" title="3.单例模式注意事项和细节说明"></a>3.单例模式注意事项和细节说明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。</span><br><span class="line">2）当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new</span><br><span class="line">3）单例模式使用的场景：需要频繁进行创建和销毁的对象，创建对象时耗时过多或耗费资源过多（即：重量级对象）但又经常用到的对象，工具类对象，频繁访问数据库或文件的对象（比如数据源，session工厂等）</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>接口</title>
    <url>/2020/04/08/%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h3 id="1-接口的用途是用来定义现实世界不同类型事物的共同行为特征"><a href="#1-接口的用途是用来定义现实世界不同类型事物的共同行为特征" class="headerlink" title="1.接口的用途是用来定义现实世界不同类型事物的共同行为特征"></a>1.接口的用途是用来定义现实世界<strong><em>不同类型事物</em></strong>的共同行为特征</h3><p>接口关注的是行为特征，比如：<br>1）飞行特征（包括起飞，飞行，着陆等行为）是鸟和飞机所共有的。鸟和飞机的共同行为特征可被定义在接口中</p>
<h3 id="2-接口中的所有方法都是抽象方法，接口是没有构造器的"><a href="#2-接口中的所有方法都是抽象方法，接口是没有构造器的" class="headerlink" title="2.接口中的所有方法都是抽象方法，接口是没有构造器的"></a>2.接口中的所有方法都是抽象方法，接口是没有构造器的</h3><h3 id="3-接口中的所有属性必然是全局常量（public-static-final），只能读不能改，这样才能为实现接口的对象提供一个统一的属性"><a href="#3-接口中的所有属性必然是全局常量（public-static-final），只能读不能改，这样才能为实现接口的对象提供一个统一的属性" class="headerlink" title="3. 接口中的所有属性必然是全局常量（public static final），只能读不能改，这样才能为实现接口的对象提供一个统一的属性"></a>3. 接口中的所有属性必然是全局常量（public static final），只能读不能改，这样才能为实现接口的对象提供一个统一的属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通俗的讲，只要是认为会变化的东西，就放在我们的是实现中，不能放到接口里面去。对修改关闭，对扩展开放（不同的implements），接口是对开闭原则的一种体现。接口表达的是一种能力或某种标准规范，通常用形容词来命名接口。</span><br></pre></td></tr></table></figure>

<h3 id="4-接口中成员变量的默认修饰符是public-static-final，成员方法的默认修饰符是public-abstract"><a href="#4-接口中成员变量的默认修饰符是public-static-final，成员方法的默认修饰符是public-abstract" class="headerlink" title="4.接口中成员变量的默认修饰符是public static final，成员方法的默认修饰符是public abstract"></a>4.接口中成员变量的默认修饰符是public static final，成员方法的默认修饰符是public abstract</h3><h3 id="5-接口为什么可以多继承呢？因为接口中的都是抽象方法，没有方法体，没法压栈执行，具体的实现还得看具体的子类"><a href="#5-接口为什么可以多继承呢？因为接口中的都是抽象方法，没有方法体，没法压栈执行，具体的实现还得看具体的子类" class="headerlink" title="5.接口为什么可以多继承呢？因为接口中的都是抽象方法，没有方法体，没法压栈执行，具体的实现还得看具体的子类"></a>5.接口为什么可以多继承呢？因为接口中的都是抽象方法，没有方法体，没法压栈执行，具体的实现还得看具体的子类</h3>]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>抽象类。</title>
    <url>/2020/04/08/%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）抽象类使用abstract关键字修饰</span><br><span class="line">2）抽象类中可以包含抽象方法，抽象方法被abstract关键字修饰，并且只有方法声明</span><br><span class="line">3）抽象类也可以包含非抽象方法</span><br><span class="line">4）抽象类是不能创建对象的，因为抽象类中可能含有抽象方法，而抽象方法没法执行</span><br><span class="line">5）具体类继承抽象类时，需要重写所有抽象方法</span><br><span class="line">综上即包含抽象方法的类是抽象类，但是抽象类可以不包含抽象方法。具体类有的抽象类都可以有。</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>final关键字</title>
    <url>/2020/04/08/final%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final 修饰类，表明这个类是终极类，不能被继承。</span><br><span class="line">final 修饰方法，表明这个方法是终极完美方法，不允许子类重写。</span><br><span class="line">final 修饰变量，表明这个量是终极量，它必须被赋值唯一的一次，不允许多次赋值，也不允许不赋值。</span><br><span class="line">public static final 修饰的量 称为全局常量。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>static知识点</title>
    <url>/2020/04/07/static%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h3 id="1-类在加载时非静态成员是先于静态成员加载的，比如在饿汉单例模式中，有静态引用指向对象时，必须先保证对象能创建出来"><a href="#1-类在加载时非静态成员是先于静态成员加载的，比如在饿汉单例模式中，有静态引用指向对象时，必须先保证对象能创建出来" class="headerlink" title="1.类在加载时非静态成员是先于静态成员加载的，比如在饿汉单例模式中，有静态引用指向对象时，必须先保证对象能创建出来"></a>1.类在加载时非静态成员是先于静态成员加载的，比如在饿汉单例模式中，有静态引用指向对象时，必须先保证对象能创建出来</h3><h3 id="2-静态代码块又称为类的初始化块，是从属于类的，而普通的代码块是从属于对象的。当A类中有静态代码块，普通代码块时，B中同样有静态代码块和普通代码块，B类是A的子类，那么在生成B类的对象时，执行顺序是："><a href="#2-静态代码块又称为类的初始化块，是从属于类的，而普通的代码块是从属于对象的。当A类中有静态代码块，普通代码块时，B中同样有静态代码块和普通代码块，B类是A的子类，那么在生成B类的对象时，执行顺序是：" class="headerlink" title="2. 静态代码块又称为类的初始化块，是从属于类的，而普通的代码块是从属于对象的。当A类中有静态代码块，普通代码块时，B中同样有静态代码块和普通代码块，B类是A的子类，那么在生成B类的对象时，执行顺序是："></a>2. 静态代码块又称为类的初始化块，是从属于类的，而普通的代码块是从属于对象的。当A类中有静态代码块，普通代码块时，B中同样有静态代码块和普通代码块，B类是A的子类，那么在生成B类的对象时，执行顺序是：</h3><pre><code>1）A类的静态代码块  

2）B类的静态代码块 

3）A类的普通代码块

4）A类的构造方法 

5）B类的普通代码块 

6）B类的构造方法</code></pre>]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>多态知识点</title>
    <url>/2020/04/07/%E5%A4%9A%E6%80%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h3 id="1-属性不具备多态性，只有方法具备多态性"><a href="#1-属性不具备多态性，只有方法具备多态性" class="headerlink" title="1. 属性不具备多态性，只有方法具备多态性"></a>1. 属性不具备多态性，只有方法具备多态性</h3><h3 id="2-什么是虚方法引用？"><a href="#2-什么是虚方法引用？" class="headerlink" title="2.什么是虚方法引用？"></a>2.什么是虚方法引用？</h3><p>​    虚拟方法调用：通过多态引用调用多态方法</p>
]]></content>
      <categories>
        <category>JavaSE</category>
        <category>多态</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式的七大原则-迪米特法则</title>
    <url>/2020/04/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</url>
    <content><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>1）一个对象应该对其它对象保持最少的了解。</p>
<p>2）类与类关系越密切，耦合度越大。</p>
<p>3）<strong><em>迪米特法则（Demeter Principle）又叫最少知道原则</em></strong>，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多复杂，都尽量将逻辑封装在类的内部。对外除了提供public方法，不对外泄露任何信息。</p>
<p>4）<strong><em>迪米特法则还有个更简单的定义：只与直接的朋友通信。</em></strong></p>
<p>5）直接的朋友：只要两个对象之间有耦合关系，我们就说这两个对象是朋友关系。耦合的方法有很多：依赖，关联，组合，聚合等。<strong><em>其中我们称成员变量，方法参数，方法返回值中的类为直接朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</em></strong></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>1）迪米特法则的核心是降低类之间的耦合。</p>
<p>2）但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完全没有依赖关系。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>Object中的主要方法</title>
    <url>/2020/04/06/Object%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Object中的主要方法（没有属性）"><a href="#Object中的主要方法（没有属性）" class="headerlink" title="Object中的主要方法（没有属性）"></a>Object中的主要方法（没有属性）</h1><h3 id="1-public-boolean-equals-Object-obj-判断this对象和obj对象内容是否相等"><a href="#1-public-boolean-equals-Object-obj-判断this对象和obj对象内容是否相等" class="headerlink" title="1. public boolean equals(Object obj),判断this对象和obj对象内容是否相等"></a>1. <code>public boolean equals(Object obj)</code>,判断<code>this</code>对象和<code>obj</code>对象内容是否相等</h3><h3 id="2-public-int-hashCode-获得对象的Hash码"><a href="#2-public-int-hashCode-获得对象的Hash码" class="headerlink" title="2. public int hashCode()获得对象的Hash码"></a>2. <code>public int hashCode()</code>获得对象的Hash码</h3><p>​    2.1 哈希码：也称之为散列码，是为了使对象在内存不要重叠，尽量散开；对象的哈希码是通过哈希函数计算而得到的，但不同的对象可能会得到相同的哈希值，所以会存在哈希冲突（散列冲突），如果哈希值相同的对象不是很多，会将这些哈希码相同的对象放在一个单链表中进行存储，如果超过8则会通过红黑树进行存储。所以<strong><em>如果两个对象的<code>hashCode</code>不相同,则它们equals肯定是false,如果equals为true，则<code>hashCode</code>一定相同.</em></strong></p>
<p>​    2.2 <code>hashCode()</code>和<code>equals()</code>方法的作用其实一样，在<code>Java</code>里都是用来对比两个对象是否相等一致，那么既然equals()方法能够实现对比功能了，为什么还要<code>hashCode()</code>呢？</p>
<p>​    因为重写的equals()里一般比较得比较全面复杂，这样使用的时候效率就很低，而利用<code>hashCode()</code>方法进行对比，只要生成一个hash值就可以，效率很高。在<code>equals()</code>方法中一般就会先判断hash值是否相等，如果<code>hash</code>值不相等，则这两个对象肯定不一致，直接返回<code>false</code>；如果<code>hash</code>值相等，则继续进行更加详细的判断。</p>
<p>  所以<code>hashCode</code>方法和<code>equals</code>方法必须同时重写。</p>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>继承考点</title>
    <url>/2020/04/06/%E7%BB%A7%E6%89%BF%E8%80%83%E7%82%B9/</url>
    <content><![CDATA[<h3 id="1-为什么父类又被称之为基类或超类？"><a href="#1-为什么父类又被称之为基类或超类？" class="headerlink" title="1.为什么父类又被称之为基类或超类？"></a>1.为什么父类又被称之为基类或超类？</h3><p>​    基类：因为子类是在父类的基础上进行扩展（extends）</p>
<p>​    超类：因为在子类中使用关键字super标识从父类继承的成员</p>
<h3 id="2-什么是方法覆盖？方法覆盖有什么条件？"><a href="#2-什么是方法覆盖？方法覆盖有什么条件？" class="headerlink" title="2.什么是方法覆盖？方法覆盖有什么条件？"></a>2.什么是方法覆盖？方法覆盖有什么条件？</h3><p>​    子类根据需求对父类的方法进行重写，改造，对父类方法的不满</p>
<p>​    要求：</p>
<p>​            1）方法的签名一致，返回值类型，方法名，参数列表（参数类型，顺序，个数）</p>
<p>​            2）子类的覆盖方法的访问控制修饰符要大于等于父类的</p>
<h3 id="3-如果A类被B类继承，B类又被C类继承，在A-B-C类中都包含test-，创建C类对象，调用test-方法，执行的是哪个类的方法？在C类中有几个test-方法？"><a href="#3-如果A类被B类继承，B类又被C类继承，在A-B-C类中都包含test-，创建C类对象，调用test-方法，执行的是哪个类的方法？在C类中有几个test-方法？" class="headerlink" title="3.如果A类被B类继承，B类又被C类继承，在A B C类中都包含test()，创建C类对象，调用test()方法，执行的是哪个类的方法？在C类中有几个test()方法？"></a>3.如果A类被B类继承，B类又被C类继承，在A B C类中都包含test()，创建C类对象，调用test()方法，执行的是哪个类的方法？在C类中有几个test()方法？</h3><p>​    执行的是C类中的test()方法</p>
<p>​    1个方法：从测试类的角度去看，C类中只有一个test()方法，但是C类中保存了父类模板的标记，可以通过标记去访问父类的test方法</p>
<h3 id="4-子类能继承父类的私有成员嘛？如何处理呢？"><a href="#4-子类能继承父类的私有成员嘛？如何处理呢？" class="headerlink" title="4.子类能继承父类的私有成员嘛？如何处理呢？"></a>4.子类能继承父类的私有成员嘛？如何处理呢？</h3><p>​    子类能继承父类的所有成员（构造器除外），包括私有成员。</p>
<p>​    虽然能继承父类的私有成员，但是不可以直接访问，必须通过从父类继承的公共方法间接访问</p>
<h3 id="5-关于构造器"><a href="#5-关于构造器" class="headerlink" title="5.关于构造器"></a>5.关于构造器</h3><p>​    1）所有的类必须有构造器，如果类中没有提供任何构造器，那编译器会自动添加一个默认的构造器</p>
<p>​    2）所有类的构造器中都必须先有对父类构造器的调用，如何体现“先”，强制第一行</p>
<p>​        （1）所有类的构造器中默认第一行是super()</p>
<p>​        （2）所有类的第一行要么是this(…),要么是super(…)，不能同时存在</p>
<p>​          super的作用是直接调用父类构造器</p>
<p>​          this(…)作用的调用其它的重载构造器</p>
]]></content>
      <categories>
        <category>JavaSE</category>
        <category>继承</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式七大原则-开闭原则</title>
    <url>/2020/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h1>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式的七大原则-里氏替换原则</title>
    <url>/2020/04/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h1><p>​    1）里氏替换原则（<code>**Liskov Substitution Principle**</code>）在1988年，由麻省理工学院是一位姓里的女士提出的。</p>
<p>​    2）如果对每个类型为<code>T1</code>的对象<code>o1</code>，都有类型为<code>T2</code>的对象<code>o2</code>，使得以<code>T1</code>定义的所有程序P在所有的对象<code>o1</code>都替换成<code>o2</code>时，程序p的行为没有发生变化，那么类型<code>T2</code>时类型<code>T1</code>的子类型，<strong><em>换句话说，所有引用基类的地方必须能透明地使用其子类的对象</em></strong>。</p>
<p>​    3）<strong><em>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法</em></strong>。</p>
<p>​    4）里氏替换原则告诉我们，<strong><em>继承实际上让两个类的耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题,或者让原来的父类和和子类都继承一个更通俗的基类，原有的关系去掉。</em></strong></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式的七大原则-依赖倒转原则</title>
    <url>/2020/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h1><p>​    依赖倒转原则（Dependence Inversion Principle）是指：</p>
<p>1）高层模块不应依赖于低层模块，二者都应该依赖于抽象</p>
<p>2）抽象不应该依赖细节，细节应该依赖抽象</p>
<p>3）<strong>依赖倒转原则的中心思想是面向接口编程</strong></p>
<p>4）依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构以细节为基础搭建的架要稳定的多。在Java中，抽象指的是接口或抽象类，细节就是具体的实现类</p>
<p>5）使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式的七大原则-接口隔离原则</title>
    <url>/2020/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h1><p>1）一个类对另外一个类的依赖应该建立在最小的接口上。</p>
<p>例：类A通过<code>interface1</code>依赖类B，但是A只用到了B中的<code>operation1</code>和<code>operation2</code>方法，C通过<code>interface1</code>依赖类D，但是C只用到了D中的<code>operation1</code>和<code>operation3</code>方法，<strong>这样对于A类对B类的依赖以及C类对D类的依赖都没有建立在最小的接口上，</strong>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(Interface1 i)</span></span>&#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">        i.operation2();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        operation(<span class="keyword">new</span> B());<span class="comment">//A类通过Interface1使用了B类</span></span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        c.operation(<span class="keyword">new</span> D());<span class="comment">//C类通过Interface1使用了D类</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(Interface1 i)</span></span>&#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">        i.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>A类对B类的依赖以及C类对D类的依赖都没有建立在最小的接口上，违反了<em>接口隔离原则。</em></strong></p>
<p>应该对接口Interface1进行拆分如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(Interface1 i)</span></span>&#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">        i.operation2();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        operation(<span class="keyword">new</span> B());<span class="comment">//A类通过Interface1,Interface2使用了B类</span></span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        c.operation(<span class="keyword">new</span> D());<span class="comment">//C类通过Interface1,Interface3使用了D类</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(Interface1 i)</span></span>&#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">        i.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span>,<span class="title">Interface2</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    D<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span>,<span class="title">Interface3</span></span>&#123;</span><br><span class="line">     <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这样将<code>Interface1</code>进行拆分，A类通过<code>Interface1，Interface2</code>使用B类，C类通过<code>Interface1，Interface3</code>使用D类都建立在最小的接口上进行调用，接口中都没有多余的动能，这样就遵守了接口隔离原则。</strong></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>UML类图中的关系</title>
    <url>/2020/04/02/UML%E7%B1%BB%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><code>UML（unified modeling language）</code>是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果。其中类图中的关系中元素之间的关系有：依赖，泛化，实现，关联，聚合，组合等。</p>
<h1 id="1-依赖关系（Dependency）"><a href="#1-依赖关系（Dependency）" class="headerlink" title="1.依赖关系（Dependency）"></a>1.依赖关系（Dependency）</h1><p>​    依赖关系是一种使用关系，即在一个类中使用使用另一个类。在代码中的体现有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）类的成员变量</span><br><span class="line">2）方法的返回值</span><br><span class="line">3）方法接收的参数类型</span><br><span class="line">4）方法中使用到</span><br></pre></td></tr></table></figure>


<p>如程序员依赖（使用）计算机，则在UML类图中表现为程序员——-&gt;计算机</p>
<p><img src="https://imgedu.lagou.com/e29f0cb85f60465db8654eaf35e16bfc.jpg" alt="依赖关系"></p>
<h1 id="2-泛化关系（继承）"><a href="#2-泛化关系（继承）" class="headerlink" title="2.泛化关系（继承）"></a>2.泛化关系（继承）</h1><p> 【箭头指向】：带三角箭头的实线，箭头指向父类 </p>
<h1 id="3-实现关系"><a href="#3-实现关系" class="headerlink" title="3.实现关系"></a>3.实现关系</h1><p> 【箭头指向】：带三角箭头的虚线，箭头指向接口.(有些画法接口为一个圈，实现的类之间是一条直接) </p>
<h1 id="4-关联关系（Association）"><a href="#4-关联关系（Association）" class="headerlink" title="4. 关联关系（Association）"></a>4. 关联关系（Association）</h1><p>​       【关联关系】：是一种拥有的关系，它是依赖关系的特例，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。<br>　　【代码体现】：成员变量<br>　　【箭头及指向】：带普通箭头的实心线，指向被拥有者 </p>
<h1 id="5-聚合关系（Aggregation）"><a href="#5-聚合关系（Aggregation）" class="headerlink" title="5. 聚合关系（Aggregation）"></a>5. 聚合关系（Aggregation）</h1><p>​     【聚合关系】：是整体与部分，是“contains-a”关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。<br>　　聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。<br>　 【箭头及指向】：带空心菱形的实心线，菱形指向整体</p>
<h1 id="6-组合关系（composition）"><a href="#6-组合关系（composition）" class="headerlink" title="6. 组合关系（composition）"></a>6. 组合关系（composition）</h1><p>​       组合关系】：是整体与部分，是“has-a”关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。<br>　　组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。<br>　  【箭头及指向】：带实心菱形的实线，菱形指向整体</p>
]]></content>
      <categories>
        <category>UML</category>
        <category>类图</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式的七大原则-单一职责原则</title>
    <url>/2020/04/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1. 单一职责原则"></a>1. 单一职责原则</h1><p>​    对类来说，即一个类应该只负责一项职责。</p>
<h1 id="2-单一职责原则注意事项和细节"><a href="#2-单一职责原则注意事项和细节" class="headerlink" title="2. 单一职责原则注意事项和细节"></a>2. 单一职责原则注意事项和细节</h1><ul>
<li>1）降低类的复杂度，一个类只负责一项职责</li>
<li>2）提高类的可读性，可维护性</li>
<li>3）降低变更引起的风险</li>
<li>4）通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级别上违反单一职责原则，只有在类中方法数量足够少，可以在方法级别保持单一职责原则</li>
</ul>
<h1 id="3-代码举例"><a href="#3-代码举例" class="headerlink" title="3.代码举例"></a>3.代码举例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">        vehicle.run(<span class="string">"飞机"</span>);</span><br><span class="line">        vehicle.run(<span class="string">"汽车"</span>);</span><br><span class="line">        vehicle.run(<span class="string">"火车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交通工具类</span></span><br><span class="line"><span class="comment">//1.在方式1的run方法中违反了单一职责原则</span></span><br><span class="line"><span class="comment">//2.解决的办法非常简单，根据交通工具运行方法不同，分解成不同的类即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在公路上运行"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RoadVehicle roadVehicle = <span class="keyword">new</span> RoadVehicle();</span><br><span class="line">        roadVehicle.run(<span class="string">"摩托车"</span>);</span><br><span class="line">        AirVehicle airVehicle = <span class="keyword">new</span> AirVehicle();</span><br><span class="line">        airVehicle.run(<span class="string">"飞机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 方案2的分析</span></span><br><span class="line"><span class="comment">* 1.遵守单一职责原则</span></span><br><span class="line"><span class="comment">* 2.但是这样做的改动很大，直接将类分解了</span></span><br><span class="line"><span class="comment">* 3.改进，直接修改Vehicle类，这样改动的代码会比较少-》方案3</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadVehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在公路上运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirVehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在天空中运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterVehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在水中运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vehicle2 vehicle2 = <span class="keyword">new</span> Vehicle2();</span><br><span class="line">        vehicle2.run(<span class="string">"摩托"</span>);</span><br><span class="line">        vehicle2.runAir(<span class="string">"飞机"</span>);</span><br><span class="line">        vehicle2.runWater(<span class="string">"游艇"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 方式3的分析</span></span><br><span class="line"><span class="comment">* 1.这种修改方法对原来的类没有作大的修改，只是增加了方法</span></span><br><span class="line"><span class="comment">* 2.这里虽然没有在类的级别上遵守单一职责原则，但是在方法上，仍然是遵守了单一职责原则</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在公路上运行"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAir</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在天上运行"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runWater</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在水运行"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式概述</title>
    <url>/2020/04/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="1-什么是设计模式"><a href="#1-什么是设计模式" class="headerlink" title="1. 什么是设计模式"></a>1. 什么是设计模式</h1><p>​    软件工程中，设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。设计模式这个术语是1990年代从建筑领域中引入到计算机科学的。</p>
<h1 id="2-设计模式出现在软件设计过程中的哪些阶段？"><a href="#2-设计模式出现在软件设计过程中的哪些阶段？" class="headerlink" title="2.设计模式出现在软件设计过程中的哪些阶段？"></a>2.设计模式出现在软件设计过程中的哪些阶段？</h1><p>​    面向对象-&gt;<strong>功能模块[设计模式+数据结构+算法]</strong>-&gt;<strong>框架[使用多种设计模式]</strong>-&gt;架构[服务器集群]。</p>
<p>由此可见，开发过程中设计模式的使用大多数是在开发功能模块或者使用的某些框架中，所以很多面试的时候面试官都会问在某个项目的功能模块中使用了哪些设计模式或者哪个框架中的哪部分代码使用了什么设计模式。</p>
<h1 id="3-设计模式的目的"><a href="#3-设计模式的目的" class="headerlink" title="3. 设计模式的目的"></a>3. 设计模式的目的</h1><p> 1）代码重用性（即相同功能的代码，不用重复编写）<br> 2）可读性（即编程规范性，便于其它程序员阅读和理解）<br> 3）可扩展性（即当需要增加新的功能时，非常的方便）<br> 4）可靠性（即当增加新的功能后，对原来的功能没有影响）<br> 5）使程序呈现高内聚，低耦合的特性</p>
<h1 id="4-设计模式的原则"><a href="#4-设计模式的原则" class="headerlink" title="4.设计模式的原则"></a>4.设计模式的原则</h1><p>​    设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础（即设计模式为什么这么设计的依据）</p>
<p>​    <strong>设计模式常用的七大设计原则有：</strong></p>
<ul>
<li><p>1.单一职责原则</p>
</li>
<li><p>2.接口隔离原则</p>
</li>
<li><p>3.依赖倒转原则</p>
</li>
<li><p>4.里氏替换原则</p>
</li>
<li><p>5.开闭原则</p>
</li>
<li><p>6.迪米特原则</p>
</li>
<li><p>7.合成复用原则</p>
</li>
</ul>
<h1 id="5-掌握设计模式的层次"><a href="#5-掌握设计模式的层次" class="headerlink" title="5.掌握设计模式的层次"></a>5.掌握设计模式的层次</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）第1层：刚开始学编程不久，听说过什么是设计模式。</span><br><span class="line">2）第2层：有很长时间的编程经验，自己写了很多代码，其中用到了设计模式，但自己不知道。</span><br><span class="line">3）第3层：学习了设计模式，发现自己已经在使用了，并且发现了一些新的模式挺好用的。</span><br><span class="line">4）第4层：阅读了很多别人写的源码和框架，在其中看到别人设计模式，并且能够领会到设计模式的精妙和带来的好处。</span><br><span class="line">5）第5层：代码写着写着，自己都没有意识到使用了设计模式，并且熟练的写了出来。</span><br></pre></td></tr></table></figure>

<h1 id="6-设计模式分类"><a href="#6-设计模式分类" class="headerlink" title="6.设计模式分类"></a>6.设计模式分类</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）创建型模式（强调的是创建对象时应该怎么去设计我们的代码）：单例模式，抽象工厂模式，原型模式，建造者模式，工厂模式。</span><br><span class="line">2）结构型模式（站在软件结构的角度来思考的，怎么让软件更加具有扩展性，伸缩性）：适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式。</span><br><span class="line">3）行为型模式（站在方法的角度来思考和设计的，怎么让方法的设计和调度更合理）：模板方法模式，命令模式，访问者模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式，状态模式，策略模式，职责链模式（责任链模式）。</span><br><span class="line">不同的书籍对分类和名称略有差别。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>对象的创建过程分析</title>
    <url>/2020/03/27/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<ul>
<li>示例代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"jack"</span>,<span class="number">19</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name: "</span> + name + <span class="string">",age: "</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Teacher t1 = <span class="keyword">new</span> Teacher(<span class="string">"susan"</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(t1.say());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分析如下</li>
</ul>
<ol>
<li>首先将main()压入虚拟机栈中，在主方法的栈帧中（包含局部变量表，操作数栈，动态连接和方法返回地址等信息）生成一个<code>Teacher</code>对象的引用<code>t1</code></li>
<li>在方法区中检查要创建的对象的类模板信息是否已经加载（<code>Teacher.class</code>），如果未加载，则由类加载器将其加载到方法区中，若已加载则进行第3步</li>
<li>根据类模板中所有属性的定义信息（修饰符 数据类型 变量名）在<code>GC</code>堆中开辟一块适当的空间</li>
<li>为所有的属性隐式初始化为零值</li>
<li>若属性有显示初始化赋值，则执行</li>
<li>执行构造方法</li>
<li>把对象的内存地址返回给创建者</li>
</ol>
<ul>
<li><p>图解如下</p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.png" alt="对象创建"></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>晚间学习计划</title>
    <url>/2020/03/26/%E6%99%9A%E9%97%B4%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h1 id="10点前"><a href="#10点前" class="headerlink" title="10点前"></a>10点前</h1><ul>
<li>1.制定一个学习计划（15-30分钟，梳理一天的知识点）<ul>
<li>1）这个知识点是什么？</li>
<li>2）这个知识点有什么特点？</li>
<li>3）这个知识点有什么用？</li>
<li>4）这个知识点什么时候用？</li>
</ul>
</li>
<li>2.重复地敲白天的代码<ul>
<li>1）刚开始的时候，可以参考老师的代码敲一遍</li>
<li>2）先看一下老师的代码，确定好需求后，关闭老师的代码，尝试自己去写，遇到错误，解决错误</li>
<li>3）一直敲到可以完全脱离老师的代码，独立写出来为止，而且在过程中没有任何报错</li>
</ul>
</li>
</ul>
<h1 id="10点后"><a href="#10点后" class="headerlink" title="10点后"></a>10点后</h1><ul>
<li>1.写计划的作业</li>
<li>2.至少拿出30分钟预习第二天需要学习的知识，预习的程度至少要达到以下几点<ul>
<li>1）这个知识点是什么？</li>
<li>2）这个知识点有什么用？</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
  </entry>
  <entry>
    <title>类的加载过程</title>
    <url>/2020/03/23/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h1><p>1.通过一个类的全限定名获取定义此类的二进制字节流<br>2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br>3.在内存中生成一个代表这个类的Java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>1.<strong>验证</strong>：目的在于确保class文件的字节流中包含信息符合当前虚拟机的要求，保证被加载的类的正确性，不会危害虚拟机自身安全，主要包括文件格式验证，元数据验证，字节码验证，符号引用验证  </p>
<p>2.<strong>准备</strong>：为<strong>类变量（由static修饰的变量）</strong>分配内存并且设置变量的默认初始值（零值），这里不包含使用final修饰的static变量，由final修饰的static变量会在准备阶段就初始化为指定的值，这里也不会为实例变量分配内存初始化，类变量会先分配在方法区中，而实例变量是会随着对象一起分配到Java堆中<br>3.<strong>解析</strong>：将常量池内的符号引用转换为直接引用的过程  </p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><ul>
<li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</li>
<li>此方法不需要定义，是Javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</li>
<li>构造器方法指令按语句在源文件中出现的顺序执行</li>
<li><code>&lt;clinit&gt;()</code>不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;()</code>）</li>
<li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>,已经执行完毕</li>
<li>虚拟机必须保证一个类的<code>&lt;clinit&gt;（）</code>方法在多线程条件下被同步</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM的生命周期</title>
    <url>/2020/03/22/JVM%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="1-虚拟机的启动"><a href="#1-虚拟机的启动" class="headerlink" title="1.虚拟机的启动"></a>1.虚拟机的启动</h1><p>​    Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的</p>
<h1 id="2-虚拟机的执行"><a href="#2-虚拟机的执行" class="headerlink" title="2.虚拟机的执行"></a>2.虚拟机的执行</h1><p>​    一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序，程序开始执行时它才运行，程序结束时它就停止，执行一个所谓的Java程序的时候，真真正正在执行的是一个叫作Java虚拟机的进程</p>
<h1 id="3-虚拟机的退出"><a href="#3-虚拟机的退出" class="headerlink" title="3.虚拟机的退出"></a>3.虚拟机的退出</h1><p>​    有如下几种情况：<br>​    1）程序正常执行结束<br>​    2）程序在执行过程中遇到了异常或错误而异常终止<br>​    3）由于操作系统出现错误而导致Java虚拟机进程终止<br>​    4）某线程调用Runtime类（对应的就是JVM运行时数据区内存）或System类的exit方法，或Runtime的halt的方法，并且Java安全管理器也允许这次exit或halt操作<br>​    </p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>hexo博客搭建交由github托管的基本步骤</title>
    <url>/2020/03/21/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<p>1.hexo博客框架是基于nodejs实现的，所以首先到<a href="https://nodejs.org/下载nodejs，下载完安装，然后在cmd终端中输入node" target="_blank" rel="noopener">https://nodejs.org/下载nodejs，下载完安装，然后在cmd终端中输入node</a> -v和npm -v分别查看nodejs的版本和npm的版本，确认安装成功再进行下面的操作</p>
<p>2.由于node安装插件是从国外服务器下载，受网络影响大，速度慢且可能出现异常。所以如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队（阿里巴巴旗下业务阿里云）干了这事，所以输入 npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org就可以使用阿里定制的cnpm来代替npm了" target="_blank" rel="noopener">https://registry.npm.taobao.org就可以使用阿里定制的cnpm来代替npm了</a></p>
<p>3.输入cnpm -v检查cnpm是否成功安装，成功则继续下面的步骤</p>
<p>4.输入cnpm install -g hexo-cli安装hexo博客框架</p>
<p>5.输入hexo -v检查hexo是否成功安装，成功则继续下面的步骤</p>
<p>6.建立一个空的文件夹作为后面博客输出话的目录，比如md blog</p>
<p>7.然后进入blog目录 cd blog</p>
<p>8.位于blog目录后，输入hexo init初始化博客，这样blog就成为了一个博客目录，所以如果后面出错了直接把blog删除重来就可以</p>
<p>9.输入hexo s命令即可启动hexo服务，然后通过localhost:4000可在本地访问静态博客，对于hexo的基本使用可以参考网址<a href="https://hexo.io/zh-cn/docs/index.html，写博客是基于markdown形式的，markdown的基本使用可参考网址https://www.runoob.com/markdown/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/index.html，写博客是基于markdown形式的，markdown的基本使用可参考网址https://www.runoob.com/markdown/</a></p>
<p>10.后面将博客部署到github上，首先进入个人github新建一个仓库，命名为name.github.io</p>
<p>11.在cmd中输入cnpm install  hexo-deployer-git –save安装git部署的插件，warning提示可忽略不管</p>
<p>12.然后打开博客主目录下的<em>config.yml文件进行配置，在底部deploy字段下面配置3个属性</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: git</span><br><span class="line">repo: 刚新建的github仓库的地址</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>

<p>13.然后输入hexo d命令将博客部署到github即可</p>
<p>14.最后通过在浏览器中输入name.github.io可访问博客</p>
<p>15.如果不喜欢样式主题，可进行更换，以next主题为例</p>
<p>16.首先进入blog路径，在终端中输入git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next 将next主题克隆到blog/theme/next目录下</p>
<p>17.然后修改blog目录下的_config.yml文件，将theme的value值配置为next 即：<br> <code>theme: next</code></p>
<p>18.然后重新通过hexo clean清理本地博客，hexo g生成本地静态博客，hexo s开启服务即可通过localhost:4000访问</p>
<p>19.通过hexo d重新将博客部署到github上</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
  </entry>
  <entry>
    <title>java小知识点</title>
    <url>/2020/03/21/java%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="1-n和n-的区别"><a href="#1-n和n-的区别" class="headerlink" title="1.++n和n++的区别?"></a>1.++n和n++的区别?</h1><p>​    ++n 先加后用，不需要临时空间，效率高；n++ 先用后加，需要一个临时空间保存未++操作之前的值（也就是要用的值），然后再进行++操作。</p>
<h1 id="2-switch中的穿透，如果case或者default语句中不加break-由上往下执行的时候如果匹配正确一次的，那么switch这个匹配表达式生命周期就结束了，如果没有break-后面的case将不再做匹配判断，直接运行case下的代码"><a href="#2-switch中的穿透，如果case或者default语句中不加break-由上往下执行的时候如果匹配正确一次的，那么switch这个匹配表达式生命周期就结束了，如果没有break-后面的case将不再做匹配判断，直接运行case下的代码" class="headerlink" title="2.switch中的穿透，如果case或者default语句中不加break,由上往下执行的时候如果匹配正确一次的，那么switch这个匹配表达式生命周期就结束了，如果没有break,后面的case将不再做匹配判断，直接运行case下的代码"></a>2.switch中的穿透，如果case或者default语句中不加break,由上往下执行的时候如果匹配正确一次的，那么switch这个匹配表达式生命周期就结束了，如果没有break,后面的case将不再做匹配判断，直接运行case下的代码</h1><pre><code>示例代码1：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 0;</span><br><span class="line">while(a &lt; 5)&#123;</span><br><span class="line">	switch(a)&#123;</span><br><span class="line">		case 0:</span><br><span class="line">		case 3: a &#x3D; a + 2;</span><br><span class="line">		case 1:</span><br><span class="line">		case 2: a &#x3D; a + 3;</span><br><span class="line">		default: a &#x3D; a + 5;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>
代码的输出结果是10,case 0匹配后，没有break,后面的case 3,case 1,case 2,default就不会再判断是否匹配了，会直接执行case下的语句
示例代码2
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int x &#x3D; 2,y &#x3D; 3;</span><br><span class="line">switch(x)&#123;</span><br><span class="line">	default:</span><br><span class="line">		y++；</span><br><span class="line">	case 3:</span><br><span class="line">		y++;</span><br><span class="line">	case 4:</span><br><span class="line">		y++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(y);</span><br></pre></td></tr></table></figure>
最后输出结果为6，道理同上，default分支条件成立，后面则不会再判断是否成立了，直接执行分支后的语句，所以y累加3次，最后结果为6</code></pre><h1 id="3-方法重写（override）"><a href="#3-方法重写（override）" class="headerlink" title="3.方法重写（override）"></a>3.方法重写（override）</h1><p>子类对父类方法的重写，需要遵守一下几点</p>
<p> 1）子类的覆盖方法和父类的被覆盖方法的方法签名完全一致（返回值类型，方法名，参数列表）</p>
<p> 2）子类的覆盖方法的访问权限修饰要大于等于父类的方法的访问权限修饰</p>
<h1 id="4-属性不具备多态性，只有方法具备多态性"><a href="#4-属性不具备多态性，只有方法具备多态性" class="headerlink" title="4.属性不具备多态性，只有方法具备多态性"></a>4.属性不具备多态性，只有方法具备多态性</h1><h3 id="5-外部类只可以用public-和-default访问修饰符修饰，那为什么外部类不能用private-protected修饰呢？"><a href="#5-外部类只可以用public-和-default访问修饰符修饰，那为什么外部类不能用private-protected修饰呢？" class="headerlink" title="5. 外部类只可以用public 和 default访问修饰符修饰，那为什么外部类不能用private,protected修饰呢？"></a>5. 外部类只可以用public 和 default访问修饰符修饰，那为什么外部类不能用private,protected修饰呢？</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java的外部类为什么不能使用private、protected进行修饰 ... 因为外部类的上一单元是包，所以外部类只有两个作用域：同包，任何位置。 因此，只需要两种控制权限：包控制权限和公开访问权限，也就对应两种控制修饰符：public和默认(default)。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>基本语法</title>
    <url>/2020/03/20/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li><ol>
<li>变量是什么</li>
</ol>
</li>
</ul>
<pre><code>&gt;答：变量是内存中一块被命名的被特定的数据类型约束的区域，此区域中可以保存数据类型范围内的数据</code></pre><ul>
<li><p>2.变量的分类</p>
<blockquote>
<p>基本数据类型（内存空间中保存的是数据本身）  </p>
<pre><code>1）byte：占1个字节，数据范围：-128~127
2）short：占2个字节，数据范围：-32768~32767
3）int：占4个字节，数据范围：-20多亿~20多亿
4）long：占8个字节，数据范围：-巨大~巨大（900多亿亿）
5）float：占4个字节，数据范围：-10^38~10^38(比long类型的数据范围大很多)
6）double：占8个字节，数据范围：-10^308~10^308
7）char：占2个字节，数据范围：0~65535（对应Unicode字符编码）
8）boolean：占1个字节，数据范围：只有true，false</code></pre><p>引用数据类型（内存空间中保存的是对象的地址）</p>
</blockquote>
</li>
<li><p>3.数据类型运算中几条重要的属性</p>
<blockquote>
<p>1）整数字面量默认是int类型的，浮点数字面量量默认是double类型的<br>2）任意非long整数变量作运算，结果总是升级为int，即会把数据类型转为int再进行运算<br>3）各种类型的变量混合运算，结果总是升级为范围最大的那个类型<br>4）数据类型的数值范围大小，从小到大排序：byte&lt;short&lt;int&lt;long&lt;float&lt;double</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>Java基本认识</title>
    <url>/2020/03/20/Java%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<ul>
<li><h1 id="Java的8大特性"><a href="#Java的8大特性" class="headerlink" title="Java的8大特性"></a>Java的8大特性</h1>  1）跨平台：执行class文件的JVM是跨平台的（跨操作系统），不同的平台有不同的虚拟机<br>  2）面向对象：Java是面向对象的，和面向过程相对，关注点是解决问题的抽象而非具体的过程<br>  3）简单：相对c/c++简单<br>  4）安全：在将class文件加载到jvm中执行时，会先对class文件进行检查看是否符合class文件的规范<br>  5）健壮：Java语言是强类型的（所有的数据必须要有唯一的确定的数据类型），而且拥有完善的异常处理机制和垃圾回收机制，并且对指针进行了安全化（引用），这些都为健壮性提供了保障<br>  6）效率高：Java是编译型语言，将源文件编译为class文件后由类加载器加载到jvm中执行即可，相对解释型语言解释一行执行一行效率要更高<br>  7）分布式：Java可基于网络实现多主机协作<br>  8）多线程：提高单位时间内在网络上传输的数据（吞吐量），提高CPU的利用率</li>
</ul>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>markdown基本使用</title>
    <url>/2020/03/19/markdown%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>（2）字体 </p>
<p><strong>加粗</strong></p>
<p><em>倾斜</em></p>
<p><strong><em>斜体加粗</em></strong></p>
<p>==高亮==</p>
<p><del>删除线</del></p>
<p>（3）列表</p>
<ul>
<li>一二三四五<ul>
<li>上山打老虎<ul>
<li>老虎打不到<ul>
<li>打到小松鼠</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>一二三四五</li>
<li>上山打老虎</li>
<li>老虎打不到</li>
<li>打到小松鼠</li>
</ol>
<p>（4）表格</p>
<table>
<thead>
<tr>
<th>MON</th>
<th>TUE</th>
<th>WED</th>
<th>THU</th>
<th>FRI</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>（5）引用 </p>
<blockquote>
<p>一二三四五</p>
<blockquote>
<p>上山打老虎</p>
<blockquote>
<p>啦啦啦</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="（6）分割线"><a href="#（6）分割线" class="headerlink" title="（6）分割线"></a>（6）分割线</h2><p>（7）代码<br><code>我是代码</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">代码块</span><br></pre></td></tr></table></figure>

<p><a href="http://www.baidu.com/" target="_blank" rel="noopener">百度链接</a><br><img src="http://pic.pc6.com/up/2014-5/14012420992340162.jpg" alt="柯南"></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
  </entry>
</search>
