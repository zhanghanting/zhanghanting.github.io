<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hadoop入门</title>
    <url>/2022/03/04/Hadoop%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ</title>
    <url>/2022/01/24/RabbitMQ/</url>
    <content><![CDATA[<h1 id="1-消息队列"><a href="#1-消息队列" class="headerlink" title="1.消息队列"></a>1.消息队列</h1><h2 id="1-1-消息队列的基本概念"><a href="#1-1-消息队列的基本概念" class="headerlink" title="1.1 消息队列的基本概念"></a>1.1 消息队列的基本概念</h2><h3 id="1-1-1-什么是MQ"><a href="#1-1-1-什么是MQ" class="headerlink" title="1.1.1 什么是MQ"></a>1.1.1 什么是MQ</h3><p>MQ本质上是一个FIFO的队列，主要应用于上下游传递消息。</p>
<h3 id="1-1-2-为什么要用MQ"><a href="#1-1-2-为什么要用MQ" class="headerlink" title="1.1.2 为什么要用MQ"></a>1.1.2 为什么要用MQ</h3><ol>
<li><p>削峰</p>
<p>​    举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。 </p>
</li>
<li><p>解耦</p>
<p>​    以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。 </p>
<p><img src="https://raw.githubusercontent.com/zhanghanting/p_zhanghanting/main/img/202201241119877.png" alt="image-20220124111916807"></p>
</li>
</ol>
<ol start="3">
<li><p>异步处理</p>
<p>​    有些服务间调用是异步的，例如A调用B，B需要花费很长时间执行，但是A需要知道B什么时候可以执行完，以前一般有两种方式，A过一段时间去调用B的查询api查询。或者A提供一个callback api，B执行完之后调用api通知A服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题，A调用B服务后，只需要监听B处理完成的消息，当B处理完成后，会发送一条消息给MQ，MQ会将此消息转发给A服务。这样A服务既不用循环调用B的查询api，也不用提供callback api。同样B服务也不用做这些操作。A服务还能及时的得到异步处理成功的消息。 </p>
<p><img src="https://raw.githubusercontent.com/zhanghanting/p_zhanghanting/main/img/202201241118123.png" alt="image-20220124111856052"></p>
<p>​    </p>
</li>
</ol>
<h3 id="1-1-3-MQ的分类"><a href="#1-1-3-MQ的分类" class="headerlink" title="1.1.3 MQ的分类"></a>1.1.3 MQ的分类</h3><ol>
<li><p>ActiveMQ</p>
<p> 优点：单机吞吐量万级，时效性ms级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据  缺点:官方社区现在对ActiveMQ 5.x维护越来越少，高吞吐量场景较少使用。 尚硅谷官网视频: <a href="http://www.gulixueyuan.com/course/322" target="_blank" rel="noopener">http://www.gulixueyuan.com/course/322</a> </p>
</li>
<li><p>Kafka</p>
<p>​    大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开Kafka，这款为大数据而生的消息中间件，以其百万级TPS的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被LinkedIn，Uber, Twitter, Netflix等大公司所采纳。  <strong>优点</strong>: <strong>性能卓越，单机写入TPS约在百万条/秒，最大的优点，就是吞吐量高。时效性ms级可用性非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采用Pull方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次</strong>;有优秀的第三方Kafka Web管理界面Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持：功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用  <strong>缺点</strong>：Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台代理宕机后，就会产生消息乱序，社区更新较慢</p>
</li>
<li><p>RocketMQ</p>
<p>​    RocketMQ出自阿里巴巴的开源产品，用Java语言实现，在设计时参考了 Kafka，并做出了自己的一些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog分发等场景。 <strong>优点</strong>:单机吞吐量十万级,可用性非常高，分布式架构,消息可以做到0丢失,MQ功能较为完善，还是分布式的，扩展性好,支持10亿级别的消息堆积，不会因为堆积导致性能下降,源码是java我们可以自己阅读源码，定制自己公司的MQ  <strong>缺点</strong>：支持的客户端语言不多，目前是java及c++，其中c++不成熟；社区活跃度一般,没有在MQ核心中去实现JMS等接口,有些系统要迁移需要修改大量代码 </p>
</li>
<li><p>RabbitMQ</p>
<p>​    2007年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。  优点:由于erlang语言的高并发特性，性能较好；吞吐量到万级，MQ功能比较完备,健壮、稳定、易用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高 <a href="https://www.rabbitmq.com/news.html" target="_blank" rel="noopener">https://www.rabbitmq.com/news.html</a>  缺点：商业版需要收费,学习成本较高 </p>
</li>
</ol>
<h3 id="1-1-4-MQ的选择"><a href="#1-1-4-MQ的选择" class="headerlink" title="1.1.4 MQ的选择"></a>1.1.4 MQ的选择</h3><p>1.Kafka  Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能，肯定是首选kafka了。尚硅谷官网kafka视频连接<a href="http://www.gulixueyuan.com/course/330/tasks" target="_blank" rel="noopener">http://www.gulixueyuan.com/course/330/tasks</a> </p>
<p>2.RocketMQ  天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ在稳定性上可能更值得信赖，这些业务场景在阿里双11已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择RocketMQ。 </p>
<p>3.RabbitMQ  结合erlang语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的RabbitMQ。 </p>
<h2 id="1-2-RabbitMQ"><a href="#1-2-RabbitMQ" class="headerlink" title="1.2 RabbitMQ"></a>1.2 RabbitMQ</h2><h3 id="1-2-1-RabbitMQ的概念"><a href="#1-2-1-RabbitMQ的概念" class="headerlink" title="1.2.1 RabbitMQ的概念"></a>1.2.1 RabbitMQ的概念</h3><p>RabbitMQ是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑RabbitMQ是一个快递站，一个快递员帮你传递快件。RabbitMQ与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。</p>
<p>主要功能：</p>
<p>接收消息；存储消息；转换消息</p>
<h3 id="1-2-2-核心概念"><a href="#1-2-2-核心概念" class="headerlink" title="1.2.2 核心概念"></a>1.2.2 核心概念</h3><p>生产者；交换机；队列；消费者</p>
<p>一个交换机可以绑定多个队列；一个队列可以同时被多个消费者消费，但同一条消息如果消费者A收到了，消费者B就收不到了，就如同快递的包裹一样，只会对应一个收件人。</p>
<p><img src="https://raw.githubusercontent.com/zhanghanting/p_zhanghanting/main/img/202201241144621.png" alt="image-20220124114430549"></p>
<blockquote>
<p>生产者</p>
</blockquote>
<p>产生数据发送消息的程序是生产者 </p>
<blockquote>
<p>交换机</p>
</blockquote>
<p>交换机是RabbitMQ非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定 </p>
<blockquote>
<p>队列</p>
</blockquote>
<p>队列是RabbitMQ内部使用的一种数据结构，尽管消息流经RabbitMQ和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式 </p>
<blockquote>
<p>消费者</p>
</blockquote>
<p>消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p>
<h3 id="1-2-3-RabbitMQ核心部分"><a href="#1-2-3-RabbitMQ核心部分" class="headerlink" title="1.2.3 RabbitMQ核心部分"></a>1.2.3 RabbitMQ核心部分</h3><p><img src="https://raw.githubusercontent.com/zhanghanting/p_zhanghanting/main/img/202201241650734.png" alt="image-20220124165038662"></p>
<h3 id="1-2-4-各个名词介绍"><a href="#1-2-4-各个名词介绍" class="headerlink" title="1.2.4 各个名词介绍"></a>1.2.4 各个名词介绍</h3><p><img src="https://raw.githubusercontent.com/zhanghanting/p_zhanghanting/main/img/202201241651296.png" alt="image-20220124165130238"></p>
<p>Broker：接收和分发消息的应用，RabbitMQ Server就是Message Broker</p>
<p> Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的namespace概念。当多个不同的用户使用同一个RabbitMQ server提供的服务时，可以划分出多个vhost，每个用户在自己的 vhost 创建 exchange／queue 等，即一个virtual host中可以有多个exchange</p>
<p> Connection：publisher／consumer和broker之间的TCP连接</p>
<p> Channel：如果每一次访问 RabbitMQ 都建立一个Connection，在消息量大的时候建立 TCP Connection的开销将是巨大的，效率也较低。Channel是在connection内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的channel进行通讯，AMQP method包含了channel id 帮助客户端和message broker 识别 channel，所以channel之间是完全隔离的。Channel作为轻量级的Connection极大减少了操作系统建立TCP connection的开销 </p>
<p>Exchange：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</p>
<p> Queue：消息最终被送到这里等待consumer取走</p>
<p> Binding：exchange和queue之间的虚拟连接，即将虚拟机和队列进行绑定，binding中可以包含routing key，Binding信息被保存到exchange中的查询表中，用于message的分发依据</p>
<h3 id="1-2-5-安装"><a href="#1-2-5-安装" class="headerlink" title="1.2.5 安装"></a>1.2.5 安装</h3><blockquote>
<p>官网地址</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;download.html</span><br></pre></td></tr></table></figure>

<blockquote>
<p>按顺序安装以下文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ivh erlang-21.3-1.el7.x86_64.rpm </span><br><span class="line">yum install socat -y </span><br><span class="line">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure>

<blockquote>
<p>常用服务命令</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加开机启动RabbitMQ服务  </span></span><br><span class="line">chkconfig rabbitmq-server on </span><br><span class="line"><span class="meta">#</span><span class="bash">启动服务 </span></span><br><span class="line">/sbin/service rabbitmq-server start </span><br><span class="line"><span class="meta">#</span><span class="bash">查看服务状态 </span></span><br><span class="line">/sbin/service rabbitmq-server status </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">停止服务(选择执行) </span></span><br><span class="line">/sbin/service rabbitmq-server stop </span><br><span class="line"><span class="meta">#</span><span class="bash">开启web管理插件  </span></span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>



<blockquote>
<p>开启web管理插件</p>
</blockquote>
<p>需要在rabbitmq-server未启动的时候才能开启，用默认账户guest/guest登录会报权限为问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management </span><br><span class="line"><span class="meta">#</span><span class="bash"> 访问地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash">http://ip:15672/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加新用户</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建账号 </span></span><br><span class="line">rabbitmqctl add_user admin 123456 </span><br><span class="line"><span class="meta">#</span><span class="bash">设置用户角色  </span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator </span><br><span class="line"><span class="meta">#</span><span class="bash">设置用户权限</span></span><br><span class="line">set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;  rabbitmqctl </span><br><span class="line">set_permissions -p "/" admin ".*" ".*" ".*" #用户user_admin具有/vhost1这个virtual host中所有资源的配置、写、读权限 </span><br><span class="line"><span class="meta">#</span><span class="bash">当前用户和角色 </span></span><br><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure>



<blockquote>
<p>启动RabbitMQ</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sbin/service rabbitmq-server start</span><br></pre></td></tr></table></figure>



<blockquote>
<p>再次使用admin登录</p>
</blockquote>
<p>可正常登录</p>
<blockquote>
<p>重置命令</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">关闭应用的命令为 </span></span><br><span class="line">rabbitmqctl stop_app </span><br><span class="line"><span class="meta">#</span><span class="bash">清除的命令为    </span></span><br><span class="line">rabbitmqctl reset </span><br><span class="line"><span class="meta">#</span><span class="bash">重新启动命令为  </span></span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure>





<h1 id="2-HelloWorld"><a href="#2-HelloWorld" class="headerlink" title="2.HelloWorld"></a>2.HelloWorld</h1><p>示例场景：生产者往队列中发送消息，消费者从中消费</p>
<h2 id="2-1-导入依赖"><a href="#2-1-导入依赖" class="headerlink" title="2.1 导入依赖"></a>2.1 导入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定jdk编译版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  <span class="comment">&lt;!--rabbitmq依赖客户端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  <span class="comment">&lt;!--操作文件流的一个依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="2-2-生产者代码"><a href="#2-2-生产者代码" class="headerlink" title="2.2 生产者代码"></a>2.2 生产者代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Producer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> TYS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/25 14:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接RabbitMQ的队列</span></span><br><span class="line">        <span class="comment">//ip</span></span><br><span class="line">        factory.setHost(<span class="string">"hadoop102"</span>);</span><br><span class="line">        <span class="comment">//用户名</span></span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建一个队列</span></span><br><span class="line"><span class="comment">         * param1: 队列名称</span></span><br><span class="line"><span class="comment">         * param2: 队列里面的消息是否持久化到磁盘，默认情况下消息不持久化，存储在内存中</span></span><br><span class="line"><span class="comment">         * param3: 该队列是否进行消息的共享,可被多个消费者消费，true表示可以供多个消费者消费，默认是true</span></span><br><span class="line"><span class="comment">         * param4: 是否自动删除，最后一个消费者端断开连接以后，该队列是否自动删除，true则表示自动删除</span></span><br><span class="line"><span class="comment">         * param5: 其它参数：比如延迟消息等等</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发消息</span></span><br><span class="line">        String message = <span class="string">"hello world,this is 2022"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送一条消息</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * param1: 发送到哪个交换机</span></span><br><span class="line"><span class="comment">         * param2: 路由的key值，本次是队列的名称</span></span><br><span class="line"><span class="comment">         * param3: 其它参数信息</span></span><br><span class="line"><span class="comment">         * param4: 发送的消息体</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"消息发送完毕"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-3-消费者代码"><a href="#2-3-消费者代码" class="headerlink" title="2.3 消费者代码"></a>2.3 消费者代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rabbitmq.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Consumer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> TYS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/25 15:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"hadoop102"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//推送的消息如何进行消费的接口回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag,message)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明取消消息时的回调,比如在消费消息的时候队列被删除了</span></span><br><span class="line">        CancelCallback cancelCallback = consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"消息消费被中断"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * param1: 消费哪个队列</span></span><br><span class="line"><span class="comment">         * param2: 消费成功以后是否自动应答，true表示自动应答，false表示手动应答</span></span><br><span class="line"><span class="comment">         * param3: 推送的消息如何进行消费的接口回调</span></span><br><span class="line"><span class="comment">         * param3: 消费者取消消费的回调</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,deliverCallback,cancelCallback);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-Work-Queues"><a href="#3-Work-Queues" class="headerlink" title="3.Work Queues"></a>3.Work Queues</h1><p>工作队列的主要思想是避免立即执行一些资源密集型的任务，但是不得不等任务完成。可以先把待执行的任务封装为消息放入任务队列中，由后台的任务进程去处理。</p>
<p>案例：</p>
<p><img src="https://raw.githubusercontent.com/zhanghanting/p_zhanghanting/main/img/202201261501652.png" alt="WorkQueue"></p>
<h2 id="3-1-轮询发送消息"><a href="#3-1-轮询发送消息" class="headerlink" title="3.1 轮询发送消息"></a>3.1 轮询发送消息</h2><h3 id="3-1-1-创建channel工具类"><a href="#3-1-1-创建channel工具类" class="headerlink" title="3.1.1 创建channel工具类"></a>3.1.1 创建channel工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"hadoop102"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-2-启动两个工作线程"><a href="#3-1-2-启动两个工作线程" class="headerlink" title="3.1.2 启动两个工作线程"></a>3.1.2 启动两个工作线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * param1: 消费哪个队列</span></span><br><span class="line"><span class="comment">         * param2: 消费成功以后是否自动应答，true表示自动应答，false表示手动应答</span></span><br><span class="line"><span class="comment">         * param3: 推送的消息如何进行消费的接口回调</span></span><br><span class="line"><span class="comment">         * param3: 消费者取消消费的回调</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag,message)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"接收到的消息"</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line">        CancelCallback cancelCallback = (consumerTag)-&gt;&#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">"取消消费的回调逻辑"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"线程等待接受消息"</span>);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.1.3 启动发送消息生产者线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送大量的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//队列的声明</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建一个队列</span></span><br><span class="line"><span class="comment">         * param1: 队列名称</span></span><br><span class="line"><span class="comment">         * param2: 队列里面的消息是否持久化到磁盘，默认情况下消息不持久化，存储在内存中</span></span><br><span class="line"><span class="comment">         * param3: 该队列是否进行消息的共享,可被多个消费者消费，true表示可以供多个消费者消费，默认是true</span></span><br><span class="line"><span class="comment">         * param4: 是否自动删除，最后一个消费者端断开连接以后，该队列是否自动删除，true则表示自动删除</span></span><br><span class="line"><span class="comment">         * param5: 其它参数：比如延迟消息等等</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从控制台中接收消息</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            String message = scanner.next();</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"发送消息完成："</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从控制台输入消息，两个消费者线程中可轮流消费到</p>
<h2 id="3-2-消息应答"><a href="#3-2-消息应答" class="headerlink" title="3.2 消息应答"></a>3.2 消息应答</h2><h3 id="3-2-1-概念"><a href="#3-2-1-概念" class="headerlink" title="3.2.1 概念"></a>3.2.1 概念</h3><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。 为了保证消息在发送过程中不丢失，rabbitmq引入消息应答机制，<strong>消息应答就是:消费者在接收到消息并且处理该消息之后，告诉rabbitmq它已经处理了，rabbitmq可以把该消息删除了。</strong> </p>
<h3 id="3-2-2-自动应答"><a href="#3-2-2-自动应答" class="headerlink" title="3.2.2 自动应答"></a>3.2.2 自动应答</h3><p>消息发送后立即被认为已经传送成功，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>,因为这种模式如果消息在接收到之前，消费者那边出现连接或者channel关闭，那么消息就丢失了,当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以<strong>这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。</strong></p>
<h3 id="3-2-3-手动应答的方法"><a href="#3-2-3-手动应答的方法" class="headerlink" title="3.2.3 手动应答的方法"></a>3.2.3 手动应答的方法</h3><ol>
<li><p>Channel.basicAck(用于肯定确认)  RabbitMQ已知道该消息并且成功的处理消息，可以将其丢弃了  </p>
</li>
<li><p>Channel.basicNack(用于否定确认)  </p>
</li>
<li><p>Channel.basicReject(用于否定确认) 与Channel.basicNack相比少一个参数  不处理该消息了直接拒绝，可以将其丢弃了 </p>
</li>
</ol>
<p>相差的参数是一个批量处理的参数</p>
<h3 id="3-2-4-multiple的解释（推荐不批量应答，即设置为false）"><a href="#3-2-4-multiple的解释（推荐不批量应答，即设置为false）" class="headerlink" title="3.2.4 multiple的解释（推荐不批量应答，即设置为false）"></a>3.2.4 multiple的解释（推荐不批量应答，即设置为false）</h3><p>手动应答的好处是可以批量应答并且减少网络拥堵</p>
<p><img src="https://raw.githubusercontent.com/zhanghanting/p_zhanghanting/main/img/202201261610291.png" alt="image-20220126161045224"></p>
<p>multiple的true和false代表不同意思 </p>
<p> true代表批量应答channel上未应答的消息  比如说channel上有传送tag的消息 5,6,7,8 当前tag是8 那么此时  5-8的这些还未应答的消息都会被确认收到消息应答 </p>
<p> false同上面相比  只会应答tag=8的消息 5,6,7这三个消息依然不会被确认收到消息应答</p>
<p><img src="https://raw.githubusercontent.com/zhanghanting/p_zhanghanting/main/img/202201261612571.png" alt="image-20220126161218487"></p>
<h3 id="3-2-5-消息自动重新入队"><a href="#3-2-5-消息自动重新入队" class="headerlink" title="3.2.5 消息自动重新入队"></a>3.2.5 消息自动重新入队</h3><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或TCP连接丢失)，导致消息未发送ACK确认，RabbitMQ将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。 </p>
<p><img src="https://raw.githubusercontent.com/zhanghanting/p_zhanghanting/main/img/202201261617296.png" alt="image-20220126161709219"></p>
<h3 id="3-2-6-消息手动应答代码"><a href="#3-2-6-消息手动应答代码" class="headerlink" title="3.2.6 消息手动应答代码"></a>3.2.6 消息手动应答代码</h3><p> 默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答</p>
<blockquote>
<p>生产者</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Producer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> TYS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/27 9:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 测试消息手动应答不丢失</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String TASK_QUEUE_NAME = <span class="string">"ack_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从控制台输入消息</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            String message = scanner.next();</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,TASK_QUEUE_NAME,<span class="keyword">null</span>,message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            System.out.println(<span class="string">"生产者发出消息："</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>消费者01</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Consumer01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> TYS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/27 9:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 测试消息手动应答不丢失,放回队列中重新消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String TASK_QUEUE_NAME = <span class="string">"ack_queue"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">"c1等待接受消息，处理时间较短"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动应答</span></span><br><span class="line">        <span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag,message)-&gt;&#123;</span><br><span class="line">            <span class="comment">//睡眠1s</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">"接受到的消息："</span> + <span class="keyword">new</span> String(message.getBody(),<span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//手动应答</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * deliverTag: 消息的标记，唯一标识消息</span></span><br><span class="line"><span class="comment">                 * multiple: 是否批量应答  false表示不批量应答channel中的消息</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        CancelCallback cancelCallback = (consumerTag)-&gt;&#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">"取消消费回调逻辑"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>消费者02</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Consumer02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> TYS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/27 9:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 测试消息手动应答不丢失,放回队列中重新消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String TASK_QUEUE_NAME = <span class="string">"ack_queue"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">"c2等待接受消息，处理时间较长"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动应答</span></span><br><span class="line">        <span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag,message)-&gt;&#123;</span><br><span class="line">            <span class="comment">//睡眠1s</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">                System.out.println(<span class="string">"接受到的消息："</span> + <span class="keyword">new</span> String(message.getBody(),<span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//手动应答</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * deliverTag: 消息的标记，唯一标识消息</span></span><br><span class="line"><span class="comment">                 * multiple: 是否批量应答  false表示不批量应答channel中的消息</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        CancelCallback cancelCallback = (consumerTag)-&gt;&#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">"取消消费回调逻辑"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>效果演示</p>
</blockquote>
<p>正常情况下消息发送方发送两个消息C1和C2分别接收到消息并进行处理</p>
<p>在发送者发送消息dd，发出消息之后的把C2消费者停掉，按理说该C2来处理该消息，但是由于它处理时间较长，在还未处理完，也就是说C2还没有执行ack代码的时候，C2被停掉了，此时会看到消息被C1接收到了，说明消息dd被重新入队，然后分配给能处理消息的C1处理了 ，消息不会丢失。</p>
<h2 id="3-3-RabbitMQ持久化"><a href="#3-3-RabbitMQ持久化" class="headerlink" title="3.3 RabbitMQ持久化"></a>3.3 RabbitMQ持久化</h2><h3 id="3-3-1概念"><a href="#3-3-1概念" class="headerlink" title="3.3.1概念"></a>3.3.1概念</h3><p>上面的自动应答的代码可以在任务处理的时候保证消息不丢失，但是在RabbitMQ服务关闭的时候由于队列和消息都未持久化，放在内存中，所以队列和数据都丢失了。要想保存下来就需要将队列和消息都实现持久化。</p>
<h3 id="3-3-2-队列实现持久化"><a href="#3-3-2-队列实现持久化" class="headerlink" title="3.3.2 队列实现持久化"></a>3.3.2 队列实现持久化</h3><p>之前我们创建的队列都是非持久化的，rabbitmq如果重启的化，该队列就会被删除掉，如果 要队列实现持久化 需要在声明队列的时候把durable参数设置为持久化 。</p>
<p>但是需要注意的就是如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误 。</p>
<p>这个时候即使重启rabbitmq队列也依然存在 </p>
<h3 id="3-3-3-消息实现持久化"><a href="#3-3-3-消息实现持久化" class="headerlink" title="3.3.3 消息实现持久化"></a>3.3.3 消息实现持久化</h3><p>要想让消息实现持久化需要在消息生产者修改代码，MessageProperties.PERSISTENT_TEXT_PLAIN添 加这个属性。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置消息持久化，将消息保存到磁盘上</span></span><br><span class="line">channel.basicPublish(<span class="string">""</span>,TASK_QUEUE_NAME,MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes(<span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure>

<p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉RabbitMQ将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。如果需要更强有力的持久化策略，参考后边课件发布确认章节。 </p>
<h3 id="3-3-4-不公平分发"><a href="#3-3-4-不公平分发" class="headerlink" title="3.3.4 不公平分发"></a>3.3.4 不公平分发</h3><p>默认是采用轮询分发，但是在有些场景下，这个策略不是很好，比如消费者c1的处理效率很快，消费者c2的处理效率很慢，轮询就会造成c1很多时间都是空闲，而c2就一直在干活。</p>
<p>为了避免这种情况，可以在<strong>消费者端</strong>设置参数channel.basicQos(1)</p>
<p>意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个任务，然后rabbitmq就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的worker或者改变其他存储任务的策略。</p>
<h3 id="3-3-5-预取值"><a href="#3-3-5-预取值" class="headerlink" title="3.3.5 预取值"></a>3.3.5 预取值</h3><p>本身消息的发送就是异步发送的，所以在任何时候，channel上肯定不止只有一个消息另外来自消费者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题</strong>。这个时候就可以通过<strong>使用basic.qos方法设置“预取计数”值</strong>来完成的。<strong>该值定义通道上允许的未确认消息的最大数量</strong>。一旦数量达到配置的数量，RabbitMQ将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息5、6、7，8，并且通道的预取计数设置为4，此时RabbitMQ将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被ack。比方说tag=6这个消息刚刚被确认ACK，RabbitMQ将会感知这个情况到并再发送一条消息。消息应答和QoS预取值对用户吞吐量有重大影响。通常，增加预取将提高向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理  的消息的数量也会增加，从而增加了消费者的RAM消耗(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同100到300范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。预取值为1是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境中。对于大多数应用来说，稍微高一点的值将是最佳的。</p>
<p><img src="https://raw.githubusercontent.com/zhanghanting/p_zhanghanting/main/img/202201271126115.png" alt="image-20220127112601048"></p>
<h1 id="4-发布确认"><a href="#4-发布确认" class="headerlink" title="4.发布确认"></a>4.发布确认</h1><p>生产者将信道设置成confirm模式，一旦信道进入confirm模式，<strong>所有在该信道上面发布的消息都将会被指派一个唯一的ID</strong>(从1开始)，一旦消息被投递到所有匹配的队列之后，broker就会发送一个确认给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker回传给生产者的确认消息中delivery-tag域包含了确认消息的序列号，此外broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理。</p>
<p> confirm模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条nack消息，生产者应用程序同样可以在回调方法中处理该nack消息。 </p>
<h1 id="5-交换机"><a href="#5-交换机" class="headerlink" title="5.交换机"></a>5.交换机</h1>]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>消息队列,RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>kuangshen/前端/JavaScript</title>
    <url>/2021/12/20/kuangshen/%E5%89%8D%E7%AB%AF/JavaScript/</url>
    <content><![CDATA[<h1 id="1-什么是JavaScript"><a href="#1-什么是JavaScript" class="headerlink" title="1.什么是JavaScript"></a>1.什么是JavaScript</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>JavaScript是世界上最流行的脚本语言</p>
<p>是Brendan Eich10天开发完成的</p>
<p><strong>一名合格的后端人员，必须要精通JavaScript</strong></p>
<h2 id="1-2-历史"><a href="#1-2-历史" class="headerlink" title="1.2 历史"></a>1.2 历史</h2><p><a href="https://blog.csdn.net/kese7952/article/details/79357868" target="_blank" rel="noopener">https://blog.csdn.net/kese7952/article/details/79357868</a></p>
<h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><h2 id="2-1-引入JavaScript"><a href="#2-1-引入JavaScript" class="headerlink" title="2.1 引入JavaScript"></a>2.1 引入JavaScript</h2><ol>
<li><p>内部标签 ,一般放在head或者body中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   alert(<span class="string">'hello,world'</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>外部引入</p>
<p>qj.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">'hello,world'</span>);</span><br></pre></td></tr></table></figure>

<p>test.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--script标签内，为JavaScript代码--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;script&gt;</span></span><br><span class="line"><span class="comment">        alert('hello,world');</span></span><br><span class="line"><span class="comment">    &lt;/script&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--外部引入--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注意：script标签必须成对出现--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">"js/qj.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="2-2-基本语法入门"><a href="#2-2-基本语法入门" class="headerlink" title="2.2 基本语法入门"></a>2.2 基本语法入门</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--JavaScript严格区分大小写--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 1.定义变量</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> score = <span class="number">96</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 2.条件控制,和java一样</span></span></span><br><span class="line">        if(score &gt; 70 &amp;&amp; score &lt; 90)&#123;</span><br><span class="line"><span class="actionscript">            alert(<span class="string">"good"</span>)</span></span><br><span class="line"><span class="actionscript">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt; <span class="number">90</span> &amp;&amp; score &lt;= <span class="number">100</span>)&#123;</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">"very good"</span>)</span></span><br><span class="line"><span class="actionscript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">"come on"</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">//console.log(score) 在浏览器的控制台打印变量！等价于System.out.print(score)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-数据类型"><a href="#2-3-数据类型" class="headerlink" title="2.3 数据类型"></a>2.3 数据类型</h2><p>数值，文本，视频，音频，图形……</p>
<blockquote>
<p>所有变量定义都用var关键字</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> df = <span class="number">123</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>number</p>
</blockquote>
<p>js不区分小数和整数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span><span class="comment">//整数</span></span><br><span class="line"><span class="number">123.12</span><span class="comment">//浮点数</span></span><br><span class="line"><span class="number">1.23e2</span><span class="comment">//科学记数法</span></span><br><span class="line"><span class="literal">NaN</span><span class="comment">// not a number</span></span><br><span class="line"><span class="literal">Infinity</span> <span class="comment">//无限大</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>字符串</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'123'</span></span><br><span class="line"><span class="string">"123"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>布尔值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>比较运算符</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较运算符</span></span><br><span class="line">=</span><br><span class="line">== 等于(类型不一样，值一样，也会返回<span class="literal">true</span>，比如<span class="number">1</span>==<span class="string">"1"</span> -&gt; <span class="literal">true</span>)</span><br><span class="line">=== 绝对等于,必须类型一样，值一样(<span class="number">1</span>===<span class="string">"1"</span> -&gt; <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>一定要用===進行比较</p>
<ul>
<li>NaN===NaN,这个和所有的数值都不相等，包括自己</li>
<li>只能通过isNaN(NaN)来判断这个数是否是NaN</li>
</ul>
<blockquote>
<p>null和undefined</p>
</blockquote>
<ul>
<li>null 空</li>
<li>undefined 未定义</li>
</ul>
<blockquote>
<p>数组</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="string">"2"</span>,<span class="literal">null</span>,<span class="literal">true</span>]</span><br></pre></td></tr></table></figure>

<p>取数组下标如何越界了会报undefined</p>
<blockquote>
<p>对象</p>
</blockquote>
<p>对象是大括号，数组是中括号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"zhangsan"</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    hobbies: [<span class="string">'java'</span>,<span class="string">'javascript'</span>,<span class="string">'girl'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取值 person.name</span></span><br></pre></td></tr></table></figure>



<h2 id="2-4-严格检查模式"><a href="#2-4-严格检查模式" class="headerlink" title="2.4 严格检查模式"></a>2.4 严格检查模式</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    'use strict';严格检查模式，预防JavaScript的随意性导致产生的一些问题</span></span><br><span class="line"><span class="comment">     必须写在JavaScript代码的第一行</span></span><br><span class="line"><span class="comment">    局部变量建议使用let定义</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="meta">        'use strict'</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//局部变量一般用let定义</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> i = <span class="number">1</span></span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h1><h2 id="3-1-字符串"><a href="#3-1-字符串" class="headerlink" title="3.1 字符串"></a>3.1 字符串</h2><p>1.正常字符串使用单引号，或者双引号包裹</p>
<p>2.注意转义字符\</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\&#39;</span><br><span class="line">\n</span><br><span class="line">\t</span><br><span class="line">\u4e2d Unicode字符(\u####)</span><br><span class="line">\x41 Ascll字符</span><br></pre></td></tr></table></figure>

<p>3.多行字符串编写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = </span><br><span class="line">            <span class="string">`hello </span></span><br><span class="line"><span class="string">            world</span></span><br><span class="line"><span class="string">            good`</span>;</span><br></pre></td></tr></table></figure>

<p>4.模板字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">`hello,<span class="subst">$&#123;name&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<p>5.字符串长度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str.length</span><br></pre></td></tr></table></figure>

<p>6.字符串的可变性，不可变</p>
<p>7.大小写转换</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str.toUpperCase();</span><br><span class="line">str.toLowerCase();</span><br></pre></td></tr></table></figure>

<p>8.indexof substring</p>
<h2 id="3-2-数组"><a href="#3-2-数组" class="headerlink" title="3.2 数组"></a>3.2 数组</h2><p><strong>Array可以包含任意的数据类型</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">12</span>,<span class="number">3</span>,<span class="number">43</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>1.长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.length</span><br></pre></td></tr></table></figure>

<p>2.indexof</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.indexof(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>3.slice(),截取array的一部分，返回一个新数组，类似于string中的substring</p>
<p>4.push() pop() 尾部</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">push:压入数组尾部</span><br><span class="line">pop:弹出尾部的一个元素</span><br></pre></td></tr></table></figure>

<p>5.unshift(),shift  头部</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unshift(): 在头部压入元素</span><br><span class="line">shift()：在头部弹出元素</span><br></pre></td></tr></table></figure>

<p>6.排序 sort</p>
<p>7.元素反转reverse</p>
<p>8.concat()拼接数组，返回新数组，不会修改原来的数组</p>
<p>9.通过连接符打印数组 join</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.join(&#39;-&#39;)</span><br></pre></td></tr></table></figure>

<h2 id="3-3-对象"><a href="#3-3-对象" class="headerlink" title="3.3 对象"></a>3.3 对象</h2><p>若干个键值对</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象名 = &#123;</span><br><span class="line">    属性名: 属性值,</span><br><span class="line">    属性名: 属性值,</span><br><span class="line">    属性名: 属性值</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">           name: <span class="string">"zhang"</span>, </span><br><span class="line">            age: <span class="number">3</span>,</span><br><span class="line">            score: <span class="number">100</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>1.对象赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.name =  <span class="string">'dfd'</span>;</span><br></pre></td></tr></table></figure>

<p>2.动态删减属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> person.name</span><br></pre></td></tr></table></figure>

<p>3.动态添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.hh = <span class="string">'hh'</span></span><br></pre></td></tr></table></figure>

<p>4.判断属性是否在对象中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'age'</span> <span class="keyword">in</span> person</span><br></pre></td></tr></table></figure>

<p>5.判断一个属性是否是自身拥有的，不是继承而来的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.hasOwnProperty(<span class="string">'age'</span>);</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">person.hasOwnProperty(<span class="string">'toString'</span>);</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>



<h2 id="3-4-流程控制"><a href="#3-4-流程控制" class="headerlink" title="3.4 流程控制"></a>3.4 流程控制</h2><p>1.if判断（同java）</p>
<p>2.循环 for foreach for of…</p>
<h2 id="3-5-Map和Set"><a href="#3-5-Map和Set" class="headerlink" title="3.5 Map和Set"></a>3.5 Map和Set</h2><p>Map:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map  = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'jack'</span>,<span class="number">100</span>],[<span class="string">'susan'</span>,<span class="number">90</span>],[<span class="string">'curry'</span>,<span class="number">100</span>]]);</span><br><span class="line">        <span class="keyword">var</span> jack = map.get(<span class="string">'jack'</span>);</span><br><span class="line">        map.set(<span class="string">'kobe'</span>,<span class="number">24</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(jack)</span><br><span class="line">        <span class="built_in">console</span>.log(map)</span><br></pre></td></tr></table></figure>

<p>Set:无序不重复集合</p>
<h2 id="3-6-iterator"><a href="#3-6-iterator" class="headerlink" title="3.6 iterator"></a>3.6 iterator</h2><h1 id="4-函数"><a href="#4-函数" class="headerlink" title="4.函数"></a>4.函数</h1><h2 id="4-1-定义函数"><a href="#4-1-定义函数" class="headerlink" title="4.1 定义函数"></a>4.1 定义函数</h2><p>绝对值函数</p>
<blockquote>
<p>定义方式一</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦执行到return就代表函数结束</p>
<p>如果没有执行return，函数执行也会返回结果，结果就是undefined</p>
<blockquote>
<p>定义方式二</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>调用函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">abs(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>参数问题，JavaScript可以传任意个参数，也可以不传参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> x!== <span class="string">'number'</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">'Not a number'</span>;</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> -x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>arguments</p>
</blockquote>
<p>arguments是一个JS免费赠送的关键字</p>
<p>代表，传递进来的所有参数，是一个数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[i])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> -x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>问题：arguments会包含所有的参数，有时候想用部分参数进行附加操作，需要排除已有的参数</p>
<blockquote>
<p>rest</p>
</blockquote>
<p>ES6引入的新特性，获取除了已经定义的参数之外的所有参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a,b,...rest</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`a=&gt;<span class="subst">$&#123;a&#125;</span>`</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`b=&gt;<span class="subst">$&#123;b&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">            <span class="built_in">console</span>.log(rest)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-变量作用域"><a href="#4-2-变量作用域" class="headerlink" title="4.2 变量作用域"></a>4.2 变量作用域</h2><p>在JavaScript中，var定义变量是有作用域的</p>
<p>假设在函数体中声明，则在函数体外不可以使用（可以使用闭包实现）</p>
<p>内部函数可以使用外部函数的成员</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> b = a + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提升变量的作用域</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xx</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span>  x = <span class="string">'x'</span> + y;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    <span class="keyword">var</span> y = <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：x undefined</p>
<p>说明：js执行引擎，自动提升了y的声明，但不会提升y的赋值</p>
<p>所以都放在最前面统一定义</p>
<blockquote>
<p>全局函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量 </span></span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(x)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">window</span>.x)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>全局对象window</p>
</blockquote>
<p>默认所有的全局变量都会自动绑定到window下</p>
<p>alert()这个函数本身也是一个window的变量</p>
<p>JavaScript实际上只有一个全局作用于，任何变量(函数也可以视为变量)，假设没有在函数作用范围内找到，就会向外查找，如果在全局作用于都没有找到，会报错<strong><em>ReferenceError</em></strong></p>
<blockquote>
<p>规范</p>
</blockquote>
<p>由于所有的全局变量都会绑定到window上，如果不同的js文件使用了相同的全局变量，就会产生冲突—》如何减少冲突</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义全局作用域</span></span><br><span class="line">        <span class="keyword">var</span> XxxApp = &#123;&#125;;</span><br><span class="line">        <span class="comment">//定义全局变量</span></span><br><span class="line">        XxxApp.name = <span class="string">'zhang'</span>;</span><br><span class="line">        XxxApp.add = <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>把自己的代码全部放入自己定义的唯一空间作用域红，降低全局命名冲突的问题</p>
<p>jQuery就是这样做的，它的域就用jQuery，用$简化代替</p>
<blockquote>
<p>局部作用域</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">             <span class="built_in">console</span>.log(i);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">console</span>.log(i+<span class="number">1</span>);<span class="comment">//11 问题？i出了作用域还能用</span></span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>解决,使用<strong>let</strong>定义局部作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">             <span class="built_in">console</span>.log(i);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">console</span>.log(i+<span class="number">1</span>);<span class="comment">//11 问题？i出了作用域还能用</span></span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>常量const</p>
</blockquote>
<p>const也是ES6新特性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-方法"><a href="#4-3-方法" class="headerlink" title="4.3 方法"></a>4.3 方法</h2><blockquote>
<p>定义方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> zhang = &#123;</span><br><span class="line">            name: <span class="string">'zhang'</span>,</span><br><span class="line">            birth: <span class="number">2014</span>,</span><br><span class="line">            <span class="comment">//方法</span></span><br><span class="line">            age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">                <span class="keyword">return</span> now - <span class="keyword">this</span>.birth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法调用,方法一定要带()</span></span><br><span class="line">zhang.age();</span><br></pre></td></tr></table></figure>

<p>方法即将函数放在对象里面</p>
<p>拆开上面代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> now - <span class="keyword">this</span>.birth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> zhang = &#123;</span><br><span class="line">            name: <span class="string">'zhang'</span>,</span><br><span class="line">            birth: <span class="number">2014</span>,</span><br><span class="line">            <span class="comment">//方法</span></span><br><span class="line">            age: getAge()</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//zhang.age()  ok</span></span><br><span class="line"><span class="comment">//zhang.getAge() NaN,因为this指向了window</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>apply</p>
</blockquote>
<p>在js中可以控制this的指向(java是不行的，java的this就是指向当前对象)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> now - <span class="keyword">this</span>.birth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> zhang = &#123;</span><br><span class="line">            name: <span class="string">'zhang'</span>,</span><br><span class="line">            birth: <span class="number">2014</span>,</span><br><span class="line">            <span class="comment">//方法</span></span><br><span class="line">            age: getAge()</span><br><span class="line">        &#125;;</span><br><span class="line">		<span class="keyword">var</span> chen = &#123;</span><br><span class="line">            name: <span class="string">'chen'</span>,</span><br><span class="line">            birth: <span class="number">2004</span>,</span><br><span class="line">            <span class="comment">//方法</span></span><br><span class="line">            age: getAge()</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//getAge.apply(zhang,[]);//this,指向了zhang,参数为空</span></span><br></pre></td></tr></table></figure>

<h1 id="5-内部对象"><a href="#5-内部对象" class="headerlink" title="5.内部对象"></a>5.内部对象</h1><blockquote>
<p>标准对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">2</span></span><br><span class="line"><span class="string">'number'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;</span><br><span class="line"><span class="string">'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span></span><br><span class="line"><span class="string">'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.abs</span><br><span class="line"><span class="string">'function'</span></span><br></pre></td></tr></table></figure>



<h2 id="5-1-Date"><a href="#5-1-Date" class="headerlink" title="5.1 Date"></a>5.1 Date</h2><p>基本使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        now.getFullYear();<span class="comment">//年</span></span><br><span class="line">        now.getMonth();<span class="comment">//月</span></span><br><span class="line">        now.getDate();<span class="comment">//日</span></span><br><span class="line">        now.getDay();<span class="comment">//星期几</span></span><br><span class="line">        now.getHours();<span class="comment">//时</span></span><br><span class="line">        now.getMinutes();<span class="comment">//分</span></span><br><span class="line">        now.getMilliseconds();<span class="comment">//秒</span></span><br><span class="line"></span><br><span class="line">        now.getTime();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1640251029024</span>))</span><br></pre></td></tr></table></figure>

<p>转化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">now.toLocaleString();</span><br><span class="line"><span class="string">'2021/12/23 下午5:17:09'</span></span><br><span class="line">now.toLocaleDateString();</span><br><span class="line"><span class="string">'2021/12/23'</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2-JSON"><a href="#5-2-JSON" class="headerlink" title="5.2 JSON"></a>5.2 JSON</h2><blockquote>
<p>json是什么</p>
</blockquote>
<p><a href="https://baike.baidu.com/item/JSON" target="_blank" rel="noopener">JSON</a>(<a href="https://baike.baidu.com/item/JavaScript" target="_blank" rel="noopener">JavaScript</a> Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式</p>
<p> 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率</p>
<p>在JavaScript中，一切皆对象，任何js支持的类型都可以用JSON来表示</p>
<p>格式：</p>
<ul>
<li>对象用{}</li>
<li>数组用[]</li>
<li>所有的键值对都是用key:value</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">            name: <span class="string">"zhang"</span>,</span><br><span class="line">            age: <span class="number">18</span>,</span><br><span class="line">            sex: <span class="string">'男'</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象转化为字符串</span></span><br><span class="line">        <span class="keyword">var</span> userJson = <span class="built_in">JSON</span>.stringify(user);</span><br><span class="line">        <span class="built_in">console</span>.log(userJson) <span class="comment">//&#123;"name":"zhang","age":18,"sex":"男"&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符串转对象</span></span><br><span class="line">        <span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(userJson);</span><br><span class="line">        <span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure>

<p>JSON和JS对象的区别</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="string">'hello'</span>,<span class="attr">b</span>:<span class="string">'world'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> json = &#123;<span class="string">'a'</span>:<span class="string">'hello'</span>,<span class="string">'b'</span>:<span class="string">'world'</span>&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="6-面向对象编程"><a href="#6-面向对象编程" class="headerlink" title="6.面向对象编程"></a>6.面向对象编程</h1><p>JavaScript，java，c#…….面向对象，JavaScript有些区别</p>
<p>java中</p>
<ul>
<li>类：模板</li>
<li>对象：具体的实例</li>
</ul>
<p>es6之前在javascript有点不太一样，之前使用原型对象来定义类的</p>
<p>es6之前</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">            name: <span class="string">"zhang"</span>,</span><br><span class="line">            age: <span class="number">18</span>,</span><br><span class="line">            sex: <span class="string">'男'</span>,</span><br><span class="line">            run:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(name + <span class="string">'run......'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">            name:<span class="string">"xiaoming"</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小明的原型是Student,原型相当于java中的继承，相当于xiaoming继承了Student</span></span><br><span class="line">        xiaoming._proto_ = Student;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> Bird = &#123;</span><br><span class="line">            fly:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.name +<span class="string">"fly......"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小明的原型是Bird</span></span><br><span class="line">        xiaoming._proto_ = Bird;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>class继承</p>
</blockquote>
<p>class关键字是在es6中引入的</p>
<p>1.定义类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">           <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">               <span class="keyword">this</span>.name = name;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           hello()&#123;</span><br><span class="line">               alert(<span class="string">'hello'</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zhang = <span class="keyword">new</span> Student(<span class="string">'zhang'</span>);</span><br><span class="line">zhang.hello();</span><br></pre></td></tr></table></figure>

<p>2.继承(本质就是原型)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XStudent</span> <span class="keyword">extends</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">           <span class="keyword">constructor</span>(name,grade) &#123;</span><br><span class="line">               <span class="keyword">super</span>(name);</span><br><span class="line">               <span class="keyword">this</span>.grade = grade;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>原型链</p>
</blockquote>
<p>对象的继承关系，最终会指向object对象</p>
<h1 id="7-操作BOM对象"><a href="#7-操作BOM对象" class="headerlink" title="7.操作BOM对象"></a>7.操作BOM对象</h1><p>JavaScript和浏览器的关系？</p>
<p>JavaScript的诞生就是为了代码能够在浏览器中运行</p>
<p>BOM：浏览器对象模型</p>
<ul>
<li>IE</li>
<li>Chrome</li>
<li>Safari</li>
<li>Firefox</li>
<li>Opera</li>
</ul>
<p>三方</p>
<ul>
<li><p>QQ浏览器</p>
</li>
<li><p>360浏览器</p>
</li>
</ul>
<blockquote>
<p>window（重要）</p>
</blockquote>
<p>window代表浏览器窗口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.innerHeight</span><br><span class="line"><span class="number">762</span></span><br><span class="line"><span class="built_in">window</span>.innerWidth</span><br><span class="line"><span class="number">1464</span></span><br><span class="line"><span class="built_in">window</span>.outerHeight</span><br><span class="line"><span class="number">864</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>navigator</p>
</blockquote>
<p>navigator,封装了浏览器的信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">navigator.appName</span><br><span class="line"><span class="string">'Netscape'</span></span><br><span class="line">navigator.appVersion</span><br><span class="line"><span class="string">'5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36'</span></span><br><span class="line">navigator.platform</span><br><span class="line"><span class="string">'Win32'</span></span><br></pre></td></tr></table></figure>

<p>大多数时候，我们不会使用navigator对象，因为会被人修改!</p>
<p>不建议使用这些属性来判断和编写代码</p>
<blockquote>
<p>screen</p>
</blockquote>
<p>代表屏幕尺寸</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">screen.width</span><br><span class="line"><span class="number">1536</span></span><br><span class="line">screen.height</span><br><span class="line"><span class="number">864</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>location（重要）</p>
</blockquote>
<p>location代表当前页面的url信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">host: <span class="string">"www.baidu.com"</span></span><br><span class="line">hostname: <span class="string">"www.baidu.com"</span></span><br><span class="line">href: <span class="string">"https://www.baidu.com/"</span></span><br><span class="line">origin: <span class="string">"https://www.baidu.com"</span></span><br><span class="line">port: <span class="string">""</span></span><br><span class="line">protocol: <span class="string">"https:"</span></span><br><span class="line"></span><br><span class="line">reload: ƒ reload() <span class="comment">//刷新网页</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置新地址，当访问原先地址的时候就会跳转下面设置的地址，实现重定向</span></span><br><span class="line">location.assign(<span class="string">'https://zhanghanting.github.io/'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>document</p>
</blockquote>
<p>document代表当前页面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.title</span><br><span class="line"><span class="string">'百度一下，你就知道'</span></span><br><span class="line"><span class="built_in">document</span>.title=<span class="string">'hello,world'</span></span><br><span class="line"><span class="string">'hello,world'</span></span><br></pre></td></tr></table></figure>

<p>获取具体的文档树节点</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>JavaSE<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>JavaEE<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> dl = <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>获取cookie</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie</span><br><span class="line"><span class="string">'PSTM=1631268428; BAIDUID=F11E02E2CA7A793F42BA78C2C1C14E01:FG=1; BD_UPN=12314753; BIDUPSID=9BB3D64BA5D12D53BBBBA03B5448AD3C</span></span><br></pre></td></tr></table></figure>

<p>劫持cookie原理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">'xxx.js'</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;!--恶意人员可以在前端代码中植入script代码获取用户的cookie上传到自己的服务器--&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务器端可以设置cookie设置为httpOnly，这样cookie就只能读不能获取了</p>
<blockquote>
<p>history</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">history.forward()<span class="comment">//前进</span></span><br><span class="line">history.back() <span class="comment">//后退</span></span><br></pre></td></tr></table></figure>

<h1 id="8-操作DOM对象"><a href="#8-操作DOM对象" class="headerlink" title="8.操作DOM对象"></a>8.操作DOM对象</h1><blockquote>
<p>核心</p>
</blockquote>
<p>浏览器网页就是一个DOM树形结构！</p>
<ul>
<li>更新：更新DOM节点</li>
<li>遍历DOM节点</li>
<li>删除：删除一个DOM节点</li>
<li>添加：添加一个新的DOM节点</li>
</ul>
<p>要操作一个DOM节点，就必须先获取到这个DOM节点</p>
<blockquote>
<p>获取DOM节点</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">/*对应css选择器*/</span></span><br><span class="line">    <span class="keyword">var</span> h1 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'h1'</span>);</span><br><span class="line">    <span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">'p1'</span>);</span><br><span class="line">    <span class="keyword">var</span> p2 = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'p2'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> father = <span class="built_in">document</span>.getElementById(<span class="string">'father'</span>);</span><br><span class="line">    <span class="keyword">var</span> children = father.children;<span class="comment">//获取父节点下的所有子节点</span></span><br><span class="line">    father.firstChild;</span><br><span class="line">    father.lastChild;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>这是原声代码，之后都尽量用jQuery();</p>
<blockquote>
<p>更新节点</p>
</blockquote>
<p>操作文本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">div1.innerText=<span class="number">123</span> <span class="comment">//修改对应节点的文本值</span></span><br><span class="line">div1.innerHTML=<span class="string">'&lt;strong&gt;加粗123&lt;/strong&gt;'</span> <span class="comment">//可以设置超文本</span></span><br></pre></td></tr></table></figure>

<p>操作样式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div1.style.color = <span class="string">'red'</span></span><br><span class="line"><span class="string">'red'</span></span><br><span class="line">div1.style.fontSize = <span class="string">'30px'</span></span><br><span class="line"><span class="string">'30px'</span></span><br><span class="line">div1.style.padding=<span class="string">'10em'</span></span><br><span class="line"><span class="string">'10em'</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除节点</p>
</blockquote>
<p>删除节点的步骤：先获取父节点，再通过父节点删除自己</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p1"</span>&gt;</span>p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"p2"</span>&gt;</span>p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">/*对应css选择器*/</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">'p1'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> father = p1.parentElement;</span></span><br><span class="line">    father.remove(p1);</span><br><span class="line">    </span><br><span class="line"><span class="actionscript">    <span class="comment">//或者</span></span></span><br><span class="line">    father.removeChild(father.children[1])</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>插入节点</p>
</blockquote>
<p>获得了某个DOM节点后，假设这个节点是空的，直接通过innerHTML就可以增加一个元素了，但是如果这个DOM节点已经存在元素了，就不能这样做了，会覆盖原来的内容！</p>
<blockquote>
<p>追加已有标签</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p id=<span class="string">"js"</span>&gt;javaScript&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div id="list"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p id="se"&gt;JavSE&lt;/</span>p&gt;</span><br><span class="line">        &lt;p id=<span class="string">"ee"</span>&gt;JavEE&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p id="me"&gt;JavME&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">        var js = document.getElementById('js');</span></span><br><span class="line"><span class="regexp">        var list = document.getElementById('list');</span></span><br><span class="line"><span class="regexp">        list.appendChild(js)/</span><span class="regexp">/追加到后面</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果</p>
<p><img src="https://s2.loli.net/2021/12/24/gGowOilQa4s2h8L.png" alt="image-20211224112612449"></p>
<blockquote>
<p>创建新标签，实现插入</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p id=<span class="string">"js"</span>&gt;javaScript&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div id="list"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p id="se"&gt;JavSE&lt;/</span>p&gt;</span><br><span class="line">        &lt;p id=<span class="string">"ee"</span>&gt;JavEE&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p id="me"&gt;JavME&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">        var list = document.getElementById('list');</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        var newP = document.createElement('p');/</span><span class="regexp">/创建一个p标签节点</span></span><br><span class="line"><span class="regexp">        newP.id = 'newP';</span></span><br><span class="line"><span class="regexp">        newP.innerText = 'created a p tag';</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        list.appendChild(newP);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/创建style标签</span></span><br><span class="line"><span class="regexp">        var myStyle = document.createElement('style');</span></span><br><span class="line"><span class="regexp">        myStyle.setAttribute('type','text/</span>css<span class="string">')</span></span><br><span class="line"><span class="string">        myStyle.innerHTML='</span>body&#123;background-color: yellow;&#125;<span class="string">'// 设置标签内容</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        var head = document.getElementsByTagName('</span>head<span class="string">');//将标签加入到head中</span></span><br><span class="line"><span class="string">        head[0].appendChild(myStyle);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过attribute方法可以设置任意值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个标签节点</span></span><br><span class="line"> <span class="keyword">var</span> newScript = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line"> newScript.setAttribute(<span class="string">'type'</span>,<span class="string">'text/javascript'</span>);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>insert</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ee = <span class="built_in">document</span>.getElementById(<span class="string">'ee'</span>);</span><br><span class="line">      <span class="keyword">var</span> js = <span class="built_in">document</span>.getElementById(<span class="string">'js'</span>);</span><br><span class="line">      <span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line">      <span class="comment">//(newNode,targetNode)</span></span><br><span class="line">      list.insertBefore(js,ee);</span><br></pre></td></tr></table></figure>





<h1 id="9-操作表单（验证）"><a href="#9-操作表单（验证）" class="headerlink" title="9.操作表单（验证）"></a>9.操作表单（验证）</h1><blockquote>
<p>表单是什么，也是DOM树中的节点</p>
</blockquote>
<ul>
<li>文本框 text</li>
<li>下拉框 select</li>
<li>单选框 radio</li>
<li>多选框 checkBox</li>
<li>隐藏域 hidden</li>
<li>密码框 password</li>
</ul>
<p>表单的目的：提交信息</p>
<blockquote>
<p>获得要提交的信息</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span> = <span class="string">"username"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>性别：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"man"</span> <span class="attr">id</span>=<span class="string">"man"</span>&gt;</span>男</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"women"</span> <span class="attr">id</span>=<span class="string">"girl"</span>&gt;</span>女</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> input_text = <span class="built_in">document</span>.getElementById(<span class="string">"username"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> man = <span class="built_in">document</span>.getElementById(<span class="string">"man"</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//获取输入框的值</span></span></span><br><span class="line">    input_text.value;</span><br><span class="line"><span class="actionscript">    <span class="comment">//修改输入框的值</span></span></span><br><span class="line">    input_text.value = 123;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">//对于单选框，多选框等固定的值,需要通过checked判断是否被选中</span></span></span><br><span class="line"><span class="actionscript">    man.checked;<span class="comment">//true-&gt;被选中</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>提交表单，MD5加密拦截</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!--MD5工具类--&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script src=https:/</span><span class="regexp">/cdn.bootcss.com/</span>blueimp-md5/<span class="number">2.10</span><span class="number">.0</span>/js/md5.min.js&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form method=<span class="string">"post"</span> action=<span class="string">"https://www.baidu.com/"</span> onsubmit=<span class="string">"return check()"</span>&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        &lt;span&gt;用户名：&lt;<span class="regexp">/span&gt; &lt;input type="text" id = "username" name = "username"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        &lt;span&gt;密码：&lt;<span class="regexp">/span&gt; &lt;input type="password" id = "input-password"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=<span class="string">"hidden"</span> id=<span class="string">"md5-password"</span> name=<span class="string">"password"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--绑定事件--&gt;</span><br><span class="line">    &lt;button type=<span class="string">"submit"</span>&gt;提交&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>form&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> username = <span class="built_in">document</span>.getElementById(<span class="string">'username'</span>);</span><br><span class="line">        <span class="keyword">var</span> password = <span class="built_in">document</span>.getElementById(<span class="string">'input-password'</span>);</span><br><span class="line">        <span class="keyword">var</span> md5password = <span class="built_in">document</span>.getElementById(<span class="string">'md5-password'</span>);</span><br><span class="line"></span><br><span class="line">        md5password.value = md5(password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//true则提交通过，false则阻止提交请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>





<h1 id="10-jQuery"><a href="#10-jQuery" class="headerlink" title="10.jQuery"></a>10.jQuery</h1><p>JavaScript</p>
<p>jQuery库，里面存在大量的JavaScript函数</p>
<p>参考文档：<a href="https://jquery.cuishifeng.cn/" target="_blank" rel="noopener">https://jquery.cuishifeng.cn/</a></p>
<blockquote>
<p>获取jQuery</p>
</blockquote>
<p>官网：<a href="https://jquery.com/" target="_blank" rel="noopener">https://jquery.com/</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;!--CDN在线引入jQuery--&gt;</span></span><br><span class="line"><span class="regexp">   &lt;!-- &lt;script src="http:/</span><span class="regexp">/libs.baidu.com/</span>jquery/<span class="number">2.0</span><span class="number">.0</span>/jquery.min.js<span class="string">"&gt;&lt;/script&gt;--&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;!--使用下载好的--&gt;</span></span><br><span class="line"><span class="string">    &lt;script src="</span>lib/jquery<span class="number">-3.6</span><span class="number">.0</span>.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="10-1-jQuery使用公式"><a href="#10-1-jQuery使用公式" class="headerlink" title="10.1 jQuery使用公式"></a>10.1 jQuery使用公式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;!--CDN在线引入jQuery--&gt;</span></span><br><span class="line"><span class="regexp">   &lt;!-- &lt;script src="http:/</span><span class="regexp">/libs.baidu.com/</span>jquery/<span class="number">2.0</span><span class="number">.0</span>/jquery.min.js<span class="string">"&gt;&lt;/script&gt;--&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;!--使用下载的--&gt;</span></span><br><span class="line"><span class="string">    &lt;script src="</span>lib/jquery<span class="number">-3.6</span><span class="number">.0</span>.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;!--</span></span><br><span class="line"><span class="string">公式：$(selector).action()</span></span><br><span class="line"><span class="string">--&gt;</span></span><br><span class="line"><span class="string">&lt;a href="</span><span class="string">" id="</span>test-js<span class="string">"&gt;点我&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">    //选择器就是css选择器</span></span><br><span class="line"><span class="string">    $('#test-js').click(function () &#123;</span></span><br><span class="line"><span class="string">        alert('hello ,jQuery')</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>





<blockquote>
<p>选择器</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//标签选择器</span></span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName();</span><br><span class="line">    $(<span class="string">'p'</span>).click();</span><br><span class="line">    <span class="comment">//id选择器</span></span><br><span class="line">    <span class="built_in">document</span>.getElementById();</span><br><span class="line">    $(<span class="string">'#id1'</span>).click();</span><br><span class="line">    <span class="comment">//类选择器</span></span><br><span class="line">    <span class="built_in">document</span>.getElementsByClassName();</span><br><span class="line">    $(<span class="string">'.class1'</span>).click();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>事件</p>
</blockquote>
<p>鼠标事件，键盘事件，其它事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script src="lib/</span>jquery<span class="number">-3.6</span><span class="number">.0</span>.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;style&gt;</span></span><br><span class="line"><span class="string">        #divMove&#123;</span></span><br><span class="line"><span class="string">            width: 300px;</span></span><br><span class="line"><span class="string">            height: 300px;</span></span><br><span class="line"><span class="string">            border: 1px solid red;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &lt;/style&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;!--获取鼠标当期的坐标--&gt;</span></span><br><span class="line"><span class="string">mouse: &lt;span id="</span>mouseMove<span class="string">"&gt;&lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;div id="</span>divMove<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    在这里点击鼠标</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">    /*</span></span><br><span class="line"><span class="string">    * 当网页元素加载完毕之后，响应事件</span></span><br><span class="line"><span class="string">    * */</span></span><br><span class="line"><span class="string">    /*$(document).ready(function () &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#125;)*/</span></span><br><span class="line"><span class="string">    //简写为如下方式：</span></span><br><span class="line"><span class="string">    $(function () &#123;</span></span><br><span class="line"><span class="string">        $('#divMove').mousemove(function (e) &#123;</span></span><br><span class="line"><span class="string">            $('#mouseMove').text('x:' + e.pageX + 'y: '+ e.pageY);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>





<blockquote>
<p>操作DOM</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul id=<span class="string">"test-ul"</span>&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">"js"</span>&gt;JavaScript&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li name="java"&gt;java&lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    $('#test-ul li[name=python]').text();/</span><span class="regexp">/获得值</span></span><br><span class="line"><span class="regexp"> 	$('#test-ul li[name=python]').text('设置值');/</span><span class="regexp">/设置值</span></span><br><span class="line"><span class="regexp">	$('#test-ul').css('color','red');</span></span><br><span class="line"><span class="regexp">    $('#test-ul').html();/</span><span class="regexp">/获得值</span></span><br><span class="line"><span class="regexp">	$('#test-ul').html('设置值');/</span><span class="regexp">/设置值</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure>

<p>元素的显示和隐藏,本质:display:none</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> $(<span class="string">'#test-ul'</span>).show();</span><br><span class="line"> $(<span class="string">'#test-ul'</span>).hide();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="10-2小技巧"><a href="#10-2小技巧" class="headerlink" title="10.2小技巧"></a>10.2小技巧</h2><p>1.如何巩固JS（看jQuery，看游戏源码）</p>
<p>2.巩固HTML，CSS（扒网站，全部down下来，然后对应修改看效果）</p>
]]></content>
  </entry>
  <entry>
    <title>CSS</title>
    <url>/2021/11/14/kuangshen/%E5%89%8D%E7%AB%AF/CSS/</url>
    <content><![CDATA[<p>HTML+CSS+JavaScript</p>
<p>结构+表现+交互</p>
<h1 id="1-什么是CSS"><a href="#1-什么是CSS" class="headerlink" title="1. 什么是CSS"></a>1. 什么是CSS</h1><p>如何学习</p>
<ol>
<li>CSS是什么</li>
<li>CSS怎么用(快速入门)</li>
<li>CSS选择器（重点+难点）</li>
<li>美化网页(文字，阴影，超链接，列表，渐变…)</li>
<li>盒子模型</li>
<li>浮动</li>
<li>定位</li>
<li>网页动画(特效效果)</li>
</ol>
<h2 id="1-1-什么是CSS"><a href="#1-1-什么是CSS" class="headerlink" title="1.1 什么是CSS"></a>1.1 什么是CSS</h2><p>Cascading Style Sheet层叠级联样式表</p>
<p>CSS: 表现(美化网页)</p>
<p>字体，颜色，边距，宽度，高度，背景图片，网页定位…</p>
<h2 id="1-2-发展史"><a href="#1-2-发展史" class="headerlink" title="1.2 发展史"></a>1.2 发展史</h2><p>CSS1.0</p>
<p>CSS2.0 DIV(块) + CSS，提出了HTML与CSS结构分离的思想</p>
<p>CSS2.1 浮动，定位</p>
<p>CSS3.0 圆角，阴影，动画…… 浏览器兼容性</p>
<h2 id="1-3-快速入门"><a href="#1-3-快速入门" class="headerlink" title="1.3 快速入门"></a>1.3 快速入门</h2><blockquote>
<p>基本入门</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--规范</span></span><br><span class="line"><span class="comment">&lt;style&gt;  每一个声明最好使用分号结尾</span></span><br><span class="line"><span class="comment">语法：</span></span><br><span class="line"><span class="comment">    选择器&#123;</span></span><br><span class="line"><span class="comment">        声明1;</span></span><br><span class="line"><span class="comment">        声明2;</span></span><br><span class="line"><span class="comment">        声明3;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        h1&#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>html中引入css</p>
</blockquote>
<p>建议使用这种分离规范（内容和表现分离）</p>
<p><img src="https://i.loli.net/2021/11/15/ySHz3jA97GoxZs4.png" alt="image-20211115210850968"></p>
<p>css的优势：</p>
<ol>
<li>内容和表现分离</li>
<li>网页结构表现统一，可以实现发勇</li>
<li>样式十分丰富</li>
<li>利用SEO，容易被搜索引擎收录</li>
</ol>
<h2 id="1-4-CSS的3种导入方式"><a href="#1-4-CSS的3种导入方式" class="headerlink" title="1.4 CSS的3种导入方式"></a>1.4 CSS的3种导入方式</h2><p>行内样式   内部样式  外部样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        h1&#123;</span><br><span class="line">            color: green;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--优先级：</span></span><br><span class="line"><span class="comment">就近原则</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--行内样式：在标签元素中，编写样式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">"color: red"</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>拓展；外部样式两种写法</p>
</blockquote>
<ul>
<li>链接式</li>
</ul>
<p>推荐使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/style.css"</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>导入式</li>
</ul>
<p>css2.1 不推荐使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="keyword">@import</span> url(<span class="string">"css/style.css"</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="2-选择器"><a href="#2-选择器" class="headerlink" title="2.选择器"></a>2.选择器</h1><p>作用：选择页面上的某一类或者某一个元素</p>
<p>优先级：</p>
<p>id选择器  &gt; 类选择器 &gt; 标签选择器</p>
<h2 id="2-1-基本选择器"><a href="#2-1-基本选择器" class="headerlink" title="2.1 基本选择器"></a>2.1 基本选择器</h2><p>1.标签选择器: 选择一类标签</p>
<p>标签{}</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 标签选择器会选择页面上所有的标签--&gt;</span></span></span><br><span class="line">        h1&#123;</span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#2f43ff</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        p&#123;</span><br><span class="line">            font-size: 80px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>java<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>scala<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>大数据<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>2.类选择器: 选择所有class属性一致的标签，可以跨标签</p>
<p>.类名{}</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        /*类选择器的格式，.class的名称&#123;&#125;</span><br><span class="line">        好处：可以多个标签归类复用，是同一个class</span><br><span class="line">        */</span><br><span class="line"><span class="css">        <span class="selector-class">.java</span>&#123;</span></span><br><span class="line">            color: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.scala</span>&#123;</span></span><br><span class="line">            color: antiquewhite;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"java"</span>&gt;</span>java<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"scala"</span>&gt;</span>scala<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"java"</span>&gt;</span>大数据<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>3.id选择器: 全局唯一</p>
<p>#id{}</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        /*id选择器的格式: id必须保证全局唯一</span><br><span class="line"><span class="css">        <span class="selector-id">#id</span>名称&#123;&#125;</span></span><br><span class="line">        </span><br><span class="line">        不遵循就近原则，固定的</span><br><span class="line">        id选择器 &gt; class选择器 &gt; 标签选择器</span><br><span class="line">        */</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-id">#aaa</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#d724a7</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.style1</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#2f43ff</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        h1&#123;</span><br><span class="line">            color: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span> = <span class="string">"aaa"</span> <span class="attr">class</span>=<span class="string">"style1"</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题3<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题4<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题5<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="2-2-层次选择器"><a href="#2-2-层次选择器" class="headerlink" title="2.2 层次选择器"></a>2.2 层次选择器</h2><p>1.后代选择器：在某个元素的后面    祖爷爷-&gt;爷爷-&gt;爸爸</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      <span class="comment">/*后代选择器*/</span></span><br><span class="line"><span class="comment">/*对body后面所有的后代p标签都生效，即多个层级也会生效*/</span></span><br><span class="line">      <span class="selector-tag">body</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">          <span class="attribute">background</span>: red;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<p>2.子选择器: 一代,只对下一代生效</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*子选择器*/</span></span><br><span class="line">       <span class="selector-tag">body</span>&gt;<span class="selector-tag">p</span>&#123;</span><br><span class="line">           <span class="attribute">background</span>: <span class="number">#2f43ff</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



<p>3.相邻兄弟选择器(向下相邻)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*相邻兄弟选择器.只有一个，相邻(向下)</span></span><br><span class="line"><span class="comment">        这里会选中.active类标签向下的p标签</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="selector-class">.active</span> + <span class="selector-tag">p</span>&#123;</span><br><span class="line">            <span class="attribute">background</span>: <span class="number">#d724a7</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>4.通用选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*通用选择器，也是向下取，但是会取同级向下的多个兄弟标签*/</span></span><br><span class="line">       <span class="selector-class">.active</span>~<span class="selector-tag">p</span>&#123;</span><br><span class="line">           <span class="attribute">background</span>: aquamarine;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>案例代码</p>
<p> <img src="https://i.loli.net/2021/11/21/HAoyDr7W3njvwQX.png" alt="image-20211121094806630"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        /*p&#123;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;*/</span><br><span class="line"><span class="css">        <span class="comment">/*后代选择器*/</span></span></span><br><span class="line">        /*body p&#123;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;*/</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/*子选择器*/</span></span></span><br><span class="line">      /*  body&gt;p&#123;</span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>: <span class="selector-id">#2f43ff</span>;</span></span><br><span class="line">        &#125;*/</span><br><span class="line">        /*相邻兄弟选择器.只有一个，相邻(向下)</span><br><span class="line"><span class="css">        这里会选中<span class="selector-class">.active</span>类标签向下的<span class="selector-tag">p</span>标签</span></span><br><span class="line">        */</span><br><span class="line">        /*.active + p&#123;</span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>: <span class="selector-id">#d724a7</span>;</span></span><br><span class="line">        &#125;*/</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/*通用选择器，也是向下取，但是会取同级的多个*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.active</span>~<span class="selector-tag">p</span>&#123;</span></span><br><span class="line">            background: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p0<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"active"</span>&gt;</span>p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>p4<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>p5<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>p6<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"active"</span>&gt;</span>p7<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p8<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-结构伪类选择器"><a href="#2-3-结构伪类选择器" class="headerlink" title="2.3 结构伪类选择器"></a>2.3 结构伪类选择器</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"> &lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">        <span class="comment">/*ul的第一个子元素*/</span></span><br><span class="line">        <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span>&#123;</span><br><span class="line">            <span class="attribute">background</span>: <span class="number">#2f43ff</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*ul的最后一个子元素*/</span></span><br><span class="line">        <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span>&#123;</span><br><span class="line">            <span class="attribute">background</span>: green;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面两个用的比较少，留个印象即可*/</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*选中p1: 定位到父元素，选择当前的第一个元素</span></span><br><span class="line"><span class="comment">        选择当前p元素的父级元素，父级元素的第一个子元素</span></span><br><span class="line"><span class="comment">        并且是当前元素才生效</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(2)</span>&#123;</span><br><span class="line">            <span class="attribute">background</span>: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*选中父元素，下的p元素的2个，这个是按类型，上面那个是按顺序*/</span></span><br><span class="line">        <span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type(2)</span>&#123;</span><br><span class="line">            <span class="attribute">background</span>: antiquewhite;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>样例代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/*ul的第一个子元素*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>: <span class="selector-id">#2f43ff</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/*ul的最后一个子元素*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span>&#123;</span></span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*选中p1: 定位到父元素，选择当前的第一个元素</span><br><span class="line">        选择当前p元素的父级元素，父级元素的第一个子元素</span><br><span class="line">        并且是当前元素才生效</span><br><span class="line">        */</span><br><span class="line"><span class="css">        <span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(2)</span>&#123;</span></span><br><span class="line">            background: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/*选中父元素，下的p元素的2个，这个是按类型，上面那个是按顺序*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type(2)</span>&#123;</span></span><br><span class="line">            background: antiquewhite;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">       <span class="comment">/* a:hover&#123;</span></span></span><br><span class="line">            background: yellow;</span><br><span class="line">        &#125;*/</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>li1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>li2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>li3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-属性选择器（重要-常用）"><a href="#2-4-属性选择器（重要-常用）" class="headerlink" title="2.4 属性选择器（重要-常用）"></a>2.4 属性选择器（重要-常用）</h2><p>id + class结合</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.demo</span> <span class="selector-tag">a</span>&#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">            display: block;</span><br><span class="line">            height: 50px;</span><br><span class="line">            width: 50px;</span><br><span class="line">            border-radius: 10px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>: <span class="selector-id">#2f43ff</span>;</span></span><br><span class="line">            text-align: center;</span><br><span class="line">            color: antiquewhite;</span><br><span class="line">            text-decoration: none;</span><br><span class="line">            margin-right: 5px;</span><br><span class="line">            font: bold 20px/50px Arial;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line"><span class="css">        <span class="selector-tag">a</span><span class="selector-attr">[属性]</span>&#123;&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">a</span><span class="selector-attr">[属性名=属性值(属性值可以为正则)]</span>&#123;&#125;</span></span><br><span class="line">        = 绝对等于</span><br><span class="line">        *= 通配</span><br><span class="line">        ^= 以这个开头</span><br><span class="line">        $= 以这个结尾</span><br><span class="line"></span><br><span class="line">        */</span><br><span class="line"><span class="css">        <span class="comment">/*存在id属性的元素*/</span></span></span><br><span class="line"><span class="css">        <span class="comment">/*a[id]&#123;</span></span></span><br><span class="line">            background: yellow;</span><br><span class="line">        &#125;*/</span><br><span class="line"><span class="css">        <span class="comment">/*id = first的元素*/</span></span></span><br><span class="line"><span class="css">        <span class="comment">/*a[id=first]&#123;</span></span></span><br><span class="line">            background: green;</span><br><span class="line">        &#125;*/</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/*class中有link的元素*/</span></span></span><br><span class="line"><span class="css">        <span class="comment">/*=是绝对等于  *=是通配*/</span></span></span><br><span class="line"><span class="css">      <span class="comment">/*  a[class*="links"]&#123;</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>: <span class="selector-id">#d724a7</span>;</span></span><br><span class="line">        &#125;*/</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/*选中href中以http开头的数据*/</span></span></span><br><span class="line"><span class="css">       <span class="comment">/* a[href^=http]&#123;</span></span></span><br><span class="line">            background: yellow;</span><br><span class="line">        &#125;*/</span><br><span class="line"><span class="css">        <span class="selector-tag">a</span><span class="selector-attr">[href $= pdf]</span>&#123;</span></span><br><span class="line">            background: yellow;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> <span class="attr">class</span>=<span class="string">"links item first"</span> <span class="attr">id</span> = <span class="string">"first"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://xxx.com"</span> <span class="attr">class</span>=<span class="string">"links item active"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">title</span>=<span class="string">"test"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"images/123.html"</span> <span class="attr">class</span>=<span class="string">"links item active"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"images/123.img"</span> <span class="attr">class</span>=<span class="string">"links item"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"images/123.jpg"</span> <span class="attr">class</span>=<span class="string">"links item"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"abc"</span> <span class="attr">class</span>=<span class="string">"links item"</span>&gt;</span>6<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/a.pdf"</span> <span class="attr">class</span>=<span class="string">"links item"</span>&gt;</span>7<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/abc.pdf"</span> <span class="attr">class</span>=<span class="string">"links item"</span>&gt;</span>8<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"abc.doc"</span> <span class="attr">class</span>=<span class="string">"links item"</span>&gt;</span>9<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"abbb.doc"</span> <span class="attr">class</span>=<span class="string">"links item last"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;</span><br><span class="line">^&#x3D;</span><br><span class="line">$&#x3D;</span><br><span class="line">*&#x3D;</span><br></pre></td></tr></table></figure>



<h1 id="3-美化网页元素"><a href="#3-美化网页元素" class="headerlink" title="3.美化网页元素"></a>3.美化网页元素</h1><p>span标签：重点要突出的字，使用span套起来</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#t1</span>&#123;</span></span><br><span class="line">            font-size: 66px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    欢迎学习 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"t1"</span>&gt;</span>java<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-1-字体样式"><a href="#3-1-字体样式" class="headerlink" title="3.1 字体样式"></a>3.1 字体样式</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--字体风格--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        p&#123;</span><br><span class="line">            font: oblique lighter 18px "楷体";</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    咪咪兔听见关门声，立即爬了起来。他不放心让妈妈自己上山，也拿上一把铁锹，悄悄地跟在妈妈的后面。妈妈来到自家的菜园边，开始清理地边的杂草，不一会儿工夫，头上就冒出了热气。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        font-family: 字体</span></span><br><span class="line"><span class="comment">        font-size: 字体大小</span></span><br><span class="line"><span class="comment">        font-weight: 字体粗细</span></span><br><span class="line"><span class="comment">        color: 字体颜色</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        body&#123;</span><br><span class="line">            font-family: "Arial Black",楷体;</span><br><span class="line">            color: green;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h1&#123;</span><br><span class="line">            font-size: 50px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.p1</span>&#123;</span></span><br><span class="line">            font-weight: bold;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>故事介绍<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"p1"</span>&gt;</span></span><br><span class="line">    今年刚开春，咪咪兔的妈妈就忙着上山开荒，扩大菜园。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    天剛蒙蒙亮，妈妈悄悄起床，给正在酣睡的咪咪兔掖（yē）了掖被角，就蹑（niè）手蹑脚地拿着铁锹（qiāo）出门了。</span><br><span class="line">    咪咪兔听见关门声，立即爬了起来。他不放心让妈妈自己上山，也拿上一把铁锹，悄悄地跟在妈妈的后面。妈妈来到自家的菜园边，开始清理地边的杂草，不一会儿工夫，头上就冒出了热气。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Never give up, Never lose hope.</span><br><span class="line"></span><br><span class="line">    Always have faith, It allows you to cope.</span><br><span class="line"></span><br><span class="line">    Trying times will pass, As they always do.</span><br><span class="line"></span><br><span class="line">    Just have patience, Your dreams will come true.</span><br><span class="line"></span><br><span class="line">    So put on a smile, You'll live through your pain.</span><br><span class="line"></span><br><span class="line">    Know it will pass, And strength you will gain.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-文本样式"><a href="#3-2-文本样式" class="headerlink" title="3.2 文本样式"></a>3.2 文本样式</h2><ul>
<li>颜色</li>
<li>文本对齐方式</li>
<li>首行缩进</li>
<li>行高</li>
<li>装饰</li>
</ul>
<h2 id="3-3-阴影特性"><a href="#3-3-阴影特性" class="headerlink" title="3.3 阴影特性"></a>3.3 阴影特性</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*text-shadow: 阴影颜色  水平偏移  垂直偏移  阴影半径*/</span></span><br><span class="line">     <span class="selector-id">#price</span>&#123;</span><br><span class="line">         <span class="attribute">text-shadow</span>: <span class="number">#38fff8</span> <span class="number">10px</span> <span class="number">0px</span> <span class="number">2px</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-4-超链接伪类"><a href="#3-4-超链接伪类" class="headerlink" title="3.4 超链接伪类"></a>3.4 超链接伪类</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*默认的颜色*/</span></span><br><span class="line">      <span class="selector-tag">a</span>&#123;</span><br><span class="line">          <span class="attribute">text-decoration</span>: none;</span><br><span class="line">          <span class="attribute">color</span>: black;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*鼠标悬浮的状态*/</span></span><br><span class="line">      <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">          <span class="attribute">color</span>: orange;</span><br><span class="line">          <span class="attribute">font-size</span>: <span class="number">66px</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/2021/11/13/kuangshen/%E5%89%8D%E7%AB%AF/HTML/</url>
    <content><![CDATA[<h1 id="1-初识HTML"><a href="#1-初识HTML" class="headerlink" title="1.初识HTML"></a>1.初识HTML</h1><blockquote>
<p>什么是HTML</p>
</blockquote>
<p>Hyper Text Markup Language(超文本标记语言)</p>
<p>超文本：文字，图片，音频，视频，动画等</p>
<p><img src="https://i.loli.net/2021/11/13/JeNcGTRm6vSf4d1.png" alt="image-20211113210000004"></p>
<h1 id="2-网页基本标签"><a href="#2-网页基本标签" class="headerlink" title="2.网页基本标签"></a>2.网页基本标签</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- DOCTYPE:告诉浏览器，我们要使用什么规范--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- head标签代表网页头部--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--meta描述性标签，用来描述网站的一些信息--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--meta一般用来做SEO--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"Java,JavaWeb"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"第一个网页"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--title网页标题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>我的第一个网页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--body表示网页主体--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--标题标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>二级标签<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--段落标签--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>两只老虎，<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>两只老虎，<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--换行标签--&gt;</span></span><br><span class="line">跑得快 爬得快  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">跑得快 爬得快</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--水平线标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--粗体，斜体--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>字体样式标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">粗体：<span class="tag">&lt;<span class="name">strong</span>&gt;</span>i love you<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">斜体：<span class="tag">&lt;<span class="name">em</span>&gt;</span>i love you <span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--特殊符号--&gt;</span></span><br><span class="line">空        格:</span><br><span class="line">空<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>格</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="symbol">&amp;gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="symbol">&amp;lt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="symbol">&amp;copy;</span>版权所有</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h1 id="3-图像，超链接，网页布局"><a href="#3-图像，超链接，网页布局" class="headerlink" title="3.图像，超链接，网页布局"></a>3.图像，超链接，网页布局</h1><h2 id="3-1-图像标签"><a href="#3-1-图像标签" class="headerlink" title="3.1 图像标签"></a>3.1 图像标签</h2><p><img src="https://i.loli.net/2021/11/13/vGwoL1nSpVQcJ4k.png" alt="image-20211113214436633"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>图像标签学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--img 学习</span></span><br><span class="line"><span class="comment">src: 图片地址</span></span><br><span class="line"><span class="comment">    相对地址，绝对地址</span></span><br><span class="line"><span class="comment">alt: 图片名字  必填项</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../resources/image/idea.png"</span> <span class="attr">alt</span>=<span class="string">"idea背景图"</span> <span class="attr">title</span>=<span class="string">"悬停文字"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-链接"><a href="#3-2-链接" class="headerlink" title="3.2 链接"></a>3.2 链接</h2><ul>
<li>页面间链接<ul>
<li>从一个页面链接到另一个页面</li>
</ul>
</li>
<li>锚链接</li>
<li>功能性链接</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>链接标签练习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--锚链接</span></span><br><span class="line"><span class="comment">1.需要一个锚标记</span></span><br><span class="line"><span class="comment">2.跳转到该标记</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#top"</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"down"</span>&gt;</span>down<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--功能性连接</span></span><br><span class="line"><span class="comment">邮件链接：mailto</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:1214422734@qq.com"</span>&gt;</span>点击联系我<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-行内元素和块元素"><a href="#3-3-行内元素和块元素" class="headerlink" title="3.3 行内元素和块元素"></a>3.3 行内元素和块元素</h2><ul>
<li>块元素<ul>
<li>无论内容多少，改元素独占一行</li>
<li>(p,h1-h6)</li>
</ul>
</li>
<li>行内元素<ul>
<li>内容撑开宽度，左右都是行内元素的可以排在一行</li>
<li>(a .strong .em)</li>
</ul>
</li>
</ul>
<h1 id="4-列表，表格，媒体元素"><a href="#4-列表，表格，媒体元素" class="headerlink" title="4.列表，表格，媒体元素"></a>4.列表，表格，媒体元素</h1><h2 id="4-1-列表"><a href="#4-1-列表" class="headerlink" title="4.1 列表"></a>4.1 列表</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>列表学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--有序列表</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>java<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>linux<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>scala<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--无须列表--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>java<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>linux<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>scala<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--自定义列表</span></span><br><span class="line"><span class="comment">dl: 标签</span></span><br><span class="line"><span class="comment">dt: 列表名称</span></span><br><span class="line"><span class="comment">dd: 列表内容</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>学科<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>java<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>scala<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>python<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>位置<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>宜春<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>南昌<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2-表格标签"><a href="#4-2-表格标签" class="headerlink" title="4.2 表格标签"></a>4.2 表格标签</h2><p><img src="https://i.loli.net/2021/11/13/zLHTqQyEAR9rKVj.png" alt="image-20211113221426217"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>表格标签学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--表格</span></span><br><span class="line"><span class="comment">行：tr</span></span><br><span class="line"><span class="comment">列：td</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1px"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--colspan跨列--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"4"</span>&gt;</span>1-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  rowspan      跨行--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>2-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2-4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3-2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3-4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="4-3-媒体元素"><a href="#4-3-媒体元素" class="headerlink" title="4.3 媒体元素"></a>4.3 媒体元素</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>媒体元素学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--音频和视频</span></span><br><span class="line"><span class="comment">src:资源路径</span></span><br><span class="line"><span class="comment">controls:控制条</span></span><br><span class="line"><span class="comment">outplay: 自动播放</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--&lt;video src="../resources/video/6%20-%20What%20If%20I%20Want%20to%20Move%20Faster.mp4" controls autoplay&gt;&lt;/video&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"../resources/audio/1.mp3"</span> <span class="attr">controls</span> <span class="attr">autoplay</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-4-页面结构分析"><a href="#4-4-页面结构分析" class="headerlink" title="4.4 页面结构分析"></a>4.4 页面结构分析</h2><p><img src="https://i.loli.net/2021/11/13/zBfXaQOlxMtPiUj.png" alt="image-20211113222753072"></p>
<h2 id="4-5-iframe内联框架"><a href="#4-5-iframe内联框架" class="headerlink" title="4.5 iframe内联框架"></a>4.5 iframe内联框架</h2><p><img src="https://i.loli.net/2021/11/14/4nbLtIKg1RmfWhq.png" alt="image-20211114092645204"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>iframe<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;iframe src="//player.bilibili.com/player.html?aid=55631961&amp;bvid=BV1x4411V75C&amp;cid=97257967&amp;page=11"</span></span><br><span class="line"><span class="comment">        scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--iframe内联框架</span></span><br><span class="line"><span class="comment">src: 地址</span></span><br><span class="line"><span class="comment">w-h:宽度和高度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"https://www.baidu.com/"</span> <span class="attr">name</span> = <span class="string">"hello"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">"1000px"</span> <span class="attr">height</span>=<span class="string">"800px"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"我的第一个网页.html"</span> <span class="attr">target</span>=<span class="string">"hello"</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h1 id="表单及表单应用"><a href="#表单及表单应用" class="headerlink" title="表单及表单应用"></a>表单及表单应用</h1><p><img src="https://i.loli.net/2021/11/14/CVe26KbuRYqsghl.png" alt="image-20211114093727061"></p>
<p><img src="https://i.loli.net/2021/11/14/svnGBA9HpKZwCXz.png" alt="image-20211114094656882"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录注册<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--表单form</span></span><br><span class="line"><span class="comment">action： 表单提交的位置，可以是网站，也可以是一个请求处理地址</span></span><br><span class="line"><span class="comment">method:post,get提交方式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"我的第一个网页.html"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>名字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入用户名"</span> <span class="attr">required</span> <span class="attr">name</span>=<span class="string">"username"</span>  <span class="attr">maxlength</span>=<span class="string">"8"</span> <span class="attr">size</span>=<span class="string">"30"</span> <span class="attr">readonly</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"pwd"</span> <span class="attr">hidden</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    单选框标签</span></span><br><span class="line"><span class="comment">    type = radio</span></span><br><span class="line"><span class="comment">    value：单选框的值</span></span><br><span class="line"><span class="comment">    name: 所属组</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>性别：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"boy"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">checked</span>/&gt;</span>男</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"girl"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">disabled</span>/&gt;</span>女</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    多选框--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        爱好：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"sleep"</span> <span class="attr">name</span>=<span class="string">"hobby"</span> <span class="attr">checked</span>&gt;</span>爱好</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"code"</span> <span class="attr">name</span>=<span class="string">"hobby"</span>&gt;</span>敲代码</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"girl"</span> <span class="attr">name</span>=<span class="string">"hobby"</span>&gt;</span>姑娘</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>按钮：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">name</span>=<span class="string">"btn1"</span> <span class="attr">value</span>=<span class="string">"点击变长"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;input type="image" src="../resources/image/idea.png"&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    下拉框 列表框--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>下拉框:</span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"列表名称"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"china"</span>&gt;</span>中国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"german"</span>&gt;</span>德国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"ruishi"</span> <span class="attr">selected</span>&gt;</span>瑞士<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--文本域--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>反馈:</span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"textarea"</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">cols</span>=<span class="string">"10"</span> <span class="attr">rows</span>=<span class="string">"10"</span>&gt;</span>文本内容<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    文件域--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>文件：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"files"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">name</span>=<span class="string">"upload"</span> <span class="attr">value</span>=<span class="string">"upload"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    邮件验证--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>邮箱：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">"email"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    URL--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>URL:</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> <span class="attr">name</span>=<span class="string">"url"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    数字--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>数字：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">name</span>=<span class="string">"number"</span> <span class="attr">max</span>=<span class="string">"99"</span> <span class="attr">min</span>=<span class="string">"1"</span> <span class="attr">step</span>=<span class="string">"10"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    滑块--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>音量：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">name</span>=<span class="string">"voice"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">step</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--    搜索框--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>搜索：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">name</span>=<span class="string">"search"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    增强鼠标可用性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        点击鼠标跳到指定位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"mark"</span>&gt;</span>你点我试试<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"mark"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    https://www.jb51.net/tools/regexsc.htm</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>自定义邮箱：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"diymail"</span> <span class="attr">pattern</span>=<span class="string">"^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">"清空表单信息"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h1 id="表单初级验证"><a href="#表单初级验证" class="headerlink" title="表单初级验证"></a>表单初级验证</h1><blockquote>
<p>为什么要进行表单验证</p>
</blockquote>
<p>​    安全，减轻服务器的压力</p>
<blockquote>
<p>常用方式</p>
</blockquote>
<ul>
<li>placeholder 提示信息</li>
<li>required 非空判断</li>
<li>pattern 正则表达式</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录注册<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--表单form</span></span><br><span class="line"><span class="comment">action： 表单提交的位置，可以是网站，也可以是一个请求处理地址</span></span><br><span class="line"><span class="comment">method:post,get提交方式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"我的第一个网页.html"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>名字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入用户名"</span> <span class="attr">required</span> <span class="attr">name</span>=<span class="string">"username"</span>  <span class="attr">maxlength</span>=<span class="string">"8"</span> <span class="attr">size</span>=<span class="string">"30"</span> <span class="attr">readonly</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"pwd"</span> <span class="attr">hidden</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    https://www.jb51.net/tools/regexsc.htm</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>自定义邮箱：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"diymail"</span> <span class="attr">pattern</span>=<span class="string">"^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">"清空表单信息"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>1.EasyExcel.md</title>
    <url>/2021/11/11/kuangshen/java/EasyExcel/</url>
    <content><![CDATA[<h1 id="POI和EasyExcel"><a href="#POI和EasyExcel" class="headerlink" title="POI和EasyExcel"></a>POI和EasyExcel</h1><blockquote>
<p>常用场景</p>
</blockquote>
<p>1.将用户信息导出为excel表格</p>
<p>2.将excel表的信息录入到网站数据库中</p>
<blockquote>
<p>Apache POI</p>
</blockquote>
<p>ApachePOI是用Java编写的免费开源的跨平台的JavaAPI，ApachePOI提供API给Java程序对MicrosoftOffice格式档案读和写的功能，其中使用最多的就是使用POI操作Excel文件。</p>
<p>官网：<a href="https://poi.apache.org" target="_blank" rel="noopener">https://poi.apache.org</a></p>
<blockquote>
<p>基本功能</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HSSF－提供读写MicrosoftExcelXLS格式档案的功能（03版最多65535行）</span><br><span class="line">XSSF－提供读写MicrosoftExcelOOXMLXLSX格式档案的功能(07版无限制)</span><br><span class="line">HWPF－提供读写MicrosoftWordDOC格式档案的功能</span><br><span class="line">HSLF－提供读写MicrosoftPowerPoint格式档案的功能</span><br><span class="line">HDGF－提供读MicrosoftVisio格式档案的功能</span><br><span class="line">HPBF－提供读MicrosoftPublisher格式档案的功能</span><br><span class="line">HSMF－提供读MicrosoftOutlook格式档案的功能</span><br></pre></td></tr></table></figure>







<h1 id="POI-Excel写"><a href="#POI-Excel写" class="headerlink" title="POI-Excel写"></a>POI-Excel写</h1><p>工作簿</p>
<p>工作表</p>
<p>行</p>
<p>列</p>
<p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.kuang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        xls(03)--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        xls(07)--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--日期格式化工具--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--test--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>03版</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelWriteTest</span> </span>&#123;</span><br><span class="line">    String  PATH = <span class="string">"F:\\ideaProjects\\kuangshen\\poi-easyexcel"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWrite0</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个工作簿</span></span><br><span class="line">        HSSFWorkbook workbook = <span class="keyword">new</span> HSSFWorkbook();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建一个工作表</span></span><br><span class="line">        Sheet sheet = workbook.createSheet(<span class="string">"kuangshen观众统计表"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.创建一行</span></span><br><span class="line">        Row row1 = sheet.createRow(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.创建单元格</span></span><br><span class="line">        Cell cell11 = row1.createCell(<span class="number">0</span>);</span><br><span class="line">        cell11.setCellValue(<span class="string">"新增观众张11"</span>);</span><br><span class="line"></span><br><span class="line">        Cell cell12 = row1.createCell(<span class="number">1</span>);</span><br><span class="line">        cell12.setCellValue(<span class="string">"新增观众张12"</span>);</span><br><span class="line"></span><br><span class="line">        Row row2 = sheet.createRow(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Cell cell21 = row2.createCell(<span class="number">0</span>);</span><br><span class="line">        cell21.setCellValue(<span class="string">"新增观众张21"</span>);</span><br><span class="line"></span><br><span class="line">        Cell cell22 = row2.createCell(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        String s = <span class="keyword">new</span> DateTime().toString(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">        cell22.setCellValue(<span class="string">"新增观众张22"</span> + s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成一张表(IO流)</span></span><br><span class="line">        FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(PATH + <span class="string">"03观众统计表.xls"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        workbook.write(outputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        outputStream.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"文件生成完毕"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>07版</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelWriteTest</span> </span>&#123;</span><br><span class="line">    String  PATH = <span class="string">"F:\\ideaProjects\\kuangshen\\poi-easyexcel"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWrite0</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个工作簿</span></span><br><span class="line">       <span class="comment">// HSSFWorkbook workbook = new HSSFWorkbook();</span></span><br><span class="line">        XSSFWorkbook workbook = <span class="keyword">new</span> XSSFWorkbook();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建一个工作表</span></span><br><span class="line">        Sheet sheet = workbook.createSheet(<span class="string">"kuangshen观众统计表"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.创建一行</span></span><br><span class="line">        Row row1 = sheet.createRow(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.创建单元格</span></span><br><span class="line">        Cell cell11 = row1.createCell(<span class="number">0</span>);</span><br><span class="line">        cell11.setCellValue(<span class="string">"新增观众张11"</span>);</span><br><span class="line"></span><br><span class="line">        Cell cell12 = row1.createCell(<span class="number">1</span>);</span><br><span class="line">        cell12.setCellValue(<span class="string">"新增观众张12"</span>);</span><br><span class="line"></span><br><span class="line">        Row row2 = sheet.createRow(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Cell cell21 = row2.createCell(<span class="number">0</span>);</span><br><span class="line">        cell21.setCellValue(<span class="string">"新增观众张21"</span>);</span><br><span class="line"></span><br><span class="line">        Cell cell22 = row2.createCell(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        String s = <span class="keyword">new</span> DateTime().toString(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">        cell22.setCellValue(<span class="string">"新增观众张22"</span> + s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成一张表(IO流)</span></span><br><span class="line">        FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(PATH + <span class="string">"07观众统计表.xlsx"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        workbook.write(outputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        outputStream.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"文件生成完毕"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区别：workbook对象不同，文件后缀不同</p>
<blockquote>
<p>大文件写HSSF</p>
</blockquote>
<p>最多写入65536行数据，比较快</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWrite03BigData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//时间</span></span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建工作簿</span></span><br><span class="line">        Workbook workbook = <span class="keyword">new</span> HSSFWorkbook();</span><br><span class="line">        <span class="comment">//创建表</span></span><br><span class="line">        Sheet sheet = workbook.createSheet();</span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rowNum = <span class="number">0</span>; rowNum &lt; <span class="number">65536</span>; rowNum++) &#123;</span><br><span class="line">            Row row = sheet.createRow(rowNum);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> cellNum = <span class="number">0</span>; cellNum &lt; <span class="number">10</span>; cellNum++) &#123;</span><br><span class="line">                Cell cell = row.createCell(cellNum);</span><br><span class="line">                cell.setCellValue(cellNum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"over"</span>);</span><br><span class="line"></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(PATH + <span class="string">"bigdata03.xls"</span>);</span><br><span class="line"></span><br><span class="line">        workbook.write(fileOutputStream);</span><br><span class="line"></span><br><span class="line">        fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println((<span class="keyword">double</span>) (end-begin)/<span class="number">1000</span>);<span class="comment">//2.183</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>大文件写XSSF</p>
</blockquote>
<p>行数无限制，耗时较长</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWrite07BigData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">//时间</span></span><br><span class="line">       <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建工作簿</span></span><br><span class="line">       Workbook workbook = <span class="keyword">new</span> XSSFWorkbook();</span><br><span class="line">       <span class="comment">//创建表</span></span><br><span class="line">       Sheet sheet = workbook.createSheet();</span><br><span class="line">       <span class="comment">//写入数据</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> rowNum = <span class="number">0</span>; rowNum &lt; <span class="number">65537</span>; rowNum++) &#123;</span><br><span class="line">           Row row = sheet.createRow(rowNum);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> cellNum = <span class="number">0</span>; cellNum &lt; <span class="number">10</span>; cellNum++) &#123;</span><br><span class="line">               Cell cell = row.createCell(cellNum);</span><br><span class="line">               cell.setCellValue(cellNum);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"over"</span>);</span><br><span class="line"></span><br><span class="line">       FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(PATH + <span class="string">"bigdata07.xlsx"</span>);</span><br><span class="line"></span><br><span class="line">       workbook.write(fileOutputStream);</span><br><span class="line"></span><br><span class="line">       fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">       System.out.println((<span class="keyword">double</span>) (end-begin)/<span class="number">1000</span>);<span class="comment">//14.386</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>大文件写SXSSF</p>
</blockquote>
<p>可以写入非常大的数据量，并且写入速度快，占用更少的内存</p>
<p>注意：</p>
<p>过程中会产生临时文件，需要清理临时文件</p>
<p>默认有100条记录被保存在内存中，如果超过了这个数量，则最前面的数据被写入临时文件</p>
<p>如果想自定义内存中的数据的数量，可以使用new SXSSFWorkbook(数量)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWrite07BigDataS</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">//时间</span></span><br><span class="line">       <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建工作簿</span></span><br><span class="line">       Workbook workbook = <span class="keyword">new</span> SXSSFWorkbook();</span><br><span class="line">       <span class="comment">//创建表</span></span><br><span class="line">       Sheet sheet = workbook.createSheet();</span><br><span class="line">       <span class="comment">//写入数据</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> rowNum = <span class="number">0</span>; rowNum &lt; <span class="number">65537</span>; rowNum++) &#123;</span><br><span class="line">           Row row = sheet.createRow(rowNum);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> cellNum = <span class="number">0</span>; cellNum &lt; <span class="number">10</span>; cellNum++) &#123;</span><br><span class="line">               Cell cell = row.createCell(cellNum);</span><br><span class="line">               cell.setCellValue(cellNum);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"over"</span>);</span><br><span class="line"></span><br><span class="line">       FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(PATH + <span class="string">"bigdata07s.xlsx"</span>);</span><br><span class="line"></span><br><span class="line">       workbook.write(fileOutputStream);</span><br><span class="line"></span><br><span class="line">       fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//清除临时文件</span></span><br><span class="line">       ((SXSSFWorkbook)workbook).dispose();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">       System.out.println((<span class="keyword">double</span>) (end-begin)/<span class="number">1000</span>);<span class="comment">//2.47</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h1 id="POI-Excel读"><a href="#POI-Excel读" class="headerlink" title="POI-Excel读"></a>POI-Excel读</h1><blockquote>
<p>03|07</p>
</blockquote>
<p>03版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelReadTest</span> </span>&#123;</span><br><span class="line">    String  PATH = <span class="string">"F:\\ideaProjects\\kuangshen\\"</span>;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRead03</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取文件流</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(PATH + <span class="string">"poi-easyexcelbigdata03.xls"</span>);</span><br><span class="line"></span><br><span class="line">        Workbook workbook = <span class="keyword">new</span> HSSFWorkbook(fileInputStream);</span><br><span class="line"></span><br><span class="line">        Sheet sheet = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Row row = sheet.getRow(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Cell cell = row.getCell(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(cell.getNumericCellValue());</span><br><span class="line"></span><br><span class="line">        fileInputStream.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>07版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRead07</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取文件流</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(PATH + <span class="string">"poi-easyexcelbigdata07.xlsx"</span>);</span><br><span class="line"></span><br><span class="line">        Workbook workbook = <span class="keyword">new</span> XSSFWorkbook(fileInputStream);</span><br><span class="line"></span><br><span class="line">        Sheet sheet = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Row row = sheet.getRow(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Cell cell = row.getCell(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(cell.getNumericCellValue());</span><br><span class="line"></span><br><span class="line">        fileInputStream.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意获取值的类型即可</strong></p>
<blockquote>
<p>读取不同的数据类型（最麻烦的就是这里了）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCellType</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">//获取文件流</span></span><br><span class="line">       FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(PATH + <span class="string">"user.xlsx"</span>);</span><br><span class="line"></span><br><span class="line">       Workbook workbook = <span class="keyword">new</span> XSSFWorkbook(fileInputStream);</span><br><span class="line"></span><br><span class="line">       Sheet sheet = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取标题内容</span></span><br><span class="line">       Row rowTitle = sheet.getRow(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(rowTitle != <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">int</span> cellCount = rowTitle.getPhysicalNumberOfCells();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> cellNum = <span class="number">0</span>; cellNum &lt; cellCount; cellNum++) &#123;</span><br><span class="line">               Cell cell = rowTitle.getCell(cellNum);</span><br><span class="line">               <span class="keyword">if</span>(cell != <span class="keyword">null</span>)&#123;</span><br><span class="line">                   <span class="keyword">int</span> cellType = cell.getCellType();</span><br><span class="line">                   String cellValue = cell.getStringCellValue();</span><br><span class="line">                   System.out.print(cellValue + <span class="string">"|"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       System.out.println();</span><br><span class="line">       <span class="comment">//获取表中的内容</span></span><br><span class="line">       <span class="keyword">int</span> rowCount = sheet.getPhysicalNumberOfRows();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> rowNum = <span class="number">1</span>; rowNum &lt; rowCount; rowNum++) &#123;</span><br><span class="line">           Row row = sheet.getRow(rowNum);</span><br><span class="line">           <span class="keyword">if</span>(row != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//读取列</span></span><br><span class="line">               <span class="keyword">int</span> cellCount = rowTitle.getPhysicalNumberOfCells();</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> cellNum = <span class="number">0</span>; cellNum &lt; cellCount; cellNum++) &#123;</span><br><span class="line">                   <span class="comment">//匹配列的数据类型</span></span><br><span class="line">                   Cell cell = row.getCell(cellNum);</span><br><span class="line">                   <span class="keyword">if</span>(cell != <span class="keyword">null</span>)&#123;</span><br><span class="line">                       <span class="keyword">int</span> cellType = cell.getCellType();</span><br><span class="line">                       String cellValue = <span class="string">""</span>;</span><br><span class="line">                       <span class="keyword">switch</span> (cellType)&#123;</span><br><span class="line">                           <span class="keyword">case</span> XSSFCell.CELL_TYPE_STRING: <span class="comment">//字符串</span></span><br><span class="line">                               cellValue = String.valueOf(cell.getStringCellValue());</span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                           <span class="keyword">case</span> XSSFCell.CELL_TYPE_BOOLEAN: <span class="comment">//布尔</span></span><br><span class="line">                               cellValue = String.valueOf(cell.getBooleanCellValue());</span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                           <span class="keyword">case</span> XSSFCell.CELL_TYPE_BLANK: <span class="comment">//空</span></span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                           <span class="keyword">case</span> XSSFCell.CELL_TYPE_NUMERIC: <span class="comment">//数字</span></span><br><span class="line">                               <span class="keyword">if</span>(HSSFDateUtil.isCellDateFormatted(cell))&#123;</span><br><span class="line">                                   <span class="comment">//日期</span></span><br><span class="line">                                   Date date = cell.getDateCellValue();</span><br><span class="line">                                   cellValue = <span class="keyword">new</span> DateTime(date).toString(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">                               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                                   <span class="comment">//如果不是日期格式，防止数字过长!</span></span><br><span class="line">                                   <span class="comment">//转化为字符串输出</span></span><br><span class="line">                                   cell.setCellType(XSSFCell.CELL_TYPE_STRING);</span><br><span class="line">                                   cellValue = cell.toString();</span><br><span class="line">                               &#125;</span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                           <span class="keyword">case</span> XSSFCell.CELL_TYPE_ERROR: <span class="comment">//error</span></span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       System.out.print(cellValue + <span class="string">"|"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">       &#125;</span><br><span class="line">       fileInputStream.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">昵称|手机号|密码|角色|</span><br><span class="line">甄子丹|15077777777|123456|普通用户|</span><br><span class="line">胡歌|18277777777|123456|管理员|</span><br><span class="line">谢霆锋|13177777777|123456|管理员|</span><br></pre></td></tr></table></figure>





<blockquote>
<p>计算公式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testFormula</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取文件流</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(PATH + <span class="string">"公式.xlsx"</span>);</span><br><span class="line"></span><br><span class="line">        Workbook workbook = <span class="keyword">new</span> XSSFWorkbook(fileInputStream);</span><br><span class="line"></span><br><span class="line">        Sheet sheet = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Row row = sheet.getRow(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        Cell cell = row.getCell(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到计算公式</span></span><br><span class="line">        FormulaEvaluator formulaEvaluator = <span class="keyword">new</span> XSSFFormulaEvaluator((XSSFWorkbook) workbook);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出单元格内容</span></span><br><span class="line">        <span class="keyword">int</span> cellType = cell.getCellType();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cellType)&#123;</span><br><span class="line">            <span class="keyword">case</span> Cell.CELL_TYPE_FORMULA: <span class="comment">//公式</span></span><br><span class="line">                String formula = cell.getCellFormula();</span><br><span class="line">                System.out.println(formula);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//计算</span></span><br><span class="line">                CellValue evaluate = formulaEvaluator.evaluate(cell);</span><br><span class="line"></span><br><span class="line">                String cellValue = evaluate.formatAsString();</span><br><span class="line"></span><br><span class="line">                System.out.println(cellValue);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h1 id="EasyExcel"><a href="#EasyExcel" class="headerlink" title="EasyExcel"></a>EasyExcel</h1><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0-beta2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>读</p>
</blockquote>
<p>定义样例类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoData</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置excel表头名称</span></span><br><span class="line">    <span class="meta">@ExcelProperty</span>(value = <span class="string">"学生编号"</span>,index = <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer sno;</span><br><span class="line">    <span class="meta">@ExcelProperty</span>(value = <span class="string">"学生姓名"</span>,index = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">private</span> String sname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelListener</span> <span class="keyword">extends</span> <span class="title">AnalysisEventListener</span>&lt;<span class="title">DemoData</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//一行一行读取excel内容</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(DemoData data, AnalysisContext analysisContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"****"</span>+data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取表头内容</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeHeadMap</span><span class="params">(Map&lt;Integer, String&gt; headMap, AnalysisContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"表头："</span>+headMap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取完成之后</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterAllAnalysed</span><span class="params">(AnalysisContext analysisContext)</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEasyExcel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现excel读操作</span></span><br><span class="line">        String filename = <span class="string">"F:\\write.xlsx"</span>;</span><br><span class="line">        EasyExcel.read(filename,DemoData<span class="class">.<span class="keyword">class</span>,<span class="title">new</span> <span class="title">ExcelListener</span>()).<span class="title">sheet</span>().<span class="title">doRead</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>写</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEasyExcel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//实现excel写的操作</span></span><br><span class="line">        <span class="comment">//1 设置写入文件夹地址和excel文件名称</span></span><br><span class="line">        String filename = <span class="string">"F:\\write.xlsx"</span>;</span><br><span class="line">        <span class="comment">//2 调用easyexcel里面的方法实现写操作</span></span><br><span class="line">        <span class="comment">//write方法两个参数：第一个参数文件路径名称，第二个参数实体类class</span></span><br><span class="line">        EasyExcel.write(filename,DemoData.class).sheet("学生列表").doWrite(getData());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建方法返回list集合</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;DemoData&gt; <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;DemoData&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            DemoData data = <span class="keyword">new</span> DemoData();</span><br><span class="line">            data.setSno(i);</span><br><span class="line">            data.setSname(<span class="string">"lucy"</span>+i);</span><br><span class="line">            list.add(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>EasyExcel</tag>
      </tags>
  </entry>
  <entry>
    <title>1.JavaWeb.md</title>
    <url>/2021/11/11/kuangshen/java/javaweb/1.JavaWeb/</url>
    <content><![CDATA[<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><h3 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h3><p>web开发：</p>
<ul>
<li><p>web 网页的意思</p>
</li>
<li><p>静态web</p>
<ul>
<li>html ,css</li>
<li>提供个所有人看的数据始终不会发生变化</li>
</ul>
</li>
<li><p>动态web</p>
<ul>
<li>提供个所有人看的数据会发生变化；每个人在不同的时间地点看到的信息各不相同</li>
<li>技术栈：Servlet/JSP ,ASP,PHP</li>
</ul>
<p>在Java中，动态Web资源开发的技术统称为JavaWeb</p>
</li>
</ul>
<h3 id="1-2-web应用程序"><a href="#1-2-web应用程序" class="headerlink" title="1.2 web应用程序"></a>1.2 web应用程序</h3><p>web应用程序就是指的是可以提供浏览器访问的程序</p>
<h3 id="1-3-静态web"><a href="#1-3-静态web" class="headerlink" title="1.3 静态web"></a>1.3 静态web</h3><ul>
<li>.html,*.html这些都是网页的后缀，如果服务器上一直存在这些东西，我们就可以直接通过网络进行读取</li>
</ul>
<p>静态web存在的缺点：</p>
<ul>
<li>web页面无法动态更新，所有用户看到的都是一个页面</li>
<li>无法和数据库交互，数据无法持久化</li>
</ul>
<h3 id="1-4-动态web"><a href="#1-4-动态web" class="headerlink" title="1.4 动态web"></a>1.4 动态web</h3><p>页面会动态展示：web页面的展示效果因人而异</p>
<h2 id="2-web服务器"><a href="#2-web服务器" class="headerlink" title="2.web服务器"></a>2.web服务器</h2><h3 id="2-1-技术讲解"><a href="#2-1-技术讲解" class="headerlink" title="2.1 技术讲解"></a>2.1 技术讲解</h3><p>ASP</p>
<ul>
<li>微软发明的，是国内最早流行的</li>
<li>在HTML中嵌入了VB的脚本  ASP+COM</li>
</ul>
<p>Php</p>
<ul>
<li>PHP开发速度很快，功能强大，跨平台，代码简单</li>
<li>无法承载大访问量的情况(局限性)</li>
</ul>
<p>JSP/Servlet:</p>
<ul>
<li>sun公司主推的B/S架构</li>
<li>基于java语言（所有的大公司，或者一些开源的组件，都是用java写的）</li>
<li>可以承载三高问题带来的影响</li>
<li>语法像ASP</li>
</ul>
<h3 id="2-2-web服务器"><a href="#2-2-web服务器" class="headerlink" title="2.2 web服务器"></a>2.2 web服务器</h3><p>服务器是一种被动的操作，用来处理用户的请求，返回响应</p>
<p>IIS</p>
<h2 id="3-Tomcat"><a href="#3-Tomcat" class="headerlink" title="3.Tomcat"></a>3.Tomcat</h2><h3 id="3-1-安装Tomcat"><a href="#3-1-安装Tomcat" class="headerlink" title="3.1 安装Tomcat"></a>3.1 安装Tomcat</h3><p>官网：tomcat.apache.org</p>
<blockquote>
<p>tomcat 目录</p>
</blockquote>
<ul>
<li><p>bin</p>
<p>启动，关闭脚本目录</p>
</li>
<li><p>conf</p>
<p>配置目录</p>
</li>
<li><p>lib</p>
<p>存放依赖jar包目录</p>
</li>
<li><p>logs</p>
<p>日志目录</p>
</li>
<li><p>webapps</p>
<p>存放网站目录</p>
</li>
<li><p>work</p>
</li>
</ul>
<h3 id="3-2-启动，关闭Tomcat"><a href="#3-2-启动，关闭Tomcat" class="headerlink" title="3.2 启动，关闭Tomcat"></a>3.2 启动，关闭Tomcat</h3><p>启动:startup.bat</p>
<p>关闭:shutdown.bat</p>
<blockquote>
<p>访问测试</p>
</blockquote>
<p>localhost:8080</p>
<p>可能遇到的问题：</p>
<p>1.java环境变量没有配置</p>
<p>2.闪退问题：需要配置兼容性</p>
<p>3.乱码问题：需要配置文件</p>
<h3 id="3-3-配置"><a href="#3-3-配置" class="headerlink" title="3.3 配置"></a>3.3 配置</h3><p>核心配置文件</p>
<p>conf/server.xml</p>
<p>默认端口8080</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>默认主机名称:localhost-&gt;127.0.0.1</p>
<p>默认网站应用存放的位置为：webapps</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-发布web网站"><a href="#3-4-发布web网站" class="headerlink" title="3.4 发布web网站"></a>3.4 发布web网站</h3><ul>
<li>将自己写的网站，放到Tomcat服务器指定的web文件夹下(webapps)就可以访问了</li>
</ul>
<p>网站结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--webapps</span><br><span class="line">  -ROOT</span><br><span class="line">  -kuangstudy:网站的目录名</span><br><span class="line">    -WEB-INF</span><br><span class="line">      -classes:java程序</span><br><span class="line">      -lib:web程序所依赖的jar包</span><br><span class="line">      -web.xml 网站配置文件</span><br><span class="line">    -index.html 默认的首页</span><br><span class="line">    -static</span><br><span class="line">      -css</span><br><span class="line">      -js</span><br><span class="line">      -img</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>





<h3 id="高难度面试题"><a href="#高难度面试题" class="headerlink" title="高难度面试题"></a>高难度面试题</h3><p>请你谈谈网站是如何访问的？</p>
<ol>
<li><p>输入域名，回车</p>
</li>
<li><p>检查本机的C:\Windows\System32\drivers\etc\hosts配置文件下有没有这个映射</p>
<ol>
<li><p>有：直接返回对应的ip地址，这个地址中有我们需要访问的程序，可以直接访问</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">192.168.42.100 hadoop100</span><br></pre></td></tr></table></figure>
</li>
<li><p>没有：去DNS服务器找，找到的话就返回，找不到就返回找不到</p>
</li>
</ol>
</li>
</ol>
<p><img src="https://i.loli.net/2021/11/13/O3mcyRrCQB1aP5h.png" alt=""></p>
<h2 id="4-Http"><a href="#4-Http" class="headerlink" title="4.Http"></a>4.Http</h2><h2 id="5-Maven"><a href="#5-Maven" class="headerlink" title="5.Maven"></a>5.Maven</h2><blockquote>
<p>为什么要学maven</p>
</blockquote>
<p>1.在javaweb开发中，需要使用大量的jar包，需要手动导入</p>
<p>2.如何能够让一个东西自动导入这个配置和这个包</p>
<p>由此，maven诞生了</p>
<h3 id="5-1-Maven项目架构管理工具"><a href="#5-1-Maven项目架构管理工具" class="headerlink" title="5.1 Maven项目架构管理工具"></a>5.1 Maven项目架构管理工具</h3><p>Maven的核心思想：<strong>约定大于配置</strong></p>
<ul>
<li>有约束，不要去违反</li>
</ul>
<p>maven会规定好如何去编写java代码，有特定的规范</p>
<h3 id="5-2-下载maven"><a href="#5-2-下载maven" class="headerlink" title="5.2 下载maven"></a>5.2 下载maven</h3><p>官网： <a href="https://maven.apache.org" target="_blank" rel="noopener">https://maven.apache.org</a></p>
<p>下载完成后解压即可</p>
<h3 id="5-3-配置环境变量"><a href="#5-3-配置环境变量" class="headerlink" title="5.3 配置环境变量"></a>5.3 配置环境变量</h3><p>在系统环境变量中</p>
<p>配置如下配置：</p>
<p>M2_HOME: D:\apache-maven-3.6.3\bin</p>
<p>MAVEN_HOME：D:\apache-maven-3.6.3\</p>
<p>在path中添加 %MAVEN_HOME%\bin</p>
<p>在cmd中通过mvn -version测试是否安装成功</p>
<h3 id="5-4-阿里云镜像"><a href="#5-4-阿里云镜像" class="headerlink" title="5.4 阿里云镜像"></a>5.4 阿里云镜像</h3><ul>
<li>镜像 mirrors<ul>
<li>作用：加速我们的下载</li>
</ul>
</li>
<li>国内建议使用阿里云的镜像</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="5-5-本地仓库"><a href="#5-5-本地仓库" class="headerlink" title="5.5 本地仓库"></a>5.5 本地仓库</h3><p>建立一个本地仓库，在配置文件中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\localRepo_maven2<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-6-在idea中使用maven"><a href="#5-6-在idea中使用maven" class="headerlink" title="5.6 在idea中使用maven"></a>5.6 在idea中使用maven</h3><ol>
<li>创建maven项目</li>
<li>配置groupId(一般是公司名)和artifactId(一般的项目名)</li>
</ol>
<p>在idea中配置maven的安装目录和本地仓库的目录</p>
<h2 id="6-Servlet"><a href="#6-Servlet" class="headerlink" title="6.Servlet"></a>6.Servlet</h2><h3 id="6-1-Servlet简介"><a href="#6-1-Servlet简介" class="headerlink" title="6.1 Servlet简介"></a>6.1 Servlet简介</h3><ul>
<li><p>Servlet是sun公司推出的用来开发动态web的一门技术</p>
</li>
<li><p>Sun在这些API中提供一个接口叫做:Servlet，如果想开发一个Servlet程序，只需要完成两个小步骤</p>
<ul>
<li>编写一个类实现Servlet接口</li>
<li>把开发好的java类部署到web服务器中</li>
</ul>
</li>
</ul>
<p>  <strong>把实现了Servlet接口的程序叫做servlet</strong></p>
<h3 id="6-2-HelloServlet"><a href="#6-2-HelloServlet" class="headerlink" title="6.2 HelloServlet"></a>6.2 HelloServlet</h3><p>Servlet接口有两个默认的实现类：HttpServlet GenericServlet</p>
<p>maven环境优化</p>
<p>将web.xml替换为最新的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">metadata-complete</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>构建完成的maven结构:java resource</p>
<p>编写Servlet程序</p>
<ol>
<li>编写一个普通类</li>
<li>直接继承httpServlet或实现Servlet接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line">        writer.println(<span class="string">"hello servlet"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编写Servlet映射</p>
<p>为什么需要映射：我们写的是JAVA程序，但是要通过浏览器访问，而浏览器需要连接Web服务器，所以我们需要在Web服务器中注册我们写的Servlet，还需要给他一个浏览器访问的路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--注册Servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.kuangshen.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Servlet的请求路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置tomcat</p>
<p>注意：配置项目发布的路径即可</p>
<p>启动测试</p>
<p><img src="https://s2.loli.net/2021/12/07/QJYAMEevVab5uwR.png" alt="image-20211207142352999"></p>
<h3 id="6-3-Servlet原理"><a href="#6-3-Servlet原理" class="headerlink" title="6.3 Servlet原理"></a>6.3 Servlet原理</h3><p>Servlet是由web服务器调用，web服务器在收到浏览器请求后</p>
<p><img src="https://s2.loli.net/2021/12/07/eY8NJjlFO63bfqx.png" alt="Servlet原理"></p>
<h3 id="6-4-Mapping问题"><a href="#6-4-Mapping问题" class="headerlink" title="6.4 Mapping问题"></a>6.4 Mapping问题</h3><p>1）一个Servlet可以指定一个映射路径</p>
<p>2）一个Servlet可以指定多个映射路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hell2<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hell3<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>3）一个Servlet可以指定通配映射路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4）默认请求路径</p>
<p>不建议用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>5）指定一些后缀或前缀等等</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--自定义后缀实现请求映射</span></span><br><span class="line"><span class="comment">注意点:*前面不能加映射的路径</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.zhang<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>6）优先级</p>
<p>​    指定了固有的映射路径，优先级最高，如果找不到就会找默认的处理请求</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--404--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>error<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.kuangshen.servlet.ErrorServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>error<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="6-5-ServletContext"><a href="#6-5-ServletContext" class="headerlink" title="6.5 ServletContext"></a>6.5 ServletContext</h3><p>web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext，代表了当前的web应用</p>
<h4 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h4><p>在一个Servlet中保存的数据，可以在另外一个Servlet中拿到</p>
<p>往servletContext中放入数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">      <span class="comment">//this.getInitParameter();</span></span><br><span class="line">      <span class="comment">// this.getServletConfig();</span></span><br><span class="line">       <span class="comment">// this.getServletContext();</span></span><br><span class="line">       ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">       String username = <span class="string">"张三"</span>;</span><br><span class="line">       servletContext.setAttribute(<span class="string">"username"</span>,username);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>往Servlet中取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">       ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line"></span><br><span class="line">       String username = (String) context.getAttribute(<span class="string">"username"</span>);</span><br><span class="line"></span><br><span class="line">       resp.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line">       resp.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">       resp.getWriter().print(username);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>配置mapping映射</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.kuang.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>getc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.kuang.servlet.GetServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>getc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/getc<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<p><img src="https://s2.loli.net/2021/12/07/EvabSry4Mn9A7Qx.png" alt="image-20211207163139024"></p>
<h4 id="获取初始化参数"><a href="#获取初始化参数" class="headerlink" title="获取初始化参数"></a>获取初始化参数</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置一些web应用初始化参数--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>url<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>jdbc:mysql://localhost:3306/mybatis<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line"></span><br><span class="line">        String url = context.getInitParameter(<span class="string">"url"</span>);</span><br><span class="line">        resp.getWriter().print(<span class="string">"url: "</span> + url);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"进入ServletDemo04"</span>);</span><br><span class="line"></span><br><span class="line">       ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//  /gp表示转发的请求路径</span></span><br><span class="line">       RequestDispatcher requestDispatcher = context.getRequestDispatcher(<span class="string">"/gp"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//实现请求转发</span></span><br><span class="line">       requestDispatcher.forward(req,resp);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="读取资源文件"><a href="#读取资源文件" class="headerlink" title="读取资源文件"></a>读取资源文件</h4><p>Properties</p>
<ul>
<li>在java目录下新建properties</li>
<li>在resource目录下新建到properties</li>
</ul>
<p>发现：都被打包到同一个路径下:classes,即classpath下</p>
<p>db.properties</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">username=root</span><br><span class="line">password=<span class="number">123456</span></span><br></pre></td></tr></table></figure>



<p>思路：需要一个文件流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">       ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">       InputStream is = context.getResourceAsStream(<span class="string">"/WEB-INF/classes/db.properties"</span>);</span><br><span class="line">       Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">       properties.load(is);</span><br><span class="line"></span><br><span class="line">       String username = properties.getProperty(<span class="string">"username"</span>);</span><br><span class="line">       String password = properties.getProperty(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">       resp.getWriter().print(<span class="string">"username : "</span> + username + <span class="string">",password"</span> + password);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<p><img src="https://s2.loli.net/2021/12/07/CclZ4v3xsgRI2Bo.png" alt="image-20211207170947820"></p>
<h3 id="6-6-HttpServletRequest"><a href="#6-6-HttpServletRequest" class="headerlink" title="6.6 HttpServletRequest"></a>6.6 HttpServletRequest</h3><p>web服务器接收到客户端的http请求，http请求的所有信息都封装在HttpServletRequest中。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ol>
<li>获取请求参数</li>
<li>请求转发</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        req.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">        String username = req.getParameter(<span class="string">"username"</span>);</span><br><span class="line">        String password = req.getParameter(<span class="string">"password"</span>);</span><br><span class="line">        String[] hobbies = req.getParameterValues(<span class="string">"hobbies"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后台接收中文乱码问题</span></span><br><span class="line">        System.out.println(username);</span><br><span class="line">        System.out.println(password);</span><br><span class="line">        System.out.println(Arrays.toString(hobbies));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过请求转发 /表示当前应用</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">"/succ.jsp"</span>).forward(req,resp);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h3 id="6-7-HttpServletResponse"><a href="#6-7-HttpServletResponse" class="headerlink" title="6.7 HttpServletResponse"></a>6.7 HttpServletResponse</h3><p>web服务器接收到客户端的http请求，针对这个请求，分别创建代表这个请求的request对象，代表相应的response对象。</p>
<p>如果要获取客户端请求过来的参数，找HttpServletRequest</p>
<p>如果要给客户端相应一些信息，找HttpServletResponse</p>
<h4 id="简单分类"><a href="#简单分类" class="headerlink" title="简单分类"></a>简单分类</h4><h5 id="负责向浏览器发送数据的方法"><a href="#负责向浏览器发送数据的方法" class="headerlink" title="负责向浏览器发送数据的方法"></a>负责向浏览器发送数据的方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ServletOutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"> <span class="function">PrintWriter <span class="title">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<h5 id="负责向浏览器发送响应头的方法"><a href="#负责向浏览器发送响应头的方法" class="headerlink" title="负责向浏览器发送响应头的方法"></a>负责向浏览器发送响应头的方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCharacterEncoding</span><span class="params">(String var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setContentLength</span><span class="params">(<span class="keyword">int</span> var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setContentLengthLong</span><span class="params">(<span class="keyword">long</span> var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setContentType</span><span class="params">(String var1)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setHeader</span><span class="params">(String var1, String var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addHeader</span><span class="params">(String var1, String var2)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="相应的状态码"><a href="#相应的状态码" class="headerlink" title="相应的状态码"></a>相应的状态码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> SC_CONTINUE = <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_SWITCHING_PROTOCOLS = <span class="number">101</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_OK = <span class="number">200</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_CREATED = <span class="number">201</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_ACCEPTED = <span class="number">202</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_NON_AUTHORITATIVE_INFORMATION = <span class="number">203</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_NO_CONTENT = <span class="number">204</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_RESET_CONTENT = <span class="number">205</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_PARTIAL_CONTENT = <span class="number">206</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_MULTIPLE_CHOICES = <span class="number">300</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_MOVED_PERMANENTLY = <span class="number">301</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_MOVED_TEMPORARILY = <span class="number">302</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_FOUND = <span class="number">302</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_SEE_OTHER = <span class="number">303</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_NOT_MODIFIED = <span class="number">304</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_USE_PROXY = <span class="number">305</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_TEMPORARY_REDIRECT = <span class="number">307</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_BAD_REQUEST = <span class="number">400</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_UNAUTHORIZED = <span class="number">401</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_PAYMENT_REQUIRED = <span class="number">402</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_FORBIDDEN = <span class="number">403</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_NOT_FOUND = <span class="number">404</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_METHOD_NOT_ALLOWED = <span class="number">405</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_NOT_ACCEPTABLE = <span class="number">406</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_PROXY_AUTHENTICATION_REQUIRED = <span class="number">407</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_REQUEST_TIMEOUT = <span class="number">408</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_CONFLICT = <span class="number">409</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_GONE = <span class="number">410</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_LENGTH_REQUIRED = <span class="number">411</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_PRECONDITION_FAILED = <span class="number">412</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_REQUEST_ENTITY_TOO_LARGE = <span class="number">413</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_REQUEST_URI_TOO_LONG = <span class="number">414</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_UNSUPPORTED_MEDIA_TYPE = <span class="number">415</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_REQUESTED_RANGE_NOT_SATISFIABLE = <span class="number">416</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_EXPECTATION_FAILED = <span class="number">417</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_INTERNAL_SERVER_ERROR = <span class="number">500</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_NOT_IMPLEMENTED = <span class="number">501</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_BAD_GATEWAY = <span class="number">502</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_SERVICE_UNAVAILABLE = <span class="number">503</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_GATEWAY_TIMEOUT = <span class="number">504</span>;</span><br><span class="line">   <span class="keyword">int</span> SC_HTTP_VERSION_NOT_SUPPORTED = <span class="number">505</span>;</span><br></pre></td></tr></table></figure>

<h4 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h4><ol>
<li><p>向浏览器输出消息</p>
</li>
<li><p>下载文件</p>
<ol>
<li><p>获取下载文件路径</p>
</li>
<li><p>下载文件名是啥</p>
</li>
<li><p>设置想办法让浏览器能够支持下载我们需要的东西</p>
</li>
<li><p>获取下载文件的输入流</p>
</li>
<li><p>创建缓冲区</p>
</li>
<li><p>获取outputStream对象</p>
</li>
<li><p>将FileOutputStream流写入到缓冲区</p>
</li>
<li><p>使用outputStream将缓冲区中的数据输出到客户端</p>
</li>
</ol>
</li>
</ol>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletOutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> FileServlet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> TYS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/7 17:27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//        1. 获取下载文件路径</span></span><br><span class="line">        String realPath = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">"/WEB-INF/classes/idea.png"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"下载的文件路径"</span> + realPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2. 下载文件名是啥</span></span><br><span class="line">        String fileName = realPath.substring(realPath.lastIndexOf(<span class="string">"\\"</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        3. 设置想办法让浏览器能够支持下载我们需要的东西</span></span><br><span class="line">        resp.setHeader(<span class="string">"Content-disposition"</span>,<span class="string">"attachment;filename"</span>+ URLEncoder.encode(fileName,<span class="string">"UTF-8"</span>));</span><br><span class="line"><span class="comment">//        4. 获取下载文件的输入流</span></span><br><span class="line"></span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(realPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 创建缓冲区</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//        6. 获取outputStream对象</span></span><br><span class="line"><span class="comment">//        7. 将FileOutputStream流写入到缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        8. 使用outputStream将缓冲区中的数据输出到客户端</span></span><br><span class="line">        ServletOutputStream outputStream = resp.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((len = in.read(buffer)) &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            outputStream.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        in.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><p>验证码功能</p>
<ul>
<li>前端实现</li>
<li>后端实现，需要用到java的图片类，生成一张图片</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> ImageServlet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> TYS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/9 17:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//如何让浏览器3秒刷新一下</span></span><br><span class="line">        resp.setHeader(<span class="string">"refresh"</span>,<span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在内存中创建一个图片</span></span><br><span class="line">        BufferedImage image = <span class="keyword">new</span> BufferedImage(<span class="number">100</span>, <span class="number">20</span>, BufferedImage.TYPE_INT_RGB);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到图片</span></span><br><span class="line">        Graphics2D g = (Graphics2D)image.getGraphics();<span class="comment">//拿到勾勒图片的笔</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置图片的背景颜色</span></span><br><span class="line">        g.setColor(Color.white);</span><br><span class="line">        g.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给图片写数据</span></span><br><span class="line">        g.setColor(Color.BLUE);</span><br><span class="line">        g.setFont(<span class="keyword">new</span> Font(<span class="keyword">null</span>,Font.BOLD,<span class="number">20</span>));</span><br><span class="line">        g.drawString(makeNum(),<span class="number">0</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//告诉浏览器当前请求用图片的方式打开</span></span><br><span class="line">        resp.setContentType(<span class="string">"image/png"</span>);</span><br><span class="line">        <span class="comment">//网站存在缓存，不让浏览器缓存</span></span><br><span class="line">        resp.setHeader(<span class="string">"expires"</span>,<span class="string">"-1"</span>);</span><br><span class="line">        resp.setHeader(<span class="string">"Cache-Control"</span>,<span class="string">"no-cache"</span>);</span><br><span class="line">        resp.setHeader(<span class="string">"Pragma"</span>,<span class="string">"no-cache"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把图片写给浏览器</span></span><br><span class="line">        ImageIO.write(image,<span class="string">"png"</span>,resp.getOutputStream());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成7位数的随机数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">makeNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        String num = random.nextInt(<span class="number">99999999</span>) + <span class="string">""</span>;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span> - num.length(); i++) &#123;</span><br><span class="line">            sb.append(<span class="string">"0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        num = sb.toString() + num;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







</li>
</ol>
<ol start="4">
<li><p>实现重定向</p>
<p>一个web资源受到客户端请求，通知客户端去访问另外一个web资源，这个过程称之为重定向</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">       resp.sendRedirect(<span class="string">"/r/image"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>面试题：重定向和请求转发的区别</p>
<p>相同点：页面都会跳转</p>
<p>不同点：请求转发(307)的时候，url不会发生变化；重定向(302)的时候，url会发生变化</p>
<h2 id="7-Cookie-Session"><a href="#7-Cookie-Session" class="headerlink" title="7.Cookie,Session"></a>7.Cookie,Session</h2><h3 id="7-1-会话"><a href="#7-1-会话" class="headerlink" title="7.1 会话"></a>7.1 会话</h3><p><strong>会话</strong>：用户打开了浏览器，访问web资源，关闭浏览器，这个过程可以称之为会话。</p>
<p><strong>有状态会话</strong>：一个同学来过教师，下次再来教室，我们可以知道这个同学曾经来过，称之为有状态会话。</p>
<p><strong>你如何证明你是xx大学的学生</strong></p>
<p>1.报名发票     大学给你的发票</p>
<p>2.学习登记     大学标记你来过了</p>
<p><strong>一个网站怎么证明你来过？</strong></p>
<p>客户端        服务端</p>
<p>1.服务端给客户端信件，客户端下次访问服务端带上信件就可以;cookie</p>
<p>2.服务器登记你来过了，下次你来的时候我莱匹配你</p>
<h3 id="7-2-保存会话的两种技术"><a href="#7-2-保存会话的两种技术" class="headerlink" title="7.2 保存会话的两种技术"></a>7.2 保存会话的两种技术</h3><p><strong>cookie</strong></p>
<ul>
<li>客户端技术</li>
</ul>
<p><strong>session</strong></p>
<ul>
<li>服务器技术，利用这个技术可以保存用户的会话信息，可以把信息和数据放在session中</li>
</ul>
<p>常见场景：网站登录之后，下次就不用登录了，直接就可以访问</p>
<h3 id="7-3-Cookie"><a href="#7-3-Cookie" class="headerlink" title="7.3 Cookie"></a>7.3 Cookie</h3><ol>
<li>从请求中拿到cookie信息</li>
<li>服务器给客户端响应cookie</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/20/WXsSmMDBdAiaEgJ.png" alt="image-20211220173821004"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//服务器获取客户端上一次访问的时间</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Cookie,服务器端从客户端获取</span></span><br><span class="line">        Cookie[] cookies = req.getCookies();<span class="comment">//cookie可能存在多个</span></span><br><span class="line">        <span class="comment">//判断cookie是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果存在</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cookies.length; i++) &#123;</span><br><span class="line">                Cookie cookie = cookies[i];</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">"lastLoginTime"</span>.equals(cookie.getName()))&#123;</span><br><span class="line">                    <span class="keyword">long</span> lastLoginTime = Long.parseLong(cookie.getValue());</span><br><span class="line">                    Date date = <span class="keyword">new</span> Date(lastLoginTime);</span><br><span class="line">                    out.write(date.toLocaleString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            out.write(<span class="string">"this is your first visit"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"lastLoginTime"</span>, System.currentTimeMillis() + <span class="string">""</span>);</span><br><span class="line">        <span class="comment">//设置cookie有效期为一天</span></span><br><span class="line">        cookie.setMaxAge(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">        <span class="comment">//服务器给客户端响应一个cookie，更新最新访问时间</span></span><br><span class="line">        resp.addCookie(cookie);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<p>一个网站的cookie是否存在上限!细节问题</p>
<ul>
<li>一个cookie只能保存一个信息(只有一个键，一个值)</li>
<li>一个web站点可以给浏览器发送多个cookie，最多存放20个</li>
<li>浏览器的cookie上限为300个</li>
<li>cookie大小有限制4kb</li>
</ul>
<p>删除cookie：</p>
<ul>
<li>不设置有效期(关闭浏览器，自动失效)</li>
<li>设置有效时间为0</li>
</ul>
<p>编码解码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URLEncoder.encode(<span class="string">"张"</span>,<span class="string">"utf-8"</span>)</span><br><span class="line">URLDecoder.decode(cookie.getValue(),<span class="string">"utf-8"</span>)</span><br></pre></td></tr></table></figure>



<h3 id="7-4-Session-重点"><a href="#7-4-Session-重点" class="headerlink" title="7.4 Session(重点)"></a>7.4 Session(重点)</h3><h4 id="什么是session"><a href="#什么是session" class="headerlink" title="什么是session"></a>什么是session</h4><ul>
<li>服务器会给每个用户创建一个session对象</li>
<li>一个session独占一个浏览器，只要浏览器没有关闭，这个session就存在</li>
<li>用户登录之后，整个网站它都可以访问（保存用户信息，保存购物车信息……）</li>
</ul>
<p>session和cookie的区别：</p>
<p>cookie是把用户的数据写给用户的浏览器，浏览器保存（可以保存多个）</p>
<p>session是把用户的数据写到独占的session中，服务器段保存(保存重要的信息，减少服务器资源的浪费)</p>
<p>session对象由服务器生产</p>
<p><img src="https://s2.loli.net/2021/12/20/ferYOuPdjZ2HlEg.png" alt="image-20211220174213404"></p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>保存一个登录用户的信息</li>
<li>购物车信息</li>
<li>在整个网站中，经常会使用的数据，我们将它保存在session中</li>
</ul>
<h4 id="使用session"><a href="#使用session" class="headerlink" title="使用session"></a>使用session</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionDemo1</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//解决乱码问题</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">        resp.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">        <span class="comment">//得到session</span></span><br><span class="line">        HttpSession session = req.getSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给session中存入数据</span></span><br><span class="line">        session.setAttribute(<span class="string">"name"</span>,<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="string">"18岁"</span>));</span><br><span class="line">        <span class="comment">//获取sessionID</span></span><br><span class="line">        String sessionId = session.getId();</span><br><span class="line">        <span class="comment">//判断session是不是新创建的</span></span><br><span class="line">        <span class="keyword">if</span>(session.isNew())&#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">"session创建成功，session id为："</span> + sessionId);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">"session已经存在了，session id为："</span> + sessionId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到session</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">       <span class="comment">//解决乱码问题</span></span><br><span class="line">       req.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">       resp.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">       resp.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">       <span class="comment">//得到session</span></span><br><span class="line">       HttpSession session = req.getSession();</span><br><span class="line"></span><br><span class="line">       Object name = session.getAttribute(<span class="string">"name"</span>);</span><br><span class="line">       System.out.println(name.toString());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="session过期"><a href="#session过期" class="headerlink" title="session过期"></a>session过期</h4><p>手动失效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">       HttpSession session = req.getSession();</span><br><span class="line">       session.removeAttribute(<span class="string">"name"</span>);</span><br><span class="line">       session.invalidate();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>配置自动失效时长</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置session默认失效时间--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--15min后session自动失效--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>15<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="8-JSP"><a href="#8-JSP" class="headerlink" title="8.JSP"></a>8.JSP</h2><h3 id="8-1-什么是JSP"><a href="#8-1-什么是JSP" class="headerlink" title="8.1 什么是JSP"></a>8.1 什么是JSP</h3><p>Java Serve  Pages：Java服务器页面技术，也和Servlet一样，属于动态web技术</p>
<p>最大的特点：</p>
<ul>
<li>写JSP就想写HTML</li>
<li>区别：<ul>
<li>HTML只给用户静态的数据</li>
<li>JSP页面中可以嵌入JAVA代码，为用户提供动态数据</li>
</ul>
</li>
</ul>
<h3 id="8-2-JSP原理"><a href="#8-2-JSP原理" class="headerlink" title="8.2 JSP原理"></a>8.2 JSP原理</h3><p>思路：jsp是如何执行的？</p>
<ul>
<li><p>服务器内部工作</p>
<p>Tomcat中有一个work目录，在idea中使用Tomcat的时候会在idea的Tomcat中生成一个work目录</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2021/12/30/TBo3muc4RFjIb5A.png" alt="image-20211230143744222"></p>
<p>发现页面变成了Java程序</p>
<p><img src="https://s2.loli.net/2021/12/30/Xpjt9EZ2wo4HkPs.png" alt="image-20211230144001583"></p>
<p><strong>浏览器向服务器发送请求，不管访问什么资源，都是在访问Servlet</strong></p>
<p>JSP最终也会转换为一个继承了HTTPServlet的java类，本质上也是一个Servlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//jsp服务</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(<span class="keyword">final</span> javax.servlet.http.HttpServletRequest request, <span class="keyword">final</span> javax.servlet.http.HttpServletResponse response)</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>_jspService方法分析</p>
</blockquote>
<p>1.判断请求</p>
<p>2.内置了一些对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> javax.servlet.jsp.PageContext pageContext;<span class="comment">//页面上下文</span></span><br><span class="line">javax.servlet.http.HttpSession session = <span class="keyword">null</span>;<span class="comment">//session</span></span><br><span class="line"><span class="keyword">final</span> javax.servlet.ServletContext application;</span><br><span class="line"><span class="keyword">final</span> javax.servlet.ServletConfig config;</span><br><span class="line">javax.servlet.jsp.JspWriter out = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">final</span> java.lang.Object page = <span class="keyword">this</span>;<span class="comment">//当前page</span></span><br></pre></td></tr></table></figure>

<p>3.输出页面前增加的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">pageContext = _jspxFactory.getPageContext(<span class="keyword">this</span>, request, response,</span><br><span class="line">                                          <span class="keyword">null</span>, <span class="keyword">true</span>, <span class="number">8192</span>, <span class="keyword">true</span>);</span><br><span class="line">_jspx_page_context = pageContext;</span><br><span class="line">application = pageContext.getServletContext();</span><br><span class="line">config = pageContext.getServletConfig();</span><br><span class="line">session = pageContext.getSession();</span><br><span class="line">out = pageContext.getOut();</span><br><span class="line">_jspx_out = out;</span><br></pre></td></tr></table></figure>

<p>总结：当客户端访问服务器端的jsp页面时，服务器的web容器会先找到对应的jsp页面然后转换编译生成对应的class文件，响应请求！</p>
<p>在JSP页面中，只要是java代码就会原封不动的输出；</p>
<p>如果是HTML代码，就会被转换为下面的格式输出到前端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">out.write(<span class="string">"\r\n"</span>);</span><br><span class="line">out.write(<span class="string">"&lt;html&gt;\r\n"</span>);</span><br></pre></td></tr></table></figure>





<h3 id="8-3-JSP基础语法"><a href="#8-3-JSP基础语法" class="headerlink" title="8.3 JSP基础语法"></a>8.3 JSP基础语法</h3><p>在jsp中java语法都支持，同时拥有一些自己扩充的语法(了解即可)</p>
<h4 id="jsp表达式"><a href="#jsp表达式" class="headerlink" title="jsp表达式"></a>jsp表达式</h4><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--jsp表达式</span><br><span class="line">    作用：用来作为程序的输出，输出到客户端</span><br><span class="line">    &lt;%=变量或者表达式%&gt;</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%= <span class="keyword">new</span> java.util.Date() %&gt;</span><br></pre></td></tr></table></figure>

<h4 id="jsp脚本片段"><a href="#jsp脚本片段" class="headerlink" title="jsp脚本片段"></a>jsp脚本片段</h4><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line">out.println(<span class="string">"&lt;h1&gt;sum="</span>+sum+<span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--在代码中嵌入HTML元素--%&gt;</span><br><span class="line">&lt;%</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    %&gt;</span><br><span class="line">&lt;h1&gt;hello world,&lt;%=i%&gt;&lt;/h1&gt;</span><br><span class="line">&lt;%</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<h4 id="JSP声明"><a href="#JSP声明" class="headerlink" title="JSP声明"></a>JSP声明</h4><p>代码默认都是在service方法中的，那如何定义service方法之前的代码呢</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">"loading servlet"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> globalVar = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">global</span><span class="params">()</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"this is global"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> %&gt;</span><br></pre></td></tr></table></figure>

<p>jsp声明：会被编译到jsp对应的类中！其它的会被编译到对应类的service方法中</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%=%&gt;</span><br><span class="line">&lt;%%&gt;</span><br><span class="line">&lt;%!%&gt;</span><br><span class="line">&lt;%--jsp注释，jsp注释不会在客户端显示，HTML的注释可以在客户端显示--%&gt;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-JSP指令"><a href="#8-4-JSP指令" class="headerlink" title="8.4 JSP指令"></a>8.4 JSP指令</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--定制错误页面--%&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> errorPage=<span class="string">"error/500.jsp"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%<span class="meta">@page</span> arg=<span class="string">"..."</span>%&gt;</span><br><span class="line">&lt;%<span class="meta">@include</span>%&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%--<span class="meta">@include</span>会将两个页面合二为一--%&gt;</span><br><span class="line">    &lt;%<span class="meta">@include</span> file=<span class="string">"common/header.jsp"</span>%&gt;</span><br><span class="line">    &lt;h1&gt;网页主体&lt;/h1&gt;</span><br><span class="line">    &lt;%<span class="meta">@include</span> file=<span class="string">"common/footer.jsp"</span>%&gt;</span><br><span class="line"></span><br><span class="line">    &lt;hr&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%--jsp 标签</span><br><span class="line">    jsp:include:会拼接页面，本质还是三个页面，一般用这个</span><br><span class="line">    --%&gt;</span><br><span class="line">    &lt;jsp:include page="/common/header.jsp"&gt;&lt;/jsp:include&gt;</span><br><span class="line">    &lt;h1&gt;网页主体&lt;/h1&gt;</span><br><span class="line">    &lt;jsp:include page="/common/footer.jsp"&gt;&lt;/jsp:include&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>



<h3 id="8-5-9大内置对象"><a href="#8-5-9大内置对象" class="headerlink" title="8.5 9大内置对象"></a>8.5 9大内置对象</h3><ul>
<li>PageContext</li>
<li>Request</li>
<li>Response</li>
<li>Session</li>
<li>Application[ServletContext]</li>
<li>config[ServletConfig]</li>
<li>out</li>
<li>page:一般不用</li>
<li>exception</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    pageContext.setAttribute(<span class="string">"name1"</span>,<span class="string">"value1"</span>);<span class="comment">//保存的值只在当前页面有效</span></span><br><span class="line">    request.setAttribute(<span class="string">"name2"</span>,<span class="string">"value2"</span>);<span class="comment">//保存的数据只在当前请求中有效</span></span><br><span class="line">    session.setAttribute(<span class="string">"name3"</span>,<span class="string">"value3"</span>);<span class="comment">//保存的数据在一次会话中有效（从打开浏览器到关闭浏览器）</span></span><br><span class="line">    application.setAttribute(<span class="string">"name4"</span>,<span class="string">"value4"</span>);<span class="comment">//保存的数据在整个服务打开到关闭都有效</span></span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--脚本片段中的代码会被原封不动的生成到xxxjsp.java文件中，所以这里面的代码必须保证java语法的正确性--%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">//通过寻找方式从pageContext中取值</span></span><br><span class="line">    <span class="comment">//从底层到高层中取值 page-&gt;request-&gt;session-&gt;application</span></span><br><span class="line">    String name1 = (String) pageContext.findAttribute(<span class="string">"name1"</span>);</span><br><span class="line">    String name2 = (String) pageContext.findAttribute(<span class="string">"name2"</span>);</span><br><span class="line">    String name3 = (String) pageContext.findAttribute(<span class="string">"name3"</span>);</span><br><span class="line">    String name4 = (String) pageContext.findAttribute(<span class="string">"name4"</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p>request: 客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻</p>
<p>session：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车</p>
<p>application：客户端向服务器发送请求，，产生的数据，一个用户用完了，其它用户还可能使用，比如聊天数据</p>
<h3 id="8-6-JSP标签，JSTL标签，EL表达式"><a href="#8-6-JSP标签，JSTL标签，EL表达式" class="headerlink" title="8.6 JSP标签，JSTL标签，EL表达式"></a>8.6 JSP标签，JSTL标签，EL表达式</h3><p>EL表达式：${}</p>
<ul>
<li>获取数据</li>
<li>执行运算</li>
<li>获取web开发的常用对象</li>
</ul>
<h4 id="jsp标签"><a href="#jsp标签" class="headerlink" title="jsp标签"></a>jsp标签</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;1&lt;/h1&gt;</span><br><span class="line">&lt;%--&lt;jsp:include page="jspTag2.jsp"&gt;&lt;/jsp:include&gt;--%&gt;</span><br><span class="line">&lt;jsp:forward page=<span class="string">"jspTag2.jsp"</span>&gt;</span><br><span class="line">    &lt;jsp:param name=<span class="string">"n1"</span> value=<span class="string">"v1"</span>/&gt;</span><br><span class="line">    &lt;jsp:param name=<span class="string">"n2"</span> value=<span class="string">"v2"</span>/&gt;</span><br><span class="line">&lt;/jsp:forward&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;jspTag2&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--取出参数--%&gt;</span><br><span class="line">n1:&lt;%=request.getParameter(<span class="string">"n1"</span>)%&gt;</span><br><span class="line">m2:&lt;%=request.getParameter(<span class="string">"n2"</span>)%&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<h4 id="JSTL表达式"><a href="#JSTL表达式" class="headerlink" title="JSTL表达式"></a>JSTL表达式</h4><p>JSTL标签库的使用就是为了弥补HTML标签的不足；它自定义了许多标签，可以供我们使用，标签的功能和java代码一样</p>
<h4 id="核心标签（掌握部分）"><a href="#核心标签（掌握部分）" class="headerlink" title="核心标签（掌握部分）"></a>核心标签（掌握部分）</h4><p><img src="https://s2.loli.net/2021/12/30/JqIc9r6nEemRsNK.png" alt="image-20211230181247675"></p>
<p>JSTL标签使用步骤</p>
<ul>
<li>引入对应的taglib</li>
<li>使用其中的方法</li>
<li>在Tomcat中也需要印日jstl的包，否则会报错：JSTL解析错误</li>
</ul>
<blockquote>
<p>if</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: DELL</span><br><span class="line">  Date: <span class="number">2021</span>/<span class="number">12</span>/<span class="number">30</span></span><br><span class="line">  Time: <span class="number">18</span>:<span class="number">09</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--引入JSTL标签库，才能使用JSTL标签--%&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;if测试&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">"coreif.jsp"</span>&gt;</span><br><span class="line">    &lt;%--el表达式获取表单中的数据</span><br><span class="line">    $&#123;param.参数名&#125;</span><br><span class="line">    --%&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span> value=<span class="string">"$&#123;param.username&#125;"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"login"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--如果提交的用户名是管理员，则登录成功--%&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;param.username=='admin'&#125;"</span> <span class="keyword">var</span>=<span class="string">"isAdmin"</span>&gt;</span><br><span class="line">    &lt;c:out value="welcome admin"&gt;&lt;/c:out&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:out value=<span class="string">"$&#123;isAdmin&#125;"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>when</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: DELL</span><br><span class="line">  Date: <span class="number">2021</span>/<span class="number">12</span>/<span class="number">30</span></span><br><span class="line">  Time: <span class="number">18</span>:<span class="number">33</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%--定义变量score，值为<span class="number">87</span>--%&gt;</span><br><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">"score"</span> value=<span class="string">"87"</span>/&gt;</span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">"$&#123;score&gt;=90&#125;"</span>&gt;</span><br><span class="line">        &lt;c:out value="优秀"&gt;&lt;/c:out&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">"$&#123;score&lt;=90&#125;"</span>&gt;</span><br><span class="line">        &lt;c:out value="一般"&gt;&lt;/c:out&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>foreach</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.ArrayList"</span> %&gt;&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: DELL</span><br><span class="line">  Date: <span class="number">2021</span>/<span class="number">12</span>/<span class="number">30</span></span><br><span class="line">  Time: <span class="number">18</span>:<span class="number">38</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    ArrayList&lt;String&gt; persons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    persons.add(<span class="number">0</span>,<span class="string">"curry"</span>);</span><br><span class="line">    persons.add(<span class="number">1</span>,<span class="string">"jack"</span>);</span><br><span class="line">    persons.add(<span class="number">2</span>,<span class="string">"susan"</span>);</span><br><span class="line">    persons.add(<span class="number">3</span>,<span class="string">"bill"</span>);</span><br><span class="line">    persons.add(<span class="number">4</span>,<span class="string">"james"</span>);</span><br><span class="line">    request.setAttribute(<span class="string">"list"</span>,persons);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">"person"</span> items=<span class="string">"$&#123;list&#125;"</span>&gt;</span><br><span class="line">    &lt;c:out value=<span class="string">"$&#123;person&#125;"</span>/&gt;&lt;br/&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">"person"</span> items=<span class="string">"$&#123;list&#125;"</span> begin=<span class="string">"1"</span> end=<span class="string">"3"</span> step=<span class="string">"2"</span>&gt;</span><br><span class="line">    &lt;c:out value=<span class="string">"$&#123;person&#125;"</span>/&gt;&lt;br/&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<h4 id="格式化标签"><a href="#格式化标签" class="headerlink" title="格式化标签"></a>格式化标签</h4><h4 id="SQL标签"><a href="#SQL标签" class="headerlink" title="SQL标签"></a>SQL标签</h4><h4 id="XML标签"><a href="#XML标签" class="headerlink" title="XML标签"></a>XML标签</h4><h2 id="9-JavaBean"><a href="#9-JavaBean" class="headerlink" title="9.JavaBean"></a>9.JavaBean</h2><p>实体类</p>
<p>JavaBean特定写法：</p>
<ul>
<li>必须有一个无参构造</li>
<li>属性必须私有化</li>
<li>必须有对应的set/get方法</li>
</ul>
<p>一般用来和数据库的字段做映射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line"><span class="comment">/*    People people = new People();</span></span><br><span class="line"><span class="comment">    people.setAddress();*/</span></span><br><span class="line">%&gt;</span><br><span class="line">&lt;jsp:useBean id=<span class="string">"people"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.kuang.pojo.People"</span> scope=<span class="string">"page"</span>&gt;</span><br><span class="line">    &lt;jsp:setProperty name=<span class="string">"people"</span> property=<span class="string">"address"</span> value=<span class="string">"深圳"</span>/&gt;</span><br><span class="line">    &lt;jsp:setProperty name=<span class="string">"people"</span> property=<span class="string">"id"</span> value=<span class="string">"1"</span>/&gt;</span><br><span class="line">    &lt;jsp:setProperty name=<span class="string">"people"</span> property=<span class="string">"name"</span> value=<span class="string">"jack"</span>/&gt;</span><br><span class="line">    &lt;jsp:setProperty name=<span class="string">"people"</span> property=<span class="string">"age"</span> value=<span class="string">"22"</span>/&gt;</span><br><span class="line">&lt;/jsp:useBean&gt;</span><br><span class="line"></span><br><span class="line">id：&lt;jsp:getProperty name=<span class="string">"people"</span> property=<span class="string">"id"</span>/&gt;</span><br><span class="line">姓名：&lt;jsp:getProperty name=<span class="string">"people"</span> property=<span class="string">"name"</span>/&gt;</span><br><span class="line">年龄：&lt;jsp:getProperty name=<span class="string">"people"</span> property=<span class="string">"age"</span>/&gt;</span><br><span class="line">地址：&lt;jsp:getProperty name=<span class="string">"people"</span> property=<span class="string">"address"</span>/&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>



<h2 id="10-MVC三层架构"><a href="#10-MVC三层架构" class="headerlink" title="10.MVC三层架构"></a>10.MVC三层架构</h2><p>Servlet和jsp都可以写java代码，但是为了代码易于维护，Servlet专注于处理请求，控制视图跳转，jsp专注于显示数据</p>
<p><img src="https://s2.loli.net/2021/12/31/BRsIA8hfrdZSbM1.png" alt="image-20211231145243094"></p>
<blockquote>
<p>Model</p>
</blockquote>
<ul>
<li>业务处理：业务逻辑（Service）</li>
<li>数据持久层：CRUD（DAO）</li>
</ul>
<blockquote>
<p>View</p>
</blockquote>
<ul>
<li>展示数据</li>
<li>提供链接发起Servlet请求</li>
</ul>
<blockquote>
<p>Controller</p>
</blockquote>
<ul>
<li>接收用户请求</li>
<li>交给业务层处理业务逻辑</li>
<li>控制视图跳转</li>
</ul>
<h2 id="11-Filter（重点）"><a href="#11-Filter（重点）" class="headerlink" title="11.Filter（重点）"></a>11.Filter（重点）</h2><p>过滤器：过滤网页数据；登录验证；提前处理乱码问题等等；</p>
<h3 id="filter开发步骤"><a href="#filter开发步骤" class="headerlink" title="filter开发步骤"></a>filter开发步骤</h3><ul>
<li>导包</li>
<li>编写过滤器，实现Filter接口</li>
<li>配置xml</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterEncodingFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//web服务器启动的时候执行初始化</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------init-------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        request.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">"CharacterEncodingFilter执行前"</span>);</span><br><span class="line">        <span class="comment">//放行当前请求到下一个过滤器</span></span><br><span class="line">        filterChain.doFilter(request,response);</span><br><span class="line">        System.out.println(<span class="string">"CharacterEncodingFilter执行后"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//web服务器关闭的时候过滤器会销毁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------destroy-------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ShowServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.kuang.servlet.ShowServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ShowServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet/show<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ShowServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/show<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.kuang.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--只要是/servlet请求都会被这个过滤器过滤--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>







<h2 id="12-监听器"><a href="#12-监听器" class="headerlink" title="12.监听器"></a>12.监听器</h2><p>javaweb中几乎不用</p>
<h3 id="1-实现监听器接口"><a href="#1-实现监听器接口" class="headerlink" title="1.实现监听器接口"></a>1.实现监听器接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> OnLineCountListener</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> TYS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/12/31 15:27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//统计网站在线人数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnLineCountListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建session监听</span></span><br><span class="line">    <span class="comment">//一旦创建一个session，就会触发一次这个事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">        ServletContext context = se.getSession().getServletContext();</span><br><span class="line">        System.out.println(se.getSession().getId());</span><br><span class="line">        Integer onlineCount = (Integer)context.getAttribute(<span class="string">"onlineCount"</span>);</span><br><span class="line">        <span class="keyword">if</span>(onlineCount == <span class="keyword">null</span>)&#123;</span><br><span class="line">            onlineCount = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            onlineCount = onlineCount + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        context.setAttribute(<span class="string">"onlineCount"</span>,onlineCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁session监听</span></span><br><span class="line">    <span class="comment">//一旦销毁一个session，就会触发一次这个事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">        ServletContext context = se.getSession().getServletContext();</span><br><span class="line"></span><br><span class="line">        Integer onlineCount = (Integer)context.getAttribute(<span class="string">"onlineCount"</span>);</span><br><span class="line">        <span class="keyword">if</span>(onlineCount == <span class="keyword">null</span>)&#123;</span><br><span class="line">            onlineCount = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            onlineCount = onlineCount - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        context.setAttribute(<span class="string">"onlineCount"</span>,onlineCount);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * session销毁：</span></span><br><span class="line"><span class="comment">     * 1.手动销毁 se.getSession().invalidate();</span></span><br><span class="line"><span class="comment">     * 2.配置session失效时间，单位：分钟</span></span><br><span class="line"><span class="comment">     * &lt;session-config&gt;</span></span><br><span class="line"><span class="comment">     *         &lt;session-timeout&gt;1&lt;/session-timeout&gt;</span></span><br><span class="line"><span class="comment">     *     &lt;/session-config&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-在xml中配置监听器"><a href="#2-在xml中配置监听器" class="headerlink" title="2.在xml中配置监听器"></a>2.在xml中配置监听器</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册监听器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.kuang.listener.OnLineCountListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>1<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>















































]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器及搭建环境说明.md</title>
    <url>/2021/11/06/kuangshen/linux/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8A%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="服务器相关知识"><a href="#服务器相关知识" class="headerlink" title="服务器相关知识"></a>服务器相关知识</h1><blockquote>
<p>为什么程序员都需要一个自己的服务器</p>
</blockquote>
<ol>
<li>需要发布自己的网站和项目</li>
<li>练习Linux操作</li>
<li>自己的远程仓库，远程数据库，远程Tomcat…搭建在服务器上</li>
<li>练习，进行linux环境的部署操作</li>
</ol>
<blockquote>
<p>服务器如何购买</p>
</blockquote>
<p>香港服务器可以避免备案，但是尽量不要自己挂vpn，会被封！</p>
<blockquote>
<p>买完服务器之后该做什么</p>
</blockquote>
<ol>
<li>在阿里云购买的，需要开通安全组设置；端口映射</li>
</ol>
<p><img src="https://i.loli.net/2021/11/06/UO6C4JomLA7z8ey.png" alt="image-20211106134406082"></p>
<p>2.获取服务器的公网ip地址，修改实例名称和密码，修改后需要重启，需要xshell远程连接</p>
<blockquote>
<p>连接到服务器之后，需要搭建环境</p>
</blockquote>
<h2 id="1-傻瓜式-宝塔面板"><a href="#1-傻瓜式-宝塔面板" class="headerlink" title="1.傻瓜式(宝塔面板)"></a>1.傻瓜式(宝塔面板)</h2><p>宝塔面板安装教学 <a href="https://www.bt.cn/bbs/thread-19376-1-1.html" target="_blank" rel="noopener">https://www.bt.cn/bbs/thread-19376-1-1.html</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh</span><br></pre></td></tr></table></figure>

<p>下载完毕之后，就可以得到一个地址：宝塔的管理面板</p>
<ul>
<li>url : <a href="http://47.97.1.136:8888/ee35ffb4/" target="_blank" rel="noopener">http://47.97.1.136:8888/ee35ffb4/</a></li>
<li>username: hnyvktvt</li>
<li>password:  975427c4</li>
</ul>
<p>修改：zhanghanting/Zht.201496</p>
<p><img src="https://i.loli.net/2021/11/06/RjUHnS8Z9KqOfNx.png" alt="image-20211106140204473"></p>
<p><img src="https://i.loli.net/2021/11/06/pNo2UgyTW1cktuR.png" alt="image-20211106141822071"></p>
<blockquote>
<p>一键部署应用</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/06/R4LrnqoWHTV9GCs.png" alt="image-20211106143116055"></p>
<blockquote>
<p>端口开启</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/06/F3PSXlA69NZm25r.png" alt="image-20211106144037300"></p>
<blockquote>
<p>放入网站进行访问</p>
</blockquote>
<p>比如Tomcat就直接放到webapps目录下！</p>
<p>特殊的网站：开源项目，就按照自己的操作来</p>
<blockquote>
<p>上传文件进来用xftp</p>
</blockquote>
<blockquote>
<p>网站如果访问测试失败，一定是防火墙（linux服务器，阿里云安全组面板）</p>
</blockquote>
<h2 id="2-命令式-原生"><a href="#2-命令式-原生" class="headerlink" title="2.命令式(原生)"></a>2.命令式(原生)</h2>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux.md</title>
    <url>/2021/11/06/kuangshen/linux/linux/</url>
    <content><![CDATA[<h1 id="Linux-CentOS-7"><a href="#Linux-CentOS-7" class="headerlink" title="Linux(CentOS 7)"></a>Linux(CentOS 7)</h1><p>课程基于CentOS7版本的学习</p>
<blockquote>
<p>Linux一切皆文件：文件的读，写，权限控制</p>
</blockquote>
<p>学习方式：</p>
<p>1.认识Linux</p>
<p>2.基本的命令(重点:文件操作，目录管理，文件属性，vim编辑器，账号管理，磁盘管理……)</p>
<p>3.软件的安装和部署(java,tomcat,docker……)</p>
<h1 id="入门概述"><a href="#入门概述" class="headerlink" title="入门概述"></a>入门概述</h1><p><a href="https://mp.weixin.qq.com/s/RT93qJdTagtKjWKx_A_6Nw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/RT93qJdTagtKjWKx_A_6Nw</a></p>
<h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><h2 id="1-安装CentOS（本地安装，耗资源，不太建议）"><a href="#1-安装CentOS（本地安装，耗资源，不太建议）" class="headerlink" title="1.安装CentOS（本地安装，耗资源，不太建议）"></a>1.安装CentOS（本地安装，耗资源，不太建议）</h2><p>可以将电脑装成双系统</p>
<p>虚拟机安装（VMware下载：360一键安装）</p>
<h2 id="2-购买云服务器"><a href="#2-购买云服务器" class="headerlink" title="2.购买云服务器"></a>2.购买云服务器</h2><ul>
<li>在阿里云购买云服务器</li>
<li>购买完毕，获取ip地址，重置服务器密码，就可以远程登录了</li>
</ul>
<p>注意事项：</p>
<p>如果要打开端口，需要在阿里云的安全组面板中开启对应的出入规则（开放端口），不然的话会被阿里云拦截</p>
<h1 id="走进Linux系统"><a href="#走进Linux系统" class="headerlink" title="走进Linux系统"></a>走进Linux系统</h1><blockquote>
<p>开机登录</p>
</blockquote>
<p>开机会启动许多程序。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。</p>
<p>开机成功后，它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份，密码是不显示的，输完回车即可！</p>
<p>一般来说，用户的登录方式有三种：</p>
<ul>
<li>命令行登录</li>
<li>ssh登录</li>
<li>图形界面登录</li>
</ul>
<p>最高权限账户为 root，可以操作一切！</p>
<blockquote>
<p>关机</p>
</blockquote>
<p>在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p>
<p>关机指令为：shutdown ；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sync # 将数据由内存同步到硬盘中。</span><br><span class="line"></span><br><span class="line">shutdown # 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span><br><span class="line"></span><br><span class="line">shutdown –h 10 # 这个命令告诉大家，计算机将在10分钟后关机</span><br><span class="line"></span><br><span class="line">shutdown –h now # 立马关机</span><br><span class="line"></span><br><span class="line">shutdown –h 20:25 # 系统会在今天20:25关机</span><br><span class="line"></span><br><span class="line">shutdown –h +10 # 十分钟后关机</span><br><span class="line"></span><br><span class="line">shutdown –r now # 系统立马重启</span><br><span class="line"></span><br><span class="line">shutdown –r +10 # 系统十分钟后重启</span><br><span class="line"></span><br><span class="line">reboot # 就是重启，等同于 shutdown –r now</span><br><span class="line"></span><br><span class="line">halt # 关闭系统，等同于shutdown –h now 和 poweroff</span><br></pre></td></tr></table></figure>

<p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中。</p>
<blockquote>
<p>系统目录结构</p>
</blockquote>
<p>1.一切皆文件</p>
<p>2.所有的文件都在根目录/下</p>
<p><img src="https://i.loli.net/2021/11/06/QpeoD9HGVhEmy38.png" alt="image-20211106183000484"></p>
<ul>
<li><p><strong>/bin</strong>：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</p>
</li>
<li><p><strong>/boot：</strong> 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。(不要去更改)</p>
</li>
<li><p><strong>/dev ：</strong> dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的（比如说插了磁盘，就可以在/dev目录下查看）。</p>
</li>
<li><blockquote>
<p><strong>/etc：</strong> 这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p>
</blockquote>
</li>
<li><blockquote>
<p><strong>/home</strong>：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p>
</blockquote>
</li>
<li><p><strong>/lib</strong>：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。（不要修改）</p>
</li>
<li><p><strong>/lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。（存放突然关机的）</p>
</li>
<li><p><strong>/media</strong>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p>
</li>
<li><p><strong>/mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了（我们后面会把一些本地文件挂载在这个目录下）。</p>
</li>
<li><blockquote>
<p><strong>/opt</strong>：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p>
</blockquote>
</li>
<li><p><strong>/proc</strong>：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。（不用管）</p>
</li>
<li><blockquote>
<p><strong>/root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。</p>
</blockquote>
</li>
<li><p><strong>/sbin</strong>：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p>
</li>
<li><p><strong>/srv</strong>：该目录存放一些服务启动之后需要提取的数据。</p>
</li>
<li><p><strong>/sys</strong>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</p>
</li>
<li><blockquote>
<p><strong>/tmp</strong>：这个目录是用来存放一些临时文件的。</p>
</blockquote>
</li>
<li><blockquote>
<p><strong>/usr</strong>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p>
</blockquote>
</li>
<li><p><strong>/usr/bin：</strong> 系统用户使用的应用程序。</p>
</li>
<li><p><strong>/usr/sbin：</strong> 超级用户使用的比较高级的管理程序和系统守护程序。</p>
</li>
<li><p><strong>/usr/src：</strong> 内核源代码默认的放置目录。</p>
</li>
<li><p><strong>/var</strong>：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>
</li>
<li><p><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</p>
</li>
<li><p>/www: 存放服务器网站相关的资源，比如网站的项目</p>
</li>
</ul>
<h1 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h1><blockquote>
<p>绝对路径和相对路径</p>
</blockquote>
<p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。</p>
<p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p>
<p>在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p>
<p><strong>绝对路径：</strong></p>
<p>路径的写法，由根目录 / 写起，例如：/usr/share/doc 这个目录。</p>
<p><strong>相对路径：</strong></p>
<p>路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成：cd ../man 这就是相对路径的写法啦！</p>
<blockquote>
<p>处理目录的常用命令</p>
</blockquote>
<p>接下来我们就来看几个常见的处理目录的命令吧：</p>
<ul>
<li>ls: 列出目录</li>
<li>cd：切换目录</li>
<li>pwd：显示目前的目录</li>
<li>mkdir：创建一个新的目录</li>
<li>rmdir：删除一个空的目录</li>
<li>cp: 复制文件或目录</li>
<li>rm: 移除文件或目录</li>
<li>mv: 移动文件与目录，或修改文件与目录的名称</li>
</ul>
<p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p>
<blockquote>
<p>ls列出目录</p>
</blockquote>
<p>在Linux系统当中， ls 命令可能是最常被运行的。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li>
<li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li>
</ul>
<p>将目录下的所有文件列出来(含属性与隐藏档)</p>
<blockquote>
<p>cd切换目录</p>
</blockquote>
<p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd [相对路径或绝对路径]</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换到用户目录下</span></span><br><span class="line">[root@kuangshen /]# cd home  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 mkdir 命令创建 kuangstudy 目录</span></span><br><span class="line">[root@kuangshen home]# mkdir kuangstudy</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入 kuangstudy 目录</span></span><br><span class="line">[root@kuangshen home]# cd kuangstudy</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 回到上一级</span></span><br><span class="line">[root@kuangshen kuangstudy]# cd ..</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 回到根目录</span></span><br><span class="line">[root@kuangshen kuangstudy]# cd /</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示回到自己的家目录，亦即是 /root 这个目录</span></span><br><span class="line">[root@kuangshen kuangstudy]# cd ~</span><br></pre></td></tr></table></figure>

<p>接下来大家多操作几次应该就可以很好的理解 cd 命令的。</p>
<blockquote>
<p>pwd(显示当前所在的目录)</p>
</blockquote>
<p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@kuangshen kuangstudy]#pwd [-P]</span><br></pre></td></tr></table></figure>

<p>选项与参数：<strong>-P</strong> ：显示出确实的路径，而非使用连接(link) 路径。</p>
<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 单纯显示出目前的工作目录</span></span><br><span class="line">[root@kuangshen ~]# pwd</span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果是链接，要显示真实地址，可以使用 -P参数</span></span><br><span class="line">[root@kuangshen /]# cd bin</span><br><span class="line">[root@kuangshen bin]# pwd -P</span><br><span class="line">/usr/bin</span><br></pre></td></tr></table></figure>

<blockquote>
<p>mkdir(创建新目录)</p>
</blockquote>
<p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir [-mp] 目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li>
<li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li>
</ul>
<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入我们用户目录下</span></span><br><span class="line">[root@kuangshen /]# cd /home</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建一个 <span class="built_in">test</span> 文件夹</span></span><br><span class="line">[root@kuangshen home]# mkdir test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建多层级目录</span></span><br><span class="line">[root@kuangshen home]# mkdir test1/test2/test3/test4</span><br><span class="line">mkdir: cannot create directory ‘test1/test2/test3/test4’:</span><br><span class="line">No such file or directory  # &lt;== 没办法直接创建此目录啊！</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加了这个 -p 的选项，可以自行帮你创建多层目录！</span></span><br><span class="line">[root@kuangshen home]# mkdir -p test1/test2/test3/test4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建权限为 rwx--x--x 的目录。</span></span><br><span class="line">[root@kuangshen home]# mkdir -m 711 test2</span><br><span class="line">[root@kuangshen home]# ls -l</span><br><span class="line">drwxr-xr-x 2 root root  4096 Mar 12 21:55 test</span><br><span class="line">drwxr-xr-x 3 root root  4096 Mar 12 21:56 test1</span><br><span class="line">drwx--x--x 2 root root  4096 Mar 12 21:58 test2</span><br></pre></td></tr></table></figure>



<blockquote>
<p>rmdir(删除空目录)</p>
</blockquote>
<p>选项与参数：<strong>-p ：</strong>连同上一级『空的』目录也一起删除</p>
<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 看看有多少目录存在？</span></span><br><span class="line">[root@kuangshen home]# ls -l</span><br><span class="line">drwxr-xr-x 2 root root  4096 Mar 12 21:55 test</span><br><span class="line">drwxr-xr-x 3 root root  4096 Mar 12 21:56 test1</span><br><span class="line">drwx--x--x 2 root root  4096 Mar 12 21:58 test2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可直接删除掉，没问题</span></span><br><span class="line">[root@kuangshen home]# rmdir test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 因为尚有内容，所以无法删除！</span></span><br><span class="line">[root@kuangshen home]# rmdir test1</span><br><span class="line">rmdir: failed to remove ‘test1’: Directory not empty</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 依次删除。</span></span><br><span class="line">[root@kuangshen home]# rmdir -p test1/test2/test3/test4</span><br></pre></td></tr></table></figure>

<blockquote>
<p>cp ( 复制文件或目录 )</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)</span><br><span class="line">[root@www ~]# cp [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li>
<li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li>
<li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li>
<li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li>
<li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li>
<li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li>
<li><strong>-l：</strong>进行硬式连结(hard link)的连结档创建，而非复制文件本身。</li>
<li><strong>-s：</strong>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li>
<li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li>
</ul>
<p>测试：</p>
<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 找一个有文件的目录，我这里找到 root目录</span></span><br><span class="line">[root@kuangshen home]# cd /root</span><br><span class="line">[root@kuangshen ~]# ls</span><br><span class="line">install.sh</span><br><span class="line">[root@kuangshen ~]# cd /home</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制 root目录下的install.sh 到 home目录下</span></span><br><span class="line">[root@kuangshen home]# cp /root/install.sh /home</span><br><span class="line">[root@kuangshen home]# ls</span><br><span class="line">install.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次复制，加上-i参数，增加覆盖询问？</span></span><br><span class="line">[root@kuangshen home]# cp -i /root/install.sh /home</span><br><span class="line">cp: overwrite ‘/home/install.sh’? y # n不覆盖，y为覆盖</span><br></pre></td></tr></table></figure>

<blockquote>
<p>rm ( 移除文件或目录 )</p>
</blockquote>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm [-fir] 文件或目录</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li>
<li>-i ：互动模式，在删除前会询问使用者是否动作</li>
<li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>
</ul>
<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将刚刚在 cp 的实例中创建的 install.sh删除掉！</span><br><span class="line">[root@kuangshen home]# rm -i install.sh</span><br><span class="line">rm: remove regular file ‘install.sh’? y</span><br><span class="line"># 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</span><br><span class="line"></span><br><span class="line"># 尽量不要在服务器上使用 rm -rf &#x2F;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>mv  ( 移动文件与目录，或修改名称 )</p>
</blockquote>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# mv [-fiu] source destination</span><br><span class="line">[root@www ~]# mv [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li>
<li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li>
</ul>
<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 复制一个文件到当前目录</span></span><br><span class="line">[root@kuangshen home]# cp /root/install.sh /home</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建一个文件夹 <span class="built_in">test</span></span></span><br><span class="line">[root@kuangshen home]# mkdir test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将复制过来的文件移动到我们创建的目录，并查看</span></span><br><span class="line">[root@kuangshen home]# mv install.sh test</span><br><span class="line">[root@kuangshen home]# ls</span><br><span class="line">test</span><br><span class="line">[root@kuangshen home]# cd test</span><br><span class="line">[root@kuangshen test]# ls</span><br><span class="line">install.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将文件夹重命名，然后再次查看！</span></span><br><span class="line">[root@kuangshen test]# cd ..</span><br><span class="line">[root@kuangshen home]# mv test mvtest</span><br><span class="line">[root@kuangshen home]# ls</span><br><span class="line">mvtest</span><br></pre></td></tr></table></figure>



<h1 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h1><blockquote>
<p>看懂文件属性</p>
</blockquote>
<p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p>
<p>在Linux中我们可以使用<code>ll</code>或者<code>ls –l</code>命令来显示一个文件的属性以及文件所属的用户和组，如：</p>
<p><img src="https://i.loli.net/2021/11/06/tjuMg5iTW6DYwUr.png" alt="image-20211106190430799"></p>
<p>实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。</p>
<p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：</p>
<ul>
<li>当为[ <strong>d</strong> ]则是目录</li>
<li>当为[ <strong>-</strong> ]则是文件；</li>
<li>若是[ <strong>l</strong> ]则表示为链接文档 ( link file )；</li>
<li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；</li>
<li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。</li>
</ul>
<p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。</p>
<p>其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。</p>
<p>要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p>
<p>每个文件的属性由左边第一部分的10个字符来确定（如下图）：</p>
<p><img src="https://i.loli.net/2021/11/06/sExWNeGY8mbhvOo.png" alt="image-20211106190750806"></p>
<p>从左至右用0-9这些数字来表示。</p>
<p>第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p>
<p>其中：</p>
<p>第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限；</p>
<p>第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；</p>
<p>第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。</p>
<p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p>
<p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p>
<p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p>
<p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p>
<p>在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。</p>
<blockquote>
<p>修改文件属性</p>
</blockquote>
<p><strong>1、chgrp：更改文件属组</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chgrp [-R] 属组名 文件名</span><br></pre></td></tr></table></figure>

<p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</p>
<p><strong>2、chown：更改文件属主，也可以同时更改文件属组</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown [–R] 属主名 文件名</span><br><span class="line">chown [-R] 属主名：属组名 文件名</span><br></pre></td></tr></table></figure>

<p><strong>3、chmod：更改文件9个属性</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure>

<p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p>
<p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p>
<p>先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r:4     w:2         x:1</span><br></pre></td></tr></table></figure>

<p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是：</p>
<ul>
<li>owner = rwx = 4+2+1 = 7</li>
<li>group = rwx = 4+2+1 = 7</li>
<li>others= — = 0+0+0 = 0</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 770 filename</span><br></pre></td></tr></table></figure>

<h1 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h1><blockquote>
<p>概述</p>
</blockquote>
<ul>
<li>cat 由第一行开始显示文件内容</li>
<li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>
<li>nl  显示的时候，顺道输出行号！</li>
<li>more 一页一页的显示文件内容</li>
<li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li>
<li>head 只看头几行</li>
<li>tail 只看尾巴几行</li>
</ul>
<p>你可以使用 <em>man [命令]</em>来查看各个命令的使用文档，如 ：man cp。</p>
<blockquote>
<p>cat 由第一行开始显示文件内容</p>
</blockquote>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat [-AbEnTv]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>
<li>-E ：将结尾的断行字节 $ 显示出来；</li>
<li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>
<li>-T ：将 [tab] 按键以 ^I 显示出来；</li>
<li>-v ：列出一些看不出来的特殊字符</li>
</ul>
<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/</span></span><br><span class="line">[root@kuangshen ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">DEVICE=eth0</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">ONBOOT=yes</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tac</p>
</blockquote>
<p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@kuangshen ~]# tac /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEVICE=eth0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>nl  显示行号</p>
</blockquote>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nl [-bnw] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li>
<li>-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li>
<li>-w ：行号栏位的占用的位数。</li>
</ul>
<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@kuangshen ~]# nl /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">1DEVICE=eth0</span><br><span class="line">2BOOTPROTO=dhcp</span><br><span class="line">3ONBOOT=yes</span><br></pre></td></tr></table></figure>



<blockquote>
<p>more  一页一页翻动</p>
</blockquote>
<p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p>
<ul>
<li>空白键 (space)：代表向下翻一页；</li>
<li>Enter   ：代表向下翻『一行』；</li>
<li>/字串   ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li>
<li>:f    ：立刻显示出档名以及目前显示的行数；</li>
<li>q    ：代表立刻离开 more ，不再显示该文件内容。</li>
<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@kuangshen etc]# more /etc/csh.login</span><br><span class="line">....(中间省略)....</span><br><span class="line"><span class="meta">--More--(28%</span><span class="bash">) <span class="comment"># 重点在这一行喔！你的光标也会在这里等待你的命令</span></span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>less  一页一页翻动，以下实例输出/etc/man.config文件的内容：</p>
</blockquote>
<p>less运行时可以输入的命令有：</p>
<ul>
<li>空白键  ：向下翻动一页；</li>
<li>[pagedown]：向下翻动一页；</li>
<li>[pageup] ：向上翻动一页；</li>
<li>/字串  ：向下搜寻『字串』的功能；</li>
<li>?字串  ：向上搜寻『字串』的功能；</li>
<li>n   ：重复前一个搜寻 (与 / 或 ? 有关！)</li>
<li>N   ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li>
<li>q   ：离开 less 这个程序；</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@kuangshen etc]# more /etc/csh.login</span><br><span class="line">....(中间省略)....</span><br><span class="line">:   # 这里可以等待你输入命令！</span><br></pre></td></tr></table></figure>



<blockquote>
<p>head  取出文件前面几行</p>
</blockquote>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">head [-n number] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：<strong>-n</strong> 后面接数字，代表显示几行的意思！</p>
<p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@kuangshen etc]# head -n 20 /etc/csh.login</span><br></pre></td></tr></table></figure>



<blockquote>
<p>tail  取出文件后面几行</p>
</blockquote>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail [-n number] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
</ul>
<p>默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@kuangshen etc]# tail -n 20 /etc/csh.login</span><br></pre></td></tr></table></figure>



<blockquote>
<p>拓展：Linux 链接概念</p>
</blockquote>
<p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。</p>
<p>情况下，<strong>ln</strong> 命令产生硬链接。</p>
<p><strong>硬连接</strong></p>
<p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，<strong>A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</strong></p>
<p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p>
<p><strong>软连接</strong></p>
<p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p>
<p><strong>测试：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@kuangshen /]# cd /home</span><br><span class="line">[root@kuangshen home]# touch f1 # 创建一个测试文件f1</span><br><span class="line">[root@kuangshen home]# ls</span><br><span class="line">f1</span><br><span class="line">[root@kuangshen home]# ln f1 f2     # 创建f1的一个硬连接文件f2</span><br><span class="line">[root@kuangshen home]# ln -s f1 f3   # 创建f1的一个符号连接文件f3</span><br><span class="line">[root@kuangshen home]# ls -li       # -i参数显示文件的inode节点信息</span><br><span class="line">397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f1</span><br><span class="line">397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f2</span><br><span class="line">397248 lrwxrwxrwx 1 root root     2 Mar 13 00:50 f3 -&gt; f1</span><br></pre></td></tr></table></figure>

<p>从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而符号连接文件的 inode 节点不同。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> 字符串输出 &gt;&gt; f1 输出到 f1文件</span></span><br><span class="line">[root@kuangshen home]# echo "I am f1 file" &gt;&gt;f1</span><br><span class="line">[root@kuangshen home]# cat f1</span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]# cat f2</span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]# cat f3</span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]# rm -f f1</span><br><span class="line">[root@kuangshen home]# cat f2</span><br><span class="line">I am f1 file</span><br><span class="line">[root@kuangshen home]# cat f3</span><br><span class="line">cat: f3: No such file or directory</span><br></pre></td></tr></table></figure>

<p>通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效；</p>
<p>依此您可以做一些相关的测试，可以得到以下全部结论：</p>
<ul>
<li>删除符号连接f3,对f1,f2无影响；</li>
<li>删除硬连接f2，对f1,f3也无影响；</li>
<li>删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；</li>
<li>同时删除原文件f1,硬连接f2，整个文件会真正的被删除。</li>
</ul>
<h1 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h1><blockquote>
<p>什么是vim编辑器</p>
</blockquote>
<p>vim通过一些插件可以实现和IDE一样的功能，是从vi发展出来的一个文本编辑器。主要学习查看内容，编辑内容，保存内容</p>
<blockquote>
<p>三种使用模式</p>
</blockquote>
<p>基本vi/vim共分为三种模式：分别是命令模式(Command mode)，输入模式(Insert mode)和底线命令模式(Last line mode)。</p>
<p><strong>命令模式：</strong></p>
<p>用户刚刚启动 vi/vim，便进入了命令模式。</p>
<p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p>
<p>以下是常用的几个命令：</p>
<ul>
<li><strong>i</strong> 切换到输入模式，以输入字符。</li>
<li><strong>x</strong> 删除当前光标所在处的字符。</li>
<li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li>
</ul>
<p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p>
<p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p>
<p><strong>输入模式：</strong></p>
<p>在命令模式下按下i就进入了输入模式。</p>
<p>在输入模式中，可以使用以下按键：</p>
<ul>
<li><strong>字符按键以及Shift组合</strong>，输入字符</li>
<li><strong>ENTER</strong>，回车键，换行</li>
<li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li>
<li><strong>DEL</strong>，删除键，删除光标后一个字符</li>
<li><strong>方向键</strong>，在文本中移动光标</li>
<li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</li>
<li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</li>
<li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</li>
<li><strong>ESC</strong>，退出输入模式，切换到命令模式</li>
</ul>
<p><strong>底线命令模式</strong></p>
<p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p>
<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p>
<ul>
<li>q 退出程序</li>
<li>w 保存文件</li>
</ul>
<p>按ESC键可随时退出底线命令模式。</p>
<p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p>
<p><img src="https://i.loli.net/2021/11/07/8KfkuvStbTVI6Bl.png" alt="image-20211107193231910"></p>
<blockquote>
<p>Vim 按键说明</p>
</blockquote>
<p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p>
<p><strong>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</strong></p>
<table>
<thead>
<tr>
<th align="left">移动光标的方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">h 或 向左箭头键(←)</td>
<td>光标向左移动一个字符</td>
</tr>
<tr>
<td align="left">j 或 向下箭头键(↓)</td>
<td>光标向下移动一个字符</td>
</tr>
<tr>
<td align="left">k 或 向上箭头键(↑)</td>
<td>光标向上移动一个字符</td>
</tr>
<tr>
<td align="left">l 或 向右箭头键(→)</td>
<td>光标向右移动一个字符</td>
</tr>
<tr>
<td align="left">[Ctrl] + [f]</td>
<td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td>
</tr>
<tr>
<td align="left">[Ctrl] + [b]</td>
<td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td>
</tr>
<tr>
<td align="left">[Ctrl] + [d]</td>
<td>屏幕『向下』移动半页</td>
</tr>
<tr>
<td align="left">[Ctrl] + [u]</td>
<td>屏幕『向上』移动半页</td>
</tr>
<tr>
<td align="left">+</td>
<td>光标移动到非空格符的下一行</td>
</tr>
<tr>
<td align="left">-</td>
<td>光标移动到非空格符的上一行</td>
</tr>
<tr>
<td align="left">n&lt; space&gt;</td>
<td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。</td>
</tr>
<tr>
<td align="left">0 或功能键[Home]</td>
<td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td>
</tr>
<tr>
<td align="left">$ 或功能键[End]</td>
<td>移动到这一行的最后面字符处(常用)</td>
</tr>
<tr>
<td align="left">H</td>
<td>光标移动到这个屏幕的最上方那一行的第一个字符</td>
</tr>
<tr>
<td align="left">M</td>
<td>光标移动到这个屏幕的中央那一行的第一个字符</td>
</tr>
<tr>
<td align="left">L</td>
<td>光标移动到这个屏幕的最下方那一行的第一个字符</td>
</tr>
<tr>
<td align="left">G</td>
<td>移动到这个档案的最后一行(常用)</td>
</tr>
<tr>
<td align="left">nG</td>
<td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td>
</tr>
<tr>
<td align="left">gg</td>
<td>移动到这个档案的第一行，相当于 1G 啊！(常用)</td>
</tr>
<tr>
<td align="left">n&lt; Enter&gt;</td>
<td>n 为数字。光标向下移动 n 行(常用)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">搜索替换</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">/word</td>
<td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！(常用)</td>
</tr>
<tr>
<td align="left">?word</td>
<td>向光标之上寻找一个字符串名称为 word 的字符串。</td>
</tr>
<tr>
<td align="left">n</td>
<td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td>
</tr>
<tr>
<td align="left">N</td>
<td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">删除、复制与粘贴</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">x, X</td>
<td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td>
</tr>
<tr>
<td align="left">nx</td>
<td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td>
</tr>
<tr>
<td align="left">dd</td>
<td>删除游标所在的那一整行(常用)</td>
</tr>
<tr>
<td align="left">ndd</td>
<td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td>
</tr>
<tr>
<td align="left">d1G</td>
<td>删除光标所在到第一行的所有数据</td>
</tr>
<tr>
<td align="left">dG</td>
<td>删除光标所在到最后一行的所有数据</td>
</tr>
<tr>
<td align="left">d$</td>
<td>删除游标所在处，到该行的最后一个字符</td>
</tr>
<tr>
<td align="left">d0</td>
<td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td>
</tr>
<tr>
<td align="left">yy</td>
<td>复制游标所在的那一行(常用)</td>
</tr>
<tr>
<td align="left">nyy</td>
<td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td>
</tr>
<tr>
<td align="left">y1G</td>
<td>复制游标所在行到第一行的所有数据</td>
</tr>
<tr>
<td align="left">yG</td>
<td>复制游标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td align="left">y0</td>
<td>复制光标所在的那个字符到该行行首的所有数据</td>
</tr>
<tr>
<td align="left">y$</td>
<td>复制光标所在的那个字符到该行行尾的所有数据</td>
</tr>
<tr>
<td align="left">p, P</td>
<td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用)</td>
</tr>
<tr>
<td align="left">J</td>
<td>将光标所在行与下一行的数据结合成同一行</td>
</tr>
<tr>
<td align="left">c</td>
<td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td>
</tr>
<tr>
<td align="left">u</td>
<td>复原前一个动作。(常用)</td>
</tr>
<tr>
<td align="left">[Ctrl]+r</td>
<td>重做上一个动作。(常用)</td>
</tr>
</tbody></table>
<p><strong>第二部分：一般模式切换到编辑模式的可用的按钮说明</strong></p>
<table>
<thead>
<tr>
<th align="left">进入输入或取代的编辑模式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">i, I</td>
<td>进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用)</td>
</tr>
<tr>
<td align="left">a, A</td>
<td>进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td>
</tr>
<tr>
<td align="left">o, O</td>
<td>进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用)</td>
</tr>
<tr>
<td align="left">r, R</td>
<td>进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td>
</tr>
<tr>
<td align="left">[Esc]</td>
<td>退出编辑模式，回到一般模式中(常用)</td>
</tr>
</tbody></table>
<p><strong>第三部分：一般模式切换到指令行模式的可用的按钮说明</strong></p>
<table>
<thead>
<tr>
<th align="left">指令行的储存、离开等指令</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">:w</td>
<td>将编辑的数据写入硬盘档案中(常用)</td>
</tr>
<tr>
<td align="left">:w!</td>
<td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td>
</tr>
<tr>
<td align="left">:q</td>
<td>离开 vi (常用)</td>
</tr>
<tr>
<td align="left">:q!</td>
<td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td>
</tr>
<tr>
<td align="left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td>
<td></td>
</tr>
<tr>
<td align="left">:wq</td>
<td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td>
</tr>
<tr>
<td align="left">ZZ</td>
<td>这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</td>
</tr>
<tr>
<td align="left">:w [filename]</td>
<td>将编辑的数据储存成另一个档案（类似另存新档）</td>
</tr>
<tr>
<td align="left">:r [filename]</td>
<td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td>
</tr>
<tr>
<td align="left">:n1,n2 w [filename]</td>
<td>将 n1 到 n2 的内容储存成 filename 这个档案。</td>
</tr>
<tr>
<td align="left">:! command</td>
<td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中看 /home 底下以 ls 输出的档案信息！</td>
</tr>
<tr>
<td align="left">:set nu</td>
<td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td>
</tr>
<tr>
<td align="left">:set nonu</td>
<td>与 set nu 相反，为取消行号！</td>
</tr>
</tbody></table>
<h1 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h1><blockquote>
<p>简介</p>
</blockquote>
<p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p>
<p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p>
<p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p>
<ul>
<li>用户账号的添加、删除与修改。</li>
<li>用户口令的管理。</li>
<li>用户组的管理。</li>
</ul>
<blockquote>
<p>用户账号的管理</p>
</blockquote>
<p>用户账号的管理工作主要涉及到用户账号的添加、修改和删除。</p>
<p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。</p>
<blockquote>
<p>添加账号 useradd</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd 选项 用户名</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><p>选项 :</p>
</li>
<li><ul>
<li>-c comment 指定一段注释性描述。</li>
<li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li>
<li>-g 用户组 指定用户所属的用户组。</li>
<li>-G 用户组，用户组 指定用户所属的附加组。</li>
<li>-m　使用者目录如不存在则自动建立。</li>
<li>-s Shell文件 指定用户的登录Shell。</li>
<li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li>
</ul>
</li>
<li><p>用户名 :</p>
</li>
<li><ul>
<li>指定新账号的登录名。</li>
</ul>
</li>
</ul>
<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 此命令创建了一个用户kuangshen，其中-m选项用来为登录名kuangshen产生一个主目录 /home/kuangshen</span></span><br><span class="line">[root@kuangshen home]# useradd -m kuangshen</span><br></pre></td></tr></table></figure>

<p>增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。</p>
<blockquote>
<p>Linux下如何切换用户</p>
</blockquote>
<p>1.切换用户的命令为：su username 【username是你的用户名哦】</p>
<p>2.从普通用户切换到root用户，还可以使用命令：sudo su</p>
<p>3.在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令</p>
<p>4.在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：【su - root】</p>
<p>$表示普通用户</p>
<p>#表示超级用户，也就是root用户</p>
<blockquote>
<p>删除帐号</p>
</blockquote>
<p>如果一个用户的账号不再使用，可以从系统中删除。</p>
<p>删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。</p>
<p>删除一个已有的用户账号使用userdel命令，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">userdel 选项 用户名</span><br></pre></td></tr></table></figure>

<p>常用的选项是 <strong>-r</strong>，它的作用是把用户的主目录一起删除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@kuangshen home]# userdel -r kuangshen</span><br></pre></td></tr></table></figure>

<p>此命令删除用户kuangshen在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。</p>
<blockquote>
<p>修改帐号</p>
</blockquote>
<p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p>
<p>修改已有用户的信息使用usermod命令，其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod 选项 用户名</span><br></pre></td></tr></table></figure>

<p>常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># usermod -s &#x2F;bin&#x2F;ksh -d &#x2F;home&#x2F;z –g developer kuangshen</span><br></pre></td></tr></table></figure>

<p>此命令将用户kuangshen的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。</p>
<blockquote>
<p>用户口令的管理</p>
</blockquote>
<p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p>
<p>指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。</p>
<p>命令的格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd 选项 用户名</span><br></pre></td></tr></table></figure>

<p>可使用的选项：</p>
<ul>
<li>-l 锁定口令，即禁用账号。</li>
<li>-u 口令解锁。</li>
<li>-d 使账号无口令。</li>
<li>-f 强迫用户下次登录时修改口令。</li>
</ul>
<p>如果默认用户名，则修改当前用户的口令。</p>
<p>例如，假设当前用户是kuangshen，则下面的命令修改该用户自己的口令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ passwd</span><br><span class="line">Old password:******</span><br><span class="line">New password:*******</span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure>

<p>如果是超级用户，可以用下列形式指定任何用户的口令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># passwd kuangshen</span><br><span class="line">New password:*******</span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure>

<p>普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。</p>
<p>为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。</p>
<p>为用户指定空口令时，执行下列形式的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># passwd -d kuangshen</span><br></pre></td></tr></table></figure>

<p>此命令将用户 kuangshen的口令删除，这样用户 kuangshen下一次登录时，系统就不再允许该用户登录了。</p>
<p>passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># passwd -l kuangshen</span><br></pre></td></tr></table></figure>

<h1 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h1><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p>
<blockquote>
<p>增加一个新的用户组使用groupadd命令</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupadd 选项 用户组</span><br></pre></td></tr></table></figure>

<p>可以使用的选项有：</p>
<ul>
<li>-g GID 指定新用户组的组标识号（GID）。</li>
<li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li>
</ul>
<p>实例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># groupadd group1</span><br></pre></td></tr></table></figure>

<p>此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。</p>
<p>实例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># groupadd -g 101 group2</span><br></pre></td></tr></table></figure>

<p>此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。</p>
<blockquote>
<p>如果要删除一个已有的用户组，使用groupdel命令</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupdel 用户组</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># groupdel group1</span><br></pre></td></tr></table></figure>

<p>此命令从系统中删除组group1。</p>
<blockquote>
<p>修改用户组的属性使用groupmod命令</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupmod 选项 用户组</span><br></pre></td></tr></table></figure>

<p>常用的选项有：</p>
<ul>
<li>-g GID 为用户组指定新的组标识号。</li>
<li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li>
<li>-n新用户组 将用户组的名字改为新名字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 此命令将组group2的组标识号修改为102。</span><br><span class="line">groupmod -g 102 group2</span><br><span class="line"></span><br><span class="line"># 将组group2的标识号改为10000，组名修改为group3。</span><br><span class="line">groupmod –g 10000 -n group3 group2</span><br></pre></td></tr></table></figure>



<blockquote>
<p>切换组</p>
</blockquote>
<p>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</p>
<p>用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ newgrp root</span><br></pre></td></tr></table></figure>

<p>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。</p>
<blockquote>
<p>/etc/passwd</p>
</blockquote>
<p>完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。</p>
<p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。</p>
<p>下面分别介绍这些文件的内容。</p>
<p><strong>/etc/passwd文件是用户管理工作涉及的最重要的一个文件。</strong></p>
<p>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</p>
<p>这个文件对所有用户都是可读的。它的内容类似下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">＃ cat &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">root:x:0:0:Superuser:&#x2F;:</span><br><span class="line">daemon:x:1:1:System daemons:&#x2F;etc:</span><br><span class="line">bin:x:2:2:Owner of system commands:&#x2F;bin:</span><br><span class="line">sys:x:3:3:Owner of system files:&#x2F;usr&#x2F;sys:</span><br><span class="line">adm:x:4:4:System accounting:&#x2F;usr&#x2F;adm:</span><br><span class="line">uucp:x:5:5:UUCP administrator:&#x2F;usr&#x2F;lib&#x2F;uucp:</span><br><span class="line">auth:x:7:21:Authentication administrator:&#x2F;tcb&#x2F;files&#x2F;auth:</span><br><span class="line">cron:x:9:16:Cron daemon:&#x2F;usr&#x2F;spool&#x2F;cron:</span><br><span class="line">listen:x:37:4:Network daemon:&#x2F;usr&#x2F;net&#x2F;nls:</span><br><span class="line">lp:x:71:18:Printer administrator:&#x2F;usr&#x2F;spool&#x2F;lp:</span><br></pre></td></tr></table></figure>

<p>从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</span><br></pre></td></tr></table></figure>

<p>1）”用户名”是代表用户账号的字符串。</p>
<p>通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。</p>
<p>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</p>
<p>2）“口令”一些系统中，存放着加密后的用户口令字。</p>
<p>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p>
<p>3）“用户标识号”是一个整数，系统内部用它来标识用户。</p>
<p>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</p>
<p>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</p>
<p>4）“组标识号”字段记录的是用户所属的用户组。</p>
<p>它对应着/etc/group文件中的一条记录。</p>
<p>5)“注释性描述”字段记录着用户的一些个人情况。</p>
<p>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用作finger命令的输出。</p>
<p>6)“主目录”，也就是用户的起始工作目录。</p>
<p>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</p>
<p>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</p>
<p>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。</p>
<p>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。</p>
<p>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</p>
<p>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p>
<p>8)系统中有一类用户称为伪用户（pseudo users）。</p>
<p>这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</p>
<p>常见的伪用户如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">伪 用 户 含 义</span><br><span class="line">bin 拥有可执行的用户命令文件</span><br><span class="line">sys 拥有系统文件</span><br><span class="line">adm 拥有帐户文件</span><br><span class="line">uucp UUCP使用</span><br><span class="line">lp lp或lpd子系统使用</span><br><span class="line">nobody NFS使用</span><br></pre></td></tr></table></figure>

<blockquote>
<p>/etc/shadow</p>
</blockquote>
<p><strong>1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。</strong></p>
<p>由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p>
<p><strong>2、/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生</strong></p>
<p>它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</span><br></pre></td></tr></table></figure>

<ol>
<li>“登录名”是与/etc/passwd文件中的登录名相一致的用户账号</li>
<li>“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</li>
<li>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</li>
<li>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</li>
<li>“最大时间间隔”指的是口令保持有效的最大天数。</li>
<li>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li>
<li>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li>
<li>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li>
</ol>
<blockquote>
<p>/etc/group</p>
</blockquote>
<p>用户组的所有信息都存放在/etc/group文件中。</p>
<p>将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。</p>
<p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。</p>
<p>当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。</p>
<p>用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。</p>
<p>用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">组名:口令:组标识号:组内用户列表</span><br></pre></td></tr></table></figure>

<ol>
<li>“组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</li>
<li>“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</li>
<li>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。</li>
<li>“组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</li>
</ol>
<h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><blockquote>
<p>概述</p>
</blockquote>
<p>Linux磁盘管理好坏直接关系到整个系统的性能问题。</p>
<p>Linux磁盘管理常用命令为 df、du。</p>
<ul>
<li>df ：列出文件系统的整体磁盘使用量</li>
<li>du：检查磁盘空间使用量</li>
</ul>
<blockquote>
<p>df</p>
</blockquote>
<p>df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df [-ahikHTm] [目录或文件名]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；</li>
<li>-k ：以 KBytes 的容量显示各文件系统；</li>
<li>-m ：以 MBytes 的容量显示各文件系统；</li>
<li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</li>
<li>-H ：以 M=1000K 取代 M=1024K 的进位方式；</li>
<li>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li>
<li>-i ：不用硬盘容量，而以 inode 的数量来显示</li>
</ul>
<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将系统内所有的文件系统列出来！</span><br><span class="line"># 在 Linux 底下如果 df 没有加任何选项</span><br><span class="line"># 那么默认会将系统内所有的 (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！</span><br><span class="line">[root@kuangshen &#x2F;]# df</span><br><span class="line">Filesystem     1K-blocks   Used Available Use% Mounted on</span><br><span class="line">devtmpfs          889100       0    889100   0% &#x2F;dev</span><br><span class="line">tmpfs             899460     704    898756   1% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs             899460     496    898964   1% &#x2F;run</span><br><span class="line">tmpfs             899460       0    899460   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">&#x2F;dev&#x2F;vda1       41152812 6586736  32662368  17% &#x2F;</span><br><span class="line">tmpfs             179896       0    179896   0% &#x2F;run&#x2F;user&#x2F;0</span><br><span class="line"># 将容量结果以易读的容量格式显示出来</span><br><span class="line">[root@kuangshen &#x2F;]# df -h</span><br><span class="line">Filesystem     Size Used Avail Use% Mounted on</span><br><span class="line">devtmpfs       869M     0 869M   0% &#x2F;dev</span><br><span class="line">tmpfs           879M 708K 878M   1% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs           879M 496K 878M   1% &#x2F;run</span><br><span class="line">tmpfs           879M     0 879M   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">&#x2F;dev&#x2F;vda1       40G  6.3G   32G  17% &#x2F;</span><br><span class="line">tmpfs           176M     0 176M   0% &#x2F;run&#x2F;user&#x2F;0</span><br><span class="line"># 将系统内的所有特殊文件格式及名称都列出来</span><br><span class="line">[root@kuangshen &#x2F;]# df -aT</span><br><span class="line">Filesystem     Type       1K-blocks   Used Available Use% Mounted on</span><br><span class="line">sysfs         sysfs               0       0         0    - &#x2F;sys</span><br><span class="line">proc           proc                0       0         0    - &#x2F;proc</span><br><span class="line">devtmpfs       devtmpfs       889100       0    889100   0% &#x2F;dev</span><br><span class="line">securityfs     securityfs          0       0         0    - &#x2F;sys&#x2F;kernel&#x2F;security</span><br><span class="line">tmpfs         tmpfs          899460     708    898752   1% &#x2F;dev&#x2F;shm</span><br><span class="line">devpts         devpts              0       0         0    - &#x2F;dev&#x2F;pts</span><br><span class="line">tmpfs         tmpfs          899460     496    898964   1% &#x2F;run</span><br><span class="line">tmpfs         tmpfs          899460       0    899460   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">cgroup         cgroup              0       0         0    - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;systemd</span><br><span class="line">pstore         pstore              0       0         0    - &#x2F;sys&#x2F;fs&#x2F;pstore</span><br><span class="line">cgroup         cgroup              0       0         0    - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;freezer</span><br><span class="line">cgroup         cgroup              0       0         0    - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</span><br><span class="line">cgroup         cgroup              0       0         0    - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;hugetlb</span><br><span class="line">cgroup         cgroup              0       0         0    - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;blkio</span><br><span class="line">cgroup         cgroup              0       0         0    - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;net_cls,net_prio</span><br><span class="line">cgroup         cgroup              0       0         0    - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory</span><br><span class="line">cgroup         cgroup              0       0         0    - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;pids</span><br><span class="line">cgroup         cgroup              0       0         0    - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct</span><br><span class="line">cgroup         cgroup              0       0         0    - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;devices</span><br><span class="line">cgroup         cgroup              0       0         0    - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;perf_event</span><br><span class="line">configfs       configfs            0       0         0    - &#x2F;sys&#x2F;kernel&#x2F;config</span><br><span class="line">&#x2F;dev&#x2F;vda1     ext4         41152812 6586748  32662356  17% &#x2F;</span><br><span class="line">systemd-1      -                   -       -         -    - &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;binfmt_misc</span><br><span class="line">mqueue         mqueue              0       0         0    - &#x2F;dev&#x2F;mqueue</span><br><span class="line">debugfs       debugfs             0       0         0    - &#x2F;sys&#x2F;kernel&#x2F;debug</span><br><span class="line">hugetlbfs     hugetlbfs           0       0         0    - &#x2F;dev&#x2F;hugepages</span><br><span class="line">tmpfs         tmpfs          179896       0    179896   0% &#x2F;run&#x2F;user&#x2F;0</span><br><span class="line">binfmt_misc   binfmt_misc         0       0         0    - &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;binfmt_misc</span><br><span class="line"># 将 &#x2F;etc 底下的可用的磁盘容量以易读的容量格式显示</span><br><span class="line"></span><br><span class="line">[root@kuangshen &#x2F;]# df -h &#x2F;etc</span><br><span class="line">Filesystem     Size Used Avail Use% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;vda1       40G  6.3G   32G  17% &#x2F;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>du</p>
</blockquote>
<p>Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令。</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du [-ahskm] 文件或目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li>
<li>-h ：以人们较易读的容量格式 (G/M) 显示；</li>
<li>-s ：列出总量而已，而不列出每个各别的目录占用容量；</li>
<li>-S ：不包括子目录下的总计，与 -s 有点差别。</li>
<li>-k ：以 KBytes 列出容量显示；</li>
<li>-m ：以 MBytes 列出容量显示；</li>
</ul>
<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 只列出当前目录下的所有文件夹容量（包括隐藏文件夹）:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。</span></span><br><span class="line">[root@kuangshen home]# du</span><br><span class="line">16./redis</span><br><span class="line">8./www/.oracle_jre_usage  # 包括隐藏文件的目录</span><br><span class="line">24./www</span><br><span class="line">48.                        # 这个目录(.)所占用的总量</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将文件的容量也列出来</span></span><br><span class="line">[root@kuangshen home]# du -a</span><br><span class="line">4./redis/.bash_profile</span><br><span class="line">4./redis/.bash_logout    </span><br><span class="line">....中间省略....</span><br><span class="line">4./kuangstudy.txt # 有文件的列表了</span><br><span class="line">48.</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查根目录底下每个目录所占用的容量</span></span><br><span class="line">[root@kuangshen home]# du -sm /*</span><br><span class="line">0/bin</span><br><span class="line">146/boot</span><br><span class="line">.....中间省略....</span><br><span class="line">0/proc</span><br><span class="line">.....中间省略....</span><br><span class="line">1/tmp</span><br><span class="line">3026/usr  # 系统初期最大就是他了啦！</span><br><span class="line">513/var</span><br><span class="line">2666/www</span><br></pre></td></tr></table></figure>

<p>通配符 * 来代表每个目录。</p>
<p>与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据。</p>
<blockquote>
<p>磁盘挂载与卸除</p>
</blockquote>
<p>根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”，此目录即为“挂载点”,解除此关联关系的过程称之为“卸载”</p>
<p>Linux 的磁盘挂载使用mount命令，卸载使用umount命令。</p>
<p>磁盘挂载语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将 /dev/hdc6 挂载到 /mnt/hdc6 上面！</span></span><br><span class="line">[root@www ~]# mkdir /mnt/hdc6</span><br><span class="line">[root@www ~]# mount /dev/hdc6 /mnt/hdc6</span><br><span class="line">[root@www ~]# df</span><br><span class="line">Filesystem           1K-blocks     Used Available Use% Mounted on</span><br><span class="line">/dev/hdc6              1976312     42072   1833836   3% /mnt/hdc6</span><br></pre></td></tr></table></figure>

<p>磁盘卸载命令 umount 语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">umount [-fn] 装置文件名或挂载点</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；</li>
<li>-n ：不升级 /etc/mtab 情况下卸除。</li>
</ul>
<p>卸载/dev/hdc6</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www ~]# umount /dev/hdc6</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>java log.md</title>
    <url>/2021/09/16/Java/log/java%20log/</url>
    <content><![CDATA[<h1 id="Java-Log"><a href="#Java-Log" class="headerlink" title="Java Log"></a>Java Log</h1><p>SLF4j是日志门面api，log4j、log4j2、logback才是真正的日志实现库</p>
<p>参考文档</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">https://github.com/sunwu51/notebook/blob/master/19.11/log_java%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6.md</span></span><br></pre></td></tr></table></figure>



<p><img src="https://i.loli.net/2021/09/16/9aYFnwqPdWl1krm.png" alt="image-20210916100026474"></p>
<h1 id="日志的关键组成"><a href="#日志的关键组成" class="headerlink" title="日志的关键组成"></a>日志的关键组成</h1><p><img src="https://i.loli.net/2021/09/16/UVEZTL1qHdYo3Pr.png" alt="image-20210916144322211"></p>
<h1 id="各个库单独使用"><a href="#各个库单独使用" class="headerlink" title="各个库单独使用"></a>各个库单独使用</h1><h2 id="1-log4j"><a href="#1-log4j" class="headerlink" title="1 log4j"></a>1 log4j</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>classpath下配置文件log4j.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">INFO,console</span></span><br><span class="line"><span class="meta">log4j.appender.console</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.console.target</span>=<span class="string">System.out</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%p] %c: %m%n</span></span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = Logger.getLogger(Main<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-log4j2"><a href="#2-log4j2" class="headerlink" title="2 log4j2"></a>2 log4j2</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>classpath下log4j2.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">rootLogger.level</span> = <span class="string">info</span></span><br><span class="line"><span class="meta">rootLogger.appenderRef.stdout.ref</span> = <span class="string">STDOUT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">appender.console.type</span> = <span class="string">Console</span></span><br><span class="line"><span class="meta">appender.console.name</span> = <span class="string">STDOUT</span></span><br><span class="line"><span class="meta">appender.console.layout.type</span> = <span class="string">PatternLayout</span></span><br><span class="line"><span class="meta">appender.console.layout.pattern</span> = <span class="string">%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%p] %c: %m%n</span></span><br><span class="line"><span class="attr">import</span> <span class="string">org.apache.logging.log4j.LogManager;</span></span><br><span class="line"><span class="attr">import</span> <span class="string">org.apache.logging.log4j.Logger;</span></span><br><span class="line"><span class="attr">...</span></span><br><span class="line"><span class="attr">static</span> <span class="string">final Logger LOGGER = LogManager.getLogger(Main.class);</span></span><br></pre></td></tr></table></figure>

<h2 id="3-logback"><a href="#3-logback" class="headerlink" title="3 logback"></a>3 logback</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>classpath下logback.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"console"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%p] %c: %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"debug"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">...</span><br><span class="line">static final Logger LOGGER = LoggerFactory.getLogger(Main.class);</span><br></pre></td></tr></table></figure>

<h1 id="各个库实现slf4j标准使用"><a href="#各个库实现slf4j标准使用" class="headerlink" title="各个库实现slf4j标准使用"></a>各个库实现slf4j标准使用</h1><p>注意：logback本身就是实现slf4j的，如上代码中的logger本就是slf4j的。</p>
<p>log4j实现方式，引入slf4j-log4j12</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.29<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>log4j2的实现方式，引入log4j-slf4j-impl</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样<code>组装</code>后就可以用slf4j的写法了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Main<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h1 id="多依赖项目的日志统一"><a href="#多依赖项目的日志统一" class="headerlink" title="多依赖项目的日志统一"></a>多依赖项目的日志统一</h1><p>事实上，我们的项目可能有很多依赖，各个依赖有可能有着各不相同的日志实现方式。比如我们有五个依赖，他们分别是：</p>
<ul>
<li>独立log4j</li>
<li>独立log4j2</li>
<li>slf化log4j</li>
<li>slf化log4j2</li>
<li>slf化logback 因为logback只能slf化，没有独立使用的方式，所以是5种。</li>
</ul>
<p>而当前我们项目期望使用logback，并期望统一为slf化的logback形式，<code>只配置一个logback.xml就能对所有依赖进行配置</code>。以下配置几乎是万能的，当遇到问题的时候，直接全部拷贝进去，稳定解决，绝不复发。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 处理单独log4j的依赖： --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用log4j-over-slf4j替换log4j，使依赖中的log4j也能"实现"slf4j--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.29<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>99.99.99<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 处理单独log4j2的依赖： --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用log4j-to-slf4j替换log4j2，使依赖中的log4j2也能"实现"slf4j --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-to-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>99.99.99<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 处理slf化的log4j的依赖: --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 因为slf选binding的时候有多个候选,为防止slf4j-log4j12选中,直接去掉他 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>99.99.99<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 处理slf化的log4j2的依赖: --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 因为slf选binding的时候有多个候选,为防止log4j-slf4j-impl选中,直接去掉他 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>99.99.99<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 最后引个新版本的logback --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>slf4j-log4j12:与log4j联合使用，用于使当前项目的log4j实现slf标准</li>
<li>log4j-slf4j-impl:与log4j2联合使用，用于使当前项目的log4j实现slf标准</li>
<li>log4j-over-slf4j:与剔除log4j联合使用，替换log4j，使log4j实现slf。用于让单独用log4j的依赖能遵循slf，进而统一日志配置。</li>
<li>log4j-to-slf4j:与剔除log4j2联合使用，替换log4j2，使log4j2实现slf。用于让单独用log4j2的依赖能遵循slf，进而统一日志配置。</li>
</ul>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>slf4j是门面，大的设计模式是门面系统，而logback是直接实现了slf4j-api中的接口，是通过接口实现的方式完成了门面的实现。</p>
<p>而log4j和log4j2没有直接实现接口，所以需要个适配器。slf4j-log4j12和log4j-slf4j-impl就是<code>适配器</code>，将原本不能实现slf4j的变得也能实现这个标准了。添加了适配器后，就能使用slf4j的接口来使用log4j了。</p>
<p><img src="https://i.loli.net/2021/09/16/6KQoZYRtJucw1CO.png" alt="image-20210916104535414"></p>
<p>项目的依赖中独立使用了log4j/log4j2，注意是依赖中，这时候想要统一到slf4j上来，就需要log4j-over-slf4j/log4j-to-slf4j。 以log4j-over-slf4j为例，他实际上是重写了log4j所有的类，将原来的info、debug等等方法委托给slf4j执行了，上面我们将log4j用不存在版本的方式彻底剔除了log4j中的类，使依赖加载的类被偷梁换柱为log4j-over-slf4j中的logger，这个logger中方法又委托给slf4j，slf4j向下找binding找到仅存的logback。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>2.hive调优大全.md</title>
    <url>/2021/08/06/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/hive/2.hive%E8%B0%83%E4%BC%98%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h1 id="1-Hive调优原则"><a href="#1-Hive调优原则" class="headerlink" title="1.Hive调优原则"></a>1.Hive调优原则</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、对于大数据计算引擎来说：数据量大不是问题，数据倾斜是个问题。</span><br><span class="line"></span><br><span class="line">2、Hive的复杂HQL底层会转换成多个MapReduce Job并行或者串行执行，Job数比较多的作业运行效率相对比较低，比如即使只有几百行数据的表，如果多次关联多次汇总，产生十几个Job，耗时很长。原因是 MapReduce 作业初始化的时间是比较长的。</span><br><span class="line"></span><br><span class="line">3、在进行 Hive 大数据分析时，常见的聚合操作比如 sum，count，max，min，UDAF 等 ，不怕数据倾斜问题，MapReduce 在 Mapper 阶段 的预聚合操作，使数据倾斜不成问题。</span><br><span class="line"></span><br><span class="line">4、好的建表设计，模型设计事半功倍。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5、设置合理的 MapReduce 的 Task 并行度，能有效提升性能。比如，10w+数据量 级别的计算，用 100 个 reduceTask，那是相当的浪费，1个足够，但是如果是亿级别的数据量，那么1个 Task 又显得捉襟见肘</span><br><span class="line"></span><br><span class="line">6、了解数据分布，自己动手解决数据倾斜问题是个不错的选择。这是通用的算法优化，但算法优化有时不能适应特定业务背景，开发人员了解业务，了解数据，可以通过业务逻辑精确有效的解决数据倾斜问题。</span><br><span class="line"></span><br><span class="line">7、数据量较大的情况下，慎用 count(distinct)，group by 容易产生倾斜问题。</span><br><span class="line"></span><br><span class="line">8、对小文件进行合并，是行之有效的提高调度效率的方法，假如所有的作业设置合理的文件数，对任务的整体调度效率也会产生积极的正向影响</span><br><span class="line"></span><br><span class="line">9、优化时把握整体，单个作业最优不如整体最优。</span><br><span class="line"></span><br><span class="line">10、优化 MySQL 的 SQL优化技巧，是不适用在 Hive 的</span><br></pre></td></tr></table></figure>



<h1 id="2-Hive调优经典案例"><a href="#2-Hive调优经典案例" class="headerlink" title="2.Hive调优经典案例"></a>2.Hive调优经典案例</h1>]]></content>
      <categories>
        <category>大数据</category>
        <category>Hive</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>1.Hive企业最佳实践.md</title>
    <url>/2021/07/27/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/hive/1.Hive%E4%BC%81%E4%B8%9A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="1-课程预告"><a href="#1-课程预告" class="headerlink" title="1.课程预告"></a>1.课程预告</h1><p>关于hive的内容，有3次课程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.Hive 企业最佳实践案例和面试题解析</span><br><span class="line">2.Hive 史诗级30招调优详解</span><br><span class="line">3.Hive SQL编译成MapReduce源码解析</span><br></pre></td></tr></table></figure>

<p>关于hive的知识，重点在于应用！主要集中在以下两点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.利用hive组织管理企业级PB级数据集</span><br><span class="line">2.顺利熟练编写企业级SQL实现</span><br></pre></td></tr></table></figure>



<h1 id="2-本次课程内容"><a href="#2-本次课程内容" class="headerlink" title="2.本次课程内容"></a>2.本次课程内容</h1><p>主要讲解关于HIVE SQL的编写技巧强化和思维训练</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.Hive的架构设计和SQL语句复习总结</span><br><span class="line">2.Hive的窗口分析函数详解</span><br><span class="line">3.Hive的JSON，复杂数据类型，transform处理解读</span><br><span class="line">4.Hive的三大典型需求分析和企业案例完整实现</span><br><span class="line">	自连接</span><br><span class="line">	TopN</span><br><span class="line">	行列转换</span><br><span class="line">5.Hive全局排序</span><br><span class="line">6.Hive的典型常见面试题型分析和思路总结</span><br><span class="line">7.Hive菜单：二进制思维</span><br></pre></td></tr></table></figure>



<h1 id="3-详细课程内容"><a href="#3-详细课程内容" class="headerlink" title="3.详细课程内容"></a>3.详细课程内容</h1><h2 id="3-1-Hive的架构设计和SQL语句复习总结"><a href="#3-1-Hive的架构设计和SQL语句复习总结" class="headerlink" title="3.1 Hive的架构设计和SQL语句复习总结"></a>3.1 Hive的架构设计和SQL语句复习总结</h2><h3 id="3-1-1-Hive离线数仓工具"><a href="#3-1-1-Hive离线数仓工具" class="headerlink" title="3.1.1 Hive离线数仓工具"></a>3.1.1 Hive离线数仓工具</h3><p><a href="http://hive.apache.org" target="_blank" rel="noopener">http://hive.apache.org</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.Hive是由Facebook实现并开源</span><br><span class="line">2.Hive是基于Hadoop的一个数据仓库工具</span><br><span class="line">3.Hive存储的数据位于HDFS</span><br><span class="line">4.Hive将HDFS的结构化数据映射为一张数据库表，类似于mysql</span><br><span class="line">5.Hive提供HQL查询功能</span><br><span class="line">6.Hive的本质是将SQL语句转换为MapReduce任务运行，让不熟悉MapReduce的用户方便利用HQL编写业务逻辑来计算HFDS上的结构化数据，适用于离线的批处理计算</span><br><span class="line">7.Hive极大简化了分布式计算程序的编写，将精力集中于业务逻辑</span><br></pre></td></tr></table></figure>

<p>总结：Hive依赖于HDFS存储数据，Hive将HQL转化为MapReduce执行，所以HIve是基于Hadoop的一个数据仓库工具，实质就是一个基于HDFS的MapReduce计算框架，对HDFS中的数据进行分析和管理</p>
<h3 id="3-1-2-架构原理"><a href="#3-1-2-架构原理" class="headerlink" title="3.1.2 架构原理"></a>3.1.2 架构原理</h3><p>Hive的组成分为以下4个部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.Hive的用户接口：指的是用户可以用哪些方式使用hive（命令行 web ui）</span><br><span class="line">2.Thrift server</span><br><span class="line">3.元数据库：存储了SQL语句转换成mapreduce的时候的程序输入和HDFS上的某个目录的映射（还包括：表中的字段和数据中的切分字段的映射）把存储在HDFS上的数据抽象成二维表格，table &#x3D;&gt; hdfs directory</span><br><span class="line">from table  &#x3D;&gt; mapreduce input &#x3D; hdfs path</span><br><span class="line">4.内部四大核心组件</span><br><span class="line">驱动器Driver 编译器compiler,优化器Optimizer，执行器Executor</span><br><span class="line">联合起来，完成从SQL到Mapreduce的编译转换</span><br></pre></td></tr></table></figure>



<p><img src="https://i.loli.net/2021/07/29/EqL1fbNwB7lctVM.png" alt="image-20210729143241422"></p>
<h3 id="3-1-3-HQL语法总结"><a href="#3-1-3-HQL语法总结" class="headerlink" title="3.1.3 HQL语法总结"></a>3.1.3 HQL语法总结</h3><p>支持的语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、select * from db.table1</span><br><span class="line">2、select count(distinct uid) from db.table1</span><br><span class="line">3、支持select、union all、join(left、right、full join)、like、where、having、limit等标准语法</span><br><span class="line">4、支持各种普通函数，聚合函数、表格函数</span><br><span class="line">5、支持json解析</span><br><span class="line">6、支持函数自定义：UDF（User Defined Function）&#x2F; UDAF&#x2F;UDTF</span><br><span class="line">7、不支持update和delete，不管新老版本都不支持，而且没有支持的必要！</span><br><span class="line">	原因：1.没有必要，Hive数仓，存储的都是一些反应历史变化的数据，没有必要修改  2.底层依赖于HDFS存储数据，依赖于mapreduce计算数据，支持高性能的顺序读写，支持不了高性能的随机读写（mapreduce修改某条记录其实会把所有数据扫描一遍，把其中需要修改的数据修改后，然后把所有数据输出到另外一个新文件中）</span><br><span class="line">8、hive虽然支持in&#x2F;exists（hive-0.8.x老版本不支持），但是hive推荐使用semi join的方式来代替实现，而且效率更高。</span><br><span class="line">9、支持case … when …</span><br><span class="line">10、支持if函数多条件分支，对于null的处理，通过nvl()函数来实现</span><br></pre></td></tr></table></figure>

<p>不支持的语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、支持 and多条件join，不支持 or 多条件join</span><br><span class="line">select a.*, b.* from a join b on a.id &#x3D; b.id and a.name &#x3D; b.name; √√√√√</span><br><span class="line">select a.*, b.* from a join b on a.id &#x3D; b.id or a.name &#x3D; b.name;   xxxxx</span><br><span class="line">原因：mapreduce自身的抽象造成的：数据处理过程中，会把每一条数据抽象成key-value然后会按照key进行shuffle，</span><br><span class="line">and 的时候就是id,name作为联合体作为key，但是or的时候就无法确定了</span><br><span class="line"></span><br><span class="line">2、默认情况下，不支持笛卡尔积select a.*, b.* from a, b;</span><br><span class="line"></span><br><span class="line">3.支持等值连接，不支持非等值连接</span><br><span class="line">select a.*, b.* from a join b on a.age &#x3D; b.age  √√√√√</span><br><span class="line">select a.*, b.* from a join b on a.age &gt; b.age   xxxxx</span><br></pre></td></tr></table></figure>

<p><strong>注意：这里经过测试spark sql是可以的，具体原因待研究</strong></p>
<h3 id="3-1-4-Hive的函数简单总结"><a href="#3-1-4-Hive的函数简单总结" class="headerlink" title="3.1.4 Hive的函数简单总结"></a>3.1.4 Hive的函数简单总结</h3><p>hive提供的函数很多，不敢是哪个函数，按照下面三步就可以学会了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.通过show functions获取所有函数列表，混脸熟</span><br><span class="line">2.通过desc function extended 函数名 来获取函数具体的使用方式</span><br><span class="line">3.如果还不会使用，百度</span><br></pre></td></tr></table></figure>

<p>函数的自定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.UDF  一对一  length()</span><br><span class="line">2.UDAF 多对一  max() min()</span><br><span class="line">3.UDTF explode()</span><br></pre></td></tr></table></figure>

<h3 id="3-1-5-复杂函数"><a href="#3-1-5-复杂函数" class="headerlink" title="3.1.5 复杂函数"></a>3.1.5 复杂函数</h3><p>get_json_object</p>
<p>1、先加载 rating.json 文件到 hive 的一个原始表 rate_json_1_raw</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> jsondb;<span class="keyword">use</span> jsondb;<span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> rate_json_1_raw;<span class="keyword">create</span> <span class="keyword">table</span> rate_json_1_raw(line <span class="keyword">string</span>) <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span>;<span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'/opt/module/data/rating.json'</span> <span class="keyword">into</span> <span class="keyword">table</span> rate_json_1_raw;<span class="keyword">select</span> line <span class="keyword">from</span> rate_json_1_raw <span class="keyword">limit</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>2、创建 rate_json_2_detail 这张表用来存储解析 json 出来的字段：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> rate_json_2_detail (movie <span class="built_in">int</span>, rate <span class="built_in">int</span>, unixtime <span class="built_in">int</span>, userid <span class="built_in">int</span>) <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span>;</span><br></pre></td></tr></table></figure>

<p>3、解析 json，得到结果之后存入 rate_json_2_detail表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> rate_json_2_detail</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">get_json_object(line,<span class="string">'$.movie'</span>) <span class="keyword">as</span> moive,</span><br><span class="line">get_json_object(line,<span class="string">'$.rate'</span>) <span class="keyword">as</span> rate,</span><br><span class="line">get_json_object(line,<span class="string">'$.timeStamp'</span>) <span class="keyword">as</span> unixtime,</span><br><span class="line">get_json_object(line,<span class="string">'$.uid'</span>) <span class="keyword">as</span> userid </span><br><span class="line"><span class="keyword">from</span> rate_json_1_raw;</span><br></pre></td></tr></table></figure>

<p>4.检查数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> rate_json_2_detail <span class="keyword">limit</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-6-Transform语法"><a href="#3-1-6-Transform语法" class="headerlink" title="3.1.6 Transform语法"></a>3.1.6 Transform语法</h3><p>需求：把时间戳变成星期编号（1-7）</p>
<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、内置函数</span><br><span class="line">2、自定义函数</span><br><span class="line">3、使用Transform语法： 使用外部脚本充当自定义函数 y&#x3D;f(x)</span><br></pre></td></tr></table></figure>

<p>方案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、函数 或者 自定义函数 轻松实现转换</span><br><span class="line">2、运维人员编写 Shell 脚本，或者 Python 脚本，hive 来调用执行转换。这就是 transform</span><br></pre></td></tr></table></figure>

<p>先编辑一个 python 脚本文件：weekday_mapper.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin: </span><br><span class="line">    line = line.strip()</span><br><span class="line">    movie,rate,unixtime,userid = line.split(<span class="string">'\t'</span>) </span><br><span class="line">    weekday = datetime.datetime.fromtimestamp(float(unixtime)).isoweekday()  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\t'</span>.join([movie, rate, str(weekday), userid])</span><br></pre></td></tr></table></figure>

<p>然后，将文件加入 hive 的 classpath：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">hive&gt;</span><span class="bash"> add file /opt/module/data/weekday_mapper.py;</span></span><br></pre></td></tr></table></figure>

<p>创建最后的用来存储调用 python 脚本解析出来的数据的表：rate_json_3_result</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> rate_json_3_result(movie <span class="built_in">int</span>,rate <span class="built_in">int</span>,<span class="keyword">weekday</span> <span class="built_in">int</span>,userid <span class="built_in">int</span>) <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span>;</span><br></pre></td></tr></table></figure>

<p>执行转换：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> rate_json_3_result</span><br><span class="line"><span class="keyword">select</span> transform(movie,rate,unixtime,userid) <span class="keyword">using</span> <span class="string">'python weekday_mapper.py'</span> <span class="keyword">as</span>(movie,rate,<span class="keyword">weekday</span>,userid) <span class="keyword">from</span> rate_json_2_detail;</span><br></pre></td></tr></table></figure>

<p>transform(…)为输入，as(…)为输出</p>
<p>查看数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> rate_json_3_result <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span>(<span class="keyword">weekday</span>) <span class="keyword">from</span> rate_json_3_result;</span><br></pre></td></tr></table></figure>



<h3 id="3-1-7-Hive的窗口分析函数详解"><a href="#3-1-7-Hive的窗口分析函数详解" class="headerlink" title="3.1.7 Hive的窗口分析函数详解"></a>3.1.7 Hive的窗口分析函数详解</h3><p>窗口分析函数：窗口函数也称为OLAP（OnlineAnalytical Processing）函数，是对一组值进行操作，不需要使用Group by子句对数据进行分组，还能在同一行返回原来行的列和使用聚合函数得到的聚合列。</p>
<p>官网：<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+WindowingAndAnalyti" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+WindowingAndAnalyti</a></p>
<h4 id="1-sum-avg-max-min"><a href="#1-sum-avg-max-min" class="headerlink" title="1.sum, avg, max, min"></a>1.sum, avg, max, min</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cookieid,createtime,pv,</span><br><span class="line"><span class="keyword">SUM</span>(pv) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime) <span class="keyword">AS</span> pv1,  <span class="comment">-- 默认为从起点到当前行</span></span><br><span class="line"><span class="keyword">SUM</span>(pv) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="keyword">UNBOUNDED</span> <span class="keyword">PRECEDING</span> <span class="keyword">AND</span> <span class="keyword">CURRENT</span> <span class="keyword">ROW</span>) <span class="keyword">AS</span> pv2,  <span class="comment">--从起点到当前行，结果同pv1</span></span><br><span class="line"><span class="keyword">SUM</span>(pv) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid) <span class="keyword">AS</span> pv3, <span class="comment">--分组内所有行</span></span><br><span class="line"><span class="keyword">SUM</span>(pv) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">PRECEDING</span> <span class="keyword">AND</span> <span class="keyword">CURRENT</span> <span class="keyword">ROW</span>) <span class="keyword">AS</span> pv4,    <span class="comment">--当前行+往前3行</span></span><br><span class="line"><span class="keyword">SUM</span>(pv) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">PRECEDING</span> <span class="keyword">AND</span> <span class="number">1</span> <span class="keyword">FOLLOWING</span>) <span class="keyword">AS</span> pv5,       <span class="comment">--当前行+往前3行+往后1行</span></span><br><span class="line"><span class="keyword">SUM</span>(pv) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="keyword">CURRENT</span> <span class="keyword">ROW</span> <span class="keyword">AND</span> <span class="keyword">UNBOUNDED</span> <span class="keyword">FOLLOWING</span>) <span class="keyword">AS</span> pv6     <span class="comment">--当前行+往后所有行FROM cookie1 order by cookieid, createtime;</span></span><br></pre></td></tr></table></figure>



<p>扩展</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果不指定ROWS BETWEEN,默认为从起点到当前行;</span><br><span class="line">如果不指定ORDER BY，则将分组内所有值累加;</span><br><span class="line">关键是理解ROWS BETWEEN含义,也叫做WINDOW子句： </span><br><span class="line">PRECEDING：往前 </span><br><span class="line">FOLLOWING：往后 </span><br><span class="line">CURRENT ROW：当前行 </span><br><span class="line">UNBOUNDED：起点，</span><br><span class="line">UNBOUNDED PRECEDING 表示从前面的起点， </span><br><span class="line">UNBOUNDED FOLLOWING：表示到后面的终点</span><br></pre></td></tr></table></figure>



<h4 id="2-row-number-rank-dense-rank"><a href="#2-row-number-rank-dense-rank" class="headerlink" title="2.row_number, rank, dense_rank"></a>2.row_number, rank, dense_rank</h4><p>ROW_NUMBER() – 从1开始，按照顺序，生成分组内记录的序列</p>
<p>RANK() 生成数据项在分组中的排名，排名相等会在名次中留下空位</p>
<p>DENSE_RANK() 生成数据项在分组中的排名，排名相等会在名次中不会留下空位</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cookieid, createtime, pv,  </span><br><span class="line"><span class="keyword">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> pv <span class="keyword">desc</span>) <span class="keyword">AS</span> rn1,  </span><br><span class="line"><span class="keyword">DENSE_RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> pv <span class="keyword">desc</span>) <span class="keyword">AS</span> rn2,  </span><br><span class="line">ROW_NUMBER() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> pv <span class="keyword">DESC</span>) <span class="keyword">AS</span> rn3FROM cookie2 <span class="keyword">WHERE</span> cookieid = <span class="string">'cookie1'</span>;</span><br></pre></td></tr></table></figure>



<h4 id="3-ntile-cume-dist-percent-rank"><a href="#3-ntile-cume-dist-percent-rank" class="headerlink" title="3.ntile, cume_dist, percent_rank"></a>3.ntile, cume_dist, percent_rank</h4><h4 id="4-lag-lead-frist-value-last-value"><a href="#4-lag-lead-frist-value-last-value" class="headerlink" title="4.lag, lead, frist_value, last_value"></a>4.lag, lead, frist_value, last_value</h4><h4 id="5-grouping-sets-grouping-id-cube-rollup"><a href="#5-grouping-sets-grouping-id-cube-rollup" class="headerlink" title="5.grouping sets, grouping__id, cube,rollup"></a>5.grouping sets, grouping__id, cube,rollup</h4><h3 id="3-1-8-三大典型需求"><a href="#3-1-8-三大典型需求" class="headerlink" title="3.1.8  三大典型需求"></a>3.1.8  三大典型需求</h3><h4 id="1-自连接"><a href="#1-自连接" class="headerlink" title="1.自连接"></a>1.自连接</h4><h4 id="2-TopN"><a href="#2-TopN" class="headerlink" title="2.TopN"></a>2.TopN</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> exercise_topn_dw <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> a.id <span class="keyword">as</span> <span class="keyword">id</span>, a.name <span class="keyword">as</span> <span class="keyword">name</span>, a.age <span class="keyword">as</span> age, favor_view.f <span class="keyword">as</span> favor </span><br><span class="line"><span class="keyword">from</span> exercise_topn a <span class="keyword">LATERAL</span> <span class="keyword">view</span> <span class="keyword">explode</span>(<span class="keyword">split</span>(a.favors, <span class="string">"-"</span>)) favor_view <span class="keyword">as</span> f;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- favor_view为炸裂视图的别名，f为favor_view中的列名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> a.id <span class="keyword">as</span> <span class="keyword">id</span>, a.name <span class="keyword">as</span> <span class="keyword">name</span>, a.age <span class="keyword">as</span> age, a.favor <span class="keyword">as</span> favorfrom ( <span class="keyword">select</span>  b.id <span class="keyword">as</span> <span class="keyword">id</span>, b.name <span class="keyword">as</span> <span class="keyword">name</span>, b.age <span class="keyword">as</span> age, b.favor <span class="keyword">as</span> favor, row_number() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> b.favor <span class="keyword">order</span> <span class="keyword">by</span> b.age <span class="keyword">desc</span>) <span class="keyword">as</span> <span class="keyword">rank</span>  <span class="keyword">from</span> exercise_topn_dw b ) a <span class="keyword">where</span> a.rank &lt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>



<h4 id="3-行列转换"><a href="#3-行列转换" class="headerlink" title="3.行列转换"></a>3.行列转换</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> exercise_course_result2 <span class="keyword">as</span> <span class="keyword">select</span> <span class="keyword">sid</span>, <span class="keyword">max</span>(<span class="keyword">case</span> course <span class="keyword">when</span> <span class="string">"yuwen"</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> yuwen,<span class="keyword">max</span>(<span class="keyword">case</span> course <span class="keyword">when</span> <span class="string">"shuxue"</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> shuxue,<span class="keyword">max</span>(<span class="keyword">case</span> course <span class="keyword">when</span> <span class="string">"yingyu"</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> yingyufrom exercise_course <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">sid</span>;<span class="keyword">select</span> <span class="keyword">sid</span> <span class="keyword">from</span> exercise_course_result2 <span class="keyword">where</span> yuwen &lt; shuxue;</span><br></pre></td></tr></table></figure>





<h3 id="3-1-9-hive全局排序"><a href="#3-1-9-hive全局排序" class="headerlink" title="3.1.9 hive全局排序"></a>3.1.9 hive全局排序</h3><p>见：Hive经典企业案例–全局排序.pdf</p>
<p>细节：如果使用 order by 来做，最终就是一个 reduceTask 来做，所以当数据量特别大的时候，肯定行不通。</p>
<p>方案细节：必然选择多个 reduceTask + sort by 做局部排序并不能实现全局排序，稍稍改变就可以了！</p>
<p>因为默认的数据分区是：Hash散列。必要条件：只要能保证，第一个分区的所有数据，小于第二个分区，第二个分区的所有数据小于第三个分区…..</p>
<p> 最终的实现思路： 把 Hash散列 改成 范围分区！ + 分区降序排序，大的数据放第一个分区 0-100, 100-200, 200-300,…..</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> mapreduce.job.reduces = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">directory</span> <span class="string">"hdfs://hadoop277ha/hive_student_out_order3"</span> </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,sex,age,department </span><br><span class="line"><span class="keyword">from</span> exercise_student <span class="keyword">distribute</span> <span class="keyword">by</span> </span><br><span class="line">(casewhen age &gt; <span class="number">20</span> <span class="keyword">then</span> <span class="number">0</span><span class="keyword">when</span> age &gt; <span class="number">18</span> <span class="keyword">then</span> <span class="number">1</span><span class="keyword">else</span> <span class="number">2</span><span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">sort</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>



<p>有一个问题：你怎么就确定这三个分桶的界限是：20,18 呢？有可能出现的问题：这三个桶中的数据分布不均匀！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、先确定 max, min</span><br><span class="line">2、然后通过抽样了解数据分布规律</span><br><span class="line">hive采样： </span><br><span class="line">1、全量数据取 5% </span><br><span class="line">2、全量数据取 100条 </span><br><span class="line">3、全量数据取 100M</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>大数据</category>
        <category>Hive</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>springSecurity</title>
    <url>/2021/05/26/%E5%B0%9A%E7%A1%85%E8%B0%B7/spring/springSecurity/</url>
    <content><![CDATA[<h1 id="1-SpringSecurity框架简介"><a href="#1-SpringSecurity框架简介" class="headerlink" title="1.SpringSecurity框架简介"></a>1.SpringSecurity框架简介</h1><p>Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。</p>
<p>一般来说，Web应用的安全性包括用户认证(Authentication)和用户授权（Authorization）两个部分，这两点也是Spring Security重要核心功能</p>
<p>1）<strong>用户认证</strong>：用户是否能登录系统</p>
<p>2）<strong>用户授权</strong>：用户是否有权限去做某些操作（比如某些数据文件的读取修改）</p>
<h1 id="2-SpringSecurity入门案例"><a href="#2-SpringSecurity入门案例" class="headerlink" title="2.SpringSecurity入门案例"></a>2.SpringSecurity入门案例</h1><p>默认用户名：user</p>
<p>密码：Using generated security password: <strong>2fd01230-817b-4f16-b0b2-01c39849ad11</strong></p>
<p>创建springboot项目  -》引入相关的spring security依赖 -》创建测试的controller -》浏览器访问，需要进行认证，输入用户名密码</p>
<h2 id="2-1-spring-security基本原理"><a href="#2-1-spring-security基本原理" class="headerlink" title="2.1 spring security基本原理"></a>2.1 spring security基本原理</h2><p>spring security本质是一个过滤器链</p>
<h3 id="2-1-1-过滤器链"><a href="#2-1-1-过滤器链" class="headerlink" title="2.1.1 过滤器链"></a>2.1.1 过滤器链</h3><p>启动的时候可以获取到过滤器链：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFil</span><br><span class="line">ter</span><br><span class="line">org.springframework.security.web.context.SecurityContextPersistenceFilter </span><br><span class="line">org.springframework.security.web.header.HeaderWriterFilter</span><br><span class="line">org.springframework.security.web.csrf.CsrfFilter</span><br><span class="line">org.springframework.security.web.authentication.logout.LogoutFilter </span><br><span class="line">org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter </span><br><span class="line">org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter </span><br><span class="line">org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter</span><br><span class="line">org.springframework.security.web.savedrequest.RequestCacheAwareFilter</span><br><span class="line">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter</span><br><span class="line">org.springframework.security.web.authentication.AnonymousAuthenticationFilter </span><br><span class="line">org.springframework.security.web.session.SessionManagementFilter </span><br><span class="line">org.springframework.security.web.access.ExceptionTranslationFilter </span><br><span class="line">org.springframework.security.web.access.intercept.FilterSecurityInterceptor</span><br></pre></td></tr></table></figure>

<p>代码底层流程：重点看三个过滤器：</p>
<p> <strong>FilterSecurityInterceptor</strong>：是一个方法级的权限过滤器, 基本位于过滤链的最底部</p>
<p><img src="https://i.loli.net/2021/05/26/tJK4bIAC8VHs6lv.png" alt="image-20210526164842801"></p>
<p>super.beforeInvocation(fi) 表示查看之前的 filter 是否通过。</p>
<p> fi.getChain().doFilter(fi.getRequest(), fi.getResponse());表示真正的调用后台的服务。</p>
<p><strong>ExceptionTranslationFilter</strong>：是个异常过滤器，用来处理在认证授权过程中抛出的异常</p>
<p><img src="https://i.loli.net/2021/05/26/6ompqeTwOvDAhH7.png" alt="image-20210526165053164"></p>
<p><strong>UsernamePasswordAuthenticationFilter</strong> ：对/login 的 POST 请求做拦截，校验表单中用户 名，密码。</p>
<p><img src="https://i.loli.net/2021/05/26/L2uK38b9PxJlgkj.png" alt="image-20210526165206739"></p>
<h3 id="2-1-2-过滤器是如何加载的"><a href="#2-1-2-过滤器是如何加载的" class="headerlink" title="2.1.2 过滤器是如何加载的"></a>2.1.2 过滤器是如何加载的</h3><p>首先使用SpringSecurity配置过滤器      这个事情是在DelegatingFilterProxy中完成的</p>
<p><img src="https://i.loli.net/2021/05/26/o1VI5CqTFawtnhS.png" alt="image-20210526170548415"></p>
<h2 id="2-2-两个重要的接口"><a href="#2-2-两个重要的接口" class="headerlink" title="2.2 两个重要的接口"></a>2.2 两个重要的接口</h2><h3 id="2-2-1-UserDetailsService"><a href="#2-2-1-UserDetailsService" class="headerlink" title="2.2.1 UserDetailsService"></a>2.2.1 UserDetailsService</h3><p>当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。而在实际项目中 账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。 </p>
<p>如果需要自定义逻辑时，只需要实现 UserDetailsService 接口即可。接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ~ Methods</span></span><br><span class="line">	<span class="comment">// ========================================================================================================</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Locates the user based on the username. In the actual implementation, the search</span></span><br><span class="line"><span class="comment">	 * may possibly be case sensitive, or case insensitive depending on how the</span></span><br><span class="line"><span class="comment">	 * implementation instance is configured. In this case, the &lt;code&gt;UserDetails&lt;/code&gt;</span></span><br><span class="line"><span class="comment">	 * object that comes back may have a username that is of a different case than what</span></span><br><span class="line"><span class="comment">	 * was actually requested..</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> username the username identifying the user whose data is required.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a fully populated user record (never &lt;code&gt;null&lt;/code&gt;)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> UsernameNotFoundException if the user could not be found or the user has no</span></span><br><span class="line"><span class="comment">	 * GrantedAuthority</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口里面主要就是封装查询数据库用户名和密码的过程</p>
<p><img src="https://i.loli.net/2021/05/26/C2yRVfHBZP9GNFJ.png" alt="image-20210526171447670"></p>
<h3 id="2-2-2-PasswordEncoder"><a href="#2-2-2-PasswordEncoder" class="headerlink" title="2.2.2  PasswordEncoder"></a>2.2.2  PasswordEncoder</h3><p>数据加密接口，用于返回User对象里面密码加密</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示把参数按照特定的解析规则进行解析</span></span><br><span class="line"><span class="function">String <span class="title">encode</span><span class="params">(CharSequence rawPassword)</span></span>;</span><br><span class="line"><span class="comment">// 表示验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹</span></span><br><span class="line">配，则返回 <span class="keyword">true</span>；如果不匹配，则返回 <span class="keyword">false</span>。第一个参数表示需要被解析的密码。第二个</span><br><span class="line">参数表示存储的密码。</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span></span>;</span><br><span class="line"><span class="comment">// 表示如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回</span></span><br><span class="line"><span class="keyword">false</span>。默认返回 <span class="keyword">false</span>。</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">upgradeEncoding</span><span class="params">(String encodedPassword)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>BCryptPasswordEncoder</strong> 是 Spring Security 官方推荐的密码解析器，平时多使用这个解析 器。 BCryptPasswordEncoder 是对 bcrypt 强散列方法的具体实现。是基于 Hash 算法实现的单 向加密。可以通过 strength 控制加密强度，默认 10</p>
<p>查询方法演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BCryptPasswordEncoder bCryptPasswordEncoder = <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">        String zhang = bCryptPasswordEncoder.encode(<span class="string">"zhang"</span>);</span><br><span class="line">        System.out.println(<span class="string">"加密之后的数据："</span> + zhang);</span><br><span class="line">        <span class="comment">//判断原字符加密后和加密之前是否匹配</span></span><br><span class="line">        <span class="keyword">boolean</span> result = bCryptPasswordEncoder.matches(<span class="string">"zhang"</span>, zhang);</span><br><span class="line">        System.out.println(<span class="string">"比较结果："</span> + result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">加密之后的数据：$2a$10$t5pjMUj&#x2F;yrup.WxOMoJYYuKZCL0DpEj1vS7SPIY8C8tj82UFJZI.W</span><br><span class="line">比较结果：true</span><br></pre></td></tr></table></figure>



<h1 id="3-SpringSecurity-Web权限方案"><a href="#3-SpringSecurity-Web权限方案" class="headerlink" title="3.SpringSecurity Web权限方案"></a>3.SpringSecurity Web权限方案</h1><p>1）认证</p>
<p>2）授权</p>
<h2 id="3-1-设置登录的用户名和密码"><a href="#3-1-设置登录的用户名和密码" class="headerlink" title="3.1 设置登录的用户名和密码"></a>3.1 设置登录的用户名和密码</h2><h3 id="3-1-1-第一种方式：通过配置文件"><a href="#3-1-1-第一种方式：通过配置文件" class="headerlink" title="3.1.1 第一种方式：通过配置文件"></a>3.1.1 第一种方式：通过配置文件</h3><p>在application.yml中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.security.user.name&#x3D;atguigu</span><br><span class="line">spring.security.user.password&#x3D;atguigu</span><br></pre></td></tr></table></figure>

<h3 id="3-1-2-第二种方式：通过配置类"><a href="#3-1-2-第二种方式：通过配置类" class="headerlink" title="3.1.2 第二种方式：通过配置类"></a>3.1.2 第二种方式：通过配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BCryptPasswordEncoder passwordEncoder = <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">        String password = passwordEncoder.encode(<span class="string">"123"</span>);</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="string">"zhang"</span>)</span><br><span class="line">                .password(password)</span><br><span class="line">                .roles(<span class="string">"admin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认会用到PasswordEncode这个对象，需要手动创建出来，不然会报错</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">password</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-1-3-第三种方式：自定义编写实现类"><a href="#3-1-3-第三种方式：自定义编写实现类" class="headerlink" title="3.1.3 第三种方式：自定义编写实现类"></a>3.1.3 第三种方式：自定义编写实现类</h3><p>1）创建配置类，设置使用哪个UserDetailsService实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig1</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserDetailsService userDetailsService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(password());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认会用到PasswordEncode这个对象，需要手动创建出来，不然会报错</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">password</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2）编写实现类，返回User对象，User对象中有用户名密码和操作权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"userDetailsService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        List&lt;GrantedAuthority&gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"role"</span>);</span><br><span class="line">        <span class="comment">//用户名  加密的密码  用户权限</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"zhang"</span>,<span class="keyword">new</span> BCryptPasswordEncoder().encode(<span class="string">"123"</span>),auths);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-2-自定义设置登录页面，不需要认证也可以访问"><a href="#3-2-自定义设置登录页面，不需要认证也可以访问" class="headerlink" title="3.2 自定义设置登录页面，不需要认证也可以访问"></a>3.2 自定义设置登录页面，不需要认证也可以访问</h2><p>1）在配置类实现相关的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//自定义自己编写的登录页面</span></span><br><span class="line">       http.formLogin()</span><br><span class="line">               .loginPage(<span class="string">"/login.html"</span>)<span class="comment">//登录页面设置</span></span><br><span class="line">               .loginProcessingUrl(<span class="string">"/user/login"</span>)<span class="comment">//登录访问路径</span></span><br><span class="line">               .defaultSuccessUrl(<span class="string">"/test/index"</span>).permitAll()<span class="comment">//登录成功后，跳转到的路径</span></span><br><span class="line">               .and().authorizeRequests()</span><br><span class="line">               .antMatchers(<span class="string">"/"</span>,<span class="string">"/test/hello"</span>,<span class="string">"/user/login"</span>).permitAll() <span class="comment">//设置哪些路径可以直接访问，不需要认证</span></span><br><span class="line">               .anyRequest().authenticated()</span><br><span class="line">               .and().csrf().disable();<span class="comment">//关闭csrf防护</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-3-基于角色或权限进行访问控制"><a href="#3-3-基于角色或权限进行访问控制" class="headerlink" title="3.3 基于角色或权限进行访问控制"></a>3.3 基于角色或权限进行访问控制</h2><h3 id="3-3-1-hasAuthority方法"><a href="#3-3-1-hasAuthority方法" class="headerlink" title="3.3.1 hasAuthority方法"></a>3.3.1 hasAuthority方法</h3><p>如果当前的主体有指定的权限，则返回true，否则返回false</p>
<p>使用方法如下：</p>
<p>1）在配置类中设置当前访问地址有哪些权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前登录的用户，只有具有admins权限才能访问这个路径</span></span><br><span class="line">.antMatchers(<span class="string">"/test/index"</span>).hasAuthority(<span class="string">"admins"</span>)</span><br></pre></td></tr></table></figure>

<p>2）在UserDetailsService的loadUserByUsername方法中，把返回的User对象设置权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;GrantedAuthority&gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"admins"</span>);</span><br></pre></td></tr></table></figure>



<h3 id="3-3-2-hasAnyAuthority方法"><a href="#3-3-2-hasAnyAuthority方法" class="headerlink" title="3.3.2 hasAnyAuthority方法"></a>3.3.2 hasAnyAuthority方法</h3><p>如果当前的主体有任何提供的角色（给定的作为一个逗号分隔的字符串列表）的话，返回true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前登录的用户，只要具有admins,manager任意其中的一个权限就能访问这个路径</span></span><br><span class="line"> .antMatchers(<span class="string">"/test/index"</span>).hasAnyAuthority(<span class="string">"admins,manager"</span>)</span><br></pre></td></tr></table></figure>



<h3 id="3-3-3-hasRole方法"><a href="#3-3-3-hasRole方法" class="headerlink" title="3.3.3 hasRole方法"></a>3.3.3 hasRole方法</h3><p>如果用户具备给定的角色就允许访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">"/test/index"</span>).hasRole(<span class="string">"sale"</span>)</span><br></pre></td></tr></table></figure>

<p>hasRole方法的底层会在设置的role前面加上ROLE_前缀，所以在为用户赋予对应的角色的时候也要带上ROLE__前缀</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;GrantedAuthority&gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"admins,ROLE_sale"</span>);</span><br></pre></td></tr></table></figure>



<h3 id="3-3-4-hasAnyRole方法"><a href="#3-3-4-hasAnyRole方法" class="headerlink" title="3.3.4 hasAnyRole方法"></a>3.3.4 hasAnyRole方法</h3><p>表示用户具备任何一个条件都可以访问</p>
<p>1）给用户添加角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"admins,ROLE_sale"</span>);</span><br></pre></td></tr></table></figure>

<p>2）修改配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">"/test/index"</span>).hasAnyRole(<span class="string">"admins,sale"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-4-自定义403没有访问权限的页面"><a href="#3-4-自定义403没有访问权限的页面" class="headerlink" title="3.4 自定义403没有访问权限的页面"></a>3.4 自定义403没有访问权限的页面</h2><p><img src="https://i.loli.net/2021/05/28/sUkw7fPl6G1v2ju.png" alt="image-20210528151150452"></p>
<p>在配置类中配置就可以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置没有访问权限跳转的页面</span></span><br><span class="line">http.exceptionHandling().accessDeniedPage(<span class="string">"/unauth.html"</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/05/28/XDWU7ITCK4sMoP8.png" alt="image-20210528151444769"></p>
<p><img src="https://i.loli.net/2021/05/28/6HgYirklRAXhZFL.png" alt="image-20210528151457161"></p>
<h2 id="3-5-SpringSecurity认证授权常用注解的使用"><a href="#3-5-SpringSecurity认证授权常用注解的使用" class="headerlink" title="3.5 SpringSecurity认证授权常用注解的使用"></a>3.5 SpringSecurity认证授权常用注解的使用</h2><h3 id="3-5-1-Secured"><a href="#3-5-1-Secured" class="headerlink" title="3.5.1 @Secured"></a>3.5.1 @Secured</h3><p>判断用户是否具有角色，需要注意的是这里匹配的字符串需要添加前缀“ROLE_”</p>
<p>使用注解先要开启注解功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(securedEnabled = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>

<p>1）在启动类(配置类)中开启注解功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(securedEnabled = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>

<p>2）在controller的方法上使用该注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Secured</span>(&#123;<span class="string">"ROLE_sale"</span>,<span class="string">"ROLE_manager"</span>&#125;)</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/update"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello index"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>3）在UserDetailsService中为用户设置对应的角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"ROLE_sale"</span>);</span><br></pre></td></tr></table></figure>





<h3 id="3-5-2-PreAuthorize"><a href="#3-5-2-PreAuthorize" class="headerlink" title="3.5.2 @PreAuthorize"></a>3.5.2 @PreAuthorize</h3><p>这个注解适合进入方法前的权限验证，@PreAuthorize可以将登陆用户的roles/permissions参数传到方法中</p>
<p>使用需要先开启注解功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>

<p>1）开启注解功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(securedEnabled = <span class="keyword">true</span>,prePostEnabled = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>

<p>2）在controller的方法上加上注解功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/update"</span>)</span><br><span class="line">    <span class="meta">@PreAuthorize</span>(<span class="string">"hasAnyAuthority('admins')"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello update"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>3）在UserDetailsService中为用户设置对应的角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"admins,ROLE_sale"</span>);</span><br></pre></td></tr></table></figure>



<h3 id="3-5-3-PostAuthorize"><a href="#3-5-3-PostAuthorize" class="headerlink" title="3.5.3 @PostAuthorize"></a>3.5.3 @PostAuthorize</h3><p>这个注解使用的不多，在方法执行之后再进行权限验证，适合验证带有返回值的权限</p>
<p>1）开启注解功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(securedEnabled = <span class="keyword">true</span>,prePostEnabled = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>

<p>2）在controller的方法上加上注解功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/update"</span>)</span><br><span class="line">    <span class="meta">@PostAuthorize</span>(<span class="string">"hasAnyAuthority('admins')"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello update"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>3）在UserDetailsService中为用户设置对应的角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"admins,ROLE_sale"</span>);</span><br></pre></td></tr></table></figure>



<h3 id="3-5-4-PostFilter"><a href="#3-5-4-PostFilter" class="headerlink" title="3.5.4 @PostFilter"></a>3.5.4 @PostFilter</h3><p>权限验证之后对方法返回数据进行过滤，留下指定的数据</p>
<p>表达式中的filterObject引用的是方法返回值List中某一个元素</p>
<h3 id="3-5-5-PreFilter"><a href="#3-5-5-PreFilter" class="headerlink" title="3.5.5 @PreFilter"></a>3.5.5 @PreFilter</h3><p>进入控制器之前对传入的数据进行过滤</p>
<h3 id="3-5-6-权限表达式"><a href="#3-5-6-权限表达式" class="headerlink" title="3.5.6 权限表达式"></a>3.5.6 权限表达式</h3><h2 id="3-6-用户注销"><a href="#3-6-用户注销" class="headerlink" title="3.6 用户注销"></a>3.6 用户注销</h2><h2 id="3-7-基于数据库的remember-me"><a href="#3-7-基于数据库的remember-me" class="headerlink" title="3.7 基于数据库的remember me"></a>3.7 基于数据库的remember me</h2><h3 id="3-7-1-实现原理"><a href="#3-7-1-实现原理" class="headerlink" title="3.7.1 实现原理"></a>3.7.1 实现原理</h3><p><img src="https://i.loli.net/2021/09/10/hZzQKqUBtbryIgs.png" alt="image-20210910160728686"></p>
<p><img src="https://i.loli.net/2021/09/10/igLZBEP5KT3qHQ2.png" alt="image-20210910160809903"></p>
<h3 id="3-7-2-具体实现"><a href="#3-7-2-具体实现" class="headerlink" title="3.7.2 具体实现"></a>3.7.2 具体实现</h3><p>1）创建数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`persistent_logins`</span> (  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  <span class="string">`series`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  <span class="string">`token`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  <span class="string">`last_used`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,  PRIMARY <span class="keyword">KEY</span> (<span class="string">`series`</span>) ) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<p>2）注入数据源，配置对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注入数据源</span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//配置对象</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> PersistentTokenRepository <span class="title">persistentTokenRepository</span><span class="params">()</span></span>&#123;</span><br><span class="line">       JdbcTokenRepositoryImpl jdbcTokenRepository = <span class="keyword">new</span> JdbcTokenRepositoryImpl();</span><br><span class="line">       jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">       <span class="comment">//jdbcTokenRepository.setCreateTableOnStartup(true);</span></span><br><span class="line">       <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>3）配置类中配置自动登录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.and().rememberMe().tokenRepository(persistentTokenRepository())</span><br><span class="line">                .tokenValiditySeconds(<span class="number">60</span>)<span class="comment">//设置有效时长60s</span></span><br><span class="line">                .userDetailsService(userDetailsService)</span><br></pre></td></tr></table></figure>

<p>4）在登录页面中添加复选框</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"remember-me"</span> <span class="attr">title</span>=<span class="string">"记住密码"</span>&gt;</span>自动登录</span><br><span class="line">   <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="3-8-CSRF"><a href="#3-8-CSRF" class="headerlink" title="3.8 CSRF"></a>3.8 CSRF</h2><p>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p>
<p> 跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。 从Spring Security 4.0开始，默认情况下会启用CSRF保护，以防止CSRF攻击应用程序，Spring Security CSRF会针对PATCH，POST，PUT和DELETE方法进行防护。 </p>
<h3 id="3-8-1-案例"><a href="#3-8-1-案例" class="headerlink" title="3.8.1 案例"></a>3.8.1 案例</h3><p>1）在登录页面添加一个隐藏域：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span><span class="attr">th:if</span>=<span class="string">"$&#123;_csrf&#125;!=null"</span><span class="attr">th:value</span>=<span class="string">"$&#123;_csrf.token&#125;"</span><span class="attr">name</span>=<span class="string">"_csrf"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>关闭安全配置的类中的csrf </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http.csrf().disable();</span></span><br></pre></td></tr></table></figure>

<h3 id="3-8-2-原理"><a href="#3-8-2-原理" class="headerlink" title="3.8.2 原理"></a>3.8.2 原理</h3><p>1）生成csrfToken 保存到HttpSession 或者Cookie 中</p>
<p><img src="https://i.loli.net/2021/09/10/OtsYAGDT3oLqwhJ.png" alt="image-20210910165747434"></p>
<p>2）请求到来时，从请求中提取csrfToken，和保存的csrfToken 做比较，进而判断当前请求是否合法。主要通过CsrfFilter 过滤器来完成。</p>
<h1 id="4-SpringSecurity微服务权限方案"><a href="#4-SpringSecurity微服务权限方案" class="headerlink" title="4.SpringSecurity微服务权限方案"></a>4.SpringSecurity微服务权限方案</h1><p><img src="https://i.loli.net/2021/09/10/xiWrZ9qukQzFegm.png" alt="image-20210910173033004"></p>
<p>微服务权限管理主要功能：</p>
<p>1）登录（认证）</p>
<p>2）添加角色</p>
<p>3）为角色分配菜单</p>
<p>4）添加用户</p>
<p>5）为用户分配角色</p>
<h3 id="4-1-权限管理数据模型"><a href="#4-1-权限管理数据模型" class="headerlink" title="4.1 权限管理数据模型"></a>4.1 权限管理数据模型</h3><p>菜单表    角色表   用户表</p>
<p><img src="https://i.loli.net/2021/09/10/37jaPJnOmoweyXY.png" alt="image-20210910174056451"></p>
<p>添加角色，为角色分配菜单</p>
<p>添加用户，为用户分配角色</p>
<h3 id="4-2-案例涉及技术说明"><a href="#4-2-案例涉及技术说明" class="headerlink" title="4.2 案例涉及技术说明"></a>4.2 案例涉及技术说明</h3><p>1）maven</p>
<p>​    创建父工程：管理项目依赖版本</p>
<p>​    创建子模块：使用具体依赖</p>
<p>2）SpringBoot</p>
<p>​    本质上就是Spring</p>
<p>3）mybatisPlus</p>
<p>​    用于操作数据库框架</p>
<p>4）SpringCloud </p>
<p>​    主要用到：Getway网关，注册中心（Nacos）  </p>
<p>5）其它技术</p>
<p>​    redis     jwt     swagger</p>
<h3 id="4-3-项目实现"><a href="#4-3-项目实现" class="headerlink" title="4.3 项目实现"></a>4.3 项目实现</h3><h4 id="4-3-1-搭建项目工程"><a href="#4-3-1-搭建项目工程" class="headerlink" title="4.3.1 搭建项目工程"></a>4.3.1 搭建项目工程</h4><p>1）创建父工程 acl_parent:管理依赖版本</p>
<p>2）在父工程中创建子模块</p>
<p>​    ① common</p>
<p>​        service_base:工具类</p>
<p>​        spring_security:权限配置</p>
<p>​    ②infrastructure</p>
<p>​        api_gateway:网关</p>
<p>​    ③service</p>
<p>​        service_acl:权限管理微服务模块</p>
<p><img src="https://i.loli.net/2021/09/10/hjsfvDFdqunYSc5.png" alt="image-20210910181915112"></p>
<h4 id="4-3-2-开发步骤"><a href="#4-3-2-开发步骤" class="headerlink" title="4.3.2 开发步骤"></a>4.3.2 开发步骤</h4><h5 id="1）启动redis"><a href="#1）启动redis" class="headerlink" title="1）启动redis"></a>1）启动redis</h5><h5 id="2）启动nacos-注册中心）"><a href="#2）启动nacos-注册中心）" class="headerlink" title="2）启动nacos(注册中心）"></a>2）启动nacos(注册中心）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注册中心的作用是建立网关和各服务之间的关系，</span><br><span class="line">以便网关在接收到外部请求时在注册中心中找到服务相关的ip和port转发请求</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/09/13/wcZHEup9mrXOhtb.png" alt="image-20210913095828071"></p>
<p>访问地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.92.1:8848&#x2F;nacos&#x2F;index.html</span><br><span class="line">默认用户名都是nacos</span><br></pre></td></tr></table></figure>



<h5 id="3）开发common需要的工具类"><a href="#3）开发common需要的工具类" class="headerlink" title="3）开发common需要的工具类"></a>3）开发common需要的工具类</h5><p><img src="https://i.loli.net/2021/09/13/ywOgVTZCWAlJSGm.png" alt="image-20210913101001118"></p>
<h5 id="4）编写SpringSecurity认证授权工具类和处理器"><a href="#4）编写SpringSecurity认证授权工具类和处理器" class="headerlink" title="4）编写SpringSecurity认证授权工具类和处理器"></a>4）编写SpringSecurity认证授权工具类和处理器</h5><p><img src="https://i.loli.net/2021/09/13/1M4IWBGyZiTNjeA.png" alt="image-20210913103057777"></p>
<p><img src="https://i.loli.net/2021/09/13/acxJhenu4fZsqF8.png" alt="image-20210913103841413"></p>
<h5 id="5）编写自定义认证和授权过滤器"><a href="#5）编写自定义认证和授权过滤器" class="headerlink" title="5）编写自定义认证和授权过滤器"></a>5）编写自定义认证和授权过滤器</h5><p><img src="https://i.loli.net/2021/09/13/jVwLDaIKp81OYNr.png" alt="image-20210913111732822"></p>
<p><img src="https://i.loli.net/2021/09/13/hRolDKsOSNu9jnZ.png" alt="image-20210913111747926"></p>
<p><img src="https://i.loli.net/2021/09/13/TRPiO2oaBWMGVJq.png" alt="image-20210913113508236"></p>
<h5 id="6）UserDetailService实现"><a href="#6）UserDetailService实现" class="headerlink" title="6）UserDetailService实现"></a>6）UserDetailService实现</h5><p><img src="https://i.loli.net/2021/09/13/s3Ujb2kzOMehZgC.png" alt="image-20210913143254070"></p>
<h1 id="5-SpringSecurity原理总结"><a href="#5-SpringSecurity原理总结" class="headerlink" title="5.SpringSecurity原理总结"></a>5.SpringSecurity原理总结</h1>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>clickhouse深入浅出</title>
    <url>/2021/05/12/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/clickhouse/clickhouse%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/</url>
    <content><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><p>基础篇内容：clickhouse的产生背景，核心特性和逻辑架构</p>
<h2 id="1-Clickhouse产生的需求背景"><a href="#1-Clickhouse产生的需求背景" class="headerlink" title="1.Clickhouse产生的需求背景"></a>1.Clickhouse产生的需求背景</h2><p>随着数据科技的进步，数据分析师早已不再满足于传统的T+1式报表或需要提前设置好维度与指标的 OLAP查询。数据分析师更希望使用可以支持任意指标、任意维度并秒级给出反馈的大数据Ad-hoc查询 系统。这对大数据技术来说是一项非常大的挑战，传统的大数据查询引擎根本无法做到这一点。由俄罗 斯的Yandex公司开源的ClickHouse脱颖而出。在第一届易观OLAP大赛中，在用户行为分析转化漏斗场 景里，ClickHouse比Spark快了近10倍。在随后几年的大赛中，面对各类新的大数据引擎的挑战， ClickHouse一直稳稳地坐在冠军宝座上。同时在各种OLAP查询引擎评测中，ClickHouse单表查询的速 度力压现在流行的各大数据库引擎，尤其是Ad-hoc查询速度一直遥遥领先，因此被国内大量用户和爱好 者广泛用在即席查询场景当中。</p>
<p> ClickHouse的性能测试：<a href="https://clickhouse.tech/benchmark/dbms" target="_blank" rel="noopener">https://clickhouse.tech/benchmark/dbms</a></p>
<p>总结：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据分析师，他不会在乎，底层有都复杂的数据，多大量的数据，他更在乎的是，自己指定分析维度，并且进</span><br><span class="line">行交互式的分析查询（查询延迟是秒级）。</span><br></pre></td></tr></table></figure>



<h2 id="2-OLAP"><a href="#2-OLAP" class="headerlink" title="2.OLAP"></a>2.OLAP</h2><p>OLTP + OLAP： T：transaction 事务处理 侧重于增删改 A ： analysis 分析 Select大批量数据的聚合 查询 事务处理作用：保证数据的一致性，如果涉及到事务操作，这个操作的执行效率必然不高 OLAP + OLTP =====&gt; 同时满足，很难涉及 </p>
<p>MySQL： insert update delete  </p>
<p>Hive ClickHouse: Select 查询分析的高效 读模式 + 写模式 OLAP一般都是读模式， OLTP 写模式  ClickHouse一出来，界限模糊了。 ClickHouse 写模式+ OLAP </p>
<p>海量数据做查询分析高效: 列式数据库, 写模式（保证同一列的数据类型是一样的: 方便压缩），排序 </p>
<p>OLAP体系的重要三个特点： <strong>排序</strong> + <strong>写模式</strong> + <strong>列式数据库</strong> ClickHouse 全部都具备！</p>
<p><strong>写模式</strong>：写模式指的是在将数据存储到数据库之前系统会对数据进行格式的校验</p>
<p><strong>读模式</strong>：对数据格式校验的过程是在读取数据的过程中进行的，而不是再存储数据的时候</p>
<h3 id="2-1-OLAP的场景特征"><a href="#2-1-OLAP的场景特征" class="headerlink" title="2.1 OLAP的场景特征"></a>2.1 OLAP的场景特征</h3><p>读多写少；</p>
<p>大宽表，读大量列但是少量列，结果集较小；</p>
<p>数据批量写入，且数据不更新或少更新；</p>
<p>不需要事务，数据一致性要求低；</p>
<p>灵活多变，不适合预先建模</p>
<p>1）读多写少</p>
<p>不同于事务处理（OLTP）的场景，比如电商场景中加购物车、下单、支付等需要在原地进行大量 insert、update、delete操作，数据分析（OLAP）场景通常是将数据批量导入后，进行任意维度的灵 活探索、BI工具洞察、报表制作等。 数据一次性写入后，分析师需要尝试从各个角度对数据做挖掘、分析，直到发现其中的商业价值、业务 变化趋势等信息。这是一个需要反复试错、不断调整、持续优化的过程，其中数据的读取次数远多于写 入次数。这就要求底层数据库为这个特点做专门设计，而不是盲目采用传统数据库的技术架构。</p>
<p>2）大宽表，读大量列但是少量列，结果集较小</p>
<p>在OLAP场景中，通常存在一张或是几张多列的大宽表，列数高达数百甚至数千列。对数据分析处理 时，选择其中的少数几列作为维度列、其他少数几列作为指标列，然后对全表或某一个较大范围内的数 据做聚合计算。这个过程会扫描大量的行数据，但是只用到了其中的少数列。而聚合计算的结果集相比 于动辄数十亿的原始数据，也明显小得多。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> department, <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">as</span> total <span class="keyword">from</span> student <span class="keyword">group</span> <span class="keyword">by</span> department;</span><br></pre></td></tr></table></figure>



<p>3）数据批量写入，且数据不更新或少更新</p>
<p>OLTP类业务对于延时（Latency）要求更高，要避免让客户等待造成业务损失；而OLAP类业务，由于 数据量非常大，通常更加关注写入吞吐（Throughput），要求海量数据能够尽快导入完成。一旦导入 完成，历史数据往往作为存档，不会再做更新、删除操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">更新：修改 和 删除</span><br><span class="line">批量：导入 和 导出</span><br><span class="line">mysql: insert update delete , source</span><br><span class="line">clickouse: 单挑记录的增删改 批量导入导出 多</span><br></pre></td></tr></table></figure>

<p>4）不需要事务，数据一致性要求低</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OLAP类业务对于事务需求较少，通常是导入历史日志数据，或搭配一款事务型数据库并实时从事务型</span><br><span class="line">数据库中进行数据同步。多数OLAP系统都支持最终一致性。</span><br></pre></td></tr></table></figure>



<p>5）灵活多变，不适合预先建模</p>
<p>分析场景下，随着业务变化要及时调整分析维度、挖掘方法，以尽快发现数据价值、更新业务指标。而 数据仓库中通常存储着海量的历史数据，调整代价十分高昂。预先建模技术虽然可以在特定场景中加速 计算，但是无法满足业务灵活多变的发展需求，维护成本过高。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">大宽表：100个字段，用户使用其中的任意多个字段作为组合条件进行查询分析</span><br><span class="line">kylin: 做预聚合！ clichouse 也能实现这个功能：预聚合 （在数据聚合上的预）</span><br><span class="line">hive: 离线分析：预聚合(在时间上的预</span><br></pre></td></tr></table></figure>



<h2 id="3-Clickhouse官网解释"><a href="#3-Clickhouse官网解释" class="headerlink" title="3.Clickhouse官网解释"></a>3.Clickhouse官网解释</h2><p>URL地址：<a href="https://clickhouse.tech/docs/zh/#olapchang-jing-de-guan-jian-te-zheng" target="_blank" rel="noopener">https://clickhouse.tech/docs/zh/#olapchang-jing-de-guan-jian-te-zheng</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01、绝大多数请求都是读请求</span><br><span class="line">02、数据以相当大的批次(&gt;1000行)更新，而不是单行更新;或者它根本没有更新</span><br><span class="line">03、数据已添加到数据库，但不会进行修改</span><br><span class="line">04、对于读取，每次查询都从数据库中读取大量的行，但是同时又仅需要少量的列</span><br><span class="line">05、表格“宽”，意味着它们包含大量列</span><br><span class="line">06、查询相对较少(通常每台服务器数百个查询或每秒更少)</span><br><span class="line">07、对于简单查询，允许延迟大约50毫秒</span><br><span class="line">08、列中的数据相对较小：一般来说，都是数字和短字符串(例如，每个URL 60个字节)</span><br><span class="line">09、处理单个查询时需要高吞吐量(每个服务器每秒最多数十亿行)</span><br><span class="line">10、Transactions不是必需的</span><br><span class="line">11、对数据一致性要求低</span><br><span class="line">12、每个查询有一个大表。所有其他表都很小，除了这个大表</span><br><span class="line">13、查询结果明显小于源数据。换句话说，数据被过滤或聚合后能够被盛放在单台服务器的内存中</span><br></pre></td></tr></table></figure>

<p>很容易看出OLAP 场景与其他流行场景（例如OLTP或键值访问）非常不同。 因此，如果希望获得不错 的性能，尝试使用 OLTP 或 键值DB 来处理分析查询是没有意义的。 例如，如果尝试使用 MongoDB 或 Redis 进行分析，则与OLAP数据库相比，性能会非常差。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql: 少量结构化数据的针对单条记录的增删改查</span><br><span class="line">hbase： 针对海量数据的key-value增删改查</span><br><span class="line">redis: 基于内存的针对key-value类型的增删改查，热数据的缓存</span><br><span class="line">mongodb： 文档数据库</span><br><span class="line">elasticsearch: 针对文件做全文检索的（倒排索引）</span><br><span class="line">clickhouse: 针对海量数据的大量行少量列的聚合查询分析的请求</span><br></pre></td></tr></table></figure>

<h2 id="4-Clickhouse介绍"><a href="#4-Clickhouse介绍" class="headerlink" title="4.Clickhouse介绍"></a>4.Clickhouse介绍</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>ClickHouse是一个面向列的数据库管理系统（DBMS），用于在线分析处理查询（OLAP）。</p>
<p> ClickHouse官网：<a href="https://clickhouse.tech/" target="_blank" rel="noopener">https://clickhouse.tech/</a></p>
<p> ClickHouse中文社区：<a href="http://www.clickhouse.com.cn/" target="_blank" rel="noopener">http://www.clickhouse.com.cn/</a></p>
<p>ClickHouse 是俄罗斯搜索巨头 Yandex 公司早 2016年 开源的一个极具 “ 战斗力 “ 的实时数据分析数据 库，是一个用于联机分析 (OLAP:Online Analytical Processing) 的列式数据库管理系统 (DBMS:Database Management System)，简称 CK，工作速度比传统方法快100-1000倍，ClickHouse 的性能超过了目前市场上可比的面向列的DBMS。 每秒钟每台服务器每秒处理数亿至十亿多行和数十千 兆字节的数据。它允许在运行时创建表和数据库，加载数据和运行查询，而无需重新配置和重新启动服 务器，支持线性扩展，简单方便，高可靠性，容错。</p>
<p> ClickHouse 作为一个高性能 OLAP 数据库，虽然OLAP能力逆天但也不应该把它用于任何OLTP事务性 操作的场景，相比OLTP：不支持事务、不擅长根据主键按行粒度的查询、不擅长按行删除数据，目前 市场上的其他同类高性能 OLAP 数据库同样也不擅长这些方面。因为对于一款OLAP数据库而言，OLTP 能力并不是重点。 </p>
<p>ClickHouse从OLAP场景需求出发，定制开发了一套全新的高效列式存储引擎，并且实现了数据有序存 储、主键索引、稀疏索引、数据Sharding、数据Partitioning、TTL、主备复制等丰富功能。这些功能共 同为ClickHouse极速的分析性能奠定了基础。</p>
<p> ClickHouse适合流式或批次入库的时序数据。ClickHouse不应该被用作通用数据库，而是作为超高性能 的海量数据快速查询的分布式实时处理平台，在数据汇总查询方面(如GROUP BY)，ClickHouse的查询 速度非常快。</p>
<p> 典型特点总结：ROLAP、在线实时查询、完整的DBMS、列式存储、不需要任何数据预处理、支持批量 更新、具有非常完善的SQL支持和函数、支持高可用、不依赖Hadoop复杂生态、开箱即用 简单的说，ClickHouse作为分析型数据库，有三大特点：一是跑分快， 二是功能多 ，三是文艺范</p>
<ol>
<li><p><strong>跑分快： ClickHouse跑分是Vertica的5倍快：</strong></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clickHouse性能超过了市面上大部分的列式存储数据库，相比传统的数据ClickHouse要快100-1000X，</span><br><span class="line">ClickHouse还是有非常大的优势：</span><br><span class="line">100Million 数据集:ClickHouse比Vertica约快5倍，比Hive快279倍，比MySQL快801倍</span><br><span class="line">1Billion 数据集:ClickHouse比Vertica约快5倍，MySQL和Hive已经无法完成任务了</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p><strong>功能多：ClickHouse支持数据统计分析各种场合</strong></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">支持类SQL查询，</span><br><span class="line">支持繁多库函数（例如IP转化，URL分析等，预估计算&#x2F;HyperLoglog等）</span><br><span class="line">支持数组(Array)和嵌套数据结构(Nested Data Structure)</span><br><span class="line">支持数据库异地复制部署+支持分布式</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p><strong>文艺范：目前ClickHouse的限制很多，生来就是为小资服务的</strong></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 相对较缺乏的文档，社区刚开始活跃，只有开源的C++源码</span><br><span class="line">- 不理睬Hadoop生态，走自己的路</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="4-2-发展历程"><a href="#4-2-发展历程" class="headerlink" title="4.2 发展历程"></a>4.2 发展历程</h3><p><img src="https://i.loli.net/2021/05/12/KSF6iImPwMJUR4a.png" alt="image-20210512170949968"></p>
<h3 id="4-3-社区发展"><a href="#4-3-社区发展" class="headerlink" title="4.3 社区发展"></a>4.3 社区发展</h3><p><img src="https://i.loli.net/2021/05/12/wL2sdKbDyFrOZWt.png" alt="image-20210512171056967"></p>
<h3 id="4-4-适用场景"><a href="#4-4-适用场景" class="headerlink" title="4.4 适用场景"></a>4.4 适用场景</h3><p>适用场景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、Web和App数据分析</span><br><span class="line">2、广告网络和RTB</span><br><span class="line">3、电信</span><br><span class="line">4、电子商务和金融</span><br><span class="line">5、信息安全</span><br><span class="line">6、监测和遥测</span><br><span class="line">7、时序数据</span><br><span class="line">8、商业智能</span><br><span class="line">9、在线游戏</span><br><span class="line">10、物联网</span><br></pre></td></tr></table></figure>

<p>不适用场景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、事物性工作（OLTP）</span><br><span class="line">2、高并发的键值访问</span><br><span class="line">3、Blob或者文档存储</span><br><span class="line">4、超标准化的数据</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">适合：用于结构良好清晰且不可变的事件或日志流实时查询分析。</span><br><span class="line">不适合：事务性工作(OLTP)，高请求率的键值访问，低延迟的修改或删除已存在数据，Blob或文档存储，超</span><br><span class="line">标准化数据。</span><br></pre></td></tr></table></figure>



<h3 id="4-5-优点"><a href="#4-5-优点" class="headerlink" title="4.5 优点"></a>4.5 优点</h3><p>与 Hadoop、Spark 这些巨无霸组件相比，ClickHouse 具有轻量级的优点，它的特点包括以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、真正的面向列的 DBMS</span><br><span class="line">ClickHouse 作为一个被设计用来在实时分析的 OLAP 组件，只是在高效率的分析方面性能发挥到极</span><br><span class="line">致，那必然就会在其他方面做出取舍：</span><br><span class="line">ClickHouse 是一个 DBMS，而不是一个单一的数据库。它允许在运行时创建表和数据库、加载数据和运行</span><br><span class="line">查询，而无需重新配置和重新启动服务器。</span><br><span class="line"></span><br><span class="line">2、数据压缩</span><br><span class="line">一些面向列的 DBMS（InfiniDB CE 和 MonetDB）不使用数据压缩。但是，数据压缩确实提高了性能。</span><br><span class="line"></span><br><span class="line">3、磁盘存储的数据</span><br><span class="line">许多面向列的 DBMS（SAP HANA 和 GooglePowerDrill）只能在内存中工作。但即使在数千台服务器</span><br><span class="line">上，内存也太小，无法在 Yandex.Metrica 中存储所有浏览量和会话。</span><br><span class="line"></span><br><span class="line">4、多核并行处理</span><br><span class="line">多核多节点并行化大型查询。</span><br><span class="line"></span><br><span class="line">5、在多个服务器上分布式处理</span><br><span class="line">在 ClickHouse 中，数据可以驻留在不同的分片上。每个分片都可以用于容错的一组副本，查询会在所有分</span><br><span class="line">片上并行处理。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6、SQL支持</span><br><span class="line">ClickHouse SQL 跟真正的 SQL 有不一样的函数名称。不过语法基本跟 SQL 语法兼容，支持 JOIN、</span><br><span class="line">FROM、IN 和 JOIN 子句以及标量子查询支持子查询。</span><br><span class="line"></span><br><span class="line">7、向量化引擎</span><br><span class="line">数据不仅按列存储，而且由矢量 - 列的部分进行处理，这使开发者能够实现高 CPU 性能。</span><br><span class="line"></span><br><span class="line">8、实时数据更新</span><br><span class="line">ClickHouse 支持主键表。为了快速执行对主键范围的查询，数据使用合并树 (MergeTree) 进行递增排</span><br><span class="line">序。由于这个原因，数据可以不断地添加到表中。</span><br><span class="line"></span><br><span class="line">9、支持近似计算（很多组件不具备的）统计全中国到底有多少人？1434567654 14.3E PV 近似计算</span><br><span class="line">UV 具体的值</span><br><span class="line">该库支持为有限数量的随机密钥（而不是所有密钥）运行聚合。在数据中密钥分发的特定条件下，这提供了相</span><br><span class="line">对准确的结果，同时使用较少的资源。</span><br><span class="line"></span><br><span class="line">10、数据复制和对数据完整性的支持。</span><br><span class="line">ClickHouse 使用异步多主复制。写入任何可用的副本后，数据将分发到所有剩余的副本。系统在不同的副</span><br><span class="line">本上保持相同的数据。数据在失败后自动恢复。 扩展成为分布式的数据库OLAP引擎，严重依赖于zookeeper</span><br><span class="line">的</span><br></pre></td></tr></table></figure>



<h3 id="4-6-缺点"><a href="#4-6-缺点" class="headerlink" title="4.6 缺点"></a>4.6 缺点</h3><p>ClickHouse 作为一个被设计用来在实时分析的 OLAP 组件，只是在高效率的分析方面性能发挥到极 致，那必然就会在其他方面做出取舍：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、没有完整的事务支持，不支持Transaction：想快就别想Transaction</span><br><span class="line">2、缺少完整的Update&#x2F;Delete操作，缺少高频率、低延迟的修改或删除已存在数据的能力，仅能用于批量删</span><br><span class="line">除或修改数据。</span><br><span class="line">3、聚合结果必须小于一台机器的内存大小：不是大问题</span><br><span class="line">4、支持有限操作系统，正在慢慢完善</span><br><span class="line">5、开源社区刚刚启动，主要是俄语为主，中文社区：http:&#x2F;&#x2F;www.clickhouse.com.cn</span><br><span class="line">6、不适合key-value存储，不支持 Blob 等文档型数据库</span><br></pre></td></tr></table></figure>



<h3 id="4-7-Clickhouse的用户"><a href="#4-7-Clickhouse的用户" class="headerlink" title="4.7 Clickhouse的用户"></a>4.7 Clickhouse的用户</h3><p>ClickHouse 作为俄罗斯的搜索引擎巨头公司 Yandex 开源的技术，必然在 Yandex 内部得到极广泛的应用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、Yandex有十几个项目在用使用ClickHouse，它们包括：Yandex数据分析，电子邮件，广告数据分析，</span><br><span class="line">用户行为分析等等</span><br><span class="line">3、2012年，欧洲核子研究中心使用ClickHouse保存粒子对撞机产生的大量实验数据，每年的数据存储量都</span><br><span class="line">是PB级别，并支持统计分析查询</span><br><span class="line">3、最大的应用来自于Yandex的统计分析服务Yandex.Metrica，类似于谷歌Analytics(GA)，或友盟统</span><br><span class="line">计，小米统计，帮助网站或移动应用进行数据分析和精细化运营工具，据称Yandex.Metrica为世界上第二大</span><br><span class="line">的网站分析平台。ClickHouse在这个应用中，部署了近四百台机器，每天支持200亿的事件和历史总记录超</span><br><span class="line">过13万亿条记录，这些记录都存有原始数据（非聚合数据），随时可以使用SQL查询和分析，生成用户报告。</span><br></pre></td></tr></table></figure>



<p>ClickHouse是近年来备受关注的开源列式数据库，主要用于数据分析（OLAP）领域。目前国内社区火 热，各个大厂纷纷跟进大规模使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、今日头条 内部用ClickHouse来做用户行为分析，内部一共几千个ClickHouse节点，单集群最大1200</span><br><span class="line">节点，总数据量几十PB，日增原始数据300TB左右。</span><br><span class="line">2、腾讯内部用ClickHouse做游戏数据分析，并且为之建立了一整套监控运维体系。</span><br><span class="line">3、携程内部从18年7月份开始接入试用，目前80%的业务都跑在ClickHouse上。每天数据增量十多亿，近百</span><br><span class="line">万次查询请求。</span><br><span class="line">4、快手内部也在使用ClickHouse，存储总量大约10PB， 每天新增200TB， 90%查询小于3S。</span><br><span class="line">5、其他比如：趣头条，同城艺龙，京东，虎牙直播，科大讯飞，饿了么，新浪，贝壳，青云等</span><br></pre></td></tr></table></figure>



<h1 id="应用篇"><a href="#应用篇" class="headerlink" title="应用篇"></a>应用篇</h1><p>应用篇内容：clickhouse的基础用法</p>
<h1 id="原理篇"><a href="#原理篇" class="headerlink" title="原理篇"></a>原理篇</h1><p>原理篇内容：clickhouse核心功能的运行原理</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Clickhouse</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>scala</title>
    <url>/2021/05/10/%E8%AF%AD%E8%A8%80/scala/</url>
    <content><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1-Scala和Java的关系"><a href="#1-1-Scala和Java的关系" class="headerlink" title="1.1 Scala和Java的关系"></a>1.1 Scala和Java的关系</h2><p><img src="https://i.loli.net/2021/05/10/bz18Ih9uofSkVge.png" alt="image-20210510104555426"></p>
<h2 id="1-2-为什么学习scala"><a href="#1-2-为什么学习scala" class="headerlink" title="1.2 为什么学习scala"></a>1.2 为什么学习scala</h2><p>1）很多大数据的引擎框架都是基于scala进行开发的，比如spark，flink</p>
<p>2）在大数据领域中，很多场景都是数据的分析处理，scala的函数式编程开发效率高，而且直观易于理解    </p>
<h2 id="1-3-如何在不同的场景下区分使用java还是scala呢"><a href="#1-3-如何在不同的场景下区分使用java还是scala呢" class="headerlink" title="1.3 如何在不同的场景下区分使用java还是scala呢"></a>1.3 如何在不同的场景下区分使用java还是scala呢</h2><p>java：如何强调的是业务处理之间的逻辑关系，比如电商系统的用户登录，订单支付等等，那就用java，强调的是对象之间的关系，因为本身java就是面向对象的语言</p>
<p>scala：而如果强调的是数据之间的转换和分布式统计，那就采用scala，scala的函数式编程可以让处理的过程变得简单，代码开发变得更加简洁</p>
<h1 id="2-Hello-world解析"><a href="#2-Hello-world解析" class="headerlink" title="2.Hello world解析"></a>2.Hello world解析</h1><p>java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java Helloworld 执行的时候会调用类的静态方法main，是通过类来调用的，而非创建对象</p>
<p>scala</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">      println(<span class="string">"hello world"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scala是完全面向对象的语言，所以摒弃了和面向对象无关的语法内容，也就不存在通过类来调用静态方法的语法</p>
<p>如果scala中的类想要通过名称来访问方法，那么必须创建一个使用object关键字声明的特殊的对象（伴生对象），这个对象的名称</p>
<p>和类名保持一致，所以可以通过对象访问方法。</p>
<p>用这种方式来模拟java的静态语法</p>
<p>我们一般将使用<strong>object</strong>关键字声明的类称之为伴生对象，是单例的。</p>
<p><strong>def :</strong></p>
<p>​    英文单词define的缩写：表示声明一个方法</p>
<p><strong>main:</strong></p>
<p>​    表示scala语言的主方法</p>
<p><strong>args：Array[String]</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java: String[] args</span><br><span class="line">scala: args: Array[String]</span><br><span class="line">    </span><br><span class="line">java是强类型语言（无论是常量还是变量一定要有类型），静态类型语言（在编译的时候一定要明确变量的类型，而动态类型语言变量的类型是在运行的时候确定的），所以java强调的就是类型，将类型放在前面凸显出来</span><br><span class="line">    </span><br><span class="line">scala函数式编程，看重的是函数的功能不是类型，所以名称放前，类型放后面</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">[]在java中表示数组，而在scala中表示泛型</span><br></pre></td></tr></table></figure>

<p><strong>Unit:</strong></p>
<p>​    java中void关键字不是面向对象的语法内容，所以在scala中是没有的，所以在scala中提供Unit类型来代替void，模拟无返回值的场合</p>
<p><strong>=:</strong></p>
<p>​    =表示将代码逻辑进行封装赋值给方法，变量和方法都是用=赋值，体现了访问的统一性</p>
<p><strong>System.out.println():</strong></p>
<p>​    scala语言是基于java开发的，所以java的类库在scala程序中可以直接使用，但是在scala中进行了简化（println()），提高开发效率</p>
<p><strong>分号:</strong></p>
<p>​    java为了明确代码的关系，所以采用分号进行结尾，表示代码逻辑终止。为了查看方便，一般不会将多行代码写在一行中</p>
<p>​    scala为了简化开发，如果一行代码中只有一段逻辑，那么结尾的分号可省略，使用换行来分隔</p>
<p>​    如果将多个逻辑写在一行中，那么必须使用分号分隔</p>
<h1 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h1><h2 id="3-1-scala数据类型"><a href="#3-1-scala数据类型" class="headerlink" title="3.1 scala数据类型"></a>3.1 scala数据类型</h2><p>Java的数据类型包含基本类型和引用类型</p>
<p>​    基本类型：byte,short,char,int,long,float,double,boolean</p>
<p>​    引用类型：Object，数组，字符串，包装类，集合，POJO对象等</p>
<p>Scala是完全面向对象的语言，所以不存在基本数据类型的概念，分为值对象（AnyVal）和引用对象（AnyVal）</p>
<p><img src="https://i.loli.net/2021/05/10/FOKmhfiRXG9ePgD.png" alt="image-20210510144826447"></p>
<p><img src="https://i.loli.net/2021/05/10/FY5DpOiLwMtaW4z.png" alt="image-20210510144852323"></p>
<p>其中Null为空类型，只有一个对象null</p>
<p>Nothing表示没有正常值（用于异常抛出）</p>
<p>Unit表示方法没有返回值，Unit只有一个对象，这个对象为()</p>
<h2 id="3-2-类型转换"><a href="#3-2-类型转换" class="headerlink" title="3.2 类型转换"></a>3.2 类型转换</h2><p>1）自动类型转换（隐式转换）</p>
<p>2）强制类型转换</p>
<p>3）字符串类型转换</p>
<p>​    scala是完全面向对象的语言，所有的类型都提供了toString方法，可以直接转换为字符串</p>
<h1 id="4-流程控制"><a href="#4-流程控制" class="headerlink" title="4.流程控制"></a>4.流程控制</h1><h2 id="4-1-分支控制"><a href="#4-1-分支控制" class="headerlink" title="4.1 分支控制"></a>4.1 分支控制</h2><p>if…else</p>
<h2 id="4-2-循环控制"><a href="#4-2-循环控制" class="headerlink" title="4.2 循环控制"></a>4.2 循环控制</h2><h3 id="4-2-1-for循环"><a href="#4-2-1-for循环" class="headerlink" title="4.2.1 for循环"></a>4.2.1 for循环</h3><p>1）基本语法</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(循环遍历  &lt;- 数据集)&#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的数据集可以是任意类型的集合，如字符串，集合，数组等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//案例</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">for</span> ( i &lt;- <span class="type">Range</span>(<span class="number">1</span>,<span class="number">5</span>) ) &#123; <span class="comment">// 范围集合，左闭右开</span></span><br><span class="line">            println(<span class="string">"i = "</span> + i )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( i &lt;- <span class="number">1</span> to <span class="number">5</span> ) &#123; <span class="comment">// 包含5</span></span><br><span class="line">            println(<span class="string">"i = "</span> + i )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( i &lt;- <span class="number">1</span> until <span class="number">5</span> ) &#123; <span class="comment">// 不包含5</span></span><br><span class="line">            println(<span class="string">"i = "</span> + i )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）循环守卫</p>
<p>循环时可以增加条件来决定是否继续循环体的执行,这里的判断条件我们认为是循环的守卫</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">for</span> ( i &lt;- <span class="type">Range</span>(<span class="number">1</span>,<span class="number">5</span>) <span class="keyword">if</span> i != <span class="number">3</span>  ) &#123;</span><br><span class="line">            println(<span class="string">"i = "</span> + i )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）循环步长</p>
<p>scala的集合也可以设定循环的增长幅度，也就是所谓的步长step</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">for</span> ( i &lt;- <span class="type">Range</span>(<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>) ) &#123;</span><br><span class="line">            println(<span class="string">"i = "</span> + i )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( i &lt;- <span class="number">1</span> to <span class="number">5</span> by <span class="number">2</span> ) &#123;</span><br><span class="line">            println(<span class="string">"i = "</span> + i )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>4）循环嵌套</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">for</span> ( i &lt;- <span class="type">Range</span>(<span class="number">1</span>,<span class="number">5</span>); j &lt;- <span class="type">Range</span>(<span class="number">1</span>,<span class="number">4</span>) ) &#123;</span><br><span class="line">            println(<span class="string">"i = "</span> + i + <span class="string">",j = "</span> + j )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//功能等价于</span></span><br><span class="line">        <span class="keyword">for</span> ( i &lt;- <span class="type">Range</span>(<span class="number">1</span>,<span class="number">5</span>) ) &#123;</span><br><span class="line">            <span class="comment">//但是这种方式的好处是这里可以写代码</span></span><br><span class="line">            <span class="keyword">for</span> ( j &lt;- <span class="type">Range</span>(<span class="number">1</span>,<span class="number">4</span>) ) &#123;</span><br><span class="line">                println(<span class="string">"i = "</span> + i + <span class="string">",j = "</span> + j )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5）引入变量</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">for</span> ( i &lt;- <span class="type">Range</span>(<span class="number">1</span>,<span class="number">5</span>); j = i - <span class="number">1</span> ) &#123;</span><br><span class="line">            println(<span class="string">"j = "</span> + j )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6）返回值</p>
<p>scala所有的表达式都是有返回值的。但是这里的返回值并不一定都是有值的哟。</p>
<p>如果希望for循环表达式的返回值有具体的值，需要使用关键字yield,如果不适用yield则每次循环计算的值都会丢弃，最后返回()</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> result = <span class="keyword">for</span> ( i &lt;- <span class="type">Range</span>(<span class="number">1</span>,<span class="number">5</span>) ) <span class="keyword">yield</span> &#123;</span><br><span class="line">            i * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出  Vector(2, 4, 6, 8)</span></span><br></pre></td></tr></table></figure>







<h3 id="4-2-2-while循环"><a href="#4-2-2-while循环" class="headerlink" title="4.2.2 while循环"></a>4.2.2 while循环</h3><p>while(){}   do{} while()</p>
<h3 id="4-2-3-循环中断"><a href="#4-2-3-循环中断" class="headerlink" title="4.2.3 循环中断"></a>4.2.3 循环中断</h3><p>scala是完全面向对象的语言，所以无法使用break关键字这种方式来中断循环逻辑，而是采用了函数式编程的方式替代了循环语法中的break和continue</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.control.<span class="type">Breaks</span>._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">LoopBreak</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Breaks.breakable&#123;</span></span><br><span class="line"><span class="comment">      for(i &lt;- 1 to 5)&#123;</span></span><br><span class="line"><span class="comment">        if(i == 3)&#123;</span></span><br><span class="line"><span class="comment">          //跳出循环</span></span><br><span class="line"><span class="comment">          Breaks.break()</span></span><br><span class="line"><span class="comment">        &#125;else&#123;</span></span><br><span class="line"><span class="comment">          println(i)</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//这里使用了静态导入</span></span><br><span class="line">    breakable&#123;</span><br><span class="line">      <span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">3</span>)&#123;</span><br><span class="line">          <span class="comment">//跳出循环</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          println(i)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在java中静态导入的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.test.bean.User;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> StaticImportTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> TYS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/5/10 16:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticImportTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(User.age);</span><br><span class="line">        System.out.println(User.name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多次调用静态对象的时候需要指定类名，很麻烦，可以通过静态导入的方式省略类名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.atguigu.test.bean.User.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> StaticImportTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> TYS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/5/10 16:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticImportTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="5-函数式编程"><a href="#5-函数式编程" class="headerlink" title="5.函数式编程"></a>5.函数式编程</h1><p>面向对象编程</p>
<p>​    分解对象，行为，属性，然后通过对象的关系以及行为的调用来解决问题</p>
<p>函数式编程</p>
<p>​    将问题分解成一个一个的步骤，将每个步骤进行封装（函数），通过调用这些封装好的步骤</p>
<h2 id="5-1-基本函数编程"><a href="#5-1-基本函数编程" class="headerlink" title="5.1 基本函数编程"></a>5.1 基本函数编程</h2><h3 id="5-1-1-基本语法"><a href="#5-1-1-基本语法" class="headerlink" title="5.1.1 基本语法"></a>5.1.1 基本语法</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">[修饰符] <span class="function"><span class="keyword">def</span> <span class="title">函数名</span> <span class="title">（参数列表）</span> </span>[:返回值类型] = &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(s : <span class="type">String</span>) : <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-1-2-函数-amp-方法"><a href="#5-1-2-函数-amp-方法" class="headerlink" title="5.1.2  函数&amp;方法"></a>5.1.2  函数&amp;方法</h3><p>类中的函数称之为方法，和java类似，在scala中，函数和类一样都是一级抽象，可独立存在，方法有重载和重写的概念，但是函数没有。</p>
<h3 id="5-1-3-函数定义"><a href="#5-1-3-函数定义" class="headerlink" title="5.1.3 函数定义"></a>5.1.3 函数定义</h3><p>1)    无参，无返回值</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun1</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">      println(<span class="string">"函数体"</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun1()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>2)    无参，有返回值</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun2</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line"></span><br><span class="line">      <span class="string">"zhangsan"</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println( fun2() )</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3)    有参，无返回值</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun3</span></span>( name:<span class="type">String</span> ): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">      println( name )</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun3(<span class="string">"zhangsan"</span>)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>4)    有参，有返回值</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun4</span></span>(name:<span class="type">String</span>): <span class="type">String</span> = &#123;</span><br><span class="line"></span><br><span class="line">      <span class="string">"Hello "</span> + name</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println( fun4(<span class="string">"zhangsan"</span>) )</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>5)    多参，无返回值</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun5</span></span>(hello:<span class="type">String</span>, name:<span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">      println( hello + <span class="string">" "</span> + name )</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun5(<span class="string">"Hello"</span>, <span class="string">"zhangsan"</span>)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>6)    多参，有返回值</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun6</span></span>(hello:<span class="type">String</span>, name:<span class="type">String</span>): <span class="type">String</span> = &#123;</span><br><span class="line"></span><br><span class="line">      hello + <span class="string">" "</span> + name</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println( fun6(<span class="string">"Hello"</span>, <span class="string">"zhangsan"</span>))</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-4-函数参数"><a href="#5-1-4-函数参数" class="headerlink" title="5.1.4 函数参数"></a>5.1.4 函数参数</h3><p>可变参数  参数默认值  带名参数</p>
<p>1）可变参数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun7</span></span>(names:<span class="type">String</span>*): <span class="type">Unit</span> = &#123;</span><br><span class="line">            println(names)</span><br><span class="line">        &#125;</span><br><span class="line">        fun7()</span><br><span class="line">        fun7( <span class="string">"zhangsan"</span> )</span><br><span class="line">        fun7( <span class="string">"zhangsan"</span>, <span class="string">"lisi"</span> )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可变参数不能放置在参数列表的前面，一般放置在参数列表的最后</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun777</span></span>( name:<span class="type">String</span>, names:<span class="type">String</span>* ): <span class="type">Unit</span> = &#123;</span><br><span class="line">            println( name )</span><br><span class="line">            println( names )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2）参数默认值</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun8</span></span>( name:<span class="type">String</span>, password:<span class="type">String</span> = <span class="string">"000000"</span> ): <span class="type">Unit</span> = &#123;</span><br><span class="line">            println( name + <span class="string">","</span> + password )</span><br><span class="line">        &#125;</span><br><span class="line">        fun8(<span class="string">"zhangsan"</span>, <span class="string">"123123"</span>)</span><br><span class="line">        fun8(<span class="string">"zhangsan"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3）带名参数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun9</span></span>( password:<span class="type">String</span> = <span class="string">"000000"</span>, name:<span class="type">String</span> ): <span class="type">Unit</span> = &#123;</span><br><span class="line">            println( name + <span class="string">","</span> + password )</span><br><span class="line">        &#125;</span><br><span class="line">        fun9(<span class="string">"123123"</span>, <span class="string">"zhangsan"</span> )</span><br><span class="line">        fun9(name=<span class="string">"zhangsan"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-5-函数至简原则"><a href="#5-1-5-函数至简原则" class="headerlink" title="5.1.5  函数至简原则"></a>5.1.5  函数至简原则</h3><p>所谓的至简原则，其实就是Scala的编译器为了提高开发效率。帮助我们将函数声明中能简化的地方全部都进行了简化。也就是说将函数声明中那些能省的地方全部都省掉。所以简单来说就是：能省则省</p>
<p>1）省略return关键字</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun1</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"zhangsan"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun11</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">            <span class="string">"zhangsan"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2）省略花括号</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun2</span></span>(): <span class="type">String</span> = <span class="string">"zhangsan"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3）省略返回值类型</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun3</span></span>() = <span class="string">"zhangsan"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>4）省略参数列表</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun4</span> </span>= <span class="string">"zhangsan"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>5）省略等号</p>
<p>如果函数体中有明确的return语句，那么返回值类型不能省略</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun5</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"zhangsan"</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(fun5())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数体返回值类型明确为Unit, 那么函数体中即使有return关键字也不起作用</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun5</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"zhangsan"</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(fun5())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数体返回值类型声明为Unit, 但是又想省略，那么此时就必须连同等号一起省略</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun5</span></span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"zhangsan"</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(fun5())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6）省略名称和关键字</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">            println(<span class="string">"zhangsan"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-2-高阶函数编程"><a href="#5-2-高阶函数编程" class="headerlink" title="5.2 高阶函数编程"></a>5.2 高阶函数编程</h2><p>所谓的高阶函数，其实就是把函数当成一个类型来使用，而不是当成特定的语法结构</p>
<h3 id="5-2-1-函数作为值"><a href="#5-2-1-函数作为值" class="headerlink" title="5.2.1 函数作为值"></a>5.2.1 函数作为值</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun1</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">            <span class="string">"zhangsan"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> a = fun1</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不执行函数，而是将函数整体赋值给b，b就相当于fun1()函数</span></span><br><span class="line">        <span class="keyword">val</span> b = fun1 _</span><br><span class="line">        println(a)</span><br><span class="line">        println(b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不想用下划线将函数作为整体使用，也可以明确变量类型</p>
<p>//函数类型：（参数类型） =&gt; 返回值类型</p>
<p>val v2 : String=&gt;Unit = f1</p>
<h4 id="下划线的作用"><a href="#下划线的作用" class="headerlink" title="下划线的作用"></a>下划线的作用</h4><p>1）将函数作为整体使用</p>
<p>2）可以声明变量</p>
<p>3）使用下划线代替函数的参数（如果在函数逻辑中，只使用了参数一次，那么可以使用下划线来代替参数，使用下划线来代替参数，应该遵循参数的顺序）</p>
<h3 id="5-2-2-函数作为参数"><a href="#5-2-2-函数作为参数" class="headerlink" title="5.2.2 函数作为参数"></a>5.2.2 函数作为参数</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun2</span></span>( i:<span class="type">Int</span> ): <span class="type">Int</span> = &#123;</span><br><span class="line">            i * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun22</span></span>( f : <span class="type">Int</span> =&gt; <span class="type">Int</span> ): <span class="type">Int</span> = &#123;</span><br><span class="line">            f(<span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        println(fun22(fun2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-2-3-函数作为返回值"><a href="#5-2-3-函数作为返回值" class="headerlink" title="5.2.3 函数作为返回值"></a>5.2.3 函数作为返回值</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun3</span></span>( i:<span class="type">Int</span> ): <span class="type">Int</span> = &#123;</span><br><span class="line">            i * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun33</span></span>( ) = &#123;</span><br><span class="line">            <span class="comment">//将函数作为整体返回，而不是调用，不用传参而是使用_</span></span><br><span class="line">            fun3 _</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果不想使用_将函数作为整体返回，也可以明确返回的类型，就不需要用_</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        def fun33():Int=&gt;Int = &#123;</span></span><br><span class="line"><span class="comment">            fun3</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        println(fun33()(<span class="number">10</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的语法都没错，但是一般不会这样写，一帮会把需要用到的函数封装在内部</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f3</span></span>(i:<span class="type">Int</span>): <span class="type">Int</span> =&gt; <span class="type">Int</span> = &#123;</span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">f33</span></span>(i:<span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">                i * <span class="number">100</span></span><br><span class="line">            &#125;</span><br><span class="line">            f33 _</span><br><span class="line">        &#125;</span><br><span class="line">        println(f3()(<span class="number">20</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-2-4-匿名函数"><a href="#5-2-4-匿名函数" class="headerlink" title="5.2.4 匿名函数"></a>5.2.4 匿名函数</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun4</span></span>( f:<span class="type">Int</span> =&gt; <span class="type">Int</span> ): <span class="type">Int</span> = &#123;</span><br><span class="line">            f(<span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        println(fun4((x:<span class="type">Int</span>)=&gt;&#123;x * <span class="number">20</span>&#125;))</span><br><span class="line">        println(fun4((x)=&gt;&#123;x * <span class="number">20</span>&#125;))</span><br><span class="line">        println(fun4((x)=&gt;x * <span class="number">20</span>))</span><br><span class="line">        println(fun4(x=&gt;x * <span class="number">20</span>))</span><br><span class="line">        println(fun4(_ * <span class="number">20</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-2-5-闭包"><a href="#5-2-5-闭包" class="headerlink" title="5.2.5 闭包"></a>5.2.5 闭包</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>():()=&gt;<span class="type">Int</span> = &#123;</span><br><span class="line">           <span class="keyword">val</span> i = <span class="number">10</span></span><br><span class="line">           <span class="function"><span class="keyword">def</span> <span class="title">f2</span></span>(): <span class="type">Int</span> = &#123;</span><br><span class="line">               i * <span class="number">2</span></span><br><span class="line">           &#125;</span><br><span class="line">           f2 _</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   println(f1()())<span class="comment">//输出20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包：</p>
<p>一个变量在函数执行完后被其它的函数包含使用，<strong>改变了这个函数的生命周期</strong>。这种处理方式称之为闭包。</p>
<p>等价于  一个函数使用了外部的变量，但是外部的变量不能被回收掉，应该被包含在当前函数的内部，形成一个闭合的效果，称之为闭包。</p>
<h3 id="5-2-6-函数柯里化"><a href="#5-2-6-函数柯里化" class="headerlink" title="5.2.6 函数柯里化"></a>5.2.6 函数柯里化</h3><p>函数柯里化：将负责的参数列表变得简单化，将多个参数的参数列表变成多个参数列表</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(i:<span class="type">Int</span>)(j:<span class="type">Int</span>)(f:(<span class="type">Int</span>,<span class="type">Int</span>) =&gt; <span class="type">Int</span>):<span class="type">Int</span> = &#123;</span><br><span class="line">    f(i,j)</span><br><span class="line">&#125;</span><br><span class="line">println(test(<span class="number">10</span>)(<span class="number">20</span>)(_+_))</span><br></pre></td></tr></table></figure>



<h3 id="5-2-7-控制抽象"><a href="#5-2-7-控制抽象" class="headerlink" title="5.2.7 控制抽象"></a>5.2.7 控制抽象</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//breakable其实是函数</span></span><br><span class="line"><span class="comment">//这里的大括号其实就是函数的参数列表（小括号）</span></span><br><span class="line"><span class="comment">//for循环其实是一段代码逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将一段代码逻辑作为参数传递给一个函数来执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模板方法设计模式</span></span><br><span class="line"><span class="comment">//父类中搭建算法的骨架（breakable&#123;&#125;），在子类中根据实际的业务需求动态改变业务逻辑(for()&#123;...&#125;)</span></span><br><span class="line"><span class="comment">//下面的代码书写方式一般应用再程序架构中</span></span><br><span class="line">breakable&#123;</span><br><span class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">1</span> t0 <span class="number">5</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">3</span>)&#123;</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      println(<span class="string">"i= "</span> + i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>breakable分析</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">breakable</span></span>(op: =&gt; unit)</span><br><span class="line"><span class="comment">//op: =&gt;unit 没有输入参数也没有返回值</span></span><br><span class="line"><span class="comment">//将代码逻辑作为参数传给函数执行，这就是控制抽象</span></span><br></pre></td></tr></table></figure>







<h3 id="5-2-8-递归函数"><a href="#5-2-8-递归函数" class="headerlink" title="5.2.8 递归函数"></a>5.2.8 递归函数</h3><p>递归方法必须明确返回值类型</p>
<p>同时递归的深度不能太深，不能会报错StackOverflowError,</p>
<p>如下代码</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(num:<span class="type">Int</span>):<span class="type">Int</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            num + factorial(num<span class="number">-1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println(factorial(<span class="number">1000000000</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//会报栈溢出错误，递归的深度太深了</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/05/11/cRIsfJ3MVXane2Z.png" alt="image-20210511151734794"></p>
<p>可以采用尾递归来解决</p>
<p><strong>尾递归</strong>：递归操作在函数逻辑的最后，并且和函数逻辑之间没有关联</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    tailRecursion(<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tailRecursion</span></span>(num:<span class="type">Int</span>,result: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        result</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        tailRecursion(num<span class="number">-1</span>,num + result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-2-9-惰性函数"><a href="#5-2-9-惰性函数" class="headerlink" title="5.2.9 惰性函数"></a>5.2.9 惰性函数</h3><p>其实用到数据最好的使用方式是：</p>
<p>1）用到数据的时候再去加载数据</p>
<p>2）如果没有用到数据暂时不加载</p>
<p>当函数返回值被声明为lazy时，函数的执行将被延迟，直到首次对此取值，该函数才会执行。这种函数我们称之为惰性函数。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun9</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">            println(<span class="string">"function..."</span>)</span><br><span class="line">            <span class="string">"zhangsan"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">lazy</span> <span class="keyword">val</span> a = fun9()</span><br><span class="line">        println(<span class="string">"----------"</span>)</span><br><span class="line">        println(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="6-面向对象"><a href="#6-面向对象" class="headerlink" title="6.面向对象"></a>6.面向对象</h1><h2 id="6-1-属性"><a href="#6-1-属性" class="headerlink" title="6.1 属性"></a>6.1 属性</h2><p>在类中声明属性，其实并不是声明属性，而是声明方法。在编译时，编译器会将类的属性自动编译为类的私有属性；编译的同时，编译器会给这个属性同时编译成两个公共的set/get方法。在直接访问属性是，其实是调用的get方法，直接赋值时等同于调用set方法</p>
<p>如果属性使用val声明，那么属性值一旦初始化后无法改变。编译器在编译时，val的属性会自动添加final关键字，而且没有提供对应的set方法</p>
<p>如果属性声明时使用private关键字，那么编译时的属性和set,get方法都是私有的</p>
<p>scala默认生成的set 和get方法并不是以set和get开头的</p>
<p>如果想要scala中类的属性方法符合Bean的规范，需要增加特殊的注解（<strong>@BeanProperty</strong>），添加这个注解的属性，编译时默认会增加对应的get和set方法</p>
<h1 id="7-集合"><a href="#7-集合" class="headerlink" title="7.集合"></a>7.集合</h1><h1 id="8-模式匹配"><a href="#8-模式匹配" class="headerlink" title="8.模式匹配"></a>8.模式匹配</h1><p>scala中的模式匹配类似于java中的switch语法，但是scala从语法中补充了更多的功能</p>
<h2 id="8-1-基本语法"><a href="#8-1-基本语法" class="headerlink" title="8.1 基本语法"></a>8.1 基本语法</h2><p>模式匹配语法中，采用match关键字声明，每个分支采用case关键字进行声明，当需要匹配时，会从第一个case分支开始，如果匹配成功，那么执行对应的逻辑代码，如果匹配不成功，继续执行下一个分支进行判断。如果所有case都不匹配，那么会执行case _分支，类似于Java中default语句。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaMatch</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">var</span> a: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">        <span class="keyword">var</span> b: <span class="type">Int</span> = <span class="number">20</span></span><br><span class="line">        <span class="keyword">var</span> operator: <span class="type">Char</span> = 'd'</span><br><span class="line">        <span class="keyword">var</span> result = operator <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> '+' =&gt; a + b</span><br><span class="line">            <span class="keyword">case</span> '-' =&gt; a - b</span><br><span class="line">            <span class="keyword">case</span> '*' =&gt; a * b</span><br><span class="line">            <span class="keyword">case</span> '/' =&gt; a / b</span><br><span class="line">            <span class="keyword">case</span> _ =&gt; <span class="string">"illegal"</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-2-匹配规则"><a href="#8-2-匹配规则" class="headerlink" title="8.2 匹配规则"></a>8.2 匹配规则</h2><h3 id="8-2-1-匹配常量"><a href="#8-2-1-匹配常量" class="headerlink" title="8.2.1 匹配常量"></a>8.2.1 匹配常量</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(x: <span class="type">Any</span>) = x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span> =&gt; <span class="string">"Int five"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"hello"</span> =&gt; <span class="string">"String hello"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span> =&gt; <span class="string">"Boolean true"</span></span><br><span class="line">    <span class="keyword">case</span> '+' =&gt; <span class="string">"Char +"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-2-2-匹配类型"><a href="#8-2-2-匹配类型" class="headerlink" title="8.2.2 匹配类型"></a>8.2.2 匹配类型</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(x: <span class="type">Any</span>) = x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> i: <span class="type">Int</span> =&gt; <span class="string">"Int"</span></span><br><span class="line">    <span class="keyword">case</span> s: <span class="type">String</span> =&gt; <span class="string">"String hello"</span></span><br><span class="line">    <span class="keyword">case</span> m: <span class="type">List</span>[_] =&gt; <span class="string">"List"</span></span><br><span class="line">    <span class="keyword">case</span> c: <span class="type">Array</span>[<span class="type">Int</span>] =&gt; <span class="string">"Array[Int]"</span></span><br><span class="line">    <span class="keyword">case</span> someThing =&gt; <span class="string">"something else "</span> + someThing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-2-3-匹配数组"><a href="#8-2-3-匹配数组" class="headerlink" title="8.2.3 匹配数组"></a>8.2.3 匹配数组</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (arr &lt;- <span class="type">Array</span>(<span class="type">Array</span>(<span class="number">0</span>), <span class="type">Array</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), <span class="type">Array</span>(<span class="string">"hello"</span>, <span class="number">90</span>))) &#123; <span class="comment">// 对一个数组集合进行遍历</span></span><br><span class="line">    <span class="keyword">val</span> result = arr <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>) =&gt; <span class="string">"0"</span> <span class="comment">//匹配Array(0) 这个数组</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Array</span>(x, y) =&gt; x + <span class="string">","</span> + y <span class="comment">//匹配有两个元素的数组，然后将将元素值赋给对应的x,y</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>, _*) =&gt; <span class="string">"以0开头的数组"</span> <span class="comment">//匹配以0开头和数组</span></span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"result = "</span> + result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-2-4-匹配列表"><a href="#8-2-4-匹配列表" class="headerlink" title="8.2.4 匹配列表"></a>8.2.4 匹配列表</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (list &lt;- <span class="type">Array</span>(<span class="type">List</span>(<span class="number">0</span>), <span class="type">List</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="type">List</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="type">List</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="type">List</span>(<span class="number">88</span>))) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = list <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">List</span>(<span class="number">0</span>) =&gt; <span class="string">"0"</span> <span class="comment">//匹配List(0)</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">List</span>(x, y) =&gt; x + <span class="string">","</span> + y <span class="comment">//匹配有两个元素的List</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">List</span>(<span class="number">0</span>, _*) =&gt; <span class="string">"0 ..."</span></span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">list <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> first :: second :: rest =&gt; println(first + <span class="string">"-"</span> + second + <span class="string">"-"</span> + rest)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">"something else"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-2-5-匹配元组"><a href="#8-2-5-匹配元组" class="headerlink" title="8.2.5 匹配元组"></a>8.2.5 匹配元组</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (tuple &lt;- <span class="type">Array</span>((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = tuple <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> (<span class="number">0</span>, _) =&gt; <span class="string">"0 ..."</span> <span class="comment">//是第一个元素是0的元组</span></span><br><span class="line">        <span class="keyword">case</span> (y, <span class="number">0</span>) =&gt; <span class="string">""</span> + y + <span class="string">"0"</span> <span class="comment">// 匹配后一个元素是0的对偶元组</span></span><br><span class="line">        <span class="keyword">case</span> (a, b) =&gt; <span class="string">""</span> + a + <span class="string">" "</span> + b</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span> <span class="comment">//默认</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-2-6-匹配对象"><a href="#8-2-6-匹配对象" class="headerlink" title="8.2.6 匹配对象"></a>8.2.6 匹配对象</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">val name: <span class="type">String</span>, val age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>, age: <span class="type">Int</span>): <span class="type">User</span> = <span class="keyword">new</span> <span class="type">User</span>(name, age)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(user: <span class="type">User</span>): <span class="type">Option</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = &#123;</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>)</span><br><span class="line">            <span class="type">None</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="type">Some</span>(user.name, user.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> user: <span class="type">User</span> = <span class="type">User</span>(<span class="string">"zhangsan"</span>, <span class="number">11</span>)</span><br><span class="line"><span class="keyword">val</span> result = user <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">User</span>(<span class="string">"zhangsan"</span>, <span class="number">11</span>) =&gt; <span class="string">"yes"</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">"no"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-2-7-样例类"><a href="#8-2-7-样例类" class="headerlink" title="8.2.7 样例类"></a>8.2.7 样例类</h3><p>l 样例类就是使用case关键字声明的类</p>
<p>l 样例类仍然是类，和普通类相比，只是其自动生成了伴生对象，并且伴生对象中自动提供了一些常用的方法，如apply、unapply、toString、equals、hashCode和copy。</p>
<p>l <strong>样例类是为模式匹配而优化的类</strong>，因为其默认提供了unapply方法，因此，样例类可以直接使用模式匹配，而无需自己实现unapply方法。</p>
<p>l 构造器中的每一个参数都成为val，除非它被显式地声明为var（不建议这样做）</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">ase <span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">ScalaCaseClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> user: <span class="type">User</span> = <span class="type">User</span>(<span class="string">"zhangsan"</span>, <span class="number">11</span>)</span><br><span class="line">        <span class="keyword">val</span> result = user <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">User</span>(<span class="string">"zhangsan"</span>, <span class="number">11</span>) =&gt; <span class="string">"yes"</span></span><br><span class="line">            <span class="keyword">case</span> _ =&gt; <span class="string">"no"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="8-3-偏函数"><a href="#8-3-偏函数" class="headerlink" title="8.3 偏函数"></a>8.3 偏函数</h2><p>所谓的偏函数，其实就是对集合中符合条件的数据进行处理的函数</p>
<p>偏函数也是函数的一种，通过偏函数可以对输入参数做更精确的检查。例如，该偏函数的输入类型为List[Int],而我们需要的是第一个元素是0的集合，这就是通过模式匹配实现的</p>
<p>例：将该List(1,2,3,4,5,6,”test”)中的Int类型的元素加一，并去掉字符串</p>
<p>不使用偏函数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">"test"</span>).filter(_.isInstanceOf[<span class="type">Int</span>]).map(_.asInstanceOf[<span class="type">Int</span>] + <span class="number">1</span>).foreach(println)</span><br></pre></td></tr></table></figure>

<p>使用偏函数</p>
<p>偏函数指的是一个trait的名称 ==》PartialFunction，需要实现特定的方式进行相应的处理</p>
<p>所以一般实现时，不用混入这个特质，直接使用模式匹配就可以实现</p>
<p>所以在开始时，可以采用模式匹配来代替偏函数</p>
<p>collect是采集方法，这个方法是支持使用偏函数的，将满足条件的数据采集过来</p>
<p>但并不是所有的方法都支持偏函数，比如map</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="string">"test"</span>).collect &#123; <span class="keyword">case</span> x: <span class="type">Int</span> =&gt; x + <span class="number">1</span> &#125;.foreach(println)</span><br></pre></td></tr></table></figure>



<h1 id="9-异常"><a href="#9-异常" class="headerlink" title="9.异常"></a>9.异常</h1><h2 id="9-1-简介"><a href="#9-1-简介" class="headerlink" title="9.1 简介"></a>9.1 简介</h2><p>语法处理上和Java类似，但是又不尽相同</p>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a / b;</span><br><span class="line">&#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;</span><br><span class="line">    <span class="comment">// catch时，需要将范围小的写到前面</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"finally"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Scala中的异常没有所谓的编译时异常和运行时异常，所以也无需显示抛出方法异常</p>
<h2 id="9-2-基本语法"><a href="#9-2-基本语法" class="headerlink" title="9.2 基本语法"></a>9.2 基本语法</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> n= <span class="number">10</span> / <span class="number">0</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ex: <span class="type">ArithmeticException</span>=&gt;&#123;</span><br><span class="line">                <span class="comment">// 发生算术异常</span></span><br><span class="line">                println(<span class="string">"发生算术异常"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> ex: <span class="type">Exception</span>=&gt;&#123;</span><br><span class="line">                <span class="comment">// 对异常处理</span></span><br><span class="line">                println(<span class="string">"发生了异常1"</span>)</span><br><span class="line">                println(<span class="string">"发生了异常2"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            println(<span class="string">"finally"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="10-隐式转换"><a href="#10-隐式转换" class="headerlink" title="10.隐式转换"></a>10.隐式转换</h1><h2 id="10-1-简介"><a href="#10-1-简介" class="headerlink" title="10.1 简介"></a>10.1 简介</h2><p>Scala中在程序编译错误时，可以通过内置的类型转换机制进行二次编译，尝试将本身错误的代码通过类型转换后编译通过。慢慢地，这也形成了一种扩展功能的转换机制</p>
<p>简单地说，隐式转换是将值的类型自动从一种类型转换为另外一种类型</p>
<p>这个转换的操作，开发者是看不到的，所以称之为隐式转换</p>
<p>例</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> i : <span class="type">Int</span> = <span class="number">2.0</span></span><br><span class="line">    println(i)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">DoubleInt</span></span>(x:<span class="type">Double</span>): <span class="type">Int</span> = x.toInt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：在相同的作用域中不能存在相同的转换规则，不然编译器就会不知道选择哪个无法完成隐式转换</p>
<p><strong>隐式转换主要用于扩展功能</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">transform</span></span>(user:<span class="type">User</span>): <span class="type">UserExt</span> = &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">UserExt</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> user = <span class="keyword">new</span> <span class="type">User</span>()</span><br><span class="line">	user.insertUser()</span><br><span class="line">    user.removeUser()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertUser</span></span>():<span class="type">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">"insert user"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserExt</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeUser</span></span>():<span class="type">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">"remove user"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="10-2-隐式函数"><a href="#10-2-隐式函数" class="headerlink" title="10.2 隐式函数"></a>10.2 隐式函数</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">transform</span></span>(user:<span class="type">User</span>): <span class="type">UserExt</span> = &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">UserExt</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> user = <span class="keyword">new</span> <span class="type">User</span>()</span><br><span class="line">	user.insertUser()</span><br><span class="line">    user.removeUser()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertUser</span></span>():<span class="type">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">"insert user"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserExt</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeUser</span></span>():<span class="type">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">"remove user"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="10-3-隐式参数-amp-隐式变量"><a href="#10-3-隐式参数-amp-隐式变量" class="headerlink" title="10.3 隐式参数&amp;隐式变量"></a>10.3 隐式参数&amp;隐式变量</h2><p><strong>隐式参数</strong>：</p>
<p>​    当一个函数的参数列表中，被implicit修饰的参数称为隐式参数，调用方法时，可以不用传参数，编译器会启动去找相应的隐式值，注意不能有二义性，隐式值匹配时只参考类型，跟变量名无关。</p>
<p><strong>注意：使用隐式参数时，在参数列表中只能有一个参数</strong></p>
<p><strong>隐式变量</strong>：</p>
<p>​    当一个变量使用implicit修饰时，这个变量称为隐式变量</p>
<p><strong>注意事项</strong>：</p>
<p>​    方法名：使用隐式值</p>
<p>​    方法名():使用默认值</p>
<p>​    方法名(x)：使用传入的值</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//隐式参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertUser</span></span>(<span class="keyword">implicit</span> password:<span class="type">String</span>=<span class="string">"123456"</span>):<span class="type">Unit</span> =&#123;</span><br><span class="line">        println(password)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//隐式变量</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">val</span> pwd:<span class="type">String</span> = <span class="string">"000000"</span></span><br><span class="line">    <span class="comment">//当使用隐式变量扩展功能时，不能使用括号</span></span><br><span class="line">    insertUser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>函数柯里化</strong>：</p>
<p>​    函数柯里化使用较多的场合就是隐式转换，因为因式转换参数要求必须只能有一个参数</p>
<p>​    例如</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里就不能使用隐式参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(i:<span class="type">Int</span>,j:<span class="type">Int</span>):<span class="type">Unit</span> = &#123;</span><br><span class="line">    i + j</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这可以使用隐式参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span></span>(i:<span class="type">Int</span>)(<span class="keyword">implicit</span> j:<span class="type">Int</span>):<span class="type">Unit</span> = &#123;</span><br><span class="line">    i + j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="10-4-隐式类"><a href="#10-4-隐式类" class="headerlink" title="10.4 隐式类"></a>10.4 隐式类</h2><p>单独声明需要被转换的目标类和单独声明隐式转换的方法比较麻烦，所以在scala2.10后提供了隐式类</p>
<p>隐式类用implicit进行修饰，有以下特点：</p>
<p>1）其所带的构造参数有且只有一个</p>
<p>2）隐式类必须定义在“类”或“伴生对象”或“包对象”里，即隐式类不能是顶层类</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaImplicit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> emp = <span class="keyword">new</span> <span class="type">Emp</span>()</span><br><span class="line">        <span class="comment">//这里默认就会将emp转换为User对象</span></span><br><span class="line">        emp.insertUser()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params"> emp : <span class="type">Emp</span></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">insertUser</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">            println(<span class="string">"insert user..."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="10-5-隐式机制"><a href="#10-5-隐式机制" class="headerlink" title="10.5 隐式机制"></a>10.5 隐式机制</h2><p>隐式转换规则：</p>
<p>​    1）隐式转换需要在当前作用域中或者跟当前作用域有关联的域中可以找到</p>
<p>可以在当前作用域，当前作用域的父类，特质，包对象中都可以查找因式转换，如果在指定的作用域中查找不到需要用到的隐式转换，可以通过import的方式进行导入</p>
<h2 id="10-6-功能扩展"><a href="#10-6-功能扩展" class="headerlink" title="10.6 功能扩展"></a>10.6 功能扩展</h2><p>隐式转换一般用于功能扩展</p>
<p>扩展功能主要有以下两种方式</p>
<p>特质混入，隐式转换。那如何选择呢？</p>
<p>1）trait：interface&amp;abstract  里面一般封装的是通用的功能，如果是扩展一个项目中通用的功能那就用特质混入的方式</p>
<p>2）隐式转换：如果是单独某个地方需要扩展类那就使用隐式转换</p>
<h1 id="11-泛型"><a href="#11-泛型" class="headerlink" title="11.泛型"></a>11.泛型</h1><h2 id="11-1-简介"><a href="#11-1-简介" class="headerlink" title="11.1 简介"></a>11.1 简介</h2><p>1）java的泛型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java 中的泛型是不可变的</span></span><br><span class="line"><span class="comment">//java泛型只能对声明之后的逻辑起作用</span></span><br><span class="line"><span class="comment">//java泛型只有再使用类型操作是才会起作用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="keyword">new</span> Classes);</span><br><span class="line">    List&lt;Dept&gt; dept = list;<span class="comment">//这是可以的，java的泛型是只对声明后的逻辑起作用的</span></span><br><span class="line">    <span class="comment">//dept.add(new Classes());//这里就会报错，泛型约束了只能放Dept类型的对象</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(dept);<span class="comment">//这是不是出错的，会默认调用对象的toString()</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//java泛型只有再使用类型操作是才会起作用</span></span><br><span class="line">    <span class="keyword">for</span>(Dept d : dept)&#123;<span class="comment">// 这里会出错，里面放的是Classes对象，但这里当成Dept类型的对象来使用，是有问题的</span></span><br><span class="line">        System.out.println(d)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classes</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dept</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型的上边界：public static void test(Class&lt;? extends Dept&gt; c),可以传Dept和Dept的子类</span></span><br><span class="line"><span class="comment">//泛型的下边界：public static void test2(Class&lt;? super Dept&gt; c)，可以传Dept和Dept的父类</span></span><br></pre></td></tr></table></figure>





<p>2）scala的泛型</p>
<p>scala中泛型采用中括号[]声明</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) : <span class="type">Unit</span> =&#123;</span><br><span class="line">    <span class="comment">//默认情况下，scala中的泛型和java一样是不可变的</span></span><br><span class="line">    <span class="keyword">val</span> test:<span class="type">Test1</span>[<span class="type">User</span>] = <span class="keyword">new</span> <span class="type">Test1</span>[<span class="type">Parent</span>]()  <span class="comment">//报错</span></span><br><span class="line">     <span class="comment">//scala中的泛型在java的基础上进行了扩展</span></span><br><span class="line">     <span class="keyword">val</span> test:<span class="type">Test2</span>[<span class="type">User</span>] = <span class="keyword">new</span> <span class="type">Test2</span>[<span class="type">SubUser</span>]() <span class="comment">//泛型协变</span></span><br><span class="line">    <span class="keyword">val</span> test:<span class="type">Test3</span>[<span class="type">User</span>] = <span class="keyword">new</span> <span class="type">Test3</span>[<span class="type">Parent</span>]() <span class="comment">//泛型逆变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//scala中泛型采用中括号[]声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span>[<span class="type">T</span>]</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型的协变：当前类型可子类型可用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span>[+<span class="type">T</span>]</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型的逆变：当前类型和子类型可用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test3</span>[-<span class="type">T</span>]</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubUser</span> <span class="keyword">extends</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="11-2-泛型转换"><a href="#11-2-泛型转换" class="headerlink" title="11.2 泛型转换"></a>11.2 泛型转换</h2><h2 id="11-3-泛型边界"><a href="#11-3-泛型边界" class="headerlink" title="11.3 泛型边界"></a>11.3 泛型边界</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) : <span class="type">Unit</span> =&#123;</span><br><span class="line">    <span class="comment">//泛型的边界</span></span><br><span class="line">    test[<span class="type">User</span>](<span class="keyword">new</span> <span class="type">User</span>())</span><br><span class="line">     test[<span class="type">User</span>](<span class="keyword">new</span> <span class="type">Parent</span>()) <span class="comment">//报错，</span></span><br><span class="line">     test3[<span class="type">User</span>](<span class="keyword">new</span> <span class="type">Parent</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span></span>[<span class="type">A</span>:<span class="type">User</span>](a:<span class="type">A</span>):<span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型的上限</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span></span>[<span class="type">A</span>&gt;:<span class="type">User</span>](a:<span class="type">A</span>):<span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型的下限</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span></span>[<span class="type">A</span>&lt;:<span class="type">User</span>](a:<span class="type">A</span>):<span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubUser</span> <span class="keyword">extends</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="11-4-上下文限定（泛型和隐式转换相结合）"><a href="#11-4-上下文限定（泛型和隐式转换相结合）" class="headerlink" title="11.4 上下文限定（泛型和隐式转换相结合）"></a>11.4 上下文限定（泛型和隐式转换相结合）</h2><p>在某些情况下，处理的数据需要执行的类型才可以访问，那么就需要泛型和隐式转换相结合</p>
<p>上下文限定是将泛型和隐式转换的结合产物，以下两者功能相同，使用上下文限定[A : Ordering]之后，方法内无法使用隐式参数名调用隐式参数，需要通过implicitly[Ordering[A]]获取隐式变量，如果此时无法查找到对应类型的隐式变量，会发生出错误。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) : <span class="type">Unit</span> =&#123;</span><br><span class="line">	<span class="comment">//在某些情况下，处理的数据需要执行的类型才可以访问，那么就需要泛型和隐式转换相结合</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>[<span class="type">A</span> : <span class="type">Test</span>](a:<span class="type">A</span>):<span class="type">Unit</span> = println(a)</span><br><span class="line">    <span class="comment">//A:Test 等同于需要一个特定的操作 =》Test[A],表示需要的参数A是Test的泛型,底层默认会做A:Test =&gt;Test[A]的转换</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">val</span> test:<span class="type">Test</span>[<span class="type">User</span>] = <span class="keyword">new</span> <span class="type">Test</span>[<span class="type">User</span>]</span><br><span class="line">    <span class="comment">//如果在程序调用是，出现(...)的错误哦，那么表示隐式参数没有提供</span></span><br><span class="line">    f(<span class="keyword">new</span> <span class="type">User</span>()) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>[<span class="type">T</span>]</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubUser</span> <span class="keyword">extends</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h1 id="12-正则表达式"><a href="#12-正则表达式" class="headerlink" title="12.正则表达式"></a>12.正则表达式</h1><h2 id="12-1-简介"><a href="#12-1-简介" class="headerlink" title="12.1 简介"></a>12.1 简介</h2><p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p>
<p><img src="https://i.loli.net/2021/05/12/cVFybaLZgHspzlS.png" alt="image-20210512142220765"></p>
<p><img src="https://i.loli.net/2021/05/12/Al7REHktq9TciFP.png" alt="image-20210512142240090"></p>
<p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210512142250388.png" alt="image-20210512142250388"></p>
<h2 id="12-2-基本语法"><a href="#12-2-基本语法" class="headerlink" title="12.2 基本语法"></a>12.2 基本语法</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaRegex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 构建正则表达式</span></span><br><span class="line">        <span class="keyword">val</span> pattern = <span class="string">"Scala"</span>.r</span><br><span class="line">        <span class="keyword">val</span> str = <span class="string">"Scala is Scalable Language"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配字符串 - 第一个</span></span><br><span class="line">        println(pattern.findFirstIn(str))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配字符串 - 所有</span></span><br><span class="line">        <span class="keyword">val</span> iterator: <span class="type">Regex</span>.<span class="type">MatchIterator</span> = pattern findAllIn str</span><br><span class="line">        <span class="keyword">while</span> ( iterator.hasNext ) &#123;</span><br><span class="line">            println(iterator.next())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"***************************"</span>)</span><br><span class="line">        <span class="comment">// 匹配规则：大写，小写都可</span></span><br><span class="line">        <span class="keyword">val</span> pattern1 = <span class="keyword">new</span> <span class="type">Regex</span>(<span class="string">"(S|s)cala"</span>)</span><br><span class="line">        <span class="keyword">val</span> str1 = <span class="string">"Scala is scalable Language"</span></span><br><span class="line">        println((pattern1 findAllIn str1).mkString(<span class="string">","</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="12-3-案例实操"><a href="#12-3-案例实操" class="headerlink" title="12.3 案例实操"></a>12.3 案例实操</h2><p>手机号正则表达式验证方法</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaRegex</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 构建正则表达式</span></span><br><span class="line">    println(isMobileNumber(<span class="string">"18801234567"</span>))</span><br><span class="line">    println(isMobileNumber(<span class="string">"11111111111"</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isMobileNumber</span></span>(number: <span class="type">String</span>): <span class="type">Boolean</span> =&#123;</span><br><span class="line">    <span class="keyword">val</span> regex = <span class="string">"^((13[0-9])|(14[5,7,9])|(15[^4])|(18[0-9])|(17[0,1,3,5,6,7,8]))[0-9]&#123;8&#125;$"</span>.r</span><br><span class="line">    <span class="keyword">val</span> length = number.length</span><br><span class="line">    regex.findFirstMatchIn(number.slice(length<span class="number">-11</span>,length)) != <span class="type">None</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提取邮件地址的域名部分</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaRegex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 构建正则表达式</span></span><br><span class="line">        <span class="keyword">val</span> r = <span class="string">""</span><span class="string">"([_A-Za-z0-9-]+(?:\.[_A-Za-z0-9-\+]+)*)(@[A-Za-z0-9-]+(?:\.[A-Za-z0-9-]+)*(?:\.[A-Za-z]&#123;2,&#125;)) ?"</span><span class="string">""</span>.r</span><br><span class="line">        println(r.replaceAllIn(<span class="string">"abc.edf+jianli@gmail.com   hello@gmail.com.cn"</span>, (m =&gt; <span class="string">"*****"</span> + m.group(<span class="number">2</span>))))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







































































]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title>1.程序员应该如何学好数学</title>
    <url>/2021/05/08/%E6%95%B0%E5%AD%A6/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E8%AF%BE/</url>
    <content><![CDATA[<h1 id="0-程序员应该如何学好数学"><a href="#0-程序员应该如何学好数学" class="headerlink" title="0.程序员应该如何学好数学"></a>0.程序员应该如何学好数学</h1><h2 id="1-3个阶段"><a href="#1-3个阶段" class="headerlink" title="1.3个阶段"></a>1.3个阶段</h2><p>学一门新技术的3个阶段：</p>
<p>​    第一阶段是怎么使用；第二阶段是如何实现，原理是什么   第三阶段是，为什么这样实现</p>
<p>学数学和学一门新技术一样，也有这样3个阶段，先用起来，了解原理，然后了解为什么</p>
<h2 id="2-先广度，再深度"><a href="#2-先广度，再深度" class="headerlink" title="2.先广度，再深度"></a>2.先广度，再深度</h2><p>数学整个领域太大，最好先从工作相关的领域开始，先广度，再深度</p>
<p>从工作相关的领域开始，一是有实际用得上学到的知识的机会，而是日常工作中容易耳濡目染，相当于常常在复习。有广度，是让自己心中有一个解决问题的“地图”，遇到问题能都对得上，容易获得正反馈；然后再有深度，具体去对一个特定的主题学习应用。</p>
<p>当深入学一个特定问题的时候，最好的方式是，追一门在线课程，譬如coursea,TEDx,或者在极客时间上找一门课程学习。因为在线课程有明确的节奏还有作业和测验，可以保证学习的延续性和质量。</p>
<p>而对于程序员，可以针对学习的内容写一点程序，把正在学习的问题的解法，写一个算法实现出来，这是一个非常有效的练习方式。</p>
<p>把握数学的工具属性，学习具体方法时先溯因再求果，勤于思考解决相同问题的不同方法，与解决不同问题的相同方法之间的联系与区别</p>
<h2 id="3-程序员的数学应用地图"><a href="#3-程序员的数学应用地图" class="headerlink" title="3.程序员的数学应用地图"></a>3.程序员的数学应用地图</h2><p><img src="https://i.loli.net/2021/05/08/TDyK6aflrU5LIc8.jpg" alt="29d37a8eb43c1d007b15a938213a8b50"></p>
<h1 id="1-基础思想篇"><a href="#1-基础思想篇" class="headerlink" title="1.基础思想篇"></a>1.基础思想篇</h1><h2 id="01-二进制"><a href="#01-二进制" class="headerlink" title="01 二进制"></a>01 二进制</h2><h2 id="02-余数：原来取余操作本身就是个哈希函数"><a href="#02-余数：原来取余操作本身就是个哈希函数" class="headerlink" title="02 余数：原来取余操作本身就是个哈希函数"></a>02 余数：原来取余操作本身就是个哈希函数</h2><p>余数的本质就是对数据进行分类，可以将无限的数据通过取余进行有限的分类。</p>
<h2 id="03-迭代法：不用编程语言的自带函数，你会如何计算平方根"><a href="#03-迭代法：不用编程语言的自带函数，你会如何计算平方根" class="headerlink" title="03 迭代法：不用编程语言的自带函数，你会如何计算平方根"></a>03 迭代法：不用编程语言的自带函数，你会如何计算平方根</h2><p>迭代法思想：用旧的变量来推演新的变量。方法：确定迭代变量和递推公式</p>
<h2 id="04-数学归纳法"><a href="#04-数学归纳法" class="headerlink" title="04 数学归纳法"></a>04 数学归纳法</h2><p>总结规律，避免循环计算</p>
<h2 id="05-递归（上）：泛化数学归纳，如何将复杂问题简单化"><a href="#05-递归（上）：泛化数学归纳，如何将复杂问题简单化" class="headerlink" title="05 递归（上）：泛化数学归纳，如何将复杂问题简单化"></a>05 递归（上）：泛化数学归纳，如何将复杂问题简单化</h2><h2 id="06-递归（下）：分而治之，从归并排序到MapReduce"><a href="#06-递归（下）：分而治之，从归并排序到MapReduce" class="headerlink" title="06 递归（下）：分而治之，从归并排序到MapReduce"></a>06 递归（下）：分而治之，从归并排序到MapReduce</h2><h1 id="2-概率统计篇"><a href="#2-概率统计篇" class="headerlink" title="2.概率统计篇"></a>2.概率统计篇</h1><h1 id="3-线性代数篇"><a href="#3-线性代数篇" class="headerlink" title="3.线性代数篇"></a>3.线性代数篇</h1><h1 id="4-综合应用篇"><a href="#4-综合应用篇" class="headerlink" title="4.综合应用篇"></a>4.综合应用篇</h1>]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>使用syncChanges基于changeTracking的方式实现SQLserver数据库之间数据的实时同步</title>
    <url>/2021/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlserver/%E4%BD%BF%E7%94%A8syncChanges%E5%9F%BA%E4%BA%8EchangeTracking%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5SQLServer%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><p><font color='cornflowerblue'><a href="#目的">1.目的</a></font></p>
<p><font color='cornflowerblue'><a href="#实现步骤">2.实现步骤</a></font></p>
<p>  <font color='cornflowerblue'><a href="#console">2.1 基于console application</a></font></p>
<p>  <font color='cornflowerblue'><a href="#service">2.2 基于windows service</a></font></p>
<p><font color='cornflowerblue'><a href="#问题记录">3.问题记录和沟通流程</a></font></p>
<p><font color='cornflowerblue'><a href="#总结">4.总结</a></font></p>
<h1 id="1-目的"><a href="#1-目的" class="headerlink" title="1.目的"></a><span id = "目的">1.目的</span></h1><p>基于change tracking的方式实现SQLserver数据库之间数据的实时同步</p>
<p>工具可选：</p>
<p>国内：syncNavigator    收费并且没什么人进行维护</p>
<p>国外：syncChanges    开源不收费，没有详细的实操案例，资料较少，但是优点是该项目的开发者会定期对项目进行维护，回答问题也比较热心。</p>
<p>最后选择syncChanges进行调研</p>
<p>资料连接：<a href="https://github.com/mganss/SyncChanges" target="_blank" rel="noopener">https://github.com/mganss/SyncChanges</a></p>
<h1 id="2-实现步骤"><a href="#2-实现步骤" class="headerlink" title="2.实现步骤"></a><span id = "实现步骤">2.实现步骤</span></h1><p>使用syncChanges实现SQLserver数据库间的数据同步有两种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）基于console application的方式，特点是一次调用，对应的资源包是SyncChanges.Console.2.1.308</span><br><span class="line">2）基于windows service的方式，特点是将应用程序部署为服务，在配置文件中设置调度周期，周期性的触发同步过程，周期时延可以达到秒级(后面的测试我设置为了1s)，对应的资源包是SyncChanges.Service.2.1.308</span><br><span class="line">下载地址为：https:&#x2F;&#x2F;github.com&#x2F;mganss&#x2F;SyncChanges&#x2F;releases</span><br></pre></td></tr></table></figure>

<p>下面会对两种方式的步骤都进行阐述，因为后续要实时地去同步数据，所以需要用到<strong>windows service</strong>这种方式，这种方式后续会着重阐述。</p>
<h2 id="2-1-基于console-application"><a href="#2-1-基于console-application" class="headerlink" title="2.1 基于console application"></a><span id = "console">2.1 基于console application</span></h2><p>这部分内容对应的开源文档链接：<a href="https://github.com/mganss/SyncChanges" target="_blank" rel="noopener">https://github.com/mganss/SyncChanges</a></p>
<p>其中在Usage部分进行了介绍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage</span><br><span class="line">SyncChanges can be used either as a console application that is typically invoked through a task scheduler every couple of minutes, as a Windows service, or as a library in your own applications. If you want to use the service or console application just grab a zip from releases.</span><br><span class="line"></span><br><span class="line">Usage: SyncChanges [OPTION]... CONFIGFILE...</span><br><span class="line">Replicate database changes.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -h, --help                 Show this message and exit</span><br><span class="line">  -d, --dryrun               Do not alter target databases, only perform a test</span><br><span class="line">                               run</span><br><span class="line">  -t, --timeout&#x3D;VALUE        Database command timeout in seconds</span><br><span class="line">  -l, --loop                 Perform replication in a loop, periodically</span><br><span class="line">                               checking for changes</span><br><span class="line">  -i, --interval&#x3D;VALUE       Replication interval in seconds (default is 30);</span><br><span class="line">                               only relevant in loop mode</span><br><span class="line">A configuration file looks like this:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;ReplicationSets&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Name&quot;: &quot;Test&quot;,</span><br><span class="line">      &quot;Source&quot;: &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;Primary&quot;,</span><br><span class="line">        &quot;ConnectionString&quot;: &quot;Data Source&#x3D;primary.example.com;Initial Catalog&#x3D;Test;Integrated Security&#x3D;True;MultipleActiveResultSets&#x3D;True&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;Destinations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;Name&quot;: &quot;Secondary 1&quot;,</span><br><span class="line">          &quot;ConnectionString&quot;: &quot;Data Source&#x3D;secondary1.example.com;Initial Catalog&#x3D;Test;Integrated Security&#x3D;True;MultipleActiveResultSets&#x3D;True&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;Name&quot;: &quot;Secondary 2&quot;,</span><br><span class="line">          &quot;ConnectionString&quot;: &quot;Data Source&#x3D;secondary2.example.com;Initial Catalog&#x3D;Test;Integrated Security&#x3D;True;MultipleActiveResultSets&#x3D;True&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;Tables&quot;: [ &quot;Table1&quot;, &quot;Table2&quot;, &quot;Table3&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">Tables is optional. If you don&#39;t specify it, all tables will be replicated.</span><br></pre></td></tr></table></figure>

<p>步骤如下：</p>
<h3 id="2-1-1-下载需要用到的资源包SyncChanges-Console-2-1-308"><a href="#2-1-1-下载需要用到的资源包SyncChanges-Console-2-1-308" class="headerlink" title="2.1.1 下载需要用到的资源包SyncChanges.Console.2.1.308"></a>2.1.1 下载需要用到的资源包SyncChanges.Console.2.1.308</h3><p><a href="https://github.com/mganss/SyncChanges/releases" target="_blank" rel="noopener">https://github.com/mganss/SyncChanges/releases</a></p>
<p><img src="https://i.loli.net/2021/05/07/dTH8nibyBVMG3JA.png" alt="image-20210507171839643"></p>
<h3 id="2-1-2-配置config-json"><a href="#2-1-2-配置config-json" class="headerlink" title="2.1.2 配置config.json"></a>2.1.2 配置config.json</h3><p>按照config.example.json配置模板进行同步相关的配置，主要是配置需要同步的主数据库的信息和从数据库的信息</p>
<p>我的配置如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"ReplicationSets"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"Name"</span>: <span class="string">"Test"</span>,</span><br><span class="line">      <span class="attr">"Source"</span>: &#123;</span><br><span class="line">        <span class="attr">"Name"</span>: <span class="string">"Primary"</span>,</span><br><span class="line">        <span class="attr">"ConnectionString"</span>: <span class="string">"Data Source=192.168.1.195;Initial Catalog=shanmeitest2;User ID=sa;password=123456;Integrated Security=false;MultipleActiveResultSets=True"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"Destinations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"Name"</span>: <span class="string">"Secondary1"</span>,</span><br><span class="line">          <span class="attr">"ConnectionString"</span>: <span class="string">"Data Source=192.168.1.180;Initial Catalog=shanmeitest2;User ID=sa;password=123456;Integrated Security=false;MultipleActiveResultSets=True"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中Name可自定义，为同步任务的名称</p>
<p>Source为源数据库的配置，Destinations为目标数据库的配置。主要的信息是ConnectionString，ConnectionString为数据库的连接信息，datasource配置的是数据库所在的计算机ip地址，catalog对应要同步的数据库，UserID和password分别为SQLserver数据库登录时的用户名和密码。这里需要注意的是源数据库和目标数据库的登录方式要一样（比如源数据是用SQLserver身份验证登录的，目标数据库也必须是，不能是windows身份验证方式登录），这里都是用的sa/123456</p>
<p>这里没有配置表信息，默认就会同步所有表，如果只想同步部分表信息，可以参考config.example.json进行配置</p>
<h3 id="2-1-3-准备源数据库和目标数据库的测试环境"><a href="#2-1-3-准备源数据库和目标数据库的测试环境" class="headerlink" title="2.1.3 准备源数据库和目标数据库的测试环境"></a>2.1.3 准备源数据库和目标数据库的测试环境</h3><p>这里参照windows service这一步的步骤即可</p>
<h3 id="2-1-4-运行可执行程序SyncChanges-Console-exe"><a href="#2-1-4-运行可执行程序SyncChanges-Console-exe" class="headerlink" title="2.1.4 运行可执行程序SyncChanges.Console.exe"></a>2.1.4 运行可执行程序SyncChanges.Console.exe</h3><p>进入SyncChanges.Console2.1.308目录下，进入cmd</p>
<p>运行如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SyncChanges.Console.exe config.json</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/05/07/H8psJDQhPI3ySfz.png" alt="image-20210507172511926"></p>
<p>查到目标数据库的情况，验证最终测试成功</p>
<h2 id="2-2-基于windows-service"><a href="#2-2-基于windows-service" class="headerlink" title="2.2 基于windows service"></a><span id = "service">2.2 基于windows service</span></h2><p>这部分内容对应的开源文档链接：<a href="https://github.com/mganss/SyncChanges" target="_blank" rel="noopener">https://github.com/mganss/SyncChanges</a></p>
<p>其中在service部分进行了介绍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Service</span><br><span class="line">In addition to the command line you can also run SyncChanges as a Windows service. The service periodically polls the value of CHANGE_TRACKING_CURRENT_VERSION in a configurable interval and starts replication if the version of the source has increased.</span><br><span class="line"></span><br><span class="line">The service expects a config.json configuration file in the same folder as the service executable. The desired polling interval can be configured in the SyncChanges.Service.exe.config file.</span><br><span class="line"></span><br><span class="line">To install the service, use the InstallUtil.exe tool that comes with the .NET Framework installation:</span><br><span class="line"></span><br><span class="line">C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe .\SyncChanges.Service.exe</span><br><span class="line">During installation, you have to enter credentials for the user account the service will use. This has to be a fully qualified name, e.g. if it&#39;s a local account enter .\UserName. The user has to have the necessary database permissions to carry out the replication process.</span><br><span class="line"></span><br><span class="line">To start the service:</span><br><span class="line"></span><br><span class="line">net start SyncChangesService</span><br></pre></td></tr></table></figure>

<p>步骤如下：</p>
<h3 id="2-2-1-下载需要用到的资源包SyncChanges-Service-2-1-308"><a href="#2-2-1-下载需要用到的资源包SyncChanges-Service-2-1-308" class="headerlink" title="2.2.1 下载需要用到的资源包SyncChanges.Service.2.1.308"></a>2.2.1 下载需要用到的资源包SyncChanges.Service.2.1.308</h3><p><a href="https://github.com/mganss/SyncChanges/releases" target="_blank" rel="noopener">https://github.com/mganss/SyncChanges/releases</a></p>
<p><img src="https://i.loli.net/2021/05/07/ETyc752a8F6WfGA.png" alt="image-20210507152551412"></p>
<h3 id="2-2-2-配置config-json"><a href="#2-2-2-配置config-json" class="headerlink" title="2.2.2 配置config.json"></a>2.2.2 配置config.json</h3><p>按照config.example.json配置模板进行同步相关的配置，主要是配置需要同步的主数据库的信息和从数据库的信息</p>
<p>我的配置如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"ReplicationSets"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"Name"</span>: <span class="string">"Test"</span>,</span><br><span class="line">      <span class="attr">"Source"</span>: &#123;</span><br><span class="line">        <span class="attr">"Name"</span>: <span class="string">"Primary"</span>,</span><br><span class="line">        <span class="attr">"ConnectionString"</span>: <span class="string">"Data Source=192.168.1.195;Initial Catalog=shanmeitest2;User ID=sa;password=123456;Integrated Security=false;MultipleActiveResultSets=True"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"Destinations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"Name"</span>: <span class="string">"Secondary1"</span>,</span><br><span class="line">          <span class="attr">"ConnectionString"</span>: <span class="string">"Data Source=192.168.1.180;Initial Catalog=shanmeitest2;User ID=sa;password=123456;Integrated Security=false;MultipleActiveResultSets=True"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中Name可自定义，为同步任务的名称</p>
<p>Source为源数据库的配置，Destinations为目标数据库的配置。主要的信息是ConnectionString，ConnectionString为数据库的连接信息，datasource配置的是数据库所在的计算机ip地址，catalog对应要同步的数据库，UserID和password分别为SQLserver数据库登录时的用户名和密码。这里需要注意的是源数据库和目标数据库的登录方式要一样（比如源数据是用SQLserver身份验证登录的，目标数据库也必须是，不能是windows身份验证方式登录），这里都是用的sa/123456</p>
<p>这里没有配置表信息，默认就会同步所有表，如果只想同步部分表信息，可以参考config.example.json进行配置</p>
<h3 id="2-2-3-配置任务调度周期"><a href="#2-2-3-配置任务调度周期" class="headerlink" title="2.2.3 配置任务调度周期"></a>2.2.3 配置任务调度周期</h3><p>在SyncChanges.Service.exe.config中配置任务调度周期，对应的参数为interval</p>
<p><img src="https://i.loli.net/2021/05/07/SmZ7s8efuHDLqK1.png" alt="image-20210507153820882"></p>
<p>这里设置的是1s，每隔1s触发同步操作</p>
<h3 id="2-2-4-准备源数据库和目标数据库的测试环境"><a href="#2-2-4-准备源数据库和目标数据库的测试环境" class="headerlink" title="2.2.4 准备源数据库和目标数据库的测试环境"></a>2.2.4 准备源数据库和目标数据库的测试环境</h3><p>重点：源数据库和目标数据库的表结构信息要一致，并且源数据库和需要同步的表要开启change tracking和</p>
<p>snapshot isolation。目标数据库没有强制要求，但必须先把表建好，同步过程不会自动建表。</p>
<h4 id="1）源数据库建库建表"><a href="#1）源数据库建库建表" class="headerlink" title="1）源数据库建库建表"></a>1）源数据库建库建表</h4><p><img src="https://i.loli.net/2021/05/07/ov9GxDOgst46JdE.png" alt="img"></p>
<h4 id="2）对源数据库和需要同步的表开启change-tracking和snapshot-isolation"><a href="#2）对源数据库和需要同步的表开启change-tracking和snapshot-isolation" class="headerlink" title="2）对源数据库和需要同步的表开启change tracking和snapshot isolation"></a>2）对源数据库和需要同步的表开启change tracking和snapshot isolation</h4><p><img src="https://i.loli.net/2021/05/07/vV73LWy9FaPfoTA.png" alt="img"></p>
<p>操作代码如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> shanmeitest2</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"> <span class="keyword">alter</span> <span class="keyword">database</span> shanmeitest2 <span class="keyword">set</span> CHANGE_TRACKING = <span class="keyword">ON</span></span><br><span class="line"> (change_retention = <span class="number">2</span> <span class="keyword">days</span>, auto_cleanup = <span class="keyword">on</span>)</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> shanmeitest2</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"> <span class="keyword">alter</span> <span class="keyword">table</span> dbo.t_student <span class="keyword">enable</span> CHANGE_TRACKING <span class="keyword">WITH</span>(TRACK_COLUMNS_UPDATED = <span class="keyword">off</span>)</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> shanmeitest2</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"> <span class="keyword">alter</span> <span class="keyword">database</span> shanmeitest2</span><br><span class="line"> <span class="keyword">set</span> allow_snapshot_isolation <span class="keyword">on</span></span><br><span class="line"><span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>其中如果不配置change_retention的话 默认就是2天，这个配置的意思是源数据库的数据变更保留的时间周期，超过了配置的时间变化就不再保留会删除，如果磁盘空间大的话也可以配置的长一点。</p>
<h4 id="3）目标数据库建库建表"><a href="#3）目标数据库建库建表" class="headerlink" title="3）目标数据库建库建表"></a>3）目标数据库建库建表</h4><p><img src="https://i.loli.net/2021/05/07/XLhbcrPKyMvVGTi.png" alt="image-20210507160759048"></p>
<h3 id="2-2-5-注册windows服务（SyncChangesService）"><a href="#2-2-5-注册windows服务（SyncChangesService）" class="headerlink" title="2.2.5 注册windows服务（SyncChangesService）"></a>2.2.5 注册windows服务（SyncChangesService）</h3><p>根据开源文档提示进行操作，需要注意的是在执行服务安装命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe .\SyncChanges.Service.exe</span><br></pre></td></tr></table></figure>

<p>的时候需要数据身份验证信息用户名和密码，这个用户名和密码是用来跑注册的服务的，所以需要有管理员的权限，这里试了很久才测试出来</p>
<p>具体步骤如下</p>
<h4 id="1）以管理员的身份运行命令提示符-command-prompt"><a href="#1）以管理员的身份运行命令提示符-command-prompt" class="headerlink" title="1）以管理员的身份运行命令提示符(command prompt)"></a>1）以<strong><em>管理员</em></strong>的身份运行命令提示符(command prompt)</h4><p><img src="https://i.loli.net/2021/05/07/F2E4PJXrmjLYBGN.png" alt="image-20210507161949178"></p>
<h4 id="2）进入SyncChanges-Service-2-1-308目录"><a href="#2）进入SyncChanges-Service-2-1-308目录" class="headerlink" title="2）进入SyncChanges.Service.2.1.308目录"></a>2）进入SyncChanges.Service.2.1.308目录</h4><p>我这里是F盘下面</p>
<p><img src="https://i.loli.net/2021/05/07/cZrO6UqDlhTLfyE.png" alt="image-20210507162145299"></p>
<h4 id="3）执行服务安装命令"><a href="#3）执行服务安装命令" class="headerlink" title="3）执行服务安装命令"></a>3）执行服务安装命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe .\SyncChanges.Service.exe</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/05/07/yCPkYhuQUR349n7.png" alt="image-20210507162940955"></p>
<p>需要注意的是这里安装的时候需要输入身份验证凭据，用户名和密码，这个用户需要有管理员权限，我的是Administrator，默认是没有密码的，也可以设置密码</p>
<p><img src="https://i.loli.net/2021/05/07/vgBi6Eclpx9uj8R.png" alt="image-20210507162548005"></p>
<p>需要注意的是在输入用户名的时候需要加上.\作为前缀，也就是.\用户名，我这里对应的输入就是.\Administrator</p>
<p>用户名：.\Administrator</p>
<p>密码：123456（输入自己设置的密码）</p>
<p>确认密码：123456</p>
<p>然后就会提示安装成功</p>
<p><img src="https://i.loli.net/2021/05/07/AWcfPCIVrH2S8mE.png" alt="image-20210507162305629"></p>
<h4 id="4）启动服务"><a href="#4）启动服务" class="headerlink" title="4）启动服务"></a>4）启动服务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start SyncChangesService</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/05/07/RdcJT597zkV3Oga.png" alt="image-20210507163051048"></p>
<p>然后可以将服务设置为开机自启动</p>
<p><img src="https://i.loli.net/2021/05/07/NOeTsnMcxuvlbi1.png" alt="image-20210507163444819"></p>
<h3 id="2-2-6-测试"><a href="#2-2-6-测试" class="headerlink" title="2.2.6 测试"></a>2.2.6 测试</h3><p>往源数据库的表中插入数据，查看目标数据库的表数据的变化</p>
<p><strong>源数据库</strong></p>
<p><img src="https://i.loli.net/2021/05/07/Sov5JAHKENCP2wZ.png" alt="img"></p>
<p><strong>目标数据库</strong></p>
<p><img src="https://i.loli.net/2021/05/07/VnioRqsuDhIjYv7.png" alt="image-20210507163621401"></p>
<p>经测试，可以实时地将数据同步过来</p>
<h1 id="3-问题记录和沟通过程"><a href="#3-问题记录和沟通过程" class="headerlink" title="3.问题记录和沟通过程"></a><span id = "问题记录">3.问题记录和沟通过程</span></h1><p>在测试console  application和windows service的方式都遇到了很多问题，因为无法实时沟通，一般当天发现的问题在github上提问后，需要第二天才能等到答复，具体的问题记录和沟通过程以及后续的提问都可以参照下面的网址</p>
<p><a href="https://github.com/mganss/SyncChanges/issues" target="_blank" rel="noopener">https://github.com/mganss/SyncChanges/issues</a></p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a><span id = "总结">4.总结</span></h1><p>SyncChanges经过测试，基于change tracking的方式可以达到秒级实时地同步，并且也可以同步历史数据。因为这种同步是基于数据变更的，所以它的同步效率跟原始数据库的数据量是没有关系的，有关系的因素是原始数据库的数据变化频率，具体的同步能力还需要在生产环境上进行测试。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>SQLServer</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>0.clickhouse课程介绍</title>
    <url>/2021/05/06/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/clickhouse/0.clickhouse%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h1><p>1）基础篇：clickhouse的产生背景，核心特性和逻辑架构</p>
<p>2）应用篇：clickhouse的基础用法</p>
<p>3）原理篇：clickhouse核心功能的运行原理</p>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>讲师博客主页：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;zhongqi2513</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
        <category>Clickhouse</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>2.Flink集群启动之JobManager和TaskManager启动</title>
    <url>/2021/04/26/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/Flink/%E6%BA%90%E7%A0%81/2.Flink%E9%9B%86%E7%BE%A4%E5%90%AF%E5%8A%A8%E4%B9%8BJobManager%E5%92%8CTaskManager%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="1-课程内容大纲"><a href="#1-课程内容大纲" class="headerlink" title="1.课程内容大纲"></a>1.课程内容大纲</h1><p>目标：搞清楚一个Flink Job在yarn模式下启动执行的一个完整的流程</p>
<p>课程主题：Flink 源码剖析：Flink 集群启动：JobManager 和 TaskManager 启动</p>
<p><a href="">2.1 Flink 集群启动脚本分析</a> </p>
<p><a href="">2.2 Flink 主节点 StandaloneSessionClusterEntrypoint 启动源码分析</a> </p>
<p><a href="">2.2.1 WebMonitorEndpoint 启动和初始化源码剖析</a> </p>
<p><a href="">2.2.2 ResourceManager 启动和初始化源码剖析</a> </p>
<p><a href="">2.2.3 Dispatcher 启动和初始化源码剖</a> </p>
<p><a href="">2.3 Flink 从节点 TaskManagerRunner 启动源码分析</a> </p>
<p><a href="">2.3.1 TaskManager/TaskExecutor 注册</a> </p>
<p><a href="">2.3.2 监听和获取 ResourceManager 的地址</a> </p>
<p><a href="">2.3.3 TaskExecutor 开始注册</a> </p>
<p><a href="">2.3.4 TaskExecutor 注册失败</a> </p>
<p><a href="">2.3.5 TaskExecutor 注册成功</a> </p>
<p><a href="">2.3.6 TaskExecutor 进行 Slot 汇报</a> </p>
<p><a href="">2.4 TaskExecutor 和 ResourceManager 心跳</a> </p>
<p><a href="">2.4.1 ResourceManager 端心跳服务启动</a> </p>
<p><a href="">2.4.2 TaskExecutor 端心跳处理</a> </p>
<p><a href="">2.4.3 TaskExecutor 向 ResourceManager 汇报负载</a></p>
<h1 id="2-课程详细内容：Flink集群启动源码剖析"><a href="#2-课程详细内容：Flink集群启动源码剖析" class="headerlink" title="2.课程详细内容：Flink集群启动源码剖析"></a>2.课程详细内容：Flink集群启动源码剖析</h1><h2 id="2-1-Flink集群启动脚本分析"><a href="#2-1-Flink集群启动脚本分析" class="headerlink" title="2.1 Flink集群启动脚本分析"></a>2.1 Flink集群启动脚本分析</h2><p>flink的集群启动脚本在：flink-dist子项目下，位于flink-bin下的bin目录：启动脚本为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-cluster.sh</span><br></pre></td></tr></table></figure>

<p>该脚本会首先调用config.sh来获取masters和workers</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.masters的信息，是从conf&#x2F;masters配置文件获取的</span><br><span class="line">2.workers的信息，是从conf&#x2F;workers配置文件中获取的</span><br></pre></td></tr></table></figure>

<p>然后分别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.通过jobmanager.sh 来启动JobManager</span><br><span class="line">2.通过taskManager.sh 来启动TaskManager</span><br></pre></td></tr></table></figure>

<p>它们的内部，都通过flink-daemon.sh脚本来启动相应的jvm进程，分离flink-daemon.sh脚本发现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.JobManager的启动代号：standalonesession,实现类是StandaloneSessionClusterEntrypoint</span><br><span class="line">2.TaskManager的启动代号：TaskExecutor，实现类是：TaskManagerRunner</span><br></pre></td></tr></table></figure>

<p>最终通过java命令来启动对应的jvm进程！</p>
<p>其实发现，HDFS集群启动的shell编写的方式也是一样的，Spark的Shell脚本的编写方式也差不多。这里以HDFS举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一步：执行下面脚本启动集群</span></span><br><span class="line">start-all.sh / start-dfs.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二步：启动集群启动脚本的时候，内部其实会根据集群模式来启动 namenode，datanode，等</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不管启动什么角色，最终都是通过 hadoop-daemon.sh 来启动</span></span><br><span class="line">hadoop-daemon.sh start namenode/datanode/zkfc/journalnode</span><br><span class="line"><span class="meta">#</span><span class="bash"> 第三步：在 hadoop-daemon.sh 脚本的内部的最后，是通过 java 命令来启动</span></span><br><span class="line">java org.apache.hadoop.server.namenode.NameNode</span><br></pre></td></tr></table></figure>







<h2 id="2-2-Flink主节点StandaloneSessionClusterEntrypoint启动源码分析"><a href="#2-2-Flink主节点StandaloneSessionClusterEntrypoint启动源码分析" class="headerlink" title="2.2 Flink主节点StandaloneSessionClusterEntrypoint启动源码分析"></a>2.2 Flink主节点StandaloneSessionClusterEntrypoint启动源码分析</h2><p>ClusterEntrypoint：集群启动入口类 </p>
<p><img src="https://i.loli.net/2021/04/26/gQdbu5FXWZ17DGO.png" alt="image-20210426155232070"></p>
<p>Flink 主从架构： 主节点：JobManager + 从节点：TaskManager </p>
<p>JobManager 是 Flink 集群的主节点，它包含三大重要的组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.ResourceManager</span><br><span class="line">	Flink的集群资源管理器，只有一个，负责关于slot的管理和申请等工作</span><br><span class="line">2.Dispatcher</span><br><span class="line">	负责接收用户提交的JobGraph，然后启动一个JobMaster，JobMaster类似于YARN集群中的AppMaster角色，类似于Spark Job的Driver角色。</span><br><span class="line">	内部有一个持久服务器：JobGraphStore，用来存储提交到JobManager的Job信息，也可以用作主节点宕机之后做job恢复之用</span><br><span class="line">	</span><br><span class="line">3.WebMonitorEndpoint </span><br><span class="line">    这其实是一个rest服务器&#x3D;netty服务器</span><br><span class="line">	里面维护了很多的handler，并且会启动一个netty服务器，用来接收外部的rest请求</span><br><span class="line">	假设客户端通过flink run的方式提交了一个job到flink集群，最终是由webMonitorEndpoint来接收处理，经过路由解析处理之后决定使用哪一个handler来执行处理</span><br><span class="line">	例如：submitJob   &#x3D;&#x3D;》JobSubmitHandler</span><br><span class="line">	Router 路由器 绑定了一大堆Handler</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.flink的主节点内部运行有：webMonitorEndpoint,dispatcher,resourceManager</span><br><span class="line"></span><br><span class="line">2.当client通过rest方式提交一个job到集群运行的时候（客户端会把改Job构建成JobGraph对象）是由WebMonitorEndpoint来接收处理的，WebMonitorEndpoint内部会通过Router进行路由解析找到对应的handler来执行处理，处理完毕之后交给Dispatcher,Dispatcher负责拉起JobMaster来负责这个job的slot资源申请和task的部署执行，关于Job执行过程中，所需要的slot资源，有JobMaster向ResourceManager申请。</span><br></pre></td></tr></table></figure>



<p>对应这个3个要启动的组件，都有一个对应的factory，这些组件实例的创建都是由对应的factory来完成的！这些factory最终，都会被封装到ComponentFactory中！</p>
<p>根据以上的启动脚本分析：JobManager的启动主类：StandaloneSessionClusterEntryPoint</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入口，解析命令行参数 和 配置文件 flink-conf.yaml</span></span><br><span class="line">StandaloneSessionClusterEntrypoint.main()</span><br><span class="line">ClusterEntrypoint.runClusterEntrypoint(entrypoint);</span><br><span class="line"><span class="comment">// 启动插件组件，配置文件系统实例等</span></span><br><span class="line">clusterEntrypoint.startCluster();</span><br><span class="line">runCluster(configuration, pluginManager);</span><br><span class="line"><span class="comment">// 第一步：初始化各种服务（8个基础服务,比如心跳服务选举服务等等）</span></span><br><span class="line"><span class="comment">// 比较重要的：HAService， RpcServices， HeatbeatServices，....</span></span><br><span class="line">initializeServices(configuration, pluginManager);</span><br><span class="line"><span class="comment">// 创建 DispatcherResourceManagerComponentFactory, 初始化各种组件的工厂实例</span></span><br><span class="line"><span class="comment">// 其实内部包含了三个重要的成员变量：</span></span><br><span class="line"><span class="comment">// 创建 ResourceManager 的工厂实例</span></span><br><span class="line"><span class="comment">// 创建 Dispatcher 的工厂实例</span></span><br><span class="line"><span class="comment">// 创建 WebMonitorEndpoint 的工厂实例</span></span><br><span class="line">createDispatcherResourceManagerComponentFactory(configuration);</span><br><span class="line"><span class="comment">// 创建 集群运行需要的一些组件：WebMonitorEndpoint，Dispatcher， ResourceManager 等</span></span><br><span class="line"><span class="comment">// 创建和启动 ResourceManager</span></span><br><span class="line"><span class="comment">// 创建和启动 Dispatcher</span></span><br><span class="line"><span class="comment">// 创建和启动 WebMonitorEndpoint</span></span><br><span class="line">clusterComponent = dispatcherResourceManagerComponentFactory.create(...)</span><br></pre></td></tr></table></figure>



<p>第一步 initializeServices() 中做了很多服务组件的初始化：第一步 initializeServices() 中做了很多服务组件的初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化和启动 AkkaRpcService，内部其实包装了一个 ActorSystem</span></span><br><span class="line">commonRpcService = AkkaRpcServiceUtils.createRemoteRpcService(...)</span><br><span class="line"><span class="comment">// 启动一个 JMXService，用于客户端链接 JobManager JVM 进行监控，这是1.12加上去的</span></span><br><span class="line">JMXService.startInstance(configuration.getString(JMXServerOptions.JMX_SERVER_PORT));</span><br><span class="line"><span class="comment">// 初始化一个负责 IO 的线程池, Flink 大量使用了 异步编程,所以启动了这个线程池。</span></span><br><span class="line"><span class="comment">// 这个线程池的线程的数量，默认是：cpu core 个数 * 4</span></span><br><span class="line">ioExecutor = Executors.newFixedThreadPool(...)</span><br><span class="line"><span class="comment">// 初始化 HA 服务组件，负责 HA 服务的是：ZooKeeperHaServices</span></span><br><span class="line">haServices = createHaServices(configuration, ioExecutor);</span><br><span class="line"><span class="comment">// 初始化 BlobServer 服务端</span></span><br><span class="line">blobServer = <span class="keyword">new</span> BlobServer(configuration, haServices.createBlobStore());</span><br><span class="line">blobServer.start();</span><br><span class="line"><span class="comment">// 初始化心跳服务组件, heartbeatServices = HeartbeatServices</span></span><br><span class="line">heartbeatServices = createHeartbeatServices(configuration);</span><br><span class="line"><span class="comment">// 启动 metrics（性能监控） 相关的服务，内部也是启动一个 ActorSystem</span></span><br><span class="line">MetricUtils.startRemoteMetricsRpcService(configuration, commonRpcService.getAddress());</span><br><span class="line"><span class="comment">// 初始化一个用来存储 ExecutionGraph 的 Store, 实现是：FileArchivedExecutionGraphStore</span></span><br><span class="line">archivedExecutionGraphStore = createSerializableExecutionGraphStore(...)</span><br></pre></td></tr></table></figure>

<p>第二步 createDispatcherResourceManagerComponentFactory(configuration) 中负责初始化了很多组件的工厂实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、DispatcherRunnerFactory，默认实现：DefaultDispatcherRunnerFactory，生产 DefaultDispatcherRunner</span><br><span class="line"><span class="number">2</span>、ResourceManagerFactory，默认实现：StandaloneResourceManagerFactory，生产 StandaloneResourceManager</span><br><span class="line"><span class="number">3</span>、RestEndpointFactory，默认实现：SessionRestEndpointFactory，生产 DispatcherRestEndpoint</span><br></pre></td></tr></table></figure>











<h2 id="2-3-Flink从节点TaskManagerRunner启动源码分析"><a href="#2-3-Flink从节点TaskManagerRunner启动源码分析" class="headerlink" title="2.3 Flink从节点TaskManagerRunner启动源码分析"></a>2.3 Flink从节点TaskManagerRunner启动源码分析</h2><h2 id="2-4-TaskExecutor和ResourceManager心跳"><a href="#2-4-TaskExecutor和ResourceManager心跳" class="headerlink" title="2.4 TaskExecutor和ResourceManager心跳"></a>2.4 TaskExecutor和ResourceManager心跳</h2>]]></content>
      <categories>
        <category>Flink</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>1.1使用Akka模拟实现FlinkStandalone集群</title>
    <url>/2021/04/20/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/Flink/%E6%BA%90%E7%A0%81/1.1%E4%BD%BF%E7%94%A8Akka%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0FlinkStandalone%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<p>[1.使用akka模拟实现Flink Standalone](#1.使用Akka模拟实现Flink Standalone)</p>
<p><a href="#2.代码实现">2.代码实现</a></p>
<p>  <a href="">2.1 MyJobManager实现</a></p>
<p>  [2.2 MyTaskManager实现](#2.2 MyTaskManager实现)</p>
<p>  [2.3 工具类Constant实现](#2.3 工具类Constant实现)</p>
<p>  [2.4 工具类Message实现](#2.4 工具类Message实现)</p>
<h1 id="1-使用Akka模拟实现Flink-Standalone"><a href="#1-使用Akka模拟实现Flink-Standalone" class="headerlink" title="1.使用Akka模拟实现Flink Standalone"></a>1.使用Akka模拟实现Flink Standalone</h1><p><img src="https://i.loli.net/2021/04/20/1qzjMQsEbpfl5Kt.png" alt="image-20210420114108555"></p>
<h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h1><h2 id="2-1-MyJobManager实现"><a href="#2-1-MyJobManager实现" class="headerlink" title="2.1 MyJobManager实现"></a>2.1 MyJobManager实现</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.neixuejiaoyu.rpc.akka2flink</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.actor.&#123;<span class="type">Actor</span>, <span class="type">ActorSystem</span>, <span class="type">Props</span>&#125;</span><br><span class="line"><span class="keyword">import</span> com.typesafe.config.<span class="type">ConfigFactory</span></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment"> * TODO_MA 马中华 https://blog.csdn.net/zhongqi2513</span></span><br><span class="line"><span class="comment"> * 注释： 集群主节点抽象</span></span><br><span class="line"><span class="comment"> * 1、receive 方法 接收其他 actor 发送过来的消息，然后进行模式匹配，进行消息处理，有可能返回消息</span></span><br><span class="line"><span class="comment"> * 2、preStart() 方法 对象在构建成功之后，就会触发执行 preStart</span></span><br><span class="line"><span class="comment"> * 3、postStop 方法 在对象销毁之前，会执行一次</span></span><br><span class="line"><span class="comment"> * -</span></span><br><span class="line"><span class="comment"> * 必须了解的知识：</span></span><br><span class="line"><span class="comment"> * 1、伴生类 class A 和 伴生对象 object A（定义的方法，都是静态方法）</span></span><br><span class="line"><span class="comment"> * 2、关于 scala 中定义的一个类的构造方法：</span></span><br><span class="line"><span class="comment"> * 构造器： 类名后面的括号</span></span><br><span class="line"><span class="comment"> * 代码实现： &#123;&#125; 中的一切能执行的代码</span></span><br><span class="line"><span class="comment"> * 变量的初始化</span></span><br><span class="line"><span class="comment"> * 代码块</span></span><br><span class="line"><span class="comment"> * 静态代码块</span></span><br><span class="line"><span class="comment"> * 不能执行的代码： 定义的方法（未调用， 内部类）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyJobManager</span>(<span class="params">var hostname: <span class="type">String</span>, var port: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO_MA 注释： 用来存储每个注册的NodeManager节点的信息</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> id2taskManagerInfo = <span class="keyword">new</span> mutable.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">TaskManagerInfo</span>]()<span class="comment">// TODO_MA 注释： 对所有注册的NodeManager进行去重，其实就是一个HashSet</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> taskManagerInfos = <span class="keyword">new</span> mutable.<span class="type">HashSet</span>[<span class="type">TaskManagerInfo</span>]()</span><br><span class="line">  <span class="comment">// TODO_MA 注释： actor在最开始的时候，会执行一次</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">preStart</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line">    <span class="keyword">import</span> context.dispatcher</span><br><span class="line">    <span class="comment">// TODO_MA 注释： 调度一个任务， 每隔五秒钟执行一次</span></span><br><span class="line">    context.system.scheduler.schedule(<span class="number">0</span> millis, <span class="number">5000</span> millis, self, <span class="type">CheckTimeOut</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// TODO_MA 注释： 正经服务方法,接收到一条消息，receive就会被调用一次</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="comment">// TODO_MA 注释： 接收 注册消息</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">RegisterTaskManager</span>(nodemanagerid, memory, cpu) =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> nodeManagerInfo = <span class="keyword">new</span> <span class="type">TaskManagerInfo</span>(nodemanagerid, memory, cpu)</span><br><span class="line">      println(<span class="string">s"节点 <span class="subst">$&#123;nodemanagerid&#125;</span> 上线"</span>)</span><br><span class="line">      <span class="comment">// TODO_MA 注释： 对注册的NodeManager节点进行存储管理</span></span><br><span class="line">      id2taskManagerInfo.put(nodemanagerid, nodeManagerInfo)</span><br><span class="line">      taskManagerInfos += nodeManagerInfo</span><br><span class="line">      <span class="comment">// TODO_MA 注释： 把信息存到zookeeper</span></span><br><span class="line">      <span class="comment">// TODO_MA 注释： sender() 谁给我发消息，sender方法返回的就是谁</span></span><br><span class="line">      sender() ! <span class="type">RegisteredTaskManager</span>(hostname + <span class="string">":"</span> + port)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO_MA 注释： 接收心跳消息</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Heartbeat</span>(nodemanagerid) =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> currentTime = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line">      <span class="keyword">val</span> nodeManagerInfo = id2taskManagerInfo(nodemanagerid)</span><br><span class="line">      nodeManagerInfo.lastHeartBeatTime = currentTime</span><br><span class="line">      id2taskManagerInfo(nodemanagerid) = nodeManagerInfo</span><br><span class="line">      taskManagerInfos += nodeManagerInfo</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO_MA 注释： 检查过期失效的 NodeManager</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">CheckTimeOut</span> =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> currentTime = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line">      <span class="comment">// TODO_MA 注释： 15 秒钟失效</span></span><br><span class="line">      taskManagerInfos.filter(nm =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> heartbeatTimeout = <span class="number">15000</span></span><br><span class="line">        <span class="keyword">val</span> bool = currentTime - nm.lastHeartBeatTime &gt; heartbeatTimeout</span><br><span class="line">        <span class="keyword">if</span> (bool) &#123;</span><br><span class="line">          println(<span class="string">s"节点 <span class="subst">$&#123;nm.taskmanagerid&#125;</span> 下线"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        bool</span><br><span class="line">      &#125;).foreach(deadnm =&gt; &#123;</span><br><span class="line">        taskManagerInfos -= deadnm</span><br><span class="line">        id2taskManagerInfo.remove(deadnm.taskmanagerid)</span><br><span class="line">      &#125;)</span><br><span class="line">      println(<span class="string">"当前注册成功的节点数"</span> + taskManagerInfos.size + <span class="string">"\t分别是："</span> + taskManagerInfos.map(x =&gt; x.toString)</span><br><span class="line">        .mkString(<span class="string">","</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment"> * TODO_MA 马中华 https://blog.csdn.net/zhongqi2513</span></span><br><span class="line"><span class="comment"> * 注释： 启动入口， 伴生对象！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyJobManager</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// TODO_MA 注释： 地址参数</span></span><br><span class="line">    <span class="keyword">val</span> host = <span class="string">"localhost"</span></span><br><span class="line">    <span class="keyword">val</span> port = <span class="number">6789</span></span><br><span class="line">    <span class="keyword">val</span> str =</span><br><span class="line">      <span class="string">s""</span><span class="string">"</span></span><br><span class="line"><span class="string">         |akka.actor.provider = "</span>akka.remote.<span class="type">RemoteActorRefProvider</span><span class="string">"</span></span><br><span class="line"><span class="string">         |akka.remote.netty.tcp.hostname = $&#123;host&#125;</span></span><br><span class="line"><span class="string">         |akka.remote.netty.tcp.port = $&#123;port&#125;</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span>.stripMargin</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="type">ConfigFactory</span>.parseString(str)</span><br><span class="line">    <span class="comment">// TODO 注释：启动ActorSystem</span></span><br><span class="line">    <span class="keyword">val</span> actorSystem = <span class="type">ActorSystem</span>(<span class="type">Constant</span>.<span class="type">JMAS</span>, conf)</span><br><span class="line">      <span class="comment">// TODO 注释：启动了一个actor ： MyResourceManager</span></span><br><span class="line">      actorSystem.actorOf(<span class="type">Props</span>(<span class="keyword">new</span> <span class="type">MyJobManager</span>(host, port)), <span class="type">Constant</span>.<span class="type">JMA</span>)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TODO_MA 马中华 https://blog.csdn.net/zhongqi2513</span></span><br><span class="line"><span class="comment">     * 注释： actor 的生命周期</span></span><br><span class="line"><span class="comment">     * 1、MyResourceManager actor 的构造方法</span></span><br><span class="line"><span class="comment">     * 2、preStart() 当 actor 实例创建成功的时候，就会马上调用这个 actor 的 preStart() 来执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-2-MyTaskManager实现"><a href="#2-2-MyTaskManager实现" class="headerlink" title="2.2 MyTaskManager实现"></a>2.2 MyTaskManager实现</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.neixuejiaoyu.rpc.akka2flink</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> akka.actor.&#123;<span class="type">Actor</span>, <span class="type">ActorSelection</span>, <span class="type">ActorSystem</span>, <span class="type">Props</span>&#125;</span><br><span class="line"><span class="keyword">import</span> com.typesafe.config.<span class="type">ConfigFactory</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO_MA 马中华 https://blog.csdn.net/zhongqi2513</span></span><br><span class="line"><span class="comment"> * 注释：</span></span><br><span class="line"><span class="comment"> * 1、spark rpc 生命周期方法： onStart receive onStop</span></span><br><span class="line"><span class="comment"> * 2、akka rpc 生命周期方法： preStart receive postStop()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTaskManager</span>(<span class="params">val tmhostname: <span class="type">String</span>, val jobmanagerhostname: <span class="type">String</span>, val jobmanagerport: <span class="type">Int</span>, val memory: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                    val cpu: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> taskManagerId: <span class="type">String</span> = tmhostname</span><br><span class="line">  <span class="keyword">var</span> rmRef: <span class="type">ActorSelection</span> = _</span><br><span class="line">  <span class="comment">// TODO_MA 注释： 会提前执行一次</span></span><br><span class="line">  <span class="comment">// TODO_MA 注释： 当前NM启动好了之后，就应该给 RM 发送一个注册消息</span></span><br><span class="line">  <span class="comment">// TODO_MA 注释： 发给谁，就需要获取这个谁的一个ref实例</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">preStart</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// TODO_MA 注释： 获取消息发送对象的一个ref实例</span></span><br><span class="line">    <span class="comment">// 远程path akka.tcp://（ActorSystem的名称）@（远程地址的IP）： （远程地址的端口）/user/（Actor的名称）</span></span><br><span class="line">    <span class="comment">//TODO 我此时是taskManager从节点，内部启动了ActorSystem和Actor</span></span><br><span class="line">    <span class="comment">//TODO 明确的，我需要向主节点JobManager发送注册信息，一定要找出对方的Actor定位rmRef</span></span><br><span class="line">    rmRef = context.actorSelection(<span class="string">s"akka.tcp://<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">      Constant.JMAS</span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span>@<span class="subst">$&#123;jobmanagerhostname&#125;</span>:<span class="subst">$&#123;jobmanagerport&#125;</span>/user/<span class="subst">$&#123;Constant.JMA&#125;</span>"</span>)</span><br><span class="line">    <span class="comment">// TODO_MA 注释： 发送消息</span></span><br><span class="line">    println(taskManagerId + <span class="string">" 正在注册"</span>)</span><br><span class="line">    rmRef ! <span class="type">RegisterTaskManager</span>(taskManagerId, memory, cpu)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// TODO_MA 注释： 正常服务方法</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="comment">// TODO_MA 注释： 接收到注册成功的消息</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">RegisteredTaskManager</span>(masterURL) =&gt; &#123;</span><br><span class="line">      println(masterURL);</span><br><span class="line">      <span class="comment">// TODO_MA 注释： initialDelay: FiniteDuration, 多久以后开始执行</span></span><br><span class="line">      <span class="comment">// TODO_MA 注释： interval: FiniteDuration, 每隔多长时间执行一次</span></span><br><span class="line">      <span class="comment">// TODO_MA 注释： receiver: ActorRef, 给谁发送这个消息</span></span><br><span class="line">      <span class="comment">// TODO_MA 注释： message: Any 发送的消息是啥</span></span><br><span class="line">      <span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line">      <span class="keyword">import</span> context.dispatcher</span><br><span class="line">      context.system.scheduler.schedule(<span class="number">0</span> millis, <span class="number">4000</span> millis, self, <span class="type">SendMessage</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO_MA 注释： 发送心跳</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">SendMessage</span> =&gt; &#123;</span><br><span class="line">      <span class="comment">// TODO_MA 注释： 向主节点发送心跳信息</span></span><br><span class="line">      rmRef ! <span class="type">Heartbeat</span>(taskManagerId)</span><br><span class="line">      println(<span class="type">Thread</span>.currentThread().getId)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment"> * TODO_MA 马中华 https://blog.csdn.net/zhongqi2513</span></span><br><span class="line"><span class="comment"> * 注释： 启动类</span></span><br><span class="line"><span class="comment"> * 运行的时候，需要指定参数：</span></span><br><span class="line"><span class="comment"> * localhost localhost 6789 64 32 9911 bigdata02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyTaskManager</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// TODO_MA 注释： 远程主机名称</span></span><br><span class="line">    <span class="keyword">val</span> <span class="type">HOSTNAME</span> = args(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// TODO_MA 注释： JM 的 hostname 和 port</span></span><br><span class="line">    <span class="keyword">val</span> <span class="type">JM_HOSTNAME</span> = args(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> <span class="type">JM_PORT</span> = args(<span class="number">2</span>).toInt</span><br><span class="line">    <span class="comment">// TODO_MA 注释： 抽象的内存资源 和 CPU 个数</span></span><br><span class="line">    <span class="keyword">val</span> <span class="type">TASKMANAGER_MEMORY</span> = args(<span class="number">3</span>).toInt</span><br><span class="line">    <span class="keyword">val</span> <span class="type">TASKMANAGER_CORE</span> = args(<span class="number">4</span>).toInt</span><br><span class="line">    <span class="comment">// TODO_MA 注释： 当前 TM 的 hostname 和 port</span></span><br><span class="line">    <span class="keyword">var</span> <span class="type">TASKMANAGER_PORT</span> = args(<span class="number">5</span>).toInt</span><br><span class="line">    <span class="keyword">var</span> <span class="type">TMHOSTNAME</span> = args(<span class="number">6</span>)</span><br><span class="line">    <span class="comment">// TODO_MA 注释： 指定主机名称和端口号相关的配置</span></span><br><span class="line">    <span class="keyword">val</span> str =</span><br><span class="line">      <span class="string">s""</span><span class="string">"</span></span><br><span class="line"><span class="string">         |akka.actor.provider = "</span>akka.remote.<span class="type">RemoteActorRefProvider</span><span class="string">"</span></span><br><span class="line"><span class="string">         |akka.remote.netty.tcp.hostname = $&#123;HOSTNAME&#125;</span></span><br><span class="line"><span class="string">         |akka.remote.netty.tcp.port = $&#123;TASKMANAGER_PORT&#125;</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span>.stripMargin</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="type">ConfigFactory</span>.parseString(str)</span><br><span class="line">    <span class="comment">// TODO 注释： 启动一个 ActorSystem</span></span><br><span class="line">    <span class="keyword">val</span> actorSystem = <span class="type">ActorSystem</span>(<span class="type">Constant</span>.<span class="type">JMAS</span>, conf)</span><br><span class="line">    <span class="comment">// TODO 注释： 启动一个 Actor,actor在启动的时候，会执行这个actor的preStart()</span></span><br><span class="line">    actorSystem.actorOf(<span class="type">Props</span>(<span class="keyword">new</span> <span class="type">MyTaskManager</span>(<span class="type">TMHOSTNAME</span>, <span class="type">JM_HOSTNAME</span>, <span class="type">JM_PORT</span>, <span class="type">TASKMANAGER_MEMORY</span>,</span><br><span class="line">      <span class="type">TASKMANAGER_CORE</span>)), <span class="type">Constant</span>.<span class="type">TMA</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-3-工具类Constant实现"><a href="#2-3-工具类Constant实现" class="headerlink" title="2.3 工具类Constant实现"></a>2.3 工具类Constant实现</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.neixuejiaoyu.rpc.akka2flink</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO_MA 注释： 一些名称信息类</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Constant</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> <span class="type">JMAS</span> = <span class="string">"MyJobManagerActorSystem"</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">JMA</span> = <span class="string">"MyJobManagerActor"</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">TMAS</span> = <span class="string">"MyTaskManagerActorSystem"</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">TMA</span> = <span class="string">"MyTaskManagerActor"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-4-工具类Message实现"><a href="#2-4-工具类Message实现" class="headerlink" title="2.4 工具类Message实现"></a>2.4 工具类Message实现</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.neixuejiaoyu.rpc.akka2flink</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO_MA 注释： 注册消息 TaskManager -&gt; JobManager</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterTaskManager</span>(<span class="params">val taskmanagerid: <span class="type">String</span>, val memory: <span class="type">Int</span>, val cpu: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">TODO_MA</span> <span class="title">注释：</span> <span class="title">注册完成消息</span> <span class="title">JobManager</span> <span class="title">-&gt;</span> <span class="title">TaskManager</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">RegisteredTaskManager</span>(<span class="params">val jobmanagerhostname: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">TODO_MA</span> <span class="title">注释：</span> <span class="title">心跳消息</span> <span class="title">TaskManager</span> <span class="title">-&gt;</span> <span class="title">JobManager</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Heartbeat</span>(<span class="params">val taskmanagerid: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">TODO_MA</span> <span class="title">注释：</span> <span class="title">TaskManager</span> <span class="title">信息类</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">TaskManagerInfo</span>(<span class="params">val taskmanagerid: <span class="type">String</span>, val memory: <span class="type">Int</span>, val cpu: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO_MA 注释： 上一次心跳时间</span></span><br><span class="line">  <span class="keyword">var</span> lastHeartBeatTime: <span class="type">Long</span> = _</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = &#123;</span><br><span class="line">    taskmanagerid + <span class="string">","</span> + memory + <span class="string">","</span> + cpu</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TODO_MA 注释： 一个发送心跳的信号</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">SendMessage</span></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">TODO_MA</span> <span class="title">注释：</span> <span class="title">一个检查信号</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">CheckTimeOut</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Flink</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>1.FlinkRPC</title>
    <url>/2021/04/20/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/Flink/%E6%BA%90%E7%A0%81/1.FlinkRPC/</url>
    <content><![CDATA[<h1 id="1-课程内容"><a href="#1-课程内容" class="headerlink" title="1.课程内容"></a>1.课程内容</h1><p>主要讲解Flink的源码编写中涉及到的一些比较重要的工作组件和机制。主题内容大纲如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.Flink RPC机制详解</span><br><span class="line">2.Flink RPC中的重要组件 RpcEndpoint的工作机制</span><br><span class="line">3.Flink应用程序抽象</span><br><span class="line">4.Flink on YARN的三种job运行模式</span><br><span class="line">5.Flink的选举和监听机制</span><br><span class="line">6.Flink的心跳机制</span><br><span class="line">7.Flink源码中用到的Java8 异步编程</span><br></pre></td></tr></table></figure>

<h1 id="2-Flink重要组件源码原理讲解"><a href="#2-Flink重要组件源码原理讲解" class="headerlink" title="2.Flink重要组件源码原理讲解"></a>2.Flink重要组件源码原理讲解</h1><h2 id="2-1-Flink-RPC"><a href="#2-1-Flink-RPC" class="headerlink" title="2.1 Flink RPC"></a>2.1 Flink RPC</h2><p>大数据技术栈中的技术组件非常丰富，大致总结一下各大常见组件的 RPC 实现技术：</p>
<p>技术组件         RPC 实现 </p>
<p>Hadoop         NIO + Protobuf</p>
<p>HBase            HBase-2.x 以前：NIO + ProtoBuf HBase-2.x 以后：Netty </p>
<p>ZooKeeper    BIO + NIO + Netty       </p>
<p> Spark            Spark-1.x 基于 Akka Spark-2.x 基于 Netty Flink Akka + Netty</p>
<h3 id="2-1-1-Flink-RPC的底层实现：Akka"><a href="#2-1-1-Flink-RPC的底层实现：Akka" class="headerlink" title="2.1.1 Flink RPC的底层实现：Akka"></a>2.1.1 Flink RPC的底层实现：Akka</h3><p>Flink的RPC实现是基于scala的网络编程库akka，akka的特点如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.akka对并发编程模型进行了更高的抽象</span><br><span class="line">2.akka是异步，非阻塞高性能的事件驱动编程模型</span><br><span class="line">3.akka是轻量级处理（1GB 内存可容纳百万级别个actor）</span><br></pre></td></tr></table></figure>

<p>几个重要的akka知识：ActorSystem和Actor的理解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.ActorSystem是管理actor声明周期的组件，actor是负责进行通信的组件</span><br><span class="line">2.每个actor都有一个mailbox，别的actor发给他的消息都首先存储在mailbox中，通过这种方式就实现了异步通信</span><br><span class="line">3.每个actor是单线程的处理方式，不断的从mailbox中拉取消息进行处理，所以对于actor的消息处理，不适合调用会阻塞的处理方法</span><br><span class="line">4.actor可以改变自身的状态，可以发消息也可以接收信息，并且actor可以生成新的actor</span><br><span class="line">5.每一个actorSystem和actor在启动的时候都会被指定一个name，如果要获取一个actorSystem的一个actor，则通过以下的方式进行actor的获取：</span><br><span class="line">akka:tcp:&#x2F;&#x2F;actorsystem_name@bigdata02:9527&#x2F;user&#x2F;actor_name&#x2F;来进行定位</span><br><span class="line"></span><br><span class="line">6.如果一个actor需要和另外一个actor进行通信，则必须先获取对方actor的actorRef，然后通过该对象发送消息即可</span><br><span class="line">7.通过tell发送异步消息，不接受响应，通过ask发送异步消息，得到future返回，通过异步回到返回处理结果</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/04/20/mcI5Jq68KVhpQxs.png" alt="image-20210420110320537"></p>
<h3 id="2-1-2-使用akka模拟实现Flink-standalone"><a href="#2-1-2-使用akka模拟实现Flink-standalone" class="headerlink" title="2.1.2 使用akka模拟实现Flink standalone"></a>2.1.2 使用akka模拟实现Flink standalone</h3><p>详情见使用akka模拟实现FlinkStandalone文档</p>
<h3 id="2-1-3-深入理解Flink-RPC"><a href="#2-1-3-深入理解Flink-RPC" class="headerlink" title="2.1.3  深入理解Flink RPC"></a>2.1.3  深入理解Flink RPC</h3><p>关于其它技术组件中和actor类似的概念</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、HDFS ： proxy</span><br><span class="line">2、Akka ： ActorRef</span><br><span class="line">3、Flink ： XXXGateway： JobManager（ResourceManager） TaskManager（TaskExecutor） 在 TaskExecutor 的内部，持有</span><br><span class="line">ResourceManager的一个 Gateway 对象</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p><strong>Flink中的RPCEndpoint，在作用上，等同于akka中的actor</strong></p>
<p><strong>akka的 actorRef等同于Flink 的xxxGateWay</strong></p>
<p>在阅读flink源码过程中，如果出现下面这种类型的代码，其实就是在发送RPC请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// resourceManagerGateway 就可以理解成： 当前节点中，对于 ResourceManager 代理对象的封装</span></span><br><span class="line">resourceManagerGateway.requestSlot();</span><br><span class="line"><span class="comment">// 代码跳转到：resourceManager.requestSlot();</span></span><br></pre></td></tr></table></figure>



<p>Spark 的 RPC 实现虽然是为了替换 Akka 而诞生的，但是它实际上可以看成一个简化版的 Akka，仍然遵循许多 Actor Model 的抽象。例如 </p>
<p>RpcEndpoint 对应 Actor </p>
<p>RpcEndpointRef（被包装在 Gateway 对象的内部） 对应 ActorRef </p>
<p>RpcEnv 对应 ActorSystem</p>
<p>Flink 中的 RPC 实现主要在 flink-runtime 模块下的 org.apache.flink.runtime.rpc 包中，涉及到的最重要的 API 主要是以下这四个：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>RPCGateWay</td>
<td><strong>用于远程调用的代理接口</strong>。 RpcGateway 提供了获取其所代理的 RpcEndpoint 的地址的方法。在实现一个提供 RPC 调用的组件 时，通常需要先定一个接口，该接口继承 RpcGateway 并约定好提供的远程调用的方法。</td>
</tr>
<tr>
<td>RpcServer</td>
<td>相当于 RpcEndpoint 自身的的代理对象（self gateway)。RpcServer 是 RpcService 在启动了 RpcEndpoint 之后返回的对象，每 一个 RpcEndpoint 对象内部都有一个 RpcServer 的成员变量，通过 getSelfGateway 方法就可以获得自身的代理，然后调用该 Endpoint 提供的服务。</td>
</tr>
<tr>
<td>RpcEndpoint</td>
<td>对 RPC 框架中提供具体服务的实体的抽象，所有提供远程调用方法的组件都需要继承该抽象类。另外，对于同一个 RpcEndpoint 的所有 RPC 调用都会在同一个线程（RpcEndpoint 的“主线程”）中执行，因此无需担心并发执行的线程安全问题。</td>
</tr>
<tr>
<td>RpcService</td>
<td>是 RpcEndpoint 的运行时环境，RpcService 提供了启动 RpcEndpoint , 连接到远端 RpcEndpoint 并返回远端 RpcEndpoint 的代 理对象等方法。此外，RpcService 还提供了某些异步任务或者周期性调度任务的方法。<strong>内部包装了 ActorSystem</strong></td>
</tr>
</tbody></table>
<p><img src="https://i.loli.net/2021/04/20/WkvMUEhydpGiAJ2.png" alt="image-20210420173623454"></p>
<p><strong>这里的resourceManager不是yarn里面的概念，它是flink主节点中的一个组件，如果从主从架构的角度来说，ResourceManager是主节点，TaskExecutor是从节点 。</strong></p>
<p><strong>JobMaster类似于yarn中的ApplicationMaster</strong></p>
<p>如果当前的RpcEndpoint组件需要跟其它的RPCEndpoint组件进行通信，需要获取对方的代理对象，获取方式是通过图中的虚线方式通过代理模式获取代理对象的</p>
<p>总结：RPCEndpoint下面有四个比较重要的子类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.TaskExecutor 集群中从节点中最重要的角色，负责资源管理</span><br><span class="line">2.Dispatcher  主节点中的一个工作角色，负责job调度执行</span><br><span class="line">3.JobMaster  应用程序中的主控程序，类似于spark中的driver的作用，或者MapReduce中的ApplicationMaster</span><br><span class="line">4.ResourceManager 集群中的主节点 JobManager中的负责资源管理的角色，和TaskExecutor一起构成资源管理的主从架构</span><br></pre></td></tr></table></figure>

<p>当在任意地方发现要创建这四个组件的任何一个组件的实例对象的时候，创建成功之后，都会要调用start()去启动这个RPCEndpoint，然后就会去执行它的RPCEndpoint的onStart()方法，一般来说，对应的RPCEndpoint组件都会重写，在这些RpcEndpoint组件启动的时候，一些重要的逻辑，都有可能被放在这个onStart()生命周期方法里。</p>
<p>在rpcEndpoint内部包装了一个AkkaRpcActor：如果这个rpcEndpoint接收到START控制消息，则这个RPCEndpoint的onStart()会被调用</p>
<h3 id="2-1-4-Flink-RPC实例"><a href="#2-1-4-Flink-RPC实例" class="headerlink" title="2.1.4 Flink RPC实例"></a>2.1.4 Flink RPC实例</h3><p>代码实现：</p>
<h2 id="2-2-RPCEndpoint"><a href="#2-2-RPCEndpoint" class="headerlink" title="2.2 RPCEndpoint"></a>2.2 RPCEndpoint</h2><h3 id="2-2-1-JobManager的ResourceManager"><a href="#2-2-1-JobManager的ResourceManager" class="headerlink" title="2.2.1 JobManager的ResourceManager"></a>2.2.1 JobManager的ResourceManager</h3><p>Flink Standalone集群是一个主从架构，主节点叫做JobManager，从节点叫做TaskManager，在JobManager（这只是逻辑上的概念，在代码中其实没有相应的实现）内部，其实有三大组件</p>
<p><img src="https://i.loli.net/2021/04/20/HrlKSGmFV21aJBM.png" alt="image-20210420180609540"></p>
<p>其中</p>
<p>standaloneResouceManager 负责管理资源</p>
<p>DispatcherRunner 调度分派job,具体点就是启动JobMaster</p>
<p>DispatcherRestEndpoint负责接收客户端发送的job的数据</p>
<p>其中，ResourceManger的职责就是帮助主节点JobManager完成从节点TaskManager的管理和资源的管理和分配工作</p>
<p><img src="https://i.loli.net/2021/04/20/T8gtyI5Rmqb3hjz.png" alt="image-20210420180736381"></p>
<h3 id="2-2-2-TaskManager的TaskExecutor"><a href="#2-2-2-TaskManager的TaskExecutor" class="headerlink" title="2.2.2 TaskManager的TaskExecutor"></a>2.2.2 TaskManager的TaskExecutor</h3><p>Flink Standalone 集群是一个主从架构，主节点叫做 JobManager，从节点叫做 TaskManager</p>
<p><img src="https://i.loli.net/2021/04/20/K3tNrjxz6GnfUqX.png" alt="image-20210420180831484"></p>
<p>这个TaskExecutor是存在于TaskManager的内部，真正完成资源提供和分配，接收任务和执行等相关工作。这个角色的意义等同于spark中多个worker，YARN集群中的NodeManager</p>
<h2 id="2-3-Flink应用程序抽象"><a href="#2-3-Flink应用程序抽象" class="headerlink" title="2.3 Flink应用程序抽象"></a>2.3 Flink应用程序抽象</h2><p>当程序员写好Flink Job程序之后，Flink Client提交一个Job之后：整个这个Job的概念会发生3次改变生成4个概念</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.提交到JobManager之前，会从Flink code生成StreamGraph，JobGraph</span><br><span class="line">2.客户端其实是提交JobGraph给服务端，还要转换为ExecutionGraph，然后再转换为物理task，去申请slot资源，部署task执行</span><br></pre></td></tr></table></figure>

<p>几个基础概念</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.Function</span><br><span class="line">2.StreamOperator</span><br><span class="line">3.Transformation</span><br><span class="line">4.StreamNode</span><br><span class="line"></span><br><span class="line">Function --&gt;StreamOperator --&gt;Transformation --&gt; StreamNode</span><br><span class="line">其中每一个operator转换为transformation后会加入到env环境的transformations集合中，在调用env.execute()的时候，会遍历transformations集合，在遍历的时候会将transformation转换为streamNode，根据里面的streamNode构建StreamGraph</span><br><span class="line"></span><br><span class="line">也就是说我们的一个算子加上里面我们传的function参数会先编程StreamOperator，然后再变成Transformation，然后最终再变成一个StreamNode，最后根据整个程序的StreamNode就构建成了程序的StreamGraph。也就是说在我们的StreamGraph中每一个顶点就对应一个算子形成的StreamNode，里面会存储计算逻辑和并行度。StreamGraph中连接算子顶点（StreamNode）的叫做边（StreamEdge）</span><br></pre></td></tr></table></figure>

<p>Flink的一个Job，最终归根结底，还是构建一个高效率的用于分布式并行执行的DAG执行图</p>
<p>Flink中的Job被抽象成graph进行管理，执行图graph可以分为4层：streamGraph ==》JobGraph  ==》 ExecutionGraph  ==》物理执行图</p>
<p><strong>StreamGraph</strong>：根据用户通过stream api编写的代码生成的最初的图，用于表示程序的拓扑结构</p>
<p><strong>JobGraph</strong>：StreamGraph经过优化后生成了JobGraph，提交给JobManager的数据结构。主要的优化为：将多个符合条件的节点chain在一起作为一个节点，这样可以减少数据在节点之间流动所需要的序列化反序列化传输消耗</p>
<p><strong>ExecutionGraph</strong>：JobManager根据JobGraph生成ExecutionGraph。ExecutionGraph是JobGraph的并行化版本，是调度层最核心的数据结构</p>
<p><strong>物理执行图</strong>：JobManger根据ExecutionGraph对Job进行调度后，在各个TaskManager上部署task后形成的图，并不是一个具体的数据结构</p>
<p>关于这4层结构的演变，请看下图</p>
<p><img src="https://i.loli.net/2021/04/20/dKCgyGZs8T7npxD.png" alt="image-20210420184705028"></p>
<h3 id="2-3-1-StreamGraph"><a href="#2-3-1-StreamGraph" class="headerlink" title="2.3.1 StreamGraph"></a>2.3.1 StreamGraph</h3><p><img src="https://i.loli.net/2021/04/21/SpT8XcglsY3yh2n.png" alt="image-20210421103128221"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function --&gt;StreamOperator --&gt;Transformation --&gt; StreamNode</span><br><span class="line">其中每一个operator转换为transformation后会加入到env环境的transformations集合中，在调用env.execute()的时候，会遍历transformations集合，在遍历的时候会将transformation转换为streamNode，根据里面的streamNode构建StreamGraph</span><br><span class="line"></span><br><span class="line">也就是说我们的一个算子加上里面我们传的function参数会先编程StreamOperator，然后再变成Transformation，然后最终再变成一个StreamNode，最后根据整个程序的StreamNode就构建成了程序的StreamGraph。也就是说在我们的StreamGraph中每一个顶点就对应一个算子形成的StreamNode，里面会存储计算逻辑和并行度。StreamGraph中连接算子顶点（StreamNode）的叫做边（StreamEdge）</span><br></pre></td></tr></table></figure>

<p><strong>StreamEdge</strong></p>
<p><img src="https://i.loli.net/2021/04/21/sgxGUfTNdo625rD.png" alt="image-20210421103243739"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在StreamEdge类中，有两个对应上下游StreamNode的变量，其中sourceId就代表了上游顶点StreamNode，targetId就代表了下游顶点targetId。而对于StreamNode来说，作为输入的StreamEdge称之为入边，作为输出的StreamEdge称之为出边。</span><br></pre></td></tr></table></figure>



<h3 id="2-3-2-JobGraph"><a href="#2-3-2-JobGraph" class="headerlink" title="2.3.2 JobGraph"></a>2.3.2 JobGraph</h3><p><img src="https://i.loli.net/2021/04/21/vXjLFqhz276B3Id.png" alt="image-20210421103705490"></p>
<p>JobGraph：StreamGraph 经过优化后生成了 JobGraph，提交给 JobManager 的数据结构 </p>
<p>它包含的主要抽象概念有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、JobVertex：经过优化后符合条件的多个 StreamNode 可能会 chain 在一起生成一个 JobVertex，即一个JobVertex 包含一个或多个 operator，</span><br><span class="line">JobVertex 的输入是 JobEdge，输出是 IntermediateDataSet。</span><br><span class="line">2、IntermediateDataSet：表示 JobVertex 的输出，即经过 operator 处理产生的数据集。producer 是JobVertex，consumer 是 JobEdge。</span><br><span class="line">3、JobEdge：代表了job graph中的一条数据传输通道。source 是 IntermediateDataSet，target 是 JobVertex。即数据通过JobEdge由</span><br><span class="line">IntermediateDataSet传递给目标JobVertex。</span><br></pre></td></tr></table></figure>



<p>由StreamGraph转换为JobGraph过程中，最重要的是对StreamGraph进行了优化，优化的内容是：判断相邻的两个顶点是否满足一定的条件（有9个），如果满足一定的条件会合并为一个顶点。</p>
<p>原来的顶点叫做StreamNode，在JobGraph中顶点称之为JobVertex，边叫做JobEdge，其中JobEdge的下游是顶点，上游是Intermediate DataSet</p>
<p><strong>JobEdge</strong></p>
<p><img src="https://i.loli.net/2021/04/21/yYL9xQZjR7qwetF.png" alt="image-20210421104524080"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JobEdge的上游是IntermediateDataSet，也就是说IntermediateDataSet是JobEdge的生产者，下游是顶点JobVertex</span><br></pre></td></tr></table></figure>



<p><strong>JobVertex</strong></p>
<p><img src="https://i.loli.net/2021/04/21/QX5ovFq8mfZgSJO.png" alt="image-20210421104745418"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JobVertex的输入是JobEdge的集合inputs，输出是IntermediateDataSet的集合results,那一个JobVertex到底有多少个JobEdge和IntermediateDataSet呢，JobEdge的个数取决于有多少个输入流，输入流有多少个就有多少个JobEdge，输出流有多少个就有多少个IntermediateDataSet。大部分情况下，这两个集合的长度都是1</span><br></pre></td></tr></table></figure>



<p>然后客户端将生成的JobGraph提交给服务端</p>
<h3 id="2-3-3-ExecutionGraph"><a href="#2-3-3-ExecutionGraph" class="headerlink" title="2.3.3 ExecutionGraph"></a>2.3.3 ExecutionGraph</h3><p><img src="https://i.loli.net/2021/04/21/ucxqQPZ28hpO15R.png" alt="image-20210421105536739"></p>
<p>ExecutionGraph：JobManager(JobMaster) 根据 JobGraph 生成 ExecutionGraph。ExecutionGraph 是JobGraph 的并行化版本，是调度层最核心的数 据结构。 它包含的主要抽象概念有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、ExecutionJobVertex：和JobGraph中的JobVertex一一对应。每一个ExecutionJobVertex都有和并发度一样多的 ExecutionVertex。</span><br><span class="line">2、ExecutionVertex：表示ExecutionJobVertex的其中一个并发子任务，输入是ExecutionEdge，输出是IntermediateResultPartition。</span><br><span class="line">3、IntermediateResult：和JobGraph中的IntermediateDataSet一一对应。一个IntermediateResult包含多个IntermediateResultPartition，</span><br><span class="line">其个数等于该operator的并发度。</span><br><span class="line">4、IntermediateResultPartition：表示ExecutionVertex的一个输出分区，producer是ExecutionVertex，consumer是若干个ExecutionEdge。</span><br><span class="line">5、ExecutionEdge：表示ExecutionVertex的输入，source是IntermediateResultPartition，target是ExecutionVertex。source和target都只</span><br><span class="line">能是一个。</span><br><span class="line">6、Execution：是执行一个 ExecutionVertex 的一次尝试。当发生故障或者数据需要重算的情况下 ExecutionVertex 可能会有多个</span><br><span class="line">ExecutionAttemptID。一个 Execution 通过 ExecutionAttemptID 来唯一标识。JM和TM之间关于 task 的部署和 task status 的更新都是通过</span><br><span class="line">ExecutionAttemptID 来确定消息接受者。</span><br></pre></td></tr></table></figure>



<h3 id="2-3-4-物理执行图"><a href="#2-3-4-物理执行图" class="headerlink" title="2.3.4 物理执行图"></a>2.3.4 物理执行图</h3><p><img src="https://i.loli.net/2021/04/21/ASRJFPhwul52GHr.png" alt="image-20210421111138602"></p>
<p>物理执行图：JobManager 根据 ExecutionGraph 对 Job 进行调度后，在各个TaskManager 上部署 Task 后形成的“图”，并不是一个具体的数据结构。 它包含的主要抽象概念有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、Task：Execution 被调度后在分配的 TaskManager 中启动对应的 Task。Task 包裹了具有用户执行逻辑的 operator。</span><br><span class="line">2、ResultPartition：代表由一个 Task 的生成的数据，和 ExecutionGraph 中的 IntermediateResultPartition 一一对应。</span><br><span class="line">3、ResultSubpartition：是 ResultPartition 的一个子分区。每个 ResultPartition 包含多个 ResultSubpartition，其数目要由下游消费 Task数和 DistributionPattern 来决定。</span><br><span class="line">4、InputGate：代表 Task 的输入封装，和 JobGraph 中 JobEdge 一一对应。每个 InputGate 消费了一个或多个的 ResultPartition。</span><br><span class="line">5、InputChannel：每个 InputGate 会包含一个以上的 InputChannel，和 ExecutionGraph 中的 ExecutionEdge一一对应，也和</span><br><span class="line">ResultSubpartition 一对一地相连，即一个 InputChannel 接收一个 ResultSubpartition 的输出。</span><br></pre></td></tr></table></figure>





<h2 id="2-4-Flink-Job-3种运行模式"><a href="#2-4-Flink-Job-3种运行模式" class="headerlink" title="2.4 Flink Job 3种运行模式"></a>2.4 Flink Job 3种运行模式</h2><p>如果是flink standalone集群：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/flink run --target <span class="built_in">local</span> <span class="comment"># Local submission using a MiniCluster in Session Mode</span></span><br><span class="line">./bin/flink run --target remote <span class="comment"># Submission to an already running Flink cluster</span></span><br></pre></td></tr></table></figure>

<p>Flink 的 Job 部署模式有多种，支持 YARN、Kubernetes、Mesos，这里我们重点探讨 Flink On YARN</p>
<p><img src="https://i.loli.net/2021/04/21/w1UxBtvzQjRCh2f.png" alt="image-20210421113803870"></p>
<p>在图中可以看出，Flink 与 YARN 的关系与 MapReduce 和 YARN 的关系是一样的。Flink 通过 YARN 的接口实现了自己的 AppMaster。当在 YARN 中部 署了Flink，YARN 就会用自己的 Container 来启动 Flink 的 JobManager（也就是 AppMaster）和 TaskManager。 </p>
<p>Flink On YARN 有三种模式：</p>
<p>application模式时flink1.11后推出的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/flink run --target yarn-session <span class="comment"># Submission to an already running Flink on YARN cluster</span></span><br><span class="line">./bin/flink run --target yarn-per-job <span class="comment"># Submission spinning up a Flink on YARN cluster in Per-Job</span></span><br><span class="line">Mode</span><br><span class="line">./bin/flink run-application --target yarn-application <span class="comment"># Submission spinning up Flink on YARN cluster in</span></span><br><span class="line">Application Mode</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/04/21/WXuNZDaiGkESzbx.png" alt="image-20210421114143530"></p>
<p>Session 模式：在 YARN 中初始化一个 Flink 集群，开辟指定的资源，之后我们提交的 Flink Jon 都在这个 Flink yarn-session 中，也就是说不管提交 多少个job，这些 job 都会共用开始时在 YARN 中申请的资源。这个 Flink集群会常驻在 YARN 集群中，除非手动停止。</p>
<p> Per-Job 模式：在 YARN 中，每次提交 job 都会创建一个新的 Flink 集群，任务之间相互独立，互不影响并且方便管理。任务执行完成之后创建的集 群也会消失。 所以每个 Job 执行完毕，Flink 集群关闭，释放资源。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>优点</th>
<th>缺点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Session模式</td>
<td>一次资源分配，多次 job 执行，充分利用 资源，Job 启动快</td>
<td>一直占据资源，可能导致连锁重启， JobManager负载大</td>
<td>小规模短时间运行的作业</td>
</tr>
<tr>
<td>Per-Job模式</td>
<td>资源分配粒度更细，方便单个 Job 的管理</td>
<td>当提交 Job 的 Client 集中的时候，会加重负载 （带宽和CPU消耗）</td>
<td>大规模长时间运行的作业</td>
</tr>
<tr>
<td>Application模式</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>具体可以参考官网：<a href="https://ci.apache.org/projects/flink/flink-docs-stable/deployment/cli.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-stable/deployment/cli.html</a></p>
<p> <a href="https://ci.apache.org/projects/flink/flink-docs-stable/deployment/cli.html#advanced-cli" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-stable/deployment/cli.html#advanced-cli</a></p>
<p> <a href="https://ci.apache.org/projects/flink/flink-docs-stable/deployment/resource-providers/yarn.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-stable/deployment/resource-providers/yarn.html</a> </p>
<p>Flink On YARN 不同的模式，其实入口是不一样的，总的来说是：ClusterEntryPoint，ClusterEntryPoint 是 Flink 集群模式的入口基类，它有三种实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.apache.flink.runtime.entrypoint.SessionClusterEntrypoint</span><br><span class="line">org.apache.flink.runtime.entrypoint.JobClusterEntrypoint</span><br><span class="line">org.apache.flink.client.deployment.application.ApplicationClusterEntryPoint</span><br></pre></td></tr></table></figure>

<p>其中 SessionClusterEntrypoint 又有四种实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.apache.flink.runtime.entrypoint.StandaloneSessionClusterEntrypoint</span><br><span class="line">org.apache.flink.mesos.entrypoint.MesosSessionClusterEntrypoint</span><br><span class="line">org.apache.flink.mesos.entrypoint.YarnSessionClusterEntrypoint</span><br><span class="line">org.apache.flink.mesos.entrypoint.KubernetesSessionClusterEntrypoint</span><br></pre></td></tr></table></figure>





<h2 id="2-5-Flink-选举和监听机制"><a href="#2-5-Flink-选举和监听机制" class="headerlink" title="2.5 Flink 选举和监听机制"></a>2.5 Flink 选举和监听机制</h2><p>Flink 的选举和监听机制，都是依托于 Curator 框架的 API 进行封装提供了的实现，具体涉及到的实现类包括：LeaderContender 和 LeaderElectionService 和 LeaderRetrievalService。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、LeaderContender 参选者 竞选者 （namenode1 namenoode2）</span><br><span class="line">2、LeaderElectionService 选举服务</span><br><span class="line">3、LeaderRetrievalService 监听服务</span><br></pre></td></tr></table></figure>

<p>在 Flink 中，封装了一个选举服务叫做：LeaderElectionService， 接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LeaderElectionService</span> </span>&#123;</span><br><span class="line"><span class="comment">// 启动选举，启动方法将竞争者作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(LeaderContender contender)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// 停止</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// 确认</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">confirmLeadership</span><span class="params">(UUID leaderSessionID, String leaderAddress)</span></span>;</span><br><span class="line"><span class="comment">// 判断是否拥有指定session下的leadership</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasLeadership</span><span class="params">(@Nonnull UUID leaderSessionId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LeaderContender 是 LeaderElectionService 中的参与选举的竞选者。它有四种实现：</p>
<p><img src="https://i.loli.net/2021/04/21/TOBy4hHkbMnjDVq.png" alt="image-20210421143410305"></p>
<p>这四个竞选者类中，都有一个 LeaderElectionService 的选举服务实例对象！完整的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、初始化选举对象 X，X 的内部拥有一个 LeaderElectionService 选举服务实例</span><br><span class="line">2、X 会在某个时机调用：leaderElectionService.start(this); 执行选举，此时 X &#x3D; this</span><br><span class="line">3、如果竞选成功，则会回调：LeaderContender.grantLeadership(sessionID) 方法</span><br><span class="line">4、正常来说，会有很多的服务应该是竞选成功才启动或者执行某些操作，这些业务代码，都在 grantLeadership 方法中进行定义</span><br></pre></td></tr></table></figure>

<p>LeaderElectionService 的默认实现是基于 ZooKeeper 的 DefaultLeaderElectionService。在 DefaultLeaderElectionService 的内部封装了一个 ZooKeeperLeaderElectionDriver 来执行选举和监听。ZooKeeperLeaderElectionDriver 是 FLink-1.12 版本的一个改进，优化了代码的阅读。但是整体 逻辑没变。当 ZooKeeperLeaderElectionDriver 去选举的时候，由内部的基于 Curator 的 LeaderLatch 来执行选举，并且注册了监听。实质上，当 Drvier 竞选成功了，则会执行监听回调：Driver.isLeader() 方法，否则回调 Driver.notLeader() 方法。 在 Driver.isLeader() 方法的内部，其实是在调用 LeaderContender.grantLeadership(sessionID) 方法！ </p>
<p>ZooKeeperLeaderRetrievalDriver 是 Flink 封装出来用来实现 ZooKeeper 监听功能的一个组件。请先看它的接口定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LeaderRetrievalService</span> </span>&#123;</span><br><span class="line"><span class="comment">// 开启监听</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(LeaderRetrievalListener listener)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// 结束监听</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 ZooKeeper 来说，监听的类型有三种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZooKeeper.getData(..., watcher) 注册 监听znode 节点变化的监听</span><br><span class="line">ZooKeeper.exists(...., watcher) 注册 监听znode 创建删除的监听</span><br><span class="line">ZooKeeper.getChildren(....., watcher) 注册 监听znode 子节点个数变化 的监听</span><br></pre></td></tr></table></figure>

<p>但是 Flink 并没有直接使用 ZooKeeper 的 API ，而是使用了 ZooKeeper 的一个 API 框架：Curator 去实现的：对应的监听是：</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>NodeCache</td>
<td>监听节点对应增，删，改操作</td>
</tr>
<tr>
<td>PathChildrenCache</td>
<td>监听节点下一级子节点的增，删，改操作</td>
</tr>
<tr>
<td>TreeCache</td>
<td>可以将指定的路径节点作为根节点，对其所有的子节点操作进行监听，呈现树形目录的监听</td>
</tr>
</tbody></table>
<p>如果 LeaderRetrievalService 通过 start(LeaderRetrievalListener ) 方法开启监听，则当发生事件响应的时候，会回调 start() 方法参数实例 LeaderRetrievalListener 的 notifyLeaderAddress() 方法。详细请看 LeaderRetrievalListener 的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LeaderRetrievalListener</span> </span>&#123;</span><br><span class="line"><span class="comment">// 监听回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyLeaderAddress</span><span class="params">(@Nullable String leaderAddress, @Nullable UUID leaderSessionID)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleError</span><span class="params">(Exception exception)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/04/21/RShFfKnvpVrDbge.png" alt="image-20210421145057181"></p>
<h3 id="2-5-1-JobManagerRunnerImpl"><a href="#2-5-1-JobManagerRunnerImpl" class="headerlink" title="2.5.1 JobManagerRunnerImpl"></a>2.5.1 JobManagerRunnerImpl</h3><p><img src="https://i.loli.net/2021/04/21/biHU64McFSBoKsl.png" alt="image-20210421145225469"></p>
<h3 id="2-5-2-WebMonitorEndpoint"><a href="#2-5-2-WebMonitorEndpoint" class="headerlink" title="2.5.2 WebMonitorEndpoint"></a>2.5.2 WebMonitorEndpoint</h3><p><img src="https://i.loli.net/2021/04/21/qpKQuaJn8WseBwE.png" alt="image-20210421145257616"></p>
<h3 id="2-5-3-JobManager的ResourceManager"><a href="#2-5-3-JobManager的ResourceManager" class="headerlink" title="2.5.3 JobManager的ResourceManager"></a>2.5.3 JobManager的ResourceManager</h3><p><img src="https://i.loli.net/2021/04/21/pmQMfIGVk4Nnuwg.png" alt="image-20210421145332752"></p>
<h3 id="2-5-4-DefaultDispatcherRunner"><a href="#2-5-4-DefaultDispatcherRunner" class="headerlink" title="2.5.4 DefaultDispatcherRunner"></a>2.5.4 DefaultDispatcherRunner</h3><p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210421145408451.png" alt="image-20210421145408451"></p>
<h2 id="2-6-HeartbeatMonitor和HeartbeatTarget"><a href="#2-6-HeartbeatMonitor和HeartbeatTarget" class="headerlink" title="2.6 HeartbeatMonitor和HeartbeatTarget"></a>2.6 HeartbeatMonitor和HeartbeatTarget</h2>]]></content>
      <categories>
        <category>Flink</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>速读与回忆提升及提升行动力讲解和训练</title>
    <url>/2021/04/19/%E5%B0%9A%E5%BF%86%E6%95%99%E8%82%B2/%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB/10.%E9%80%9F%E8%AF%BB%E4%B8%8E%E5%9B%9E%E5%BF%86%E6%8F%90%E5%8D%87%E5%8F%8A%E6%8F%90%E5%8D%87%E8%A1%8C%E5%8A%A8%E5%8A%9B%E8%AE%B2%E8%A7%A3%E5%92%8C%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<h1 id="一、今天内容"><a href="#一、今天内容" class="headerlink" title="一、今天内容"></a>一、今天内容</h1><h1 id="二、理论讲解"><a href="#二、理论讲解" class="headerlink" title="二、理论讲解"></a>二、理论讲解</h1><p><img src="https://i.loli.net/2021/04/19/xsrPDLgSKFzO1E5.png" alt="image-20210419143925785"></p>
<p><img src="https://i.loli.net/2021/04/19/VI3iANOqJgK9PoC.png" alt="image-20210419144221755"></p>
<p>比如亲子教育为例：在孩子放松的时候灌输思想和信念，并且需要不断的重复，潜意识才会留下印象</p>
<p><img src="https://i.loli.net/2021/04/19/XtvRLKby3H2Mlga.png" alt="image-20210419150442056"></p>
<p>借力法：</p>
<p>比如说发表演讲会紧张，这种能力比较差，那可以通过想象的方式想象比如演讲能力的人（比如何炅）把演讲能力传输给我们</p>
<p><img src="https://i.loli.net/2021/04/19/qD4aSrfincXlygO.png" alt="image-20210419151429923"></p>
]]></content>
      <categories>
        <category>尚忆教育</category>
        <category>快速阅读</category>
      </categories>
      <tags>
        <tag>快速阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>快速阅读和记忆方法结合</title>
    <url>/2021/04/19/%E5%B0%9A%E5%BF%86%E6%95%99%E8%82%B2/%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB/9.%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB%E5%92%8C%E8%AE%B0%E5%BF%86%E6%96%B9%E6%B3%95%E7%BB%93%E5%90%88/</url>
    <content><![CDATA[<h1 id="一、今天内容"><a href="#一、今天内容" class="headerlink" title="一、今天内容"></a>一、今天内容</h1><p><img src="https://i.loli.net/2021/04/19/vhB8xCul2t9LbMO.png" alt="image-20210419095718711"></p>
<h1 id="二、理论讲解"><a href="#二、理论讲解" class="headerlink" title="二、理论讲解"></a>二、理论讲解</h1><p><img src="https://i.loli.net/2021/04/19/JUHd9Cs4uA1T5LX.png" alt="image-20210419104859830"></p>
<p><img src="https://i.loli.net/2021/04/19/PRNzFeCh2y3DaJu.png" alt="image-20210419105102780"></p>
<p><img src="https://i.loli.net/2021/04/19/dAItyg5LjnFQwYB.png" alt="image-20210419105113222"></p>
<p><img src="https://i.loli.net/2021/04/19/j7UA2GhPRV8u413.png" alt="image-20210419110055909"></p>
<p><strong>纸条记忆法</strong>：</p>
<p>将白纸裁成纸张大的小纸条，每条小纸条只记录问题，不记答案， 但是记录答案对应的页码位置，那么一张小纸条正反两面大约就可以记录10个问题，适合背诵知识点多的学科书籍或者单词</p>
<p>原理：1.将任务分解    减少背诵压力  2.可以充分利用零碎时间</p>
<p><strong>画画记忆法</strong>：</p>
<p>大脑喜欢记忆短的东西不喜欢短的，所以要压缩关键词</p>
<p>大脑不喜欢记忆抽象的喜欢图像的，所以要将抽象的东西转化为图像</p>
<p>大脑记忆不喜欢陌生的东西，所以要将陌生的东西和熟悉的东西关联进行转化</p>
<p><img src="https://i.loli.net/2021/04/19/eDP59o4Ub6dLzfx.png" alt="image-20210419113032131"></p>
]]></content>
      <categories>
        <category>尚忆教育</category>
        <category>快速阅读</category>
      </categories>
      <tags>
        <tag>快速阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>8.高效学习法：快速阅读与思维导图结合讲解</title>
    <url>/2021/04/15/%E5%B0%9A%E5%BF%86%E6%95%99%E8%82%B2/%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB/8.%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E6%B3%95%EF%BC%9A%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB%E4%B8%8E%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%BB%93%E5%90%88%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="一、今天内容"><a href="#一、今天内容" class="headerlink" title="一、今天内容"></a>一、今天内容</h1><p><img src="https://i.loli.net/2021/04/15/nQP7TeI4lMUX1Kc.png" alt="image-20210415155153245"></p>
<h1 id="二、理论讲解"><a href="#二、理论讲解" class="headerlink" title="二、理论讲解"></a>二、理论讲解</h1><p><img src="https://i.loli.net/2021/04/15/hpgwm8EC7zNjbtk.png" alt="image-20210415161610105"></p>
<p><img src="https://i.loli.net/2021/04/15/YkIFCQoVyneS176.png" alt="image-20210415163042464"></p>
]]></content>
      <categories>
        <category>尚忆教育</category>
        <category>快速阅读</category>
      </categories>
      <tags>
        <tag>快速阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读快10倍方法讲解及训练</title>
    <url>/2021/04/12/%E5%B0%9A%E5%BF%86%E6%95%99%E8%82%B2/%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB/7.%E9%98%85%E8%AF%BB%E5%BF%AB10%E5%80%8D%E6%96%B9%E6%B3%95%E8%AE%B2%E8%A7%A3%E5%8F%8A%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<h1 id="一、今天内容"><a href="#一、今天内容" class="headerlink" title="一、今天内容"></a>一、今天内容</h1><p><img src="https://i.loli.net/2021/04/12/BRWZ8ka4bihvzYm.png" alt="image-20210412095440868"></p>
<h1 id="二、理论讲解"><a href="#二、理论讲解" class="headerlink" title="二、理论讲解"></a>二、理论讲解</h1><p>以前先看书名，再看目录，然后深扎从头看到尾的方式效果很差，按下面的方法效果会好很多</p>
<h2 id="2-1-步骤一-》准备"><a href="#2-1-步骤一-》准备" class="headerlink" title="2.1 步骤一 -》准备"></a>2.1 步骤一 -》准备</h2><h3 id="2-1-1-设定明确的目的"><a href="#2-1-1-设定明确的目的" class="headerlink" title="2.1.1 设定明确的目的"></a>2.1.1 设定明确的目的</h3><p>1）阅读这篇文章的目的是什么？</p>
<p>2）这篇文章对自己有多重要？</p>
<p>3）我需要的是多详细的信息，粗读还是细读？</p>
<p>4）为了达成目的，现在需要花多少时间？</p>
<h3 id="2-1-2-进入阅读文章的状态"><a href="#2-1-2-进入阅读文章的状态" class="headerlink" title="2.1.2 进入阅读文章的状态"></a>2.1.2 进入阅读文章的状态</h3><p>放松训练   橘子集中法  冥想 </p>
<h2 id="2-2-步骤二-》-预习"><a href="#2-2-步骤二-》-预习" class="headerlink" title="2.2 步骤二 -》 预习"></a>2.2 步骤二 -》 预习</h2><p>预习时间一般不要超过10-15分钟，防止陷进去</p>
<p>预习能让头脑整理，分类即将吸收的信息，并提高阅读的速度和理解能力</p>
<p>预习有3个步骤：“调查文章”，“找出关键语”，“重新检讨阅读方针”</p>
<p><strong>调查</strong>就是大致看过整个文章，掌握文章的结构</p>
<p><strong>关键语</strong>就是经常出现，而且会跃入眼帘，有分量的词语</p>
<p><strong>重新检讨阅读方针</strong>就是判断想看的文章是否真正符合自己的目的</p>
<h2 id="2-3-步骤三-》高速阅读"><a href="#2-3-步骤三-》高速阅读" class="headerlink" title="2.3 步骤三 -》高速阅读"></a>2.3 步骤三 -》高速阅读</h2><p>1）把整本书大致看过一遍，以寻找记载着问题答案的地方</p>
<p>2）眼睛沿着页面从上往下移动，眼睛在页面的中间偏左位置，其中会有某部分忽然引起你的注意。这就是直觉的信号，告诉你“这里很重要”。一出现这个信号，就不要违背直觉，马上阅读这个部分。换句话说，针对那些文字以能够理解的速度大致看一遍。如果觉得已经得到想要的信息，就继续进行超阅读。</p>
<p>高速阅读时，速度也有可能会降到旧式阅读的水准。例如，要了解专门的图表，数学公式，或诗的含义，就会降低速度。相对的，高速是为了维持速度，并在必要的地方阅读。</p>
<p>对于提升能力的书籍，比如200-300页的 一般都要控制在2-3个小时，阅读的周期最好不要超过3天</p>
<h2 id="2-4-步骤四-》活化阅读"><a href="#2-4-步骤四-》活化阅读" class="headerlink" title="2.4 步骤四  -》活化阅读"></a>2.4 步骤四  -》活化阅读</h2><p>活化阅读即深刻理解书中的真理</p>
<p>活化阅读的方式有以下两种</p>
<p>1）重新再读</p>
<p>2）制作读书笔记（导图）  第二次看导图复习也可以</p>
]]></content>
      <categories>
        <category>尚忆教育</category>
        <category>快速阅读</category>
      </categories>
      <tags>
        <tag>快速阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>6.面式阅读实际应用和训练</title>
    <url>/2021/04/07/%E5%B0%9A%E5%BF%86%E6%95%99%E8%82%B2/%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB/6.%E9%9D%A2%E8%AF%95%E9%98%85%E8%AF%BB%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%92%8C%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<h1 id="一、今天内容"><a href="#一、今天内容" class="headerlink" title="一、今天内容"></a>一、今天内容</h1><p><img src="https://i.loli.net/2021/04/07/PYvl8IJCA6Vgn2z.png" alt="image-20210407082600170"></p>
<h1 id="二、理论讲解"><a href="#二、理论讲解" class="headerlink" title="二、理论讲解"></a>二、理论讲解</h1><p><img src="https://i.loli.net/2021/04/07/6CKb9qnOdV1iFag.png" alt="image-20210407085048780"></p>
<p>一定有下面几种阅读法：</p>
<p><img src="https://i.loli.net/2021/04/07/sh5LASrCZjgvfDk.png" alt="image-20210407085109253"></p>
<p><img src="https://i.loli.net/2021/04/07/PNKM5eIYVU2r7xG.png" alt="image-20210407085541558"></p>
<p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210407090102422.png" alt="image-20210407090102422"></p>
<p>一般都是用前两种</p>
<p><img src="https://i.loli.net/2021/04/07/v7q9Q13ctxlEiZg.png" alt="image-20210407090149917"></p>
<p><img src="https://i.loli.net/2021/04/09/uzcPwCM9XBZGKQF.png" alt="image-20210409150523719"></p>
]]></content>
      <categories>
        <category>尚忆教育</category>
        <category>快速阅读</category>
      </categories>
      <tags>
        <tag>快速阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>24-Kafka生产者之消费者发送消息原理</title>
    <url>/2021/04/01/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/kafka/%E5%9F%BA%E7%A1%80/24-Kafka%E7%94%9F%E4%BA%A7%E8%80%85%E4%B9%8B%E6%B6%88%E8%B4%B9%E8%80%85%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><img src="https://i.loli.net/2021/04/01/ocw7dTYQxrOtPWN.png" alt="image-20210401151819106"></p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>3.stateBackend和savePoint</title>
    <url>/2021/03/30/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/Flink/3.stateBackend%E5%92%8CsavePoint/</url>
    <content><![CDATA[<h1 id="一、课程内容"><a href="#一、课程内容" class="headerlink" title="一、课程内容"></a>一、课程内容</h1><p>本次课程对上次常见的state进行案例实践，并且引出checkpoints机制原理，主要掌握以下内容：</p>
<p>1）掌握State Backend的类型</p>
<p>2）掌握Checkpoints算法原理</p>
<p>3）掌握Checkpoints配置使用</p>
<p>4）精确一次处理方案设计</p>
<h1 id="二、知识要点"><a href="#二、知识要点" class="headerlink" title="二、知识要点"></a>二、知识要点</h1><h2 id="2-1-StateBackend"><a href="#2-1-StateBackend" class="headerlink" title="2.1 StateBackend"></a>2.1 StateBackend</h2><h3 id="2-1-1-StateBackend分类"><a href="#2-1-1-StateBackend分类" class="headerlink" title="2.1.1 StateBackend分类"></a>2.1.1 StateBackend分类</h3><p>1）memory state backend</p>
<p>默认使用的就是memory state backend</p>
<p><img src="https://i.loli.net/2021/03/30/siF4xkdtmKYWS36.png" alt="image-20210330160000175"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">缺点：只能保存很小的状态并且在内存中容易丢</span><br><span class="line"></span><br><span class="line">优点：开发测试方便</span><br><span class="line">用于测试</span><br></pre></td></tr></table></figure>





<p>2）Fs stateBackend</p>
<p><img src="https://i.loli.net/2021/03/30/uLl6EUDRiPSob5r.png" alt="image-20210330160341954"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">缺点：状态大小受taskManager内存限制（默认是5M）</span><br><span class="line"></span><br><span class="line">优点：状态访问速度快，而且状态信息不会丢失</span><br><span class="line"></span><br><span class="line">用于生产，也可用于存储状态数据量大的情况</span><br></pre></td></tr></table></figure>





<p>3）RocksDBStateBackend</p>
<p><img src="https://i.loli.net/2021/03/30/hz2YX9fl8u4ZkmG.png" alt="image-20210330161356796"></p>
<p>状态信息存储在 RocksDB 数据库 (key-value 的数据存储服务)， 最终保存在本地文件中 checkpoint 的时候将状态保存到指定的文件中 (HDFS 等文件系统)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">缺点： 状态访问速度有所下降</span><br><span class="line"></span><br><span class="line">优点： 可以存储超大量的状态信息 状态信息不会丢失 用于： 生产，可以存储超大量的状态信息</span><br></pre></td></tr></table></figure>



<h3 id="2-1-2-StateBackend的配置方式"><a href="#2-1-2-StateBackend的配置方式" class="headerlink" title="2.1.2 StateBackend的配置方式"></a>2.1.2 StateBackend的配置方式</h3><p>1）单任务配置（推荐）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改当前任务代码</span></span><br><span class="line">env.setStateBackend(<span class="keyword">new</span></span><br><span class="line">FsStateBackend(<span class="string">"hdfs://namenode:9000/flink/checkpoints"</span>));</span><br><span class="line"><span class="comment">//或者new MemoryStateBackend()</span></span><br><span class="line"><span class="comment">//或者new RocksDBStateBackend(filebackend, true);【需要添加第三方依赖】</span></span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果使用RocksDBStateBackend方式，需要在pom.xml文件中，添加如下依赖</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.flink&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;flink-statebackend-rocksdb_2.11&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>2）全局配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">//修改flink-conf.yaml</span></span><br><span class="line"><span class="attr">state.backend:</span> <span class="string">filesystem</span></span><br><span class="line"><span class="attr">state.checkpoints.dir:</span> <span class="string">hdfs://namenode:9000/flink/checkpoints</span></span><br><span class="line"><span class="string">注意：state.backend的值可以是下面几种：jobmanager(MemoryStateBackend),</span></span><br><span class="line"><span class="string">filesystem(FsStateBackend),</span> <span class="string">rocksdb(RocksDBStateBackend)</span></span><br></pre></td></tr></table></figure>



<h2 id="2-2-checkpoint原理"><a href="#2-2-checkpoint原理" class="headerlink" title="2.2 checkpoint原理"></a>2.2 checkpoint原理</h2><h3 id="2-2-1-checkpoint概述（容错）"><a href="#2-2-1-checkpoint概述（容错）" class="headerlink" title="2.2.1 checkpoint概述（容错）"></a>2.2.1 checkpoint概述（容错）</h3><p>checkpoint可以保证flink集群在某个算子发生故障时，能够将整个应用流图的状态恢复到故障之前的状态，保证应用流图的状态一致性</p>
<h3 id="2-2-2-checkpoint的简单想法"><a href="#2-2-2-checkpoint的简单想法" class="headerlink" title="2.2.2 checkpoint的简单想法"></a>2.2.2 checkpoint的简单想法</h3><p><img src="https://i.loli.net/2021/03/30/7novZWaBzCNLMsF.png" alt="image-20210330164058697"></p>
<p>当任务运行失败的时候，执行恢复流程</p>
<p><img src="https://i.loli.net/2021/03/30/5Z1EYscqaNBQIb6.png" alt="image-20210330164248421"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上述对于个人的checkpoint的简单想法可以保证容错，但是效率太差，因为在做checkpoint的时候任务停止了，flink是用下面的方式做的</span><br></pre></td></tr></table></figure>



<h3 id="2-2-3-Chandy-Lamport算法"><a href="#2-2-3-Chandy-Lamport算法" class="headerlink" title="2.2.3 Chandy-Lamport算法"></a>2.2.3 Chandy-Lamport算法</h3><h4 id="1）任务开启"><a href="#1）任务开启" class="headerlink" title="1）任务开启"></a>1）任务开启</h4><p><img src="https://i.loli.net/2021/03/30/Gt5VwnLNO2roEpI.png" alt="image-20210330170549980"></p>
<h4 id="2）JobManager发起Checkpoint"><a href="#2）JobManager发起Checkpoint" class="headerlink" title="2）JobManager发起Checkpoint"></a>2）JobManager发起Checkpoint</h4><p><img src="https://i.loli.net/2021/03/30/SiFbJzKlWPtGduR.png" alt="image-20210330170717457"></p>
<h4 id="3）source上报checkpoint"><a href="#3）source上报checkpoint" class="headerlink" title="3）source上报checkpoint"></a>3）source上报checkpoint</h4><p>当barrier这个特殊的数据流入到source时，就需要将状态保存到状态后端，并在完成时需要向JobManager上报完成，然后将barrier继续往下游task发送</p>
<p><img src="https://i.loli.net/2021/03/30/7fgdvzbEPj9I1Jp.png" alt="image-20210330171025321"></p>
<h4 id="4）数据处理"><a href="#4）数据处理" class="headerlink" title="4）数据处理"></a>4）数据处理</h4><p>当下游task接收到上游task发送的barrier时，需要将barrier之后的数据进行缓存，即缓存后一次checkpoint时计算的数据</p>
<p><img src="https://i.loli.net/2021/03/30/oHzBUYOitDadKmu.png" alt="image-20210330171954635"></p>
<h4 id="5）barrier对齐"><a href="#5）barrier对齐" class="headerlink" title="5）barrier对齐"></a>5）barrier对齐</h4><p>当当前的task接收到上游所有task的barrier时，对当前的task状态进行checkpoint，并将barrier发给下一个task</p>
<p><img src="https://i.loli.net/2021/03/30/ChFXpMexH6lOY2K.png" alt="image-20210330173137680"></p>
<h4 id="6）对缓存数据进行处理"><a href="#6）对缓存数据进行处理" class="headerlink" title="6）对缓存数据进行处理"></a>6）对缓存数据进行处理</h4><p>在向下游task发送barrier之后，需要对之前缓冲的数据进行处理</p>
<p><img src="https://i.loli.net/2021/03/30/k3gjBApbNK6xo4I.png" alt="image-20210330173404608"></p>
<h4 id="7）sink上报checkpoint"><a href="#7）sink上报checkpoint" class="headerlink" title="7）sink上报checkpoint"></a>7）sink上报checkpoint</h4><p>最后sink会向JobManager上报checkpoint，此次checkpoint就结束了</p>
<p><img src="https://i.loli.net/2021/03/30/mhMCFvAiK2PfS4k.png" alt="image-20210330173431087"></p>
<h2 id="2-3-checkpoint配置"><a href="#2-3-checkpoint配置" class="headerlink" title="2.3 checkpoint配置"></a>2.3 checkpoint配置</h2><p>默认checkpoint功能是disabled的，想要使用的时候需要先启用，checkpoint开启之后， checkPointMode有两种，Exactly-once和At-least-once，默认的checkPointMode是Exactly-once， Exactly-once对于大多数应用来说是最合适的。At-least-once可能用在某些延迟超低的应用程序（始终 延迟为几毫秒）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">默认checkpoint功能是disabled的，想要使用的时候需要先启用</span><br><span class="line">StreamExecutionEnvironment env =</span><br><span class="line">StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="comment">// 每隔1000 ms进行启动一个检查点【设置checkpoint的周期】</span></span><br><span class="line">env.enableCheckpointing(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 高级选项：</span></span><br><span class="line"><span class="comment">// 设置模式为exactly-once （这是默认值）</span></span><br><span class="line">env.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);</span><br><span class="line"><span class="comment">// 检查点必须在一分钟内完成，或者被丢弃【checkpoint的超时时间】</span></span><br><span class="line">env.getCheckpointConfig().setCheckpointTimeout(<span class="number">60000</span>);</span><br><span class="line"><span class="comment">// 同时允许多少个checkpoint</span></span><br><span class="line">env.getCheckpointConfig().setMaxConcurrentCheckpoints(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 确保检查点之间有至少500 ms的间隔【checkpoint最小间隔】</span></span><br><span class="line">env.getCheckpointConfig().setMinPauseBetweenCheckpoints(<span class="number">500</span>);</span><br><span class="line"><span class="comment">// 表示一旦Flink处理程序被cancel后，会保留Checkpoint数据，以便根据实际需要恢复到指定的</span></span><br><span class="line"><span class="comment">//Checkpoint【详细解释见备注】</span></span><br><span class="line">env.getCheckpointConfig().enableExternalizedCheckpoints(ExternalizedCheckpointCl</span><br><span class="line">eanup.RETAIN_ON_CANCELLATION);</span><br></pre></td></tr></table></figure>



<h2 id="2-4-重启策略（配合checkpoint实现自动容错）"><a href="#2-4-重启策略（配合checkpoint实现自动容错）" class="headerlink" title="2.4 重启策略（配合checkpoint实现自动容错）"></a>2.4 重启策略（配合checkpoint实现自动容错）</h2><h3 id="2-4-1-重启策略概述"><a href="#2-4-1-重启策略概述" class="headerlink" title="2.4.1 重启策略概述"></a>2.4.1 重启策略概述</h3><p>Flink支持不同的重启策略，以在故障发生时控制作业如何重启，集群在启动时会伴随一个默认的重启策 略，在没有定义具体重启策略时会使用该默认策略。 如果在工作提交时指定了一个重启策略，该策略会 覆盖集群的默认策略，默认的重启策略可以通过 Flink 的配置文件 flink-conf.yaml 指定。配置参数 restart-strategy 定义了哪个策略被使用。</p>
<p>常用的重启策略</p>
<p>1）固定间隔（Fixed delay）一般就用这个</p>
<p>2）失败率（Failure rate）</p>
<p>3）无重启（No restart）</p>
<p>如果没有启用 checkpointing，则使用无重启 (no restart) 策略。 如果启用了 checkpointing，但没有配置重启策略，则使用固定间隔 (fixed-delay) 策略， 尝试重启次数</p>
<p>默认值是：Integer.MAX_VALUE，重启策略可以在flink-conf.yaml中配置，表示全局的配置。也可以在 应用代码中动态指定，会覆盖全局配置。</p>
<h3 id="2-4-2-重启策略配置"><a href="#2-4-2-重启策略配置" class="headerlink" title="2.4.2 重启策略配置"></a>2.4.2 重启策略配置</h3><p>1）固定间隔</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第一种：全局配置 flink-conf.yaml</span><br><span class="line">restart-strategy: fixed-delay</span><br><span class="line">restart-strategy.fixed-delay.attempts: <span class="number">3</span></span><br><span class="line">restart-strategy.fixed-delay.delay: <span class="number">10</span> s</span><br><span class="line">第二种：应用代码设置</span><br><span class="line">env.setRestartStrategy(RestartStrategies.fixedDelayRestart(</span><br><span class="line"><span class="number">3</span>, <span class="comment">// 尝试重启的次数</span></span><br><span class="line">Time.of(<span class="number">10</span>, TimeUnit.SECONDS) <span class="comment">// 间隔</span></span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<p>2）失败率</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第一种：全局配置 flink-conf.yaml</span><br><span class="line">restart-strategy: failure-rate</span><br><span class="line">restart-strategy.failure-rate.max-failures-per-interval: <span class="number">3</span></span><br><span class="line">restart-strategy.failure-rate.failure-rate-interval: <span class="number">5</span> min</span><br><span class="line">restart-strategy.failure-rate.delay: <span class="number">10</span> s</span><br><span class="line">第二种：应用代码设置</span><br><span class="line">env.setRestartStrategy(RestartStrategies.failureRateRestart(</span><br><span class="line"><span class="number">3</span>, <span class="comment">// 一个时间段内的最大失败次数</span></span><br><span class="line">Time.of(<span class="number">5</span>, TimeUnit.MINUTES), <span class="comment">// 衡量失败次数的是时间段</span></span><br><span class="line">Time.of(<span class="number">10</span>, TimeUnit.SECONDS) <span class="comment">// 间隔</span></span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<p>3）无重启</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第一种：全局配置 flink-conf.yaml</span><br><span class="line">restart-strategy: none</span><br><span class="line">第二种：应用代码设置</span><br><span class="line">env.setRestartStrategy(RestartStrategies.noRestart());</span><br></pre></td></tr></table></figure>

<h2 id="2-5-从checkpoint恢复数据"><a href="#2-5-从checkpoint恢复数据" class="headerlink" title="2.5 从checkpoint恢复数据"></a>2.5 从checkpoint恢复数据</h2><p>如果flink程序异常失败了，或者最近一段时间内处理错误，可以将程序从某一个checkpoint点进行恢复，下面手动演示自动容错的逻辑</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flink run -c lesson06.TestCheckpoint original-flink-state-1.0-SNAPSHOT.jar --</span><br><span class="line">hostname 192.168.123.102 --port 9999</span><br><span class="line"></span><br><span class="line">flink run -s</span><br><span class="line">hdfs://192.168.123.102:9000/flink/checkpoint/947a2aabced76d5f83b59deecd2b7b55/ch</span><br><span class="line">k-22/_metadata -c lesson06.TestCheckpoint original-flink-state-1.0-SNAPSHOT.jar</span><br><span class="line">--hostname 192.168.123.102 --port 9999</span><br></pre></td></tr></table></figure>

<p>程序正常运行后，还会按照Checkpoint配置进行运行，继续生成Checkpoint数据。</p>
<p>当然恢复数据的方式还可以在自己的代码里面指定checkpoint目录，这样下一次启动的时候即使代码发 生了改变就自动恢复数据了。</p>
<h2 id="2-6-SavePoint"><a href="#2-6-SavePoint" class="headerlink" title="2.6 SavePoint"></a>2.6 SavePoint</h2><h3 id="2-6-1-savepoint概述"><a href="#2-6-1-savepoint概述" class="headerlink" title="2.6.1 savepoint概述"></a>2.6.1 savepoint概述</h3><p>savepoint是一个重量级的checkpoint，checkpoint的定时存储所有task的关键状态信息，而savepoint会存储包括数据在内的所有信息，这样程序在后续升级或者修改并行度的时候，还能从保存的状态位置继续启动恢复。可以保存数据源offset，operator操作状态等信息，可以从应用在过去任意做了savepoint的时刻开始继续消费。</p>
<p>需要用户手动执行，不会过期，在集群升级/代码迁移等情况下使用。</p>
<h3 id="2-6-2-注意事项"><a href="#2-6-2-注意事项" class="headerlink" title="2.6.2 注意事项"></a>2.6.2 注意事项</h3><p>为了能够在作业的不同版本之间和flink集群的不同版本之间顺利升级，强烈建议开发人员通过uid(String)方法手动的给算子赋予ID，这些ID将用于确定每一个算子的状态范围。如果不手动指定的话，则Flink默认会给每个算子指定ID，只要这些ID没有改变就能从savepoint将程序恢复回来。但是这些自动生成的ID依赖于程序的结构，并且对代码的更改是非常敏感的，因此，强烈建议手动设置算子的ID。</p>
<h4 id="checkpoint和savepoint区别"><a href="#checkpoint和savepoint区别" class="headerlink" title="checkpoint和savepoint区别"></a>checkpoint和savepoint区别</h4><table>
<thead>
<tr>
<th></th>
<th>checkpoint</th>
<th>savepoint</th>
</tr>
</thead>
<tbody><tr>
<td>触发方式</td>
<td>自动触发</td>
<td>用户手动触发</td>
</tr>
<tr>
<td>主要功能</td>
<td>task发生异常时自动恢复数据</td>
<td>作业升级，代码修改，参数调整等</td>
</tr>
<tr>
<td>特点</td>
<td>轻量级，作业停止默认清除</td>
<td>重量级，数据持久化，diamante修改，参数调整后恢复数据</td>
</tr>
</tbody></table>
<h3 id="2-6-3-savepoint的使用"><a href="#2-6-3-savepoint的使用" class="headerlink" title="2.6.3  savepoint的使用"></a>2.6.3  savepoint的使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 停止程序，触发savepoint，指定存放savepoint的目录</span><br><span class="line">停止程序：bin&#x2F;flink cancel -s [targetDirectory] jobId [-yid yarnAppId]【针对on yarn</span><br><span class="line">模式需要指定-yid参数】</span><br><span class="line">这样savepoint就存储在targetDirectory下了</span><br><span class="line"></span><br><span class="line">2.从指定的savepoint启动job</span><br><span class="line">bin&#x2F;flink run -s savepointPath [runArgs]</span><br></pre></td></tr></table></figure>







<h2 id="2-7-Flink容错机制"><a href="#2-7-Flink容错机制" class="headerlink" title="2.7 Flink容错机制"></a>2.7 Flink容错机制</h2><p>Flink的容错机制是整个程序的容错，分为source -》处理阶段 -》sink阶段</p>
<h3 id="2-7-1-source"><a href="#2-7-1-source" class="headerlink" title="2.7.1 source"></a>2.7.1 source</h3><p><img src="https://i.loli.net/2021/03/31/zJfXtVOQpk9W1d5.png" alt="image-20210331105203778"></p>
<p>大部分情况下使用的就是kafka</p>
<h4 id="1）kafka-consumer的偏移量管理"><a href="#1）kafka-consumer的偏移量管理" class="headerlink" title="1）kafka consumer的偏移量管理"></a>1）kafka consumer的偏移量管理</h4><p>而在kafka的source端是通过checkpoint将消费offset以状态的方式保存下来从而实现精准一次消费，kafka的_consumer_offset主题中本身也会保存offset，flink状态中也会保存offset，那应该使用哪个呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StreamExecutionEnvironment env =</span><br><span class="line">StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">String topic=<span class="string">"test"</span>; <span class="comment">//3</span></span><br><span class="line">Properties consumerProperties = <span class="keyword">new</span> Properties();</span><br><span class="line">consumerProperties.setProperty(<span class="string">"bootstrap.servers"</span>,<span class="string">"192.168.123.102:9092"</span>);</span><br><span class="line">consumerProperties.setProperty(<span class="string">"group.id"</span>,<span class="string">"testSlot_consumer"</span>);</span><br><span class="line">FlinkKafkaConsumer&lt;String&gt; myConsumer = <span class="keyword">new</span> FlinkKafkaConsumer&lt;&gt;(topic,</span><br><span class="line"><span class="keyword">new</span> SimpleStringSchema(),</span><br><span class="line">consumerProperties);</span><br><span class="line">DataStreamSource&lt;String&gt; data =</span><br><span class="line">env.addSource(myConsumer).setParallelism(<span class="number">3</span>);<span class="comment">// 3 task</span></span><br><span class="line">myConsumer.setCommitOffsetsOnCheckpoints(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>结论</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 我们使用FlinkKafkaConumser,并且启用Checkpoint，偏移量会通过checkpoint保存到state里</span><br><span class="line">面，并且默认会写入到kafka的特殊主体中，也就是__consumer_offset</span><br><span class="line">2. setCommitOffsetsOnCheckpoints 默认会true，就是把偏移量写入_consumer_offset主题中</span><br><span class="line">3. Flink自动重启的过程中，读取的偏移量是state中的偏移量</span><br><span class="line">4. 我们手动重启任务的过程中，也不指定checkpoints恢复数据，默认读取的是__consumer_offset中</span><br><span class="line">的偏移量，如果__consumer_offset里面没有，那么默认就会从earliest读取数据</span><br></pre></td></tr></table></figure>



<h3 id="2-7-2-flink自身容错"><a href="#2-7-2-flink自身容错" class="headerlink" title="2.7.2 flink自身容错"></a>2.7.2 flink自身容错</h3><p>flink自身是通过checkpoint进行容错的</p>
<h3 id="2-7-3-sink"><a href="#2-7-3-sink" class="headerlink" title="2.7.3 sink"></a>2.7.3 sink</h3><p><img src="https://i.loli.net/2021/03/31/7AWqSh2FrCJiDOV.png" alt="image-20210331111654918"></p>
<h4 id="1）幂等性写入"><a href="#1）幂等性写入" class="headerlink" title="1）幂等性写入"></a>1）幂等性写入</h4><p><img src="https://i.loli.net/2021/03/31/Sr2ZUBAPKfmCyad.png" alt="image-20210331114712642"></p>
<p>结论</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过幂等性实现仅一次语义</span><br></pre></td></tr></table></figure>



<h4 id="2）Flink两阶段提交"><a href="#2）Flink两阶段提交" class="headerlink" title="2）Flink两阶段提交"></a>2）Flink两阶段提交</h4><p>要想保证sink端的精准一次性，还可以通过保证在最后sink阶段将数据写入sink端系统的这个操作和sink端状态写入到状态后端的这个过程通过事务的方式要么都成功要么都失败。</p>
<p>第一次预提交：第一次将数据预提交到kafka中，但此时的数据会设置为用户不可见</p>
<p>第二次提交：但sink端做完checkpoint的时候进行第二次提交，并将数据设置为可见</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在分布式系统中，可以使用两阶段提交来实现事务性从而保证数据的一致性，两阶段提交分为：预提交阶段与</span><br><span class="line">提交阶段，通常包含两个角色：协调者与执行者，协调者用于用于管理所有执行者的操作，执行者用于执行具</span><br><span class="line">体的提交操作，具体的操作流程：</span><br><span class="line">1. 首先协调者会送预提交(pre-commit)命令有的执行者</span><br><span class="line">2. 执行者执行预提交操作然后发送一条反馈(ack)消息给协调者</span><br><span class="line">3. 待协调者收到所有执行者的成功反馈，则发送一条提交信息(commit)给执行者</span><br><span class="line">4. 执行者执行提交操作</span><br><span class="line">如果在流程2中部分预提交失败，那么协调者就会收到一条失败的反馈，则会发送一条rollback消息给所有执</span><br><span class="line">行者，执行回滚操作，保证数据一致性；但是如果在流程4中，出现部分提交成功部分提交失败，那么就会造</span><br><span class="line">成数据的不一致，因此后面也提出了3PC或者通过其他补偿机制来保证数据最终一致性，接下看看flink 是如</span><br><span class="line">何做到2PC，保证数据的一致性。</span><br><span class="line">flink的流程大概与这个流程相似</span><br></pre></td></tr></table></figure>

<p>flink 两阶段提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flink中两阶段提交是为了保证端到端的Exactly Once，主要依托checkpoint机制来实现，先看一下</span><br><span class="line">checkpoint的整体流程，</span><br><span class="line">1.JobManager会周期性的发送执行checkpoint命令(start checkpoint)；</span><br><span class="line">2.当source端收到执行指令后会产生一条barrier消息插入到input消息队列中，当处理到barrier时</span><br><span class="line">会执行本地checkpoint, 并且会将barrier发送到下一个节点，当checkpoint完成之后会发送一条ack信</span><br><span class="line">息给JobManager;</span><br><span class="line">3. 当所有节点都完成checkpoint之后，JobManager会收到来自所有节点的ack信息，那么就表示一次</span><br><span class="line">完整的checkpoint的完成；</span><br><span class="line">4. JobManager会给所有节点发送一条callback信息，表示通知checkpoint完成消息。接下来就可以</span><br><span class="line">提交事务了</span><br><span class="line">对比flink整个checkpoint机制调用流程可以发现与2PC非常相似，JobManager相当于协调者，flink提</span><br><span class="line">供了CheckpointedFunction与CheckpointListener这样两个接口，CheckpointedFunction中有</span><br><span class="line">snapshotState方法，每次checkpoint触发执行方法，通常会将缓存数据放入状态中，可以理解为是一个</span><br><span class="line">hook，这个方法里面可以实现预提交，CheckpointListener中有notifyCheckpointComplete方法，</span><br><span class="line">checkpoint完成之后的通知方法，这里可以做一些额外的操作，比如真正提交kafka的事务；在2PC中提到</span><br><span class="line">如果对应流程2预提交失败，那么本次checkpoint就被取消不会执行，不会影响数据一致性.如果流程4失</span><br><span class="line">败，那么重启的时候会再次执行commit</span><br></pre></td></tr></table></figure>





<h1 id="三、扩展"><a href="#三、扩展" class="headerlink" title="三、扩展"></a>三、扩展</h1><p>1.如果提交流程报如下错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: org.apache.flink.core.fs.UnsupportedFileSystemSchemeException: Could</span><br><span class="line">not find a file system implementation <span class="keyword">for</span> scheme <span class="string">'hdfs'</span>. The scheme is not</span><br><span class="line">directly supported by Flink and no Hadoop file system to support <span class="keyword">this</span> scheme</span><br><span class="line">could be loaded.</span><br><span class="line">at</span><br><span class="line">org.apache.flink.core.fs.FileSystem.getUnguardedFileSystem(FileSystem.java:<span class="number">450</span>)</span><br><span class="line">at org.apache.flink.core.fs.FileSystem.get(FileSystem.java:<span class="number">362</span>)</span><br><span class="line">at org.apache.flink.core.fs.Path.getFileSystem(Path.java:<span class="number">298</span>)</span><br><span class="line">at org.apache.flink.runtime.state.filesystem.FsCheckpointStorage.&lt;init&gt;</span><br><span class="line">(FsCheckpointStorage.java:<span class="number">64</span>)</span><br><span class="line">at</span><br><span class="line">org.apache.flink.runtime.state.filesystem.FsStateBackend.createCheckpointStorage</span><br><span class="line">(FsStateBackend.java:<span class="number">490</span>)</span><br><span class="line"></span><br><span class="line">at org.apache.flink.runtime.checkpoint.CheckpointCoordinator.&lt;init&gt;</span><br><span class="line">(CheckpointCoordinator.java:<span class="number">279</span>)</span><br><span class="line">... <span class="number">23</span> more</span><br><span class="line">Caused by: org.apache.flink.core.fs.UnsupportedFileSystemSchemeException: Hadoop</span><br><span class="line">is not in the classpath/dependencies.</span><br><span class="line">at</span><br><span class="line">org.apache.flink.core.fs.UnsupportedSchemeFactory.create(UnsupportedSchemeFactor</span><br><span class="line">y.java:<span class="number">58</span>)</span><br><span class="line">at</span><br><span class="line">org.apache.flink.core.fs.FileSystem.getUnguardedFileSystem(FileSystem.java:<span class="number">446</span>)</span><br><span class="line">... <span class="number">28</span> more</span><br><span class="line">End of exception on server side&gt;]</span><br><span class="line">at</span><br><span class="line">org.apache.flink.runtime.rest.RestClient.parseResponse(RestClient.java:<span class="number">390</span>)</span><br><span class="line">at</span><br><span class="line">org.apache.flink.runtime.rest.RestClient.lambda$submitRequest$<span class="number">3</span>(RestClient.java:</span><br><span class="line"><span class="number">374</span>)</span><br><span class="line">at</span><br><span class="line">java.util.concurrent.CompletableFuture.uniCompose(CompletableFuture.java:<span class="number">952</span>)</span><br><span class="line">at</span><br><span class="line">java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java</span><br><span class="line">:<span class="number">926</span>)</span><br></pre></td></tr></table></figure>

<p>那么下载如下的包 下载地址：<a href="https://repo.maven.apache.org/maven2/org/apache/flink/flink-shaded-hadoop-2-ube" target="_blank" rel="noopener">https://repo.maven.apache.org/maven2/org/apache/flink/flink-shaded-hadoop-2-ube</a> r/ 要按照HADOOP版本下载，然后把jar加入flink的lib目录下，重启集群。</p>
<p>要按照HADOOP版本下载，然后把jar加入flink的lib目录下，重启集群。</p>
<h1 id="四、面试题"><a href="#四、面试题" class="headerlink" title="四、面试题"></a>四、面试题</h1><ol>
<li>说说有哪三个StateBackend，都有什么特点</li>
<li>说说Checkpoint和SavePoint的应用场景</li>
<li>Flink相比SparkStreaming有什么区别</li>
</ol>
]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>6.CEP&amp;Flink内存模型&amp;Stream</title>
    <url>/2021/03/30/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/Flink/6.CEP&amp;Flink%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B&amp;ZStream/</url>
    <content><![CDATA[<h1 id="一、课程内容"><a href="#一、课程内容" class="headerlink" title="一、课程内容"></a>一、课程内容</h1><h2 id="1-1-CEP"><a href="#1-1-CEP" class="headerlink" title="1.1 CEP"></a>1.1 CEP</h2><h2 id="1-2-Flink内存模型"><a href="#1-2-Flink内存模型" class="headerlink" title="1.2 Flink内存模型"></a>1.2 Flink内存模型</h2><h1 id="二、知识要点"><a href="#二、知识要点" class="headerlink" title="二、知识要点"></a>二、知识要点</h1><h2 id="2-1-CEP使用流程"><a href="#2-1-CEP使用流程" class="headerlink" title="2.1 CEP使用流程"></a>2.1 CEP使用流程</h2><h3 id="2-1-1-读取数据"><a href="#2-1-1-读取数据" class="headerlink" title="2.1.1 读取数据"></a>2.1.1 读取数据</h3><h3 id="2-1-2-定义匹配规则"><a href="#2-1-2-定义匹配规则" class="headerlink" title="2.1.2 定义匹配规则"></a>2.1.2 定义匹配规则</h3><h3 id="2-1-3-在事件流上应用匹配规则"><a href="#2-1-3-在事件流上应用匹配规则" class="headerlink" title="2.1.3 在事件流上应用匹配规则"></a>2.1.3 在事件流上应用匹配规则</h3><h3 id="2-1-4-提取匹配事件"><a href="#2-1-4-提取匹配事件" class="headerlink" title="2.1.4 提取匹配事件"></a>2.1.4 提取匹配事件</h3><h2 id="2-2-Flink内存模型"><a href="#2-2-Flink内存模型" class="headerlink" title="2.2 Flink内存模型"></a>2.2 Flink内存模型</h2><h3 id="2-1-1-flink架构图"><a href="#2-1-1-flink架构图" class="headerlink" title="2.1.1 flink架构图"></a>2.1.1 flink架构图</h3><p><img src="https://i.loli.net/2021/04/12/54BTyiMGFnjJQVc.png" alt="image-20210412153602831"></p>
<p><img src="https://i.loli.net/2021/04/12/bIZR4CnlmyeBduK.png" alt="image-20210412153840481"></p>
<p><img src="https://i.loli.net/2021/04/12/zfVPXvyrxbe5wsZ.png" alt="image-20210412153906115"></p>
<h3 id="2-2-2-Flink-taskManager之间的数据传输（基于netty架构）"><a href="#2-2-2-Flink-taskManager之间的数据传输（基于netty架构）" class="headerlink" title="2.2.2 Flink taskManager之间的数据传输（基于netty架构）"></a>2.2.2 Flink taskManager之间的数据传输（基于netty架构）</h3><p><img src="https://i.loli.net/2021/04/12/HzL7WJ9GNemw8gO.png" alt="image-20210412153930706"></p>
<p><img src="https://i.loli.net/2021/04/12/gHukByQ4rKonF8p.png" alt="image-20210412154008093"></p>
<h3 id="2-2-3-Flink内存管理"><a href="#2-2-3-Flink内存管理" class="headerlink" title="2.2.3 Flink内存管理"></a>2.2.3 Flink内存管理</h3><p>flink最后的代码时运行在JVM上的，但是JVM管理内存存在缺陷，所以Flink自身对内存有自己的管理机制</p>
<p>JVM管理内存的缺陷：</p>
<ol>
<li>Java对象存储密度低：一个只包含boolean属性的对象占用16个字节内存：对象头占了8个， boolean属性占了1个，对其填充占了7个，而实际只需要一个bit（1/8字节）就够了。、</li>
<li>Full GC会极大地影响性能，尤其是为了处理更大数据而开了很大内存空间的JVM来说，GC会达到 秒级甚至分钟级。 </li>
<li>OOM问题影响稳定性：OutOfMenoryError是分布式计算框架经常会遇到的问题，当JVM中所有 对象大小超过分配给JVM的内存大小时，就会发生OutOfMenoryError错误，导致JVM崩溃，分布 式框架的健壮性和性能都会受到影响。</li>
</ol>
<p><img src="https://i.loli.net/2021/04/12/5qh3s1IxA6igGcO.png" alt="image-20210412155224167"></p>
<p>其中Process memory指的就是yarn的container的内存</p>
<p><img src="https://i.loli.net/2021/04/12/dqhurBEJ9SAtfIP.png" alt="image-20210412155510676"></p>
<p><img src="https://i.loli.net/2021/04/12/1DfmWtbr9scjFAM.png" alt="image-20210412181635242"></p>
<h2 id="2-3-SQL-on-Stream"><a href="#2-3-SQL-on-Stream" class="headerlink" title="2.3 SQL on Stream"></a>2.3 SQL on Stream</h2><p>公司已经有iQuery平台，iQuery可以通过在页面写SQL语句，通过Hive引擎，Spark引擎执行离线任 务。故公司提出是否可以研发SQL on Stream平台，实时任务也SQL化，有如下好处： 1. 提升开发效率 2. 降低任务交接的难度 3. 降低实时任务开发门槛 于是研发了ZStream平台，该平台基于<a href="https://github.com/DTStack/flinkStreamSQL" target="_blank" rel="noopener">https://github.com/DTStack/flinkStreamSQL</a> 项目二次开发 ZStream页面 新建任务 SQL编辑 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh submit.sh </span><br><span class="line">-mode yarnPer </span><br><span class="line">-sql /home/wen/Desktop/flink_stream_sql_conf/sql/Test01.sql </span><br><span class="line">-name TestAll </span><br><span class="line">-localSqlPluginPath /home/wen/IdeaProjects/flinkStreamSQL/plugins </span><br><span class="line">-remoteSqlPluginPath /home/wen/IdeaProjects/flinkStreamSQL/plugins </span><br><span class="line">-flinkconf /home/wen/Desktop/flink_stream_sql_conf/flinkConf </span><br><span class="line">-yarnconf /home/wen/Desktop/flink_stream_sql_conf/yarnConf_node1 </span><br><span class="line">-flinkJarPath /home/wen/Desktop/dtstack/flink-1.8.1/lib </span><br><span class="line">-pluginLoadMode shipfile </span><br><span class="line">-confProp &#123;\"time.characteristic\":\"eventTime\",\"logLevel\":\"info\"&#125; </span><br><span class="line">-queue c</span><br></pre></td></tr></table></figure>



<h2 id="2-4-Flink相比SparkStreaming有什么区别"><a href="#2-4-Flink相比SparkStreaming有什么区别" class="headerlink" title="2.4 Flink相比SparkStreaming有什么区别"></a>2.4 Flink相比SparkStreaming有什么区别</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 架构模型 Spark Streaming 在运行时的主要角色包括：Master、Worker、Driver、Executor Flink 在运行时主要包含：Jobmanager、Taskmanager、 Client 、Slot。</span><br><span class="line"></span><br><span class="line">2.任务调度 Spark Streaming 连续不断的生成微小的数据批次，构建有向无环图 DAG，Spark Streaming 会依次创 建 DStreamGraph、JobGenerator、JobScheduler。 Flink 根据用户提交的代码生成 StreamGraph，经过优化生成 JobGraph，然后提交给 JobManager 进 行处理，JobManager 会根据 JobGraph 生成 ExecutionGraph，ExecutionGraph 是 Flink 调度最核心 的数据结构，JobManager 根据 ExecutionGraph 对 Job 进行调度。 </span><br><span class="line"></span><br><span class="line">3.时间机制 Spark Streaming 支持的时间机制有限，只支持处理时间。 Flink 支持了流处理程序在时间上的三个定义：处理时间、事件时间、注入时间。同时也支持 watermark 机制来处理滞后数据。 </span><br><span class="line"></span><br><span class="line">4. 容错机制 对于 Spark Streaming 任务，我们可以设置 checkpoint，然后假如发生故障并重启，我们可以从上次 checkpoint 之处恢复，但是这个行为只能使得数据不丢失，可能会重复处理，不能做到恰一次处理语 义，如果我们想要实现Exactly-once，需要自己实现。 Flink 内部提供了Exactly-once实现，使用起来较为方便 5. 还可以有其他角度 state，window等等</span><br></pre></td></tr></table></figure>



























<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>4.速度在学科上的应用讲解与课堂阅读书籍训练</title>
    <url>/2021/03/26/%E5%B0%9A%E5%BF%86%E6%95%99%E8%82%B2/%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB/4.%E9%80%9F%E8%AF%BB%E5%9C%A8%E5%AD%A6%E7%A7%91%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8%E8%AE%B2%E8%A7%A3%E4%B8%8E%E8%AF%BE%E5%A0%82%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<h1 id="一、今天内容"><a href="#一、今天内容" class="headerlink" title="一、今天内容"></a>一、今天内容</h1><p><img src="https://i.loli.net/2021/03/26/Zot8v72sV5BqpdK.png" alt="image-20210326064013861"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="二、理论讲解"><a href="#二、理论讲解" class="headerlink" title="二、理论讲解"></a>二、理论讲解</h1><h2 id="2-1-正确对待音读和回看"><a href="#2-1-正确对待音读和回看" class="headerlink" title="2.1 正确对待音读和回看"></a>2.1 正确对待音读和回看</h2><p><img src="https://i.loli.net/2021/03/26/gfYT3b8FdLPx9Hq.png" alt="image-20210326072426203"></p>
<h2 id="2-2-提升能力和专业的书籍"><a href="#2-2-提升能力和专业的书籍" class="headerlink" title="2.2 提升能力和专业的书籍"></a>2.2 提升能力和专业的书籍</h2><p><img src="https://i.loli.net/2021/03/26/ZyMk4FShUesJ5z8.png" alt="image-20210326072830365"></p>
<p><img src="https://i.loli.net/2021/03/26/qSR2f4zjguYOaNZ.png" alt="image-20210326073520652"></p>
<h2 id="2-3-如何区分提升能力书和专业书的重点"><a href="#2-3-如何区分提升能力书和专业书的重点" class="headerlink" title="2.3 如何区分提升能力书和专业书的重点"></a>2.3 如何区分提升能力书和专业书的重点</h2><p>1）章 节大小标题（这些标题就是问题）</p>
<p>2）反复出现的词语</p>
<p>3）粗体字  敏感字  特殊符号   图表等</p>
<h2 id="2-4-使用阅读技巧"><a href="#2-4-使用阅读技巧" class="headerlink" title="2.4 使用阅读技巧"></a>2.4 使用阅读技巧</h2><p>1）明确阅读目标（有目标才有方向）</p>
<p>2）带着问题，带着强烈动机去阅读（学以致用是效果最好的）</p>
<p>3）要想有好的效果，动笔（不动笔不读书）</p>
]]></content>
      <categories>
        <category>尚忆教育</category>
        <category>快速阅读</category>
      </categories>
      <tags>
        <tag>快速阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>3.提升能力书籍讲解和课堂文章能力训练</title>
    <url>/2021/03/24/%E5%B0%9A%E5%BF%86%E6%95%99%E8%82%B2/%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB/3.%E6%8F%90%E5%8D%87%E8%83%BD%E5%8A%9B%E4%B9%A6%E7%B1%8D%E8%AE%B2%E8%A7%A3%E5%92%8C%E8%AF%BE%E5%A0%82%E6%96%87%E7%AB%A0%E8%83%BD%E5%8A%9B%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<h1 id="一、今天内容"><a href="#一、今天内容" class="headerlink" title="一、今天内容"></a>一、今天内容</h1><h2 id="1-1-训练：眼睛热身，短文，一分钟3页文章，回忆训练"><a href="#1-1-训练：眼睛热身，短文，一分钟3页文章，回忆训练" class="headerlink" title="1.1 训练：眼睛热身，短文，一分钟3页文章，回忆训练"></a>1.1 训练：眼睛热身，短文，一分钟3页文章，回忆训练</h2><h2 id="1-2-理论：深化回忆技巧"><a href="#1-2-理论：深化回忆技巧" class="headerlink" title="1.2 理论：深化回忆技巧"></a>1.2 理论：深化回忆技巧</h2><p>总结概括法，标题法</p>
<p>提链子法</p>
<h2 id="1-3-综合素质：内视觉训练-出图能力"><a href="#1-3-综合素质：内视觉训练-出图能力" class="headerlink" title="1.3 综合素质：内视觉训练-出图能力"></a>1.3 综合素质：内视觉训练-出图能力</h2><h2 id="1-4-书籍阅读训练：明朝那些事儿（消遣读物）"><a href="#1-4-书籍阅读训练：明朝那些事儿（消遣读物）" class="headerlink" title="1.4 书籍阅读训练：明朝那些事儿（消遣读物）"></a>1.4 书籍阅读训练：明朝那些事儿（消遣读物）</h2>]]></content>
      <categories>
        <category>尚忆教育</category>
        <category>快速阅读</category>
      </categories>
      <tags>
        <tag>快速阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>5.速读在学科上的应用讲解与课堂阅读书籍训练</title>
    <url>/2021/03/23/%E5%B0%9A%E5%BF%86%E6%95%99%E8%82%B2/%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB/5.%E9%80%9F%E8%AF%BB%E5%9C%A8%E5%AD%A6%E7%A7%91%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8%E8%AE%B2%E8%A7%A3%E4%B8%8E%E8%AF%BE%E5%A0%82%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<h1 id="一、今天内容"><a href="#一、今天内容" class="headerlink" title="一、今天内容"></a>一、今天内容</h1><h1 id="二、理论讲解"><a href="#二、理论讲解" class="headerlink" title="二、理论讲解"></a>二、理论讲解</h1>]]></content>
      <categories>
        <category>尚忆教育</category>
        <category>快速阅读</category>
      </categories>
      <tags>
        <tag>快速阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>1.速度基本原理讲解与基础训练</title>
    <url>/2021/03/22/%E5%B0%9A%E5%BF%86%E6%95%99%E8%82%B2/%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB/2.%E9%80%9F%E5%BA%A6%E6%A0%B8%E5%BF%83%E8%AE%AD%E7%BB%83%E8%AE%B2%E8%A7%A3%E4%B8%8E%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<h1 id="1-训练营收获"><a href="#1-训练营收获" class="headerlink" title="1.训练营收获"></a>1.训练营收获</h1><p>1）阅读能力提升</p>
<p>2）阅读动力提升</p>
<p>3）科学笔记提升</p>
<p>4）注意力提升</p>
<p>5）判断重点总结能力提升</p>
<p>6）右脑图像能力提升</p>
<h1 id="2-今天内容"><a href="#2-今天内容" class="headerlink" title="2.今天内容"></a>2.今天内容</h1><h2 id="2-1-理论：速度简述，训练方法"><a href="#2-1-理论：速度简述，训练方法" class="headerlink" title="2.1 理论：速度简述，训练方法"></a>2.1 理论：速度简述，训练方法</h2><h2 id="2-2-训练：眼睛热身，短文，一分钟2页文章"><a href="#2-2-训练：眼睛热身，短文，一分钟2页文章" class="headerlink" title="2.2 训练：眼睛热身，短文，一分钟2页文章"></a>2.2 训练：眼睛热身，短文，一分钟2页文章</h2><h1 id="3-速度理论讲解"><a href="#3-速度理论讲解" class="headerlink" title="3.速度理论讲解"></a>3.速度理论讲解</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h2><p>速读：快速又有效的阅读</p>
<h2 id="3-2-速读的作用"><a href="#3-2-速读的作用" class="headerlink" title="3.2 速读的作用"></a>3.2 速读的作用</h2><p>快速分离重点和非重点，并初步理解，为下一步加工做准备，缩短学习的时间，阅读是初（粗）加工；笔记，背诵和深度思考是精加工</p>
<h2 id="3-3-阅读慢的原因"><a href="#3-3-阅读慢的原因" class="headerlink" title="3.3 阅读慢的原因"></a>3.3 阅读慢的原因</h2><p>1）视幅窄：一个字一个字看</p>
<p>2）回看：频繁的再看</p>
<p>3）音读：读出声音或默读</p>
<p>4）心理障碍：怕漏信息，怕快了看不懂，求全心理</p>
<h2 id="3-4-训练方法"><a href="#3-4-训练方法" class="headerlink" title="3.4 训练方法"></a>3.4 训练方法</h2><p>1）增加视幅：一次看一个组块，整体，意群，一次多看几个字</p>
<p>2）减少回看：提升速度</p>
<p>3）减少音读：提升速度</p>
<p>4）打破心理障碍：积极的自我暗示，加快速度</p>
<p>重点：速度是组块阅读，在生活中养成组块阅读的习惯</p>
<h1 id="4-训练"><a href="#4-训练" class="headerlink" title="4.训练"></a>4.训练</h1><h2 id="4-1-眼睛热身训练"><a href="#4-1-眼睛热身训练" class="headerlink" title="4.1 眼睛热身训练"></a>4.1 眼睛热身训练</h2><h3 id="1）A图：训练注意力，感知时间"><a href="#1）A图：训练注意力，感知时间" class="headerlink" title="1）A图：训练注意力，感知时间"></a>1）A图：训练注意力，感知时间</h3><p><img src="https://i.loli.net/2021/03/22/ye3ah9DV1FfvOu5.png" alt="image-20210322070017859"></p>
<h3 id="2）B图：眼睛灵活；快速移动，瞬间停顿"><a href="#2）B图：眼睛灵活；快速移动，瞬间停顿" class="headerlink" title="2）B图：眼睛灵活；快速移动，瞬间停顿"></a>2）B图：眼睛灵活；快速移动，瞬间停顿</h3><p><img src="https://i.loli.net/2021/03/22/sJnkBQavbeEFcoL.png" alt="image-20210322070454391"></p>
<h3 id="3）C图"><a href="#3）C图" class="headerlink" title="3）C图"></a>3）C图</h3><p><img src="https://i.loli.net/2021/03/22/rD1soENJHqQO3zZ.png" alt="image-20210322070844922"></p>
<h3 id="4）-D图"><a href="#4）-D图" class="headerlink" title="4） D图"></a>4） D图</h3><p><img src="https://i.loli.net/2021/03/22/gX9GnSolxIEkWtM.png" alt="image-20210322071406583"></p>
<h3 id="5）E图"><a href="#5）E图" class="headerlink" title="5）E图"></a>5）E图</h3><p><img src="https://i.loli.net/2021/03/22/UrfHlGamC7w9ByY.png" alt="image-20210322071432603"></p>
<h2 id="4-2-词组短句闪卡"><a href="#4-2-词组短句闪卡" class="headerlink" title="4.2 词组短句闪卡"></a>4.2 词组短句闪卡</h2><p><img src="https://i.loli.net/2021/03/22/iQUFsApylncxPbB.png" alt="image-20210322072028359"></p>
<h2 id="4-3-短文训练"><a href="#4-3-短文训练" class="headerlink" title="4.3 短文训练"></a>4.3 短文训练</h2><p><img src="https://i.loli.net/2021/03/22/avz7yJbxiZSE6TV.png" alt="image-20210322072635121"></p>
<h2 id="4-4-1分钟2页文章训练"><a href="#4-4-1分钟2页文章训练" class="headerlink" title="4.4 1分钟2页文章训练"></a>4.4 1分钟2页文章训练</h2><p><img src="https://i.loli.net/2021/03/22/28QA3CeUxRtEadB.png" alt="image-20210322073310536"></p>
]]></content>
      <categories>
        <category>尚忆教育</category>
        <category>快速阅读</category>
      </categories>
      <tags>
        <tag>快速阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>1.速度基本原理讲解与基础训练</title>
    <url>/2021/03/22/%E5%B0%9A%E5%BF%86%E6%95%99%E8%82%B2/%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB/1.%E9%80%9F%E5%BA%A6%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3%E4%B8%8E%E8%AE%AD%E7%BB%83%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="1-训练营收获"><a href="#1-训练营收获" class="headerlink" title="1.训练营收获"></a>1.训练营收获</h1><p>1）阅读能力提升</p>
<p>2）阅读动力提升</p>
<p>3）科学笔记提升</p>
<p>4）注意力提升</p>
<p>5）判断重点总结能力提升</p>
<p>6）右脑图像能力提升</p>
<h1 id="2-今天内容"><a href="#2-今天内容" class="headerlink" title="2.今天内容"></a>2.今天内容</h1><h2 id="2-1-理论：速度简述，训练方法"><a href="#2-1-理论：速度简述，训练方法" class="headerlink" title="2.1 理论：速度简述，训练方法"></a>2.1 理论：速度简述，训练方法</h2><h2 id="2-2-训练：眼睛热身，短文，一分钟2页文章"><a href="#2-2-训练：眼睛热身，短文，一分钟2页文章" class="headerlink" title="2.2 训练：眼睛热身，短文，一分钟2页文章"></a>2.2 训练：眼睛热身，短文，一分钟2页文章</h2><h1 id="3-速度理论讲解"><a href="#3-速度理论讲解" class="headerlink" title="3.速度理论讲解"></a>3.速度理论讲解</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h2><p>速读：快速又有效的阅读</p>
<h2 id="3-2-速读的作用"><a href="#3-2-速读的作用" class="headerlink" title="3.2 速读的作用"></a>3.2 速读的作用</h2><p>快速分离重点和非重点，并初步理解，为下一步加工做准备，缩短学习的时间，阅读是初（粗）加工；笔记，背诵和深度思考是精加工</p>
<h2 id="3-3-阅读慢的原因"><a href="#3-3-阅读慢的原因" class="headerlink" title="3.3 阅读慢的原因"></a>3.3 阅读慢的原因</h2><p>1）视幅窄：一个字一个字看</p>
<p>2）回看：频繁的再看</p>
<p>3）音读：读出声音或默读</p>
<p>4）心理障碍：怕漏信息，怕快了看不懂，求全心理</p>
<h2 id="3-4-训练方法"><a href="#3-4-训练方法" class="headerlink" title="3.4 训练方法"></a>3.4 训练方法</h2><p>1）增加视幅：一次看一个组块，整体，意群，一次多看几个字</p>
<p>2）减少回看：提升速度</p>
<p>3）减少音读：提升速度</p>
<p>4）打破心理障碍：积极的自我暗示，加快速度</p>
<p>重点：速度是组块阅读，在生活中养成组块阅读的习惯</p>
<h1 id="4-训练"><a href="#4-训练" class="headerlink" title="4.训练"></a>4.训练</h1><h2 id="4-1-眼睛热身训练"><a href="#4-1-眼睛热身训练" class="headerlink" title="4.1 眼睛热身训练"></a>4.1 眼睛热身训练</h2><h3 id="1）A图：训练注意力，感知时间"><a href="#1）A图：训练注意力，感知时间" class="headerlink" title="1）A图：训练注意力，感知时间"></a>1）A图：训练注意力，感知时间</h3><p><img src="https://i.loli.net/2021/03/22/ye3ah9DV1FfvOu5.png" alt="image-20210322070017859"></p>
<h3 id="2）B图：眼睛灵活；快速移动，瞬间停顿"><a href="#2）B图：眼睛灵活；快速移动，瞬间停顿" class="headerlink" title="2）B图：眼睛灵活；快速移动，瞬间停顿"></a>2）B图：眼睛灵活；快速移动，瞬间停顿</h3><p><img src="https://i.loli.net/2021/03/22/sJnkBQavbeEFcoL.png" alt="image-20210322070454391"></p>
<h3 id="3）C图"><a href="#3）C图" class="headerlink" title="3）C图"></a>3）C图</h3><p><img src="https://i.loli.net/2021/03/22/rD1soENJHqQO3zZ.png" alt="image-20210322070844922"></p>
<h3 id="4）-D图"><a href="#4）-D图" class="headerlink" title="4） D图"></a>4） D图</h3><p><img src="https://i.loli.net/2021/03/22/gX9GnSolxIEkWtM.png" alt="image-20210322071406583"></p>
<h3 id="5）E图"><a href="#5）E图" class="headerlink" title="5）E图"></a>5）E图</h3><p><img src="https://i.loli.net/2021/03/22/UrfHlGamC7w9ByY.png" alt="image-20210322071432603"></p>
<h2 id="4-2-词组短句闪卡"><a href="#4-2-词组短句闪卡" class="headerlink" title="4.2 词组短句闪卡"></a>4.2 词组短句闪卡</h2><p><img src="https://i.loli.net/2021/03/22/iQUFsApylncxPbB.png" alt="image-20210322072028359"></p>
<h2 id="4-3-短文训练"><a href="#4-3-短文训练" class="headerlink" title="4.3 短文训练"></a>4.3 短文训练</h2><p><img src="https://i.loli.net/2021/03/22/avz7yJbxiZSE6TV.png" alt="image-20210322072635121"></p>
<h2 id="4-4-1分钟2页文章训练"><a href="#4-4-1分钟2页文章训练" class="headerlink" title="4.4 1分钟2页文章训练"></a>4.4 1分钟2页文章训练</h2><p><img src="https://i.loli.net/2021/03/22/28QA3CeUxRtEadB.png" alt="image-20210322073310536"></p>
]]></content>
      <categories>
        <category>尚忆教育</category>
        <category>快速阅读</category>
      </categories>
      <tags>
        <tag>快速阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>1.深入浅出flink</title>
    <url>/2021/03/21/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/Flink/1.%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAflink/</url>
    <content><![CDATA[<h1 id="一、第1课课程内容"><a href="#一、第1课课程内容" class="headerlink" title="一、第1课课程内容"></a>一、第1课课程内容</h1><p>Flink课程设计：</p>
<p>基本讲解（5个课时）+ 源码（5个课时） + 项目</p>
<h2 id="1-1-Flink编程模型"><a href="#1-1-Flink编程模型" class="headerlink" title="1.1 Flink编程模型"></a>1.1 Flink编程模型</h2><h2 id="1-2-Flink数据传输方式"><a href="#1-2-Flink数据传输方式" class="headerlink" title="1.2 Flink数据传输方式"></a>1.2 Flink数据传输方式</h2><h2 id="1-3-Flink并行度原理"><a href="#1-3-Flink并行度原理" class="headerlink" title="1.3 Flink并行度原理"></a>1.3 Flink并行度原理</h2><h1 id="二、第2课课程内容"><a href="#二、第2课课程内容" class="headerlink" title="二、第2课课程内容"></a>二、第2课课程内容</h1><h2 id="2-1-API"><a href="#2-1-API" class="headerlink" title="2.1 API"></a>2.1 API</h2><h3 id="2-1-1-source"><a href="#2-1-1-source" class="headerlink" title="2.1.1 source"></a>2.1.1 source</h3><p>1）自带的</p>
<p>readTextFile(path)</p>
<p>socketTextStream</p>
<p>fromCollection</p>
<p>主要的用途都是用于测试</p>
<p>2）扩展的数据源</p>
<p>大多是情况都是使用kafka对应的数据源</p>
<p>3）自定义数据源</p>
<p>implement SourceFunction-&gt;单并行度</p>
<p>implement ParallelSourceFunction-&gt;多并行度</p>
<h3 id="2-1-2-transform"><a href="#2-1-2-transform" class="headerlink" title="2.1.2 transform"></a>2.1.2 transform</h3><h3 id="2-1-3-sink"><a href="#2-1-3-sink" class="headerlink" title="2.1.3 sink"></a>2.1.3 sink</h3><p>重点：kafka redis hbase hdfs</p>
]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>02-kafka源码(2)</title>
    <url>/2021/03/11/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/kafka/%E6%BA%90%E7%A0%81/02-kafka%E6%BA%90%E7%A0%81(2)/</url>
    <content><![CDATA[<h1 id="图解kafka源码（1）"><a href="#图解kafka源码（1）" class="headerlink" title="图解kafka源码（1）"></a>图解kafka源码（1）</h1><h1 id="1-课程内容"><a href="#1-课程内容" class="headerlink" title="1.课程内容"></a>1.课程内容</h1><p>1）Producer初始化流程深度剖析</p>
<p>2）Producer元数据管理</p>
<p>3）Producer核心流程初探</p>
<p>4）分区选择规则源码深度剖析</p>
<p>5）RecordAccumulator消息封装流程深度剖析</p>
<p>6）CopyOnWriteMap数据结构设计与使用</p>
<p>7）把消息写入对应批次流程深度剖析</p>
<p>8）Kafka场景驱动案例讲解</p>
<h1 id="2-如何去看kafka的源码"><a href="#2-如何去看kafka的源码" class="headerlink" title="2.如何去看kafka的源码"></a>2.如何去看kafka的源码</h1><h2 id="2-1-搞懂它的通信的框架-原理"><a href="#2-1-搞懂它的通信的框架-原理" class="headerlink" title="2.1 搞懂它的通信的框架/原理"></a>2.1 搞懂它的通信的框架/原理</h2><p>Hadoop(hadoop RPC)     hbase(hadoop RPC)    spark(Netty)    flink(akka)    Kafka:NIO</p>
<h2 id="2-2-场景驱动"><a href="#2-2-场景驱动" class="headerlink" title="2.2 场景驱动"></a>2.2 场景驱动</h2><p>1）生产者发送数据</p>
<p>2）服务端接收数据</p>
<p>元数据的管理    副本数据的同步    集群的管理</p>
<p>3）消费者消费数据</p>
<h1 id="3-写数据流程"><a href="#3-写数据流程" class="headerlink" title="3.写数据流程"></a>3.写数据流程</h1>]]></content>
      <categories>
        <category>大数据</category>
        <category>Kafka</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>01-图解kafka源码（1）</title>
    <url>/2021/03/09/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/kafka/%E6%BA%90%E7%A0%81/01-kafka%E6%BA%90%E7%A0%81(1)/</url>
    <content><![CDATA[<h1 id="图解kafka源码（1）"><a href="#图解kafka源码（1）" class="headerlink" title="图解kafka源码（1）"></a>图解kafka源码（1）</h1><h1 id="1-课程内容"><a href="#1-课程内容" class="headerlink" title="1.课程内容"></a>1.课程内容</h1><p>1）kafka的特性必知必会</p>
<p>2）揭秘kafka Producer高性能架构设计方案</p>
<p>3）深度剖析kafka服务端高并发，高性能，高可用的架构设计</p>
<p>4）深度剖析kafka提升Consumer的稳定性设计</p>
<h2 id="1-1-kafka的broker节点有controller和follower之分，那controller的作用是什么呢？"><a href="#1-1-kafka的broker节点有controller和follower之分，那controller的作用是什么呢？" class="headerlink" title="1.1 kafka的broker节点有controller和follower之分，那controller的作用是什么呢？"></a>1.1 kafka的broker节点有controller和follower之分，那controller的作用是什么呢？</h2><p>第一个在zookeeper上注册的节点为controller，在zookeeper的目录中会保留kafka的元数据信息（比如topic的元数据信息，副本的元数据信息），controller节点会去去监听这些目录的变化，并将元数据信息同步到本地的内存，而且会把这些元数据信息同步给follower，保证所有的节点都有完成的元数据信息，所以在连接kafka集群的时候，只需要指定一个节点就可以了。</p>
<h2 id="1-2-partition副本leader和follower之分"><a href="#1-2-partition副本leader和follower之分" class="headerlink" title="1.2 partition副本leader和follower之分"></a>1.2 partition副本leader和follower之分</h2><p>只有leader副本才对外提供读写服务</p>
<h1 id="2-kafka高性能架构设计"><a href="#2-kafka高性能架构设计" class="headerlink" title="2.kafka高性能架构设计"></a>2.kafka高性能架构设计</h1><h2 id="2-1-kafka的服务端设计"><a href="#2-1-kafka的服务端设计" class="headerlink" title="2.1 kafka的服务端设计"></a>2.1 kafka的服务端设计</h2><h3 id="2-1-1-服务端是如何处理请求的做到高性能高并发的"><a href="#2-1-1-服务端是如何处理请求的做到高性能高并发的" class="headerlink" title="2.1.1 服务端是如何处理请求的做到高性能高并发的"></a>2.1.1 服务端是如何处理请求的做到高性能高并发的</h3><p><img src="https://i.loli.net/2021/03/10/n8cxAfgWH9C2Gdt.png" alt="image-20210310090343351"></p>
<h3 id="2-1-2-顺序读写-高性能"><a href="#2-1-2-顺序读写-高性能" class="headerlink" title="2.1.2 顺序读写-高性能"></a>2.1.2 顺序读写-高性能</h3><p><img src="https://i.loli.net/2021/03/10/zbAYZmeoia47hBG.png" alt="image-20210310090600073"></p>
<h3 id="2-1-3-跳表设计"><a href="#2-1-3-跳表设计" class="headerlink" title="2.1.3 跳表设计"></a>2.1.3 跳表设计</h3><p>通过跳表的设计，可以快速的检索到读取的offset对应在哪个log文件中</p>
<p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210310090658633.png" alt="image-20210310090658633"></p>
<p><img src="https://i.loli.net/2021/03/10/EKBIbvfWoNm9zwr.png" alt="image-20210310090754705"></p>
<h3 id="2-1-4-稀疏索引"><a href="#2-1-4-稀疏索引" class="headerlink" title="2.1.4 稀疏索引"></a>2.1.4 稀疏索引</h3><p><img src="https://i.loli.net/2021/03/10/yGmYbr6ikdM8x9B.png" alt="image-20210310094808512"></p>
<h3 id="2-1-5-零拷贝"><a href="#2-1-5-零拷贝" class="headerlink" title="2.1.5 零拷贝"></a>2.1.5 零拷贝</h3><p><img src="https://i.loli.net/2021/03/10/EQN7Or8eKH6mBw4.png" alt="image-20210310094830859"></p>
<p><img src="https://i.loli.net/2021/03/10/h31nXTxB5JPVfwR.png" alt="image-20210310095004155"></p>
<h3 id="2-1-6-服务端设计总结"><a href="#2-1-6-服务端设计总结" class="headerlink" title="2.1.6 服务端设计总结"></a>2.1.6 服务端设计总结</h3><p>1）高并发，高性能的设计</p>
<p>2）顺序读写</p>
<p>3）跳表设计  稀疏索引  零拷贝</p>
<h2 id="2-2-Producer端设计"><a href="#2-2-Producer端设计" class="headerlink" title="2.2 Producer端设计"></a>2.2 Producer端设计</h2><h3 id="2-2-1-producer端设计-批处理"><a href="#2-2-1-producer端设计-批处理" class="headerlink" title="2.2.1 producer端设计-批处理"></a>2.2.1 producer端设计-批处理</h3><p><img src="https://i.loli.net/2021/03/10/geXGDs8dZOFJTSt.png" alt="image-20210310091356757"></p>
<p>生产者生产的数据不是生产一条就建立一个连接就发送给kafka服务端的，而是按批次，达到一定的数据量才发送，所以超过一定的时间没到达指定的数据量也会发送，这样可以更高效地利用网络资源</p>
<h3 id="2-2-2-producer设计-内存池设计"><a href="#2-2-2-producer设计-内存池设计" class="headerlink" title="2.2.2 producer设计-内存池设计"></a>2.2.2 producer设计-内存池设计</h3><p><img src="https://i.loli.net/2021/03/10/bKQEsvGPY72Rj4T.png" alt="image-20210310091617305"></p>
<p>每一个批次的数据都需要向JVM申请内存，每当数据发送给服务端这个事完成了，那么当前这个任务申请的内存就需要被回收，这样会引发Full GC，造成STW，只有jvm的垃圾回收线程在工作，任务线程没法工作。所以kafka参考线程池的设计，设计了一个内存池，把申请的内存放到内存池中，不用了也不直接回收，而是放回内存池中，这样就可以避免full gc引发的问题</p>
<h3 id="2-2-3-producer设计-封装同一服务器的请求"><a href="#2-2-3-producer设计-封装同一服务器的请求" class="headerlink" title="2.2.3 producer设计-封装同一服务器的请求"></a>2.2.3 producer设计-封装同一服务器的请求</h3><p>在producer将数据发送给topic的leader partition的实时，producer会把发送同一个服务器的请求进行封装，这样就可以较少建立的连接数提升性能</p>
<h3 id="2-2-4-producer设计-总结"><a href="#2-2-4-producer设计-总结" class="headerlink" title="2.2.4 producer设计-总结"></a>2.2.4 producer设计-总结</h3><p>1）批处理</p>
<p>2）内存池设计</p>
<p>3）封装同一服务器的请求</p>
<h2 id="2-3-Consumer端设计"><a href="#2-3-Consumer端设计" class="headerlink" title="2.3 Consumer端设计"></a>2.3 Consumer端设计</h2><h3 id="2-3-1-kafka的Consumer-Group设计"><a href="#2-3-1-kafka的Consumer-Group设计" class="headerlink" title="2.3.1 kafka的Consumer Group设计"></a>2.3.1 kafka的Consumer Group设计</h3><p>P2P模型：也称点对点模型，指同一条消息只能被一个消费者消费，也就是说一个消息如果被这个消费者 消费了，其余的消费者就都不能消费了，传统的消息系统用的就是这种方式。</p>
<p> 发布订阅模型：允许消息被多个Consume r消费，但是一个Consumer需要订阅主题的所有分区</p>
<p>kafka是消费者组内是p2p模型，消费者组和消费者组之间使用了发布订阅模型</p>
<p><img src="https://i.loli.net/2021/03/10/T6wmoCOBb9Qiv1n.png" alt="image-20210310092429439"></p>
<h3 id="2-3-2-consumer设计-偏移量存储"><a href="#2-3-2-consumer设计-偏移量存储" class="headerlink" title="2.3.2 consumer设计-偏移量存储"></a>2.3.2 consumer设计-偏移量存储</h3><p><img src="https://i.loli.net/2021/03/10/jrSdQU6XbcP4Mzl.png" alt="image-20210310092524053"></p>
<p><img src="https://i.loli.net/2021/03/10/jrSdQU6XbcP4Mzl.png" alt="image-20210310092535899"></p>
<h3 id="2-3-3-consumer总结"><a href="#2-3-3-consumer总结" class="headerlink" title="2.3.3 consumer总结"></a>2.3.3 consumer总结</h3><p>1）kafka consumer group的设计</p>
<p>2）偏移量存储的改造</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Kafka</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>1.flink实时数仓</title>
    <url>/2021/03/03/%E5%B0%9A%E7%A1%85%E8%B0%B7/flink/%E9%A1%B9%E7%9B%AE/1.flink%E5%AE%9E%E6%97%B6%E6%95%B0%E4%BB%93day01/</url>
    <content><![CDATA[<h1 id="Flink实时数仓"><a href="#Flink实时数仓" class="headerlink" title="Flink实时数仓"></a>Flink实时数仓</h1><h1 id="1-实时数仓课程基本介绍"><a href="#1-实时数仓课程基本介绍" class="headerlink" title="1.实时数仓课程基本介绍"></a>1.实时数仓课程基本介绍</h1><h2 id="1-1-普通实时计算和实时数仓的区别"><a href="#1-1-普通实时计算和实时数仓的区别" class="headerlink" title="1.1 普通实时计算和实时数仓的区别"></a>1.1 普通实时计算和实时数仓的区别</h2><p>实时数仓相比于普通的实时计算的优点是可以对中间的结果进行复用，节约计算成本</p>
<h2 id="1-2-实时数仓的项目分层"><a href="#1-2-实时数仓的项目分层" class="headerlink" title="1.2 实时数仓的项目分层"></a>1.2 实时数仓的项目分层</h2><p>1）ODS</p>
<p>原始数据：日志数据和业务数据</p>
<p>2）DWD</p>
<p>对原始数据进行简单的处理，根据数据对象为单位分流，比如订单，页面访问等等</p>
<p>3）DIM</p>
<p>维度数据</p>
<p>4）DWM</p>
<p>中间层，对于部分数据对象进一步加工，比如独立访问，跳出行为，也可以和维度进行关联，形成宽表，依旧是明细数据</p>
<p>5）DWS</p>
<p>根据某个主题对象将多个事实数据轻度聚合，形成主题宽表</p>
<p>6）ADS</p>
<p>把ClickHouse中的数据根据可视化需要进行筛选聚合</p>
<h1 id="2-统计架构分析"><a href="#2-统计架构分析" class="headerlink" title="2.统计架构分析"></a>2.统计架构分析</h1><h2 id="2-1-离线架构"><a href="#2-1-离线架构" class="headerlink" title="2.1 离线架构"></a>2.1 离线架构</h2><p><img src="https://i.loli.net/2021/03/04/sbBZydI5WAiE867.png" alt="image-20210304115846698"></p>
<h2 id="2-2-实时架构"><a href="#2-2-实时架构" class="headerlink" title="2.2 实时架构"></a>2.2 实时架构</h2><p><img src="https://i.loli.net/2021/03/03/oku1NysfSWdLTE8.png" alt="image-20210303233626888"></p>
<h1 id="3-数据采集"><a href="#3-数据采集" class="headerlink" title="3.数据采集"></a>3.数据采集</h1><h2 id="3-1-日志采集到kafka"><a href="#3-1-日志采集到kafka" class="headerlink" title="3.1 日志采集到kafka"></a>3.1 日志采集到kafka</h2><p>基本流程：</p>
<p>生成日志模拟jar包 —-发送数据到—》nginx  —通过配置负载均衡–》hadoop102,hadoop103,hadoop104的日志处理服务 ——》日志落盘，日志发送到kafka</p>
<p>1）先通过logger.sh脚本启动hadoop102的nginx和hadoop102,hadoop103,hadoop104的日志处理服务</p>
<p>2）启动模拟生成日志的jar包</p>
<h2 id="3-2-业务数据采集到kafka"><a href="#3-2-业务数据采集到kafka" class="headerlink" title="3.2 业务数据采集到kafka"></a>3.2 业务数据采集到kafka</h2><p>采集流程</p>
<p>Jar模拟生成业务数据  —-》MySQL数据库  —-BinLog—-》Maxwell   —–》Kafka（ods_base_db_m）</p>
<h2 id="3-3-数据采集总结图解"><a href="#3-3-数据采集总结图解" class="headerlink" title="3.3 数据采集总结图解"></a>3.3 数据采集总结图解</h2><p><img src="https://i.loli.net/2021/03/04/v2XHpVGgsbdP9AS.png" alt="image-20210304232235904"></p>
<h1 id="4-DWD层"><a href="#4-DWD层" class="headerlink" title="4.DWD层"></a>4.DWD层</h1><h2 id="4-1-每层的职能"><a href="#4-1-每层的职能" class="headerlink" title="4.1 每层的职能"></a>4.1 每层的职能</h2><table>
<thead>
<tr>
<th><strong>分层</strong></th>
<th><strong>数据描述</strong></th>
<th><strong>生成计算工具</strong></th>
<th><strong>存储媒介</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>ODS</strong></td>
<td>原始数据，日志和业务数据</td>
<td>日志服务器，maxwell</td>
<td>kafka</td>
</tr>
<tr>
<td><strong>DWD</strong></td>
<td>根据数据对象为单位进行分流，比如订单、页面访问等等。</td>
<td>FLINK</td>
<td>kafka</td>
</tr>
<tr>
<td><strong>DWM</strong></td>
<td>对于部分数据对象进行进一步加工，比如独立访问、跳出行为。依旧是明细数据。</td>
<td>FLINK</td>
<td>kafka</td>
</tr>
<tr>
<td><strong>DIM</strong></td>
<td>维度数据</td>
<td>FLINK</td>
<td>HBase</td>
</tr>
<tr>
<td><strong>DWS</strong></td>
<td>根据某个维度主题将多个事实数据轻度聚合，形成主题宽表。</td>
<td>FLINK</td>
<td>Clickhouse</td>
</tr>
<tr>
<td><strong>ADS</strong></td>
<td>把Clickhouse中的数据根据可视化需要进行筛选聚合。</td>
<td>Clickhouse  SQL</td>
<td>可视化展示</td>
</tr>
</tbody></table>
<h2 id="4-2-DWD层日志数据数据准备实现思路"><a href="#4-2-DWD层日志数据数据准备实现思路" class="headerlink" title="4.2 DWD层日志数据数据准备实现思路"></a>4.2 DWD层日志数据数据准备实现思路</h2><p>1）功能1：环境搭建</p>
<p>2）功能2：计算用户行为日志DWD层</p>
<p>3）功能3：计算业务数据DWD层</p>
<h2 id="4-3-功能1-环境搭建"><a href="#4-3-功能1-环境搭建" class="headerlink" title="4.3 功能1 环境搭建"></a>4.3 功能1 环境搭建</h2><p>创建module gmall0820-realtime</p>
<h2 id="4-4-功能2-准备用户行为日志DWD层"><a href="#4-4-功能2-准备用户行为日志DWD层" class="headerlink" title="4.4 功能2 准备用户行为日志DWD层"></a>4.4 功能2 准备用户行为日志DWD层</h2><p>我们前面采集的日志数据已经保存到Kafka中，作为日志数据的ODS层，从kafka的ODS层读取的日志数据分为3类, 页面日志、启动日志和曝光日志。这三类数据虽然都是用户行为数据，但是有着完全不一样的数据结构，所以要拆分处理。将拆分后的不同的日志写回Kafka不同主题中，作为日志DWD层。</p>
<p>页面日志输出到主流,启动日志输出到启动侧输出流,曝光日志输出到曝光侧输出流</p>
<h3 id="4-4-1-主要任务"><a href="#4-4-1-主要任务" class="headerlink" title="4.4.1 主要任务"></a>4.4.1 主要任务</h3><p>1）从kafka的ods层读取日志数据</p>
<p>2）判断新老访客</p>
<p>3）分流</p>
<p>4）将分流后的数据写到DWD</p>
<h2 id="4-5-业务数据DWD层"><a href="#4-5-业务数据DWD层" class="headerlink" title="4.5 业务数据DWD层"></a>4.5 业务数据DWD层</h2><p>业务数据的变化，可以通过Maxwell采集到，但是Maxwell是把全部数据统一写入一个Topic中，这些数据包括业务数据，也包括维度数据，这样显然不利于日后的数据处理，所以这个功能是从kafka的业务数据ODS层读取数据，经过处理后，将维度数据保存到HBase，将事实数据写回kafka作为业务数据的DWD层。</p>
<h3 id="4-5-1-主要任务"><a href="#4-5-1-主要任务" class="headerlink" title="4.5.1 主要任务"></a>4.5.1 主要任务</h3><p>1）从kafka的ods层读取业务数据，并且对数据进行etl，过滤空数据和非法数据</p>
<p>2）实现动态分流：维度数据写入hbase，事实数据写回到kafka</p>
<p>那如何得知哪些表是维度表，哪些表是事实表呢  ？</p>
<p>可以将维度表和事实表做一个集中的配置，但是这个配置不适合写在配置文件中，因为业务端随着需求变化每增加一张表，就要修改配置重启计算程序。所以这里需要一种动态配置方案，把这种配置长期保存起来，一旦配置有变化，实时计算可以自知感知。一种是用zookeeper存储，通过watch感知数据变化，另一种是用mysql数据库存储，周期性的同步。这里选择第二种方案，主要是mysql对于配置数据初始化和维护管理，用SQL都比较方便，虽然周期性操作时效性差一点，但是配置变化并不频繁。</p>
<p><img src="https://i.loli.net/2021/03/06/npws2NTofl84AbM.png" alt="image-20210306221630619"></p>
<p>  业务场景流程分析：</p>
<p>实际业务发生了一个事件</p>
<p>1）向数据库的品牌表中添加了一个新的品牌</p>
<p>2）相当于向base_trademark表中添加了一条记录</p>
<p>3）这个时候binlog会将添加的这条记录保存下来</p>
<p>4）Maxwell会监听binlog的变化，将发生变化的这条记录json的形式发给kafka（ods_base_db_m）</p>
<p>5）BaseDBApp从kafka的ods_base_db_m读取这条记录</p>
<p>​    -从MySQL的配置表中（table_process）读取配置信息</p>
<p>​    -维度数据：保存到HBase</p>
<p>​    -事实数据：保存到kafka的DWD层</p>
<h3 id="4-5-2-接收kafka数据，过滤空值数据"><a href="#4-5-2-接收kafka数据，过滤空值数据" class="headerlink" title="4.5.2 接收kafka数据，过滤空值数据"></a>4.5.2 接收kafka数据，过滤空值数据</h3><h3 id="4-5-3-根据mysql的配置表，动态进行分流"><a href="#4-5-3-根据mysql的配置表，动态进行分流" class="headerlink" title="4.5.3 根据mysql的配置表，动态进行分流"></a>4.5.3 根据mysql的配置表，动态进行分流</h3><p>1）程序流程分析</p>
<p><img src="https://i.loli.net/2021/03/07/YUOEQZplcIXfsKF.png" alt="image-20210307224708535"></p>
<p><strong>TableProcessFunction是一个自定义算子,主要包括三条时间线任务</strong></p>
<p>Ø 图中紫线，这个时间线与数据流入无关，只要任务启动就会执行。主要的任务方法是open()这个方法在任务启动时就会执行。他的主要工作就是初始化一些连接，开启周期调度。</p>
<p>Ø 图中绿线，这个时间线也与数据流入无关，只要周期调度启动，会自动周期性执行。主要的任务是同步配置表（tableProcessMap）。通过在open()方法中加入timer实现。同时还有个附带任务就是如果发现不存在数据表，要根据配置自动创建数据库表。</p>
<p>Ø 图中黑线，这个时间线就是随着数据的流入持续发生，这部分的任务就是根据同步到内存的tableProcessMap，来为流入的数据进行标识，同时清理掉没用的字段。</p>
<h1 id="5-DWM层"><a href="#5-DWM层" class="headerlink" title="5.DWM层"></a>5.DWM层</h1><h2 id="5-1-访客uv计算"><a href="#5-1-访客uv计算" class="headerlink" title="5.1 访客uv计算"></a>5.1 访客uv计算</h2><h3 id="5-1-1-需求分析和思路"><a href="#5-1-1-需求分析和思路" class="headerlink" title="5.1.1 需求分析和思路"></a>5.1.1 需求分析和思路</h3><h2 id="5-2-跳出明细计算"><a href="#5-2-跳出明细计算" class="headerlink" title="5.2 跳出明细计算"></a>5.2 跳出明细计算</h2><h3 id="5-2-1-需求分析和思路"><a href="#5-2-1-需求分析和思路" class="headerlink" title="5.2.1 需求分析和思路"></a>5.2.1 需求分析和思路</h3><h4 id="5-2-1-1-什么是跳出"><a href="#5-2-1-1-什么是跳出" class="headerlink" title="5.2.1.1 什么是跳出"></a>5.2.1.1 什么是跳出</h4><p>跳出就是用户成功访问了网站的一个页面后就退出，不在继续访问网站的其它页面。而跳出率就是用跳出次数除以访问次数。</p>
<p>关注跳出率，可以看出引流过来的访客是否能很快的被吸引，渠道引流过来的用户之间的质量对比，对于应用优化前后跳出率的对比也能看出优化改进的成果。</p>
<h4 id="5-2-1-2-思路"><a href="#5-2-1-2-思路" class="headerlink" title="5.2.1.2 思路"></a>5.2.1.2 思路</h4><p>1）从kafka的dwd_page_log读取数据</p>
<p>2）根据CEP过滤得到跳出行为</p>
<p>3）写回kafka的DWM层</p>
<h2 id="5-3-订单宽表"><a href="#5-3-订单宽表" class="headerlink" title="5.3 订单宽表"></a>5.3 订单宽表</h2><h3 id="5-3-1-需求分析"><a href="#5-3-1-需求分析" class="headerlink" title="5.3.1 需求分析"></a>5.3.1 需求分析</h3><p>订单是统计分析的重要的对象，围绕订单有很多的维度统计需求，比如用户、地区、商品、品类、品牌等等。</p>
<p>为了之后统计计算更加方便，减少大表之间的关联，所以在实时计算过程中将围绕订单的相关数据整合成为一张订单的宽表。</p>
<p><img src="https://i.loli.net/2021/03/11/ckjLIuiXfzArGs9.png" alt="image-20210311174713368"></p>
<p>如上图，由于在之前的操作我们已经把数据分拆成了事实数据和维度数据，事实数据（绿色）进入kafka数据流（DWD层）中，维度数据（蓝色）进入hbase中长期保存。那么我们在DWM层中要把实时和维度数据进行整合关联在一起，形成宽表。那么这里就要处理有两种关联，事实数据和事实数据关联、事实数据和维度数据关联。</p>
<p>Ø 事实数据和事实数据关联，其实就是流与流之间的关联。</p>
<p>Ø 事实数据与维度数据关联，其实就是流计算中查询外部数据源。</p>
<h3 id="5-3-2-思路"><a href="#5-3-2-思路" class="headerlink" title="5.3.2 思路"></a>5.3.2 思路</h3><p>1）从kafka的dwd_order_info\dwd_order_detail消费数据</p>
<p>2）双流join</p>
<p>3）维度关联</p>
<p>4）写回到kafka</p>
<h1 id="6-DWS层"><a href="#6-DWS层" class="headerlink" title="6.DWS层"></a>6.DWS层</h1><h2 id="6-1-访客主题宽表计算"><a href="#6-1-访客主题宽表计算" class="headerlink" title="6.1 访客主题宽表计算"></a>6.1 访客主题宽表计算</h2><h2 id="6-2-商品主题宽表计算"><a href="#6-2-商品主题宽表计算" class="headerlink" title="6.2 商品主题宽表计算"></a>6.2 商品主题宽表计算</h2><h2 id="6-3-地区主题表计算"><a href="#6-3-地区主题表计算" class="headerlink" title="6.3 地区主题表计算"></a>6.3 地区主题表计算</h2><h2 id="6-4-关键词主题表"><a href="#6-4-关键词主题表" class="headerlink" title="6.4 关键词主题表"></a>6.4 关键词主题表</h2><p>涉及使用Ik分词器</p>
<p>1）思路：</p>
<p>封装一个工具类，对字符串进行分词</p>
<p>FlinkSQL</p>
<pre><code>- 创建动态表dwd_page_log -》从表中查询数据   
- select 自定义函数(searchedWord) from 动态表
- 将表转换为流
- 保存到clickhouse</code></pre><h1 id="7-Flink环境打包部署"><a href="#7-Flink环境打包部署" class="headerlink" title="7.Flink环境打包部署"></a>7.Flink环境打包部署</h1><p>​    </p>
]]></content>
      <categories>
        <category>Flink</category>
        <category>项目</category>
        <category>电商项目</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>02-企业级Hadoop源码二次开发3</title>
    <url>/2021/02/26/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/Hadoop/03-%E4%BC%81%E4%B8%9A%E7%BA%A7Hadoop%E6%BA%90%E7%A0%81%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%913%20/</url>
    <content><![CDATA[<h1 id="企业级Hadoop源码二次开发3"><a href="#企业级Hadoop源码二次开发3" class="headerlink" title="企业级Hadoop源码二次开发3"></a>企业级Hadoop源码二次开发3</h1><h2 id="1-课前准备"><a href="#1-课前准备" class="headerlink" title="1.课前准备"></a>1.课前准备</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.安装idea</span><br><span class="line">2.下载Hadoop源码</span><br><span class="line">https:&#x2F;&#x2F;archive.apache.org&#x2F;dist&#x2F;hadoop&#x2F;common&#x2F;hadoop-2.7.0&#x2F;hadoop-2.7.0-src.tar.gz</span><br><span class="line">3.将源码导入idea工具</span><br></pre></td></tr></table></figure>



<h2 id="2-课程主题"><a href="#2-课程主题" class="headerlink" title="2.课程主题"></a>2.课程主题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本节课给大家讲解Hadoop RPC原理和HDFS启动流程，为后面二次开发打下基础</span><br></pre></td></tr></table></figure>

<h2 id="3-课程大纲"><a href="#3-课程大纲" class="headerlink" title="3.课程大纲"></a>3.课程大纲</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.HDFS目录树管理</span><br><span class="line">2.HDFS元数据双缓冲方案深度剖析</span><br><span class="line">3.HDFS元数据写JournalNode流程分析</span><br><span class="line">4.StandByNameNode Checkpoint原理深度剖析</span><br><span class="line">5.ActiveNameNode FSimage文件更新流程分析</span><br></pre></td></tr></table></figure>

<h2 id="4-知识要点"><a href="#4-知识要点" class="headerlink" title="4.知识要点"></a>4.知识要点</h2><h3 id="4-1-元数据管理示意图"><a href="#4-1-元数据管理示意图" class="headerlink" title="4.1 元数据管理示意图"></a>4.1 元数据管理示意图</h3><h3 id="4-2-元数据双缓冲机制代码解析"><a href="#4-2-元数据双缓冲机制代码解析" class="headerlink" title="4.2 元数据双缓冲机制代码解析"></a>4.2 元数据双缓冲机制代码解析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>02-企业级Hadoop源码二次开发2</title>
    <url>/2021/02/21/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/Hadoop/02-%E4%BC%81%E4%B8%9A%E7%BA%A7Hadoop%E6%BA%90%E7%A0%81%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%912/</url>
    <content><![CDATA[<h1 id="企业级Hadoop源码二次开发2"><a href="#企业级Hadoop源码二次开发2" class="headerlink" title="企业级Hadoop源码二次开发2"></a>企业级Hadoop源码二次开发2</h1><h2 id="1-课前准备"><a href="#1-课前准备" class="headerlink" title="1.课前准备"></a>1.课前准备</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.安装idea</span><br><span class="line">2.下载Hadoop源码</span><br><span class="line">https:&#x2F;&#x2F;archive.apache.org&#x2F;dist&#x2F;hadoop&#x2F;common&#x2F;hadoop-2.7.0&#x2F;hadoop-2.7.0-src.tar.gz</span><br><span class="line">3.将源码导入idea工具</span><br></pre></td></tr></table></figure>



<h2 id="2-课程主题"><a href="#2-课程主题" class="headerlink" title="2.课程主题"></a>2.课程主题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本节课给大家讲解Hadoop RPC原理和HDFS启动流程，为后面二次开发打下基础</span><br></pre></td></tr></table></figure>

<h2 id="3-课程目标"><a href="#3-课程目标" class="headerlink" title="3.课程目标"></a>3.课程目标</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.掌握Hadoop RPC原理</span><br><span class="line">2.掌握HDFS启动流程</span><br><span class="line">3.掌握阅读源码技巧</span><br></pre></td></tr></table></figure>

<h2 id="4-知识要点"><a href="#4-知识要点" class="headerlink" title="4.知识要点"></a>4.知识要点</h2><h3 id="4-1-项目要点"><a href="#4-1-项目要点" class="headerlink" title="4.1 项目要点"></a>4.1 项目要点</h3><h4 id="4-1-1-项目背景"><a href="#4-1-1-项目背景" class="headerlink" title="4.1.1 项目背景"></a>4.1.1 项目背景</h4><p>公司集群运行一年之多，现在集群为满足公司要求，计划将集群扩为300+节点，在过去一年的集群管理中收集到了一些Hadoop集群的bug和性能改造点，故成立了此项目对当前的Hadoop集群进行性能提升的Bug修复</p>
<h4 id="4-1-2-项目目标"><a href="#4-1-2-项目目标" class="headerlink" title="4.1.2 项目目标"></a>4.1.2 项目目标</h4><p>提升集群性能，并且保证集群稳定</p>
<h4 id="4-1-3-学习本项目的意义"><a href="#4-1-3-学习本项目的意义" class="headerlink" title="4.1.3 学习本项目的意义"></a>4.1.3 学习本项目的意义</h4><p>1）学习Hadoop源码，掌握分布式系统设计的本质的思想</p>
<p>2）数据存储平台是大数据里面非常重要的一个环节</p>
<p>3）架构师的要求</p>
<h3 id="4-2-项目基础知识"><a href="#4-2-项目基础知识" class="headerlink" title="4.2 项目基础知识"></a>4.2 项目基础知识</h3><h4 id="4-2-1-版本选择"><a href="#4-2-1-版本选择" class="headerlink" title="4.2.1 版本选择"></a>4.2.1 版本选择</h4><p>当前的Hadoop版本已经发展到3.x版本了，但是现在业内大的趋势还是用的Hadoop2.x系列，故我们用的也是2.x源码（hadoop2.7.0）</p>
<h4 id="4-2-2-阅读大数据源码的思路"><a href="#4-2-2-阅读大数据源码的思路" class="headerlink" title="4.2.2 阅读大数据源码的思路"></a>4.2.2 阅读大数据源码的思路</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.掌握其网络通讯架构</span><br><span class="line">	hadoop:</span><br><span class="line">		hadoop RPC</span><br><span class="line">	spark:</span><br><span class="line">		1.5版本之前akka通信框架</span><br><span class="line">		1.6版本之后变成了netty</span><br><span class="line">	Flink:</span><br><span class="line">		akka -&gt; netty</span><br><span class="line">	kafka:</span><br><span class="line">		JDK socket</span><br><span class="line">		</span><br><span class="line">2.场景驱动的方式</span><br><span class="line">	HDFS源码</span><br><span class="line">	集群启动的场景</span><br><span class="line">	写数据的场景</span><br><span class="line">	读数据的场景</span><br><span class="line">	元数据管理的场景</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">3.看源码的时候，要画流程图&#x2F;边写注释</span><br><span class="line">4.看核心类注释</span><br><span class="line">	HDFS</span><br><span class="line">		Namenode</span><br><span class="line">		Datanode</span><br><span class="line">5.连蒙带猜</span><br></pre></td></tr></table></figure>



<h4 id="4-2-3-Hadoop-RCP-了解"><a href="#4-2-3-Hadoop-RCP-了解" class="headerlink" title="4.2.3 Hadoop RCP(了解)"></a>4.2.3 Hadoop RCP(了解)</h4><p>RPC是远程（不同进程）过程（方法的）调用（Remote Procedure Call）缩写模式</p>
<p>不同进程所以是C/S这种模式</p>
<p>Client</p>
<p>Server</p>
<p>客户端进程调用服务端进程的方法，方法的执行在哪呢？？？</p>
<p>​    方法的执行在服务端</p>
<h4 id="4-2-4-Hadoop-RPC认识总结"><a href="#4-2-4-Hadoop-RPC认识总结" class="headerlink" title="4.2.4 Hadoop RPC认识总结"></a>4.2.4 Hadoop RPC认识总结</h4><p>1)RPC指的是不同进程的调用，分为客户端和服务端，并且是客户端调用服务端的方法，方法的执行在服务端。</p>
<p>2) 如果要想实现Hadoop RPC的调用，需要一个协议，说白了协议就是一个接口，里面要求必须要有versionID字段</p>
<p>3) 服务端必须要实现协议（接口）</p>
<p>4) 凡是JPS能看到的服务,都是RPC的服务端</p>
<p>5) 如何构建一个Hadoop RPC</p>
<p>服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Server server = <span class="keyword">new</span> RPC.Builder(<span class="keyword">new</span> Configuration())</span><br><span class="line">                       .setBindAddress(<span class="string">"localhost"</span>)</span><br><span class="line">    				   .setPort(<span class="number">9999</span>)</span><br><span class="line">                       .setProtocol(ClientProtocol<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    				   .<span class="title">setInstance</span>(<span class="title">new</span> <span class="title">NameNodeRpcServer</span>())</span></span><br><span class="line"><span class="class">    				   .<span class="title">build</span>()</span>;</span><br></pre></td></tr></table></figure>



<p>客户端(代理),有类似如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClientProtocol namenode = RPC.getProxy(ClientProtocol<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">                                      <span class="title">ClientProtocol</span>.<span class="title">versionID</span>,</span></span><br><span class="line">                                      new InetSocketAddress("localhost",9999),</span><br><span class="line">                                      <span class="keyword">new</span> Configuration());</span><br></pre></td></tr></table></figure>

<p>大胆的猜测一下:</p>
<p>猜测namenode的代码时如何写的?</p>
<p>jps   -&gt; namenode  -&gt; rpc server</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> versionID = <span class="number">1L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> versionID = <span class="number">1L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameNode</span> <span class="title">implement</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> RPC.Builder(<span class="keyword">new</span> Configuration())</span><br><span class="line">                       .setBindAddress(<span class="string">"localhost"</span>)</span><br><span class="line">    				   .setPort(<span class="number">9999</span>)</span><br><span class="line">                       .setProtocol(ClientProtocol<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    				   .<span class="title">setInstance</span>(<span class="title">new</span> <span class="title">NameNodeRpcServer</span>())</span></span><br><span class="line"><span class="class">    				   .<span class="title">build</span>()</span>;</span><br><span class="line">        server.start();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="4-3-源码流程讲解"><a href="#4-3-源码流程讲解" class="headerlink" title="4.3 源码流程讲解"></a>4.3 源码流程讲解</h3><p>1.集群的启动场景</p>
<p>​    NameNode的启动场景(RPC服务端,进程,main是不是就可以了)</p>
<p>​    DataNode的启动场景</p>
<p>2.写数据的场景</p>
<p>3.读数据的场景</p>
<p>4.元数据的管理(HA,联邦)</p>
<h2 id="2-Hadoop-RPC"><a href="#2-Hadoop-RPC" class="headerlink" title="2.Hadoop RPC"></a>2.Hadoop RPC</h2><h3 id="2-1-小结"><a href="#2-1-小结" class="headerlink" title="2.1 小结"></a>2.1 小结</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）RPC指的是不同进程的调用，分为客户端和服务端，并且是客户端调用服务端的方法，方法的执行在服务端。</span><br><span class="line">2）如果要想实现hadoop RPC的调用，需要一个协议，说白了协议就是一个接口，里面要求必须要有versionID字段</span><br><span class="line">3）服务端必须要实现协议</span><br><span class="line">4）凡是JPS能看到的服务，都是RPC的服务端</span><br></pre></td></tr></table></figure>

<h3 id="2-2-如何构建Hadoop-RPC"><a href="#2-2-如何构建Hadoop-RPC" class="headerlink" title="2.2 如何构建Hadoop RPC"></a>2.2 如何构建Hadoop RPC</h3><h2 id="3-源码流程"><a href="#3-源码流程" class="headerlink" title="3.源码流程"></a>3.源码流程</h2><p>HDFS源码：通过场景驱动阅读源码</p>
<p>3.1 集群的启动场景</p>
<p>1）NameNode的启动场景（RPC服务端，进程，main方法是不是就可以了）</p>
<p>2）DataNode的启动场景</p>
<p>3.2 写数据的场景</p>
<p>3.3 读数据的场景</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>14.Netty快速入门实例</title>
    <url>/2021/02/20/netty/14.Netty%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="Netty快速入门实例-TCP服务"><a href="#Netty快速入门实例-TCP服务" class="headerlink" title="Netty快速入门实例-TCP服务"></a>Netty快速入门实例-TCP服务</h1><h2 id="1-实例要求"><a href="#1-实例要求" class="headerlink" title="1.实例要求"></a>1.实例要求</h2><p>1）使用IDEA创建Netty项目，Netty服务器再6668端口监听，客户端能发送消息给服务器“hello,服务器”</p>
<p>2）服务器可以回复消息给客户端“hello，客户端”</p>
<p>3）目的：对Netty线程模型有一个初步认识，便于理解Netty模型理论</p>
<h2 id="2-simple版"><a href="#2-simple版" class="headerlink" title="2.simple版"></a>2.simple版</h2><h3 id="2-1-服务端代码"><a href="#2-1-服务端代码" class="headerlink" title="2.1 服务端代码"></a>2.1 服务端代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-2-客户端代码"><a href="#2-2-客户端代码" class="headerlink" title="2.2 客户端代码"></a>2.2 客户端代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>13.Netty模型</title>
    <url>/2021/02/20/netty/13.Netty%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Netty模型"><a href="#Netty模型" class="headerlink" title="Netty模型"></a>Netty模型</h1><h2 id="1-工作原理示意图-简单版"><a href="#1-工作原理示意图-简单版" class="headerlink" title="1.工作原理示意图-简单版"></a>1.工作原理示意图-简单版</h2><p><img src="https://i.loli.net/2021/02/20/iOp7aKNld3zuUv6.png" alt="image-20210220160922547"></p>
<p>说明：</p>
<p>1）BossGroup线程维护selector，只关注accept</p>
<p>2）当接收到accept事件，获取到对应的socketChannel，封装成NIOSocketChannel并注册到work线程（事件循环），并进行维护</p>
<p>3）当worker线程监听到selector中通道发生自己感兴趣的事件后，就进行处理（由handler处理），注意handler已经加入到通道</p>
<h2 id="2-工作原理示意图-详细版"><a href="#2-工作原理示意图-详细版" class="headerlink" title="2.工作原理示意图-详细版"></a>2.工作原理示意图-详细版</h2><p><img src="https://i.loli.net/2021/02/20/AxVTE4MtasDnclR.png" alt="image-20210220162608268"></p>
<p>说明：上面示意图的NIOEventGroup有点问题，需要替换为NioEventLoop</p>
<p>1）Netty抽象出两组线程池BossGroup专门负责接收客户端的连接，WorkerGroup专门负责网络的读写</p>
<p>2）BossGroup和WorkerGroup类型都是NioEventLoopGroup</p>
<p>3）NioEventLoopGroup相当于一个事件循环组，这个组中包含多个事件循环，每一个事件循环是NIOEventLoop</p>
<p>4）NioEventLoop表示一个不断循环的执行处理的线程，每个NioEventLoop都有一个selector，用于监听绑定在其上的socket的网络通讯</p>
<p>5）NioEventLoopGroup可以有多个线程，即可以含有多个NioEventLoop</p>
<p>6）每个Boss NioEventLoop执行的步骤有3步</p>
<p>a.轮询accept事件</p>
<p>b.处理accept事件，与client建立连接，生成NioSocketChannel，并将其注册到某个worker NIOEventLoop上的selector </p>
<p>c.处理任务队列的任务，即runAllTasks</p>
<p>7）每个worker NioEventGroup循环执行的步骤</p>
<p>a.轮询read,write事件</p>
<p>b.处理IO事件，即read，write事件，在NioSocketChannel处理</p>
<p>c.处理任务队列的任务，即runAllTasks</p>
<p>8）每个Worker NioEventLoop处理业务时，会使用pipeline(管道)，pipeline中包含了channel，即通过pipeline可以获取到对应通道，管道中维护了很多的处理器</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>11.Netty介绍</title>
    <url>/2021/02/20/netty/12.netty%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="1-Netty概述"><a href="#1-Netty概述" class="headerlink" title="1.Netty概述"></a>1.Netty概述</h1><h2 id="1-1-原生NIO存在的问题"><a href="#1-1-原生NIO存在的问题" class="headerlink" title="1.1 原生NIO存在的问题"></a>1.1 原生NIO存在的问题</h2><h2 id="1-2-Netty的优点"><a href="#1-2-Netty的优点" class="headerlink" title="1.2 Netty的优点"></a>1.2 Netty的优点</h2><h1 id="2-Netty高性能架构设计"><a href="#2-Netty高性能架构设计" class="headerlink" title="2.Netty高性能架构设计"></a>2.Netty高性能架构设计</h1><h2 id="2-1-线程模型基本介绍"><a href="#2-1-线程模型基本介绍" class="headerlink" title="2.1 线程模型基本介绍"></a>2.1 线程模型基本介绍</h2><p>1）不同的线程模型，对程序的性能有很大的影响，为了搞清Netty线程模式，我们系统的讲解下各个线程模式，最后看看Netty线程模型有什么优越性</p>
<p>2）目前存在的线程模型有：</p>
<p>传统阻塞IO服务模型  Reactor模式</p>
<p>3）根据Reactor的数量和处理资源线程池的数量不同，有3种典型的实现</p>
<p>​    单Reactor单线程；</p>
<p>​    单Reactor多线程；</p>
<p>​    主从Reactor多线程</p>
<p>4）Netty线程模式（Netty主要基于主从Reactor多线程模型做了一定的改进，其中主从Reactor多线程模型有多个Reactor  ）</p>
<h2 id="2-2-传统阻塞IO服务模型分析"><a href="#2-2-传统阻塞IO服务模型分析" class="headerlink" title="2.2 传统阻塞IO服务模型分析"></a>2.2 传统阻塞IO服务模型分析</h2><h3 id="2-2-1-工作原理图"><a href="#2-2-1-工作原理图" class="headerlink" title="2.2.1 工作原理图"></a>2.2.1 工作原理图</h3><p><img src="https://i.loli.net/2021/02/20/oQnwediTEB8LbuM.png" alt="image-20210220095410281"></p>
<p>说明：</p>
<p>黄色的框代表对象，蓝色的框代表线程，白色的框表示方法API</p>
<h3 id="2-2-2-模型特点"><a href="#2-2-2-模型特点" class="headerlink" title="2.2.2 模型特点"></a>2.2.2 模型特点</h3><p>1）采用阻塞IO获取客户端输入的数据</p>
<p>2）每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</p>
<h3 id="2-2-3-问题分析"><a href="#2-2-3-问题分析" class="headerlink" title="2.2.3 问题分析"></a>2.2.3 问题分析</h3><p>1）当并发数很大时，就会创建大量的线程，占用大量的系统资源</p>
<p>2）连接创建后，如果当前线程暂时没有数据可读，则该线程会阻塞在read操作上，从而造成线程资源浪费</p>
<h2 id="2-3-Reactor模式"><a href="#2-3-Reactor模式" class="headerlink" title="2.3 Reactor模式"></a>2.3 Reactor模式</h2><h3 id="2-3-1-针对传统阻塞IO服务模型的2个缺点的解决方案"><a href="#2-3-1-针对传统阻塞IO服务模型的2个缺点的解决方案" class="headerlink" title="2.3.1 针对传统阻塞IO服务模型的2个缺点的解决方案"></a>2.3.1 针对传统阻塞IO服务模型的2个缺点的解决方案</h3><p>1）基于IO复用模型多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无须阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理</p>
<p>Reactor对应的叫法：1.反应器模式 2.分发者模式（Dispatcher） 3.通知者模式（notifier）</p>
<p>2）基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程处理，一个线程可以处理多个连接的业务</p>
<p> 简略示意图如下</p>
<p><img src="https://i.loli.net/2021/02/20/A2ZCXl18pWzcxd6.png" alt="image-20210220102921335"></p>
<h3 id="2-3-2-Reactor模式基本设计思想"><a href="#2-3-2-Reactor模式基本设计思想" class="headerlink" title="2.3.2 Reactor模式基本设计思想"></a>2.3.2 Reactor模式基本设计思想</h3><p><img src="https://i.loli.net/2021/02/20/eJzClOH2Ev5h1LD.png" alt="image-20210220103225659"></p>
<p>说明如下：</p>
<p>1）Reactor模式，通过一个或多个输入同时传递给服务处理器的模式（基于事件驱动）</p>
<p>2）服务器端程序处理传入的多个请求，并将它们同步分派到相应的处理线程，因此Reactor模式也叫Dispatcher模式</p>
<p>3）Reactor模式使用IO复用监听事件，收到事件后，分发给某个线程（进程），这点就是网络服务器高并发处理关键</p>
<h3 id="2-3-3-Reactor模式中核心组成"><a href="#2-3-3-Reactor模式中核心组成" class="headerlink" title="2.3.3 Reactor模式中核心组成"></a>2.3.3 Reactor模式中核心组成</h3><p>1）Reactor：Reactor在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件作出反应。它就像是公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人</p>
<p>2）Handlers：处理程序执行IO事件要完成的实际事件，类似于客户想要与之交谈的公司的实际官员。Reactor通过调度适当的处理程序来响应IO事件，处理程序执行非阻塞操作。</p>
<h3 id="2-3-4-Reactor模式分类"><a href="#2-3-4-Reactor模式分类" class="headerlink" title="2.3.4 Reactor模式分类"></a>2.3.4 Reactor模式分类</h3><p>根据Reactor的数量和处理资源池线程的数量不同，有3种典型的实现</p>
<p>1）单Reactor单线程</p>
<p>2）单Reactor多线程</p>
<p>3）主从Reactor多线程（Netty就是基于这种模式上改进的）</p>
<h4 id="2-3-4-1-单Reactor单线程"><a href="#2-3-4-1-单Reactor单线程" class="headerlink" title="2.3.4.1 单Reactor单线程"></a>2.3.4.1 单Reactor单线程</h4><p>类似之前NIO群聊系统，示意图如下</p>
<p><img src="https://i.loli.net/2021/02/20/sa2wyAVBMD4U1Oq.png" alt="image-20210220110935095"></p>
<p>之前NIO群聊系统中的selector就相当于Reactor，对于监听的不同的事件类型（accept，read…）做不同的处理，同样可以在NIO群聊中将sendData和readData封装在一个Handler中 </p>
<p>方案说明：</p>
<p>1）select是前面IO复用模型介绍的标准网络编程API，可以实现应用程序通过一个阻塞对象监听多路连接请求</p>
<p>2）Reactor对象通过select监控客户端请求事件，收到事件后通过Dispatch进行分发</p>
<p>3）如果是建立连接请求事件，则由Acceptor通过accept处理连接请求，然后创建一个Handler对象处理连接完成后的后续业务处理</p>
<p>4）如果不是建立连接事件，则Reactor会分发调用连接对应的Handler来响应</p>
<p>5）Handler会完成Read-》业务处理-》Send的完成业务流程</p>
<p>结合实例：服务器端用一个线程通过多路复用搞定所有的IO操作（包括连接，读，写等），编码简单，清晰明了，但是如果客户端连接数较多，将无法支撑，前面的NIO案例就属于这种模型</p>
<p>优缺点分析：</p>
<p>1）优点：模型简单，没有多线程，进程通信，竞争的问题，全部都在一个线程中完成</p>
<p>2）缺点：性能问题，只有一个线程，无法完全发挥多个CPU的性能。Handler在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈；可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</p>
<p>3）使用场景：客户端的连接数有限，业务处理非常快速，比如Redis在业务处理的时间复杂度O(1)的情况</p>
<h4 id="2-3-4-2-单Reactor多线程"><a href="#2-3-4-2-单Reactor多线程" class="headerlink" title="2.3.4.2 单Reactor多线程"></a>2.3.4.2 单Reactor多线程</h4><p><img src="https://i.loli.net/2021/02/20/IbXMJuSPDkyU5Lx.png" alt="image-20210220113306538"></p>
<p>方案说明：</p>
<p>1）Reactor对象通过select监控客户端请求事件，收到事件后，通过Dispatch进行分发</p>
<p>2）如果建立连接请求，则由Acceptor通过accept处理连接请求，然后创建一个Handler对象处理完成连接后的各种事件</p>
<p>3）如果不是连接请求，则由Reactor对象分发调用连接对应的handler来处理</p>
<p>4）handle只负责响应事件，不做具体的业务处理，通过read读取数据后，会分发给后面的worker线程池的某个线程处理</p>
<p>5）worker线程池会分配独立的线程完成真正的业务，并将处理后的结果返回给handler</p>
<p>6）handler收到响应后，通过send将结果返回给client</p>
<p>方案优缺点分析：</p>
<p>1）优点：可以充分的利用多核CPU的处理能力</p>
<p>2）缺点：多线程数据共享和访问比较复杂，reactor处理所有的事件的监听和响应，在单线程运行，在高并发场景容易出现性能瓶颈</p>
<h4 id="2-3-4-3-主从Reactor多线程"><a href="#2-3-4-3-主从Reactor多线程" class="headerlink" title="2.3.4.3 主从Reactor多线程"></a>2.3.4.3 主从Reactor多线程</h4><p> 工作原理示意图</p>
<p><img src="https://i.loli.net/2021/02/20/LG1cuehjv8EnlYt.png" alt="image-20210220114311342"></p>
<p>方案说明：</p>
<p>1）Reactor主线程MainReactor对象通过select监听连接事件，收到事件后，通过Acceptor处理连接事件</p>
<p>2）当Acceptor处理连接事件后，MainReactor将连接分配给SubReactor</p>
<p>3）SubReactor将连接加入到连接队列进行监听，并同时创建Handler进行各种事件处理</p>
<p>4）当有新的事件发生时，SubReactor就会调用对应的handler进行处理</p>
<p>5）handler通过read读取数据，分发给后面的worker线程池进行处理，</p>
<p>6）worker线程池会分配独立的work线程进行业务处理，并返回结果</p>
<p>7）handler收到响应的结果后，再通过send将结果返回给client</p>
<p>8）Reactor主线程可以对应多个Reactor子线程，即MainReactor可以关联多个SubReactor</p>
<p>方案优缺点说明：</p>
<p>1）优点：父线程与子线程地方数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理</p>
<p>2）优点：父线程和子线程的数据交互简单，Reactor主线程只需要把新连接传给子线程，子线程无须返回数据</p>
<p>3）缺点：编程复杂度较高</p>
<p>结合实例：这种模型在许多项目中广泛使用，包括Nginx主从Reactor多进程模型，Memcached主从多线程，Netty主从多线程模型的支持</p>
<h3 id="2-3-5-Reactor模式小结"><a href="#2-3-5-Reactor模式小结" class="headerlink" title="2.3.5 Reactor模式小结"></a>2.3.5 Reactor模式小结</h3><p>3种模式生活案例来理解</p>
<p>1）单Reactor单线程  前台接待员和服务员是同一个人，全程为顾客服务</p>
<p>2）单Reactor多线程 1个前台接待员，多个服务员，接待员只负责接待</p>
<p>3）多Reactor多线程 多个前台接待员，多个服务生</p>
<p>Reactor模式具有如下的优点：</p>
<p>1）响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的</p>
<p>2）可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销</p>
<p>3）扩展性好，可以方便的通过增加Reactor实例个数来充分利用CPU资源</p>
<p>4）复用性好，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>11.零拷贝AIO内容梳理</title>
    <url>/2021/02/19/netty/11.AIO%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="零拷贝AIO内容梳理"><a href="#零拷贝AIO内容梳理" class="headerlink" title="零拷贝AIO内容梳理"></a>零拷贝AIO内容梳理</h1><h2 id="1-Java-AIO基本介绍"><a href="#1-Java-AIO基本介绍" class="headerlink" title="1.Java AIO基本介绍"></a>1.Java AIO基本介绍</h2><p>1）JDK引入了Asynchronous I/O,即AIO。在进行IO编程中，常用到两周模式：Reactor和Proactor。Java的NIO就是Reactor，当有事件触发时，服务器端得到通知，进行相应的处理</p>
<p>2）AIO即NIO2.0，叫做异步不阻塞的IO。AIO引入异步通道的概念，采用了Proactor模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</p>
<p>3）目前AIO还没有广泛应用，Netty也是基于NIO，而不是AIO。</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>10.NIO之零拷贝原理解析</title>
    <url>/2021/02/19/netty/10.NIO%E4%B9%8B%E9%9B%B6%E6%8B%B7%E8%B4%9D%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="NIO之零拷贝原理解析"><a href="#NIO之零拷贝原理解析" class="headerlink" title="NIO之零拷贝原理解析"></a>NIO之零拷贝原理解析</h1><h2 id="1-零拷贝基本介绍"><a href="#1-零拷贝基本介绍" class="headerlink" title="1.零拷贝基本介绍"></a>1.零拷贝基本介绍</h2><p>1）零拷贝是网络编程的关键，很多性能优化都离不开</p>
<p>2）在Java程序中，常用的零拷贝有mmap(内存映射)和sendFile。那么，他们在OS里，到底是怎么样的一个设计？我们分析mmap和sendFile这两个零拷贝</p>
<p>3）另外我们看下NIO中如何使用零拷贝</p>
<h2 id="2-传统IO数据读写以及利用零拷贝技术的优化"><a href="#2-传统IO数据读写以及利用零拷贝技术的优化" class="headerlink" title="2.传统IO数据读写以及利用零拷贝技术的优化"></a>2.传统IO数据读写以及利用零拷贝技术的优化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"test.txt"</span>);</span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"rw"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) file.length()];</span><br><span class="line"></span><br><span class="line">raf.read(arr);</span><br><span class="line"></span><br><span class="line">Socket socket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>).accept();</span><br><span class="line">socket.getOutputStream().write(arr);</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/02/19/UTQ8KCHij2d9uLE.png" alt="image-20210219191033358"></p>
<p>传统的一次IO读写需要经过4次拷贝，3次空间的切换，代价非常高。</p>
<h3 id="2-1-mmap优化"><a href="#2-1-mmap优化" class="headerlink" title="2.1 mmap优化"></a>2.1 mmap优化</h3><p>1）mmap通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。如下图</p>
<p>2）mmap示意图</p>
<p> <img src="https://i.loli.net/2021/02/19/txQhAjDoRG965Ss.png" alt="image-20210219191653379"></p>
<p>mmap优化减少了数据拷贝次数，但是空间的切换次数依旧没有减少</p>
<h3 id="2-2-sendFile优化"><a href="#2-2-sendFile优化" class="headerlink" title="2.2 sendFile优化"></a>2.2 sendFile优化</h3><p>1）Linux2.1版本提供了sendFile函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到SocketBuffer，同时，由于和用户态完全无关，就减少了一次上下文切换</p>
<p>2）示意图和小结</p>
<p><img src="https://i.loli.net/2021/02/19/7lQTnbyR9UtXEpL.png" alt="image-20210219192826304"></p>
<p>提示：零拷贝从操作系统角度，是没有CPU拷贝，所以在Linux2.1的版本中，kernel buffer和socket buffer的数据是相同的，之间还存在一次CPU拷贝不能算真正的零拷贝</p>
<p>3）Linux在2.4版本中，做了一些修改，避免了从内核缓冲区拷贝到Socket buffer的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。具体如下图</p>
<p><img src="https://i.loli.net/2021/02/19/YJNZtmdP6z13weI.png" alt="image-20210219193755985"></p>
<p>这里存在的一次CPU拷贝 kernel buffer   -》 socket buffer 但是，拷贝的信息很少，比如length，offset描述信息，消耗低，可以忽略</p>
<h3 id="2-3-零拷贝技术的再次理解"><a href="#2-3-零拷贝技术的再次理解" class="headerlink" title="2.3 零拷贝技术的再次理解"></a>2.3 零拷贝技术的再次理解</h3><p>1）零拷贝是从操作系统的角度来说的，因为内核缓冲区之间，没有数据是重复的（只有kernel buffer有一份数据）</p>
<p>2）零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的CPU缓存伪共享以及无CPU校验和计算</p>
<h3 id="2-4-mmap和sendFile的去呗"><a href="#2-4-mmap和sendFile的去呗" class="headerlink" title="2.4 mmap和sendFile的去呗"></a>2.4 mmap和sendFile的去呗</h3><p>1）mmap适合小数据量读写，sendFile适合大文件传输</p>
<p>2）mmap需要3次上下文切换，3次数据拷贝；sendFile需要2次上下文切换，最少2次数据拷贝</p>
<p>3）sendFile可以利用DMA方式，减少CPU拷贝，mmap则不能（必须从内核拷贝到Socket缓冲区）</p>
<h2 id="3-NIO零拷贝案例"><a href="#3-NIO零拷贝案例" class="headerlink" title="3.NIO零拷贝案例"></a>3.NIO零拷贝案例</h2><h3 id="3-1-案例要求"><a href="#3-1-案例要求" class="headerlink" title="3.1 案例要求"></a>3.1 案例要求</h3><p>1）使用传统的IO方法传递一个大文件</p>
<p>2）使用NIO零拷贝方式传递（transferTo）一个大文件</p>
<p>3）看看两种传递方式耗时时间分别是多少</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>9.NIO网络编程应用实例-群聊系统</title>
    <url>/2021/02/19/netty/9.NIO%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="NIO网络编程应用实例-群聊系统"><a href="#NIO网络编程应用实例-群聊系统" class="headerlink" title="NIO网络编程应用实例-群聊系统"></a>NIO网络编程应用实例-群聊系统</h1><h2 id="1-实例要求"><a href="#1-实例要求" class="headerlink" title="1.实例要求"></a>1.实例要求</h2><p>1）编写一个NIO群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</p>
<p>2）实现多人群聊</p>
<p>3）服务器端：可以监测用户上线，离线，并实现消息转发功能</p>
<p>4）客户端：通过channel可以无阻塞发送消息给其它所有用户，同时可以接收其它用户发送的消息（由服务器转发得到）</p>
<p>5）目的：进一步理解NIO非阻塞网络编程机制</p>
<p>示意图</p>
<p><img src="https://i.loli.net/2021/02/19/eAyfjz2codGbsSR.png" alt="image-20210219175712954"></p>
<h2 id="2-实现步骤"><a href="#2-实现步骤" class="headerlink" title="2.实现步骤"></a>2.实现步骤</h2><p>1）编写服务器端</p>
<p>1.1 服务器启动并监听6667</p>
<p>1.2 服务器接收客户端信息，并实现转发（处理上线和离线）</p>
<p>2）编写客户端</p>
<p>2.1 连接服务器</p>
<p>2.2 发送消息</p>
<p>2.3 接受服务器消息</p>
<h2 id="3-服务端代码"><a href="#3-服务端代码" class="headerlink" title="3.服务端代码"></a>3.服务端代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">erSocketChannel.open();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            listenChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            <span class="comment">//设置非阻塞模式</span></span><br><span class="line">            listenChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将该listenChannel注册到selector</span></span><br><span class="line">            listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//循环处理</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> count = selector.select();</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//遍历SelectionKey集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//监听到accept</span></span><br><span class="line">                        <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                            SocketChannel sc = listenChannel.accept();</span><br><span class="line">                            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                            sc.register(selector,SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//提示</span></span><br><span class="line">                            System.out.println(sc.getRemoteAddress() + <span class="string">"上线"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(key.isReadable())&#123;<span class="comment">//通道发生read事件，即通道为可读状态</span></span><br><span class="line">                            readData(key);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//手动从集合中移除当前的SelectionKey，防止重复操作</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"等待......"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取客户端消息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义SocketChannel</span></span><br><span class="line">        SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//创建buffer</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">int</span> count = channel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//将缓冲区数据输出</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                System.out.println(<span class="string">"from客户端："</span> + msg);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//向其它客户端转发消息(排除自己)，专门写一个方法来处理</span></span><br><span class="line">                sendInfoToOtherClients(msg,channel);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">"离线了"</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转发消息给其它的客户（通道）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendInfoToOtherClients</span><span class="params">(String msg,SocketChannel self)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器转发消息中"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历所有注册到selector上的SocketChannel，并排除自己</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey key : selector.keys()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过key取出对应的SocketChannel</span></span><br><span class="line">            Channel targetChannel = key.channel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//排除自己</span></span><br><span class="line">            <span class="keyword">if</span>(targetChannel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel != self)&#123;</span><br><span class="line">                <span class="comment">//转型</span></span><br><span class="line">                SocketChannel dest = (SocketChannel)targetChannel;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将msg存储到buffer</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将buffer的数据写入通道</span></span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建服务器对象</span></span><br><span class="line">        GroupChatServer groupChatServer = <span class="keyword">new</span> GroupChatServer();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-客户端代码"><a href="#4-客户端代码" class="headerlink" title="4.客户端代码"></a>4.客户端代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义相关的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String HOST = <span class="string">"127.0.0.1"</span>;<span class="comment">//服务器IP</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>;<span class="comment">//服务器端口</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器，完成初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GroupChatClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        socketChannel = socketChannel.open(<span class="keyword">new</span> InetSocketAddress(HOST,PORT));</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将channel注册到selector</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到username</span></span><br><span class="line">        username = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(username + <span class="string">" is ok"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(String info)</span></span>&#123;</span><br><span class="line">        info = username + <span class="string">"说："</span> + info;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取从服务器端回复的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> readChannels = selector.select();</span><br><span class="line">            <span class="keyword">if</span>(readChannels &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line"></span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                         <span class="comment">//得到相关的通道</span></span><br><span class="line">                        SocketChannel sc = (SocketChannel)key.channel();</span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//读取</span></span><br><span class="line">                        sc.read(buffer);</span><br><span class="line"></span><br><span class="line">                        String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line"></span><br><span class="line">                        System.out.println(msg.trim());</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//删除当前的SelectionKey防止重复操作</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动客户端</span></span><br><span class="line">        GroupChatClient chatClient = <span class="keyword">new</span> GroupChatClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动一个线程,每隔3s读取从服务器发送的数据</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    chatClient.readInfo();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据给服务器</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            chatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>8.serversocketchannel API和SocketChannel API</title>
    <url>/2021/02/19/netty/8.ServerSocketChannelAPI/</url>
    <content><![CDATA[<h1 id="ServerSocketChannel-API"><a href="#ServerSocketChannel-API" class="headerlink" title="ServerSocketChannel API"></a>ServerSocketChannel API</h1><h2 id="1）ServerSocketChannel在服务器端监听新的客户端Socket连接"><a href="#1）ServerSocketChannel在服务器端监听新的客户端Socket连接" class="headerlink" title="1）ServerSocketChannel在服务器端监听新的客户端Socket连接"></a>1）ServerSocketChannel在服务器端监听新的客户端Socket连接</h2><h2 id="2）相关方法如下"><a href="#2）相关方法如下" class="headerlink" title="2）相关方法如下"></a>2）相关方法如下</h2><p><img src="https://i.loli.net/2021/02/19/LilT4VIB1Yh2GcX.png" alt="image-20210219160242812"></p>
<h1 id="SocketChannel-API"><a href="#SocketChannel-API" class="headerlink" title="SocketChannel API"></a>SocketChannel API</h1><p>1）SocketChannel，网络IO通道，具体负责进行读写操作。NIO把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区</p>
<p>2）相关方法如下</p>
<p><img src="https://i.loli.net/2021/02/19/pouAshwHn82eSzi.png" alt="image-20210219163201256"></p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>7. selectionKey API</title>
    <url>/2021/02/19/netty/7.SelectionKey-API/</url>
    <content><![CDATA[<h1 id="SelectionKey-API"><a href="#SelectionKey-API" class="headerlink" title="SelectionKey API"></a>SelectionKey API</h1><h2 id="1）SelectionKey-，表示Selector和网络通道的注册关系，共四种"><a href="#1）SelectionKey-，表示Selector和网络通道的注册关系，共四种" class="headerlink" title="1）SelectionKey ，表示Selector和网络通道的注册关系，共四种"></a>1）SelectionKey ，表示Selector和网络通道的注册关系，共四种</h2><p>int OP_ACCEPT:有新的网络连接可以accept，值为16</p>
<p>int OP_CONNECT:代表连接已经建立，值为8</p>
<p>int OP_READ:代表读操作，值为1</p>
<p>int OP_WRITE:代表写操作，值为4</p>
<p>源码中：</p>
<p>public static final int OP_READ=1 &lt;&lt;0;</p>
<p>public static final int OP_WRITE=1 &lt;&lt; 2;</p>
<p>public static final int OP_CONNECT=1 &lt;&lt; 3;</p>
<p>public static final int OP_ACCEPT=1 &lt;&lt; 4;</p>
<h2 id="2）selectionKey相关方法"><a href="#2）selectionKey相关方法" class="headerlink" title="2）selectionKey相关方法"></a>2）selectionKey相关方法</h2><p><img src="https://i.loli.net/2021/02/19/TcwvQjKoV3imX6H.png" alt="image-20210219155405421"></p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>6.NIO非阻塞网络编程快速入门</title>
    <url>/2021/02/19/netty/6.NIO%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="NIO非阻塞网络编程快速入门"><a href="#NIO非阻塞网络编程快速入门" class="headerlink" title="NIO非阻塞网络编程快速入门"></a>NIO非阻塞网络编程快速入门</h1><h2 id="1-案例需求"><a href="#1-案例需求" class="headerlink" title="1.案例需求"></a>1.案例需求</h2><p>1）编写一个NIO入门实例，实现服务器端和客户端之间的数据简单通讯（非阻塞）</p>
<p>2）目的：理解NIO非阻塞网络编程机制</p>
<h2 id="2-服务器端代码"><a href="#2-服务器端代码" class="headerlink" title="2.服务器端代码"></a>2.服务器端代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建ServerSocketChannel -》ServerSocketChannel</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到一个Selector对象</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定端口6666，在服务器监听</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把ServerSocketChannel注册到Selector中，selector关系的事件为OP_ACCEPT</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环等待客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//这里等待1s，如果没有事件发生就返回</span></span><br><span class="line">            <span class="keyword">if</span>(selector.select(<span class="number">1000</span>) == <span class="number">0</span>)&#123;<span class="comment">//没有事件发生</span></span><br><span class="line">                System.out.println(<span class="string">"服务器等待了1s，无连接"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果返回的&gt;0,就回去到相关的selectionKey集合</span></span><br><span class="line">            <span class="comment">//1.如何返回的大于0，表示已经获取到关注的事件</span></span><br><span class="line">            <span class="comment">//2.selector.selectedKeys()返回关注事件的集合</span></span><br><span class="line">            <span class="comment">// 通过selectionKeys反向获取通道</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用迭代器遍历selectionKeys</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext())&#123;</span><br><span class="line">                <span class="comment">//获取到selectionKey</span></span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//根据key对应的通道发生的事件做相应的处理</span></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable())&#123;<span class="comment">//如果是OP_ACCEPT，表示有新的客户端连接</span></span><br><span class="line">                    <span class="comment">//给该客户生成一个SocketChannel</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//将当前的SocketChannel 注册到selector,关注事件为OP_READ，同时给SocketChannel</span></span><br><span class="line">                    <span class="comment">// 关联一个buffer</span></span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(key.isReadable())&#123;<span class="comment">//如果是OP_READ</span></span><br><span class="line">                    <span class="comment">//通过key反向获取对应的channel</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//获取到该channel关联的buffer</span></span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer)key.attachment();</span><br><span class="line"></span><br><span class="line">                    channel.read(buffer);</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"from客户端"</span> + <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//手动从集合中移除当前的selectionKey,防止重复操作</span></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-客户端代码"><a href="#3-客户端代码" class="headerlink" title="3.客户端代码"></a>3.客户端代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//得到一个网络通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提供服务器的IP和端口</span></span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="keyword">if</span>(!socketChannel.connect(inetSocketAddress))&#123;</span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">                System.out.println(<span class="string">"因为连接需要时间，客户端不会阻塞，可以做其它工作"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果连接成功，就发送数据</span></span><br><span class="line">        String str = <span class="string">"hello,netty learner"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//wrap a byte array into a buffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(str.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据，将buffer数据写入channel</span></span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>























]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>09-Kafka优秀架构之网络设计</title>
    <url>/2021/02/19/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/kafka/%E5%9F%BA%E7%A1%80/09-Kafka%E4%BC%98%E7%A7%80%E6%9E%B6%E6%9E%84%E4%B9%8B%E7%BD%91%E7%BB%9C%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="Kafka优秀架构之网络设计"><a href="#Kafka优秀架构之网络设计" class="headerlink" title="Kafka优秀架构之网络设计"></a>Kafka优秀架构之网络设计</h1><h2 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1.前置知识"></a>1.前置知识</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">难度有些大，需要大家要有一个java 的NIO方面网络的知识。一定要下去先找一些博客学习一下。</span><br><span class="line">然后再回过头来学这个课程。</span><br><span class="line">一定要听这个课的理由：</span><br><span class="line">1）网络设计部分是kafka里面设计得最好的一个部分。</span><br><span class="line">   这也就是为什么kafka能保证高并发，高性能的原因。</span><br><span class="line">2）后面我们搭建Kafka的集群的时候，需要对kafka集群进行调优</span><br><span class="line">   首先就得对kafka的原理要比较了解，特别是网络部分。</span><br></pre></td></tr></table></figure>

<p>接下来，也不直接透露Kafka的网络是如何设计的？先自己一步步设计再到Kafka的设计</p>
<p>2.</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>08-Kafka优秀架构之二分查找定位数据</title>
    <url>/2021/02/18/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/kafka/%E5%9F%BA%E7%A1%80/08-Kafka%E4%BC%98%E7%A7%80%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%AE%9A%E4%BD%8D%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="Kafka优秀架构之二分查找定位数据"><a href="#Kafka优秀架构之二分查找定位数据" class="headerlink" title="Kafka优秀架构之二分查找定位数据"></a>Kafka优秀架构之二分查找定位数据</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Producer -》 Kafka(Log)  《-  Consumer 消费数据（从哪个【位置】继续消费？）</span><br><span class="line">在kafka里面，offset</span><br><span class="line">Kafka里面每一条消息，都会有自己个offset（相对的偏移位置），物理的磁盘上面，哪个位置</span><br><span class="line">position：物理位置（代表的就是磁盘上面的哪个地方）</span><br><span class="line"></span><br><span class="line">也就是说我们一条日志：</span><br><span class="line">offset相对位置    position：物理位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">日志文件的命名是以日志中的第一条数据的offset命名的</span><br><span class="line"></span><br><span class="line">在.index文件中存储了log文件的稀疏索引，kafka里面每当写入了4KB的数据，就往.index文件中写入日志的索引位置</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/02/18/ZzR8cJkThtO7o6f.png" alt="image-20210218191835623"></p>
<p>在从指定位置的进行消费的时候，可以根据.index文件通过二分查找的方式快速确定读取的位置</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>07-Kafka优秀架构之日志分段存储</title>
    <url>/2021/02/18/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/kafka/%E5%9F%BA%E7%A1%80/07-Kafka%E4%BC%98%E7%A7%80%E6%9E%B6%E6%9E%84%E4%B9%8B%E6%97%A5%E5%BF%97%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h1 id="Kafka优秀架构之日志分段存储"><a href="#Kafka优秀架构之日志分段存储" class="headerlink" title="Kafka优秀架构之日志分段存储"></a>Kafka优秀架构之日志分段存储</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们之前说过kafka里面有主题的这个概念</span><br><span class="line">主题只是逻辑上的一个概念，主题里面是分区的。</span><br><span class="line">比如我们创建一个topic_a 然后创建的时候指定了这个主题有3个分区。</span><br><span class="line"></span><br><span class="line">其实最终就是在会在三台机器上面，创建三个目录。</span><br><span class="line">日志系统</span><br><span class="line">kafka1:</span><br><span class="line">	创建目录topic_a-0：</span><br><span class="line">		目录下面就是我们文件（存储的数据），Message,</span><br><span class="line">		在Kafka里面我们数据称作Message，数据存储在一个log文件里面。</span><br><span class="line">		.log结尾的就是日志文件，在Kafka里面把数据文件就叫做日志文件。</span><br><span class="line">		一个分区下面可以有n多个日志文件，默认一个日志文件的大小是1G。</span><br><span class="line">kafka2:</span><br><span class="line">	创建目录topic_a-1</span><br><span class="line">kafka3:</span><br><span class="line">	创建目录topic_a-2</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/02/18/P9GIaXFLZVTqKg2.png" alt="image-20210218190107538"></p>
]]></content>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>06-Kafka优秀架构之零拷贝机制保证读数据高性能</title>
    <url>/2021/02/18/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/kafka/%E5%9F%BA%E7%A1%80/06-Kafka%E4%BC%98%E7%A7%80%E6%9E%B6%E6%9E%84%E4%B9%8B%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%9C%BA%E5%88%B6%E4%BF%9D%E8%AF%81%E8%AF%BB%E6%95%B0%E6%8D%AE%E9%AB%98%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h1 id="Kafka优秀架构之零拷贝机制保证读数据高性能"><a href="#Kafka优秀架构之零拷贝机制保证读数据高性能" class="headerlink" title="Kafka优秀架构之零拷贝机制保证读数据高性能"></a>Kafka优秀架构之零拷贝机制保证读数据高性能</h1><h2 id="非零拷贝方式"><a href="#非零拷贝方式" class="headerlink" title="非零拷贝方式"></a>非零拷贝方式</h2><p><img src="https://i.loli.net/2021/02/18/Q2f3xJal8kmohEM.png" alt="image-20210218164446194"></p>
<h2 id="零拷贝方式"><a href="#零拷贝方式" class="headerlink" title="零拷贝方式"></a>零拷贝方式</h2><p><img src="https://i.loli.net/2021/02/18/Woh4lTHaujmPNi5.png" alt="image-20210218164625597"></p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>05-Kafka优秀架构之磁盘顺序写保证写数据性能</title>
    <url>/2021/02/18/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/kafka/%E5%9F%BA%E7%A1%80/05-Kafka%E4%BC%98%E7%A7%80%E6%9E%B6%E6%9E%84%E4%B9%8B%E7%A3%81%E7%9B%98%E9%A1%BA%E5%BA%8F%E5%86%99%E4%BF%9D%E8%AF%81%E5%86%99%E6%95%B0%E6%8D%AE%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h1 id="Kafka优秀架构之磁盘顺序写保证写数据性能"><a href="#Kafka优秀架构之磁盘顺序写保证写数据性能" class="headerlink" title="Kafka优秀架构之磁盘顺序写保证写数据性能"></a>Kafka优秀架构之磁盘顺序写保证写数据性能</h1><p>写数据：顺序写，往磁盘上写数据的时候，就是追加数据，没有随机写的操作</p>
<p>告诉大家一个经验值。如果一个服务器，磁盘达到一定的个数，磁盘也达到一定转数。<br>    往磁盘里面顺序写（追加写）数据的速度 跟写内存的数据差不多。</p>
<p><img src="https://i.loli.net/2021/02/18/sVmLUnJh2PSaOvQ.png" alt="image-20210218163715121"></p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>04图解kafka集群架构</title>
    <url>/2021/02/18/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/kafka/%E5%9F%BA%E7%A1%80/04-%E5%9B%BE%E8%A7%A3kafka%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="图解Kafka集群架构"><a href="#图解Kafka集群架构" class="headerlink" title="图解Kafka集群架构"></a>图解Kafka集群架构</h1><p>Producer：生产者，往Kafka集群生成数据<br>    比如我们自己写的一段代码，这段代码就是要往Kafka里面写数据。<br>Consumer：消费者，往Kafka里面去获取数据，处理数据，消费数据。<br>    P -》 topic-A kafka  topic-A &lt;–  消费者()<br>    Kafka里面的数据是推送给消费者的，还是消费者自己去拉取的？<br>    是我们消费者自己去拉取，可以按需拉取。我自己应用程序能处理多少数据，我就获取多少数据。</p>
<p>topic:主题</p>
<p>partition：分区<br>    如果没有设置的话，默认一个主题就是一个分区，一般我们创建主题的时候就可以指定分区的个数。</p>
<p>consumer group:<br>    我们消费数据的时候，都必须要指定一个group id，指定一个组的ID。<br>    那么假设我的程序A和程序B指定的group id号，一样，那么我们两个程序，其实就是属于同一个<br>    consumer group，同一个消费者组的消费者不能重复消费相同的数据，如果topicA被同一个消费者组的A消费了，则B就不能再消费了。消费者组之间互不影响</p>
<p><img src="https://i.loli.net/2021/02/18/WSda2nhx4JUKlbf.png" alt="image-20210218162214202"></p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>03图解kafka核心概念</title>
    <url>/2021/02/18/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/kafka/%E5%9F%BA%E7%A1%80/03-%E5%9B%BE%E8%A7%A3kafka%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="图解Kafka核心概念"><a href="#图解Kafka核心概念" class="headerlink" title="图解Kafka核心概念"></a>图解Kafka核心概念</h1><p>一般情况下，我们说的缓存是指的内存的意思，但是kafka的数据并不是存在内存中而是存储在磁盘上的，磁盘是可以很大的。所以这个kafka集群就可以存储非常多的数据。</p>
<p>kafka是一个集群，一个kafka集群是由多个服务器构成，由多个节点构成。</p>
<p>我们创建一个主题，默认分区只有一个，但是可以指定多个分区。然后这些分区会分散存储到不同的节点上面。</p>
<p>partition的设计解决海量数据存储的问题</p>
<p><img src="https://i.loli.net/2021/02/18/xmRvf4wDcty2OYH.png" alt="image-20210218153633464"></p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>02为什么要有消息系统</title>
    <url>/2021/02/18/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/kafka/%E5%9F%BA%E7%A1%80/02-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="为什么要有消息系统？有什么作用？"><a href="#为什么要有消息系统？有什么作用？" class="headerlink" title="为什么要有消息系统？有什么作用？"></a>为什么要有消息系统？有什么作用？</h1><h2 id="1-解耦合"><a href="#1-解耦合" class="headerlink" title="1.解耦合"></a>1.解耦合</h2><p>用生产巧克力举例说明：</p>
<p>把可可豆磨成可可粉，然后对可可粉加热，加入糖，并放入巧克力酱，最后将巧克力酱冷却后变成成品的巧克力。将整个业务过程解耦为如下几步</p>
<p>1）把可可豆磨成可可粉</p>
<p>2）对可可粉加热，加入糖，并放入巧克力酱</p>
<p>3）将巧克力酱冷却后变成成品的巧克力</p>
<p><img src="https://i.loli.net/2021/02/18/iGtBmukCV4RxPwd.png" alt="image-20210218150246064"></p>
<h2 id="2-异步处理"><a href="#2-异步处理" class="headerlink" title="2.异步处理"></a>2.异步处理</h2><p>电商平台，秒杀活动</p>
<p>1）风险控制 2）库存锁定 3）生成订单  4）短信通知  5）更新数据</p>
<p><img src="https://i.loli.net/2021/02/18/9kZ3xEUCVBSNDwn.png" alt="image-20210218150856962"></p>
<h2 id="3-流量控制"><a href="#3-流量控制" class="headerlink" title="3.流量控制"></a>3.流量控制</h2><p>1）网关在接收到请求后，就把请求放入到消息队列里面</p>
<p>2）后端的服务从消息队列里面获取到请求，完成后续的秒杀处理流程。然后再给用户返回结果。</p>
<p>优点：控制流量，达到肖峰的效果</p>
<p>缺点：让整体的处理流程变慢</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>01 企业级hadoop源码二次开发1</title>
    <url>/2021/02/17/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/Hadoop/01-%E4%BC%81%E4%B8%9A%E7%BA%A7Hadoop%E6%BA%90%E7%A0%81%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%911/</url>
    <content><![CDATA[<h1 id="企业级Hadoop源码二次开发1"><a href="#企业级Hadoop源码二次开发1" class="headerlink" title="企业级Hadoop源码二次开发1"></a>企业级Hadoop源码二次开发1</h1><h1 id="课程目标"><a href="#课程目标" class="headerlink" title="课程目标"></a>课程目标</h1><h2 id="1-HDFS是如何实现有状态的高可用架构"><a href="#1-HDFS是如何实现有状态的高可用架构" class="headerlink" title="1.HDFS是如何实现有状态的高可用架构"></a>1.HDFS是如何实现有状态的高可用架构</h2><h2 id="2-HDFS是如何通过架构设计解决单机内存受限问题的？"><a href="#2-HDFS是如何通过架构设计解决单机内存受限问题的？" class="headerlink" title="2.HDFS是如何通过架构设计解决单机内存受限问题的？"></a>2.HDFS是如何通过架构设计解决单机内存受限问题的？</h2><h2 id="3-揭秘HDFS能支撑亿级流量的核心源码设计？"><a href="#3-揭秘HDFS能支撑亿级流量的核心源码设计？" class="headerlink" title="3.揭秘HDFS能支撑亿级流量的核心源码设计？"></a>3.揭秘HDFS能支撑亿级流量的核心源码设计？</h2><h1 id="课程目录"><a href="#课程目录" class="headerlink" title="课程目录"></a>课程目录</h1><h2 id="第一章-HDFS架构演变"><a href="#第一章-HDFS架构演变" class="headerlink" title="第一章 HDFS架构演变"></a>第一章 HDFS架构演变</h2><h3 id="1-HDFS1"><a href="#1-HDFS1" class="headerlink" title="1.HDFS1"></a>1.HDFS1</h3><p>hadoop1的HDFS是主从式架构，默认的块大小是64M</p>
<p><img src="https://i.loli.net/2021/02/17/6QEDgOtVaCZ5cXS.png" alt="image-20210217104120962"></p>
<h4 id="NameNode的作用"><a href="#NameNode的作用" class="headerlink" title="NameNode的作用"></a>NameNode的作用</h4><p>1）管理元数据信息（文件目录树）：文件与block块，block块与DataNode主机的关系</p>
<p>2）NameNode为了快速响应用户的操作请求，所以把元数据加载到了内存里面</p>
<h4 id="DataNode的作用"><a href="#DataNode的作用" class="headerlink" title="DataNode的作用"></a>DataNode的作用</h4><p>1）存储数据，把上传的数据划分为固定大小的文件块（Hadoop1，默认是64M）</p>
<p>2）为了保证数据安全，每个文件块默认都有3个副本</p>
<h4 id="SecondaryNameNode的作用"><a href="#SecondaryNameNode的作用" class="headerlink" title="SecondaryNameNode的作用"></a>SecondaryNameNode的作用</h4><p>周期性地合并fsimage和editlog替换旧的fsimage，减少下一次NameNode启动时合并的editlog的文件个数，加快启动时间。在HDFS中有了高可用之后就不需要SecondaryNameNode了，secondaryNameNode干的活给另一个高可用的NameNode干了</p>
<h4 id="HDFS1可能出现的问题"><a href="#HDFS1可能出现的问题" class="headerlink" title="HDFS1可能出现的问题"></a>HDFS1可能出现的问题</h4><p>1）单点故障问题</p>
<p>解决方式：增加一个NameNode节点，保留相同的元数据信息，元数据信息存放在jourNalNode集群中</p>
<p>JourNalNode的特点：1）对等式架构，节点之间数据保持一致  2）存放节点大于半数，则集群就可以正常提供服务</p>
<p>在集群少于100个节点的时候：用3个jourNalNode节点就可以了  300以上 5个就可以了</p>
<p><img src="https://i.loli.net/2021/02/17/yOwflSLIiXV1EcR.png" alt="image-20210217111323509"></p>
<p>理论上可以用zookeeper代替JourNalNode用来存储元数据，但是zookeeper本身不擅长存储大数据，所以如果元数据的数据量比较小，也是可以用zookeeper存储的，但是需要对hadoop源码进行二次开发。</p>
<p>2）内存受限问题</p>
<p>将NameNode搭建为集群方式（联邦方案Federation）</p>
<p><img src="https://i.loli.net/2021/02/17/UN7l8qyxcisERg6.png" alt="image-20210217114805769"></p>
<h3 id="2-HDFS2"><a href="#2-HDFS2" class="headerlink" title="2.HDFS2"></a>2.HDFS2</h3><h4 id="HA方案（High-Available）"><a href="#HA方案（High-Available）" class="headerlink" title="HA方案（High Available）"></a>HA方案（High Available）</h4><p>​    解决HDFS1 Namenode单点故障问题</p>
<h4 id="联邦方案"><a href="#联邦方案" class="headerlink" title="联邦方案"></a>联邦方案</h4><p>​        解决了HDFS1 内存受限问题</p>
<h3 id="3-HDFS3"><a href="#3-HDFS3" class="headerlink" title="3.HDFS3"></a>3.HDFS3</h3><p>HA方案支持多个NameNode，引入纠删码技术（解决副本存储空间浪费的问题，一般用于冷数据的存储）</p>
<h2 id="第二章-HFDS支持亿级流量的秘密"><a href="#第二章-HFDS支持亿级流量的秘密" class="headerlink" title="第二章 HFDS支持亿级流量的秘密"></a>第二章 HFDS支持亿级流量的秘密</h2><p>因为NameNode管理了元数据，用户所有的操作请求都要操作NameNode，大一点的平台一天需要运行几十万，上百万的任务。一个任务就会有很多个请求，这些所有的请求都打到NameNode这个（更新目录树），对于NameNode来说这就是亿级的流量（请求），NameNode是如何支撑亿级流量的呢？</p>
<p>1）在启动NameNode之前，首先要对文件系统进行格式化（hdfs namenode -format），生成fsimage保留对应的元数据信息,然后在启动NameNode（hdfs -daemon start namenode）,即将元数据加载到内存</p>
<p>HDFS如何管理元数据</p>
<p><img src="https://i.loli.net/2021/02/18/MCAVJrUw4fbvknH.png" alt="image-20210218114835652"></p>
<p><img src="https://i.loli.net/2021/02/18/1I9E2WykN4xdLpm.png" alt="image-20210218114900826"></p>
<h1 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h1><h2 id="1-了解HDFS架构的演变"><a href="#1-了解HDFS架构的演变" class="headerlink" title="1.了解HDFS架构的演变"></a>1.了解HDFS架构的演变</h2><h2 id="2-HDFS2是如何解决单点故障问题的"><a href="#2-HDFS2是如何解决单点故障问题的" class="headerlink" title="2.HDFS2是如何解决单点故障问题的"></a>2.HDFS2是如何解决单点故障问题的</h2><h2 id="3-HDFS2是如何解决内存受限问题的"><a href="#3-HDFS2是如何解决内存受限问题的" class="headerlink" title="3.HDFS2是如何解决内存受限问题的"></a>3.HDFS2是如何解决内存受限问题的</h2><h2 id="4-HDFS元数据管理的流程"><a href="#4-HDFS元数据管理的流程" class="headerlink" title="4.HDFS元数据管理的流程"></a>4.HDFS元数据管理的流程</h2>]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>4.NIO介绍</title>
    <url>/2021/01/31/netty/5.NIO%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="一、Java-NIO基本介绍"><a href="#一、Java-NIO基本介绍" class="headerlink" title="一、Java NIO基本介绍"></a>一、Java NIO基本介绍</h1><h1 id="二、Buffer"><a href="#二、Buffer" class="headerlink" title="二、Buffer"></a>二、Buffer</h1><h1 id="三、Channel"><a href="#三、Channel" class="headerlink" title="三、Channel"></a>三、Channel</h1><h1 id="四、Selector"><a href="#四、Selector" class="headerlink" title="四、Selector"></a>四、Selector</h1><h2 id="4-1-Selector基本介绍"><a href="#4-1-Selector基本介绍" class="headerlink" title="4.1 Selector基本介绍"></a>4.1 Selector基本介绍</h2><p>1）Java的NIO，用非阻塞的IO方式。可以用一个线程，处理多个客户端连接，就会用到Selector</p>
<p>2）Selector能够监测多个注册的通道上是否有事件发生（注意：多个channel以事件的方式可以注册到同一个selector），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就管理多个连接和请求</p>
<p>3）只有在连接真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程</p>
<p>4）避免了多线程之间的上下文切换导致的开销</p>
<h2 id="4-2-Selector示意图和特点"><a href="#4-2-Selector示意图和特点" class="headerlink" title="4.2 Selector示意图和特点"></a>4.2 Selector示意图和特点</h2><p><img src="https://i.loli.net/2021/02/19/5LxvIpD7UWGQmqg.png" alt="image-20210219103215837"></p>
<p>1）Netty的IO线程NIOEventLoop聚合了Selector，可以同时并发处理成百上千个客户端连接</p>
<p>2）当线程从某客户端Socket通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务</p>
<p>3）线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道</p>
<p>4）由于读写操作都是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁IO阻塞导致的线程挂起</p>
<p>5）一个IO线程可以并发处理N个客户端连接和读写操作，从根本上解决了传统同步阻塞IO一连接一线程模型，架构的性能，弹性伸缩能力和可靠性都得到了极大的提升</p>
<h2 id="4-3-Selector类相关方法"><a href="#4-3-Selector类相关方法" class="headerlink" title="4.3 Selector类相关方法"></a>4.3 Selector类相关方法</h2><p><img src="https://i.loli.net/2021/02/19/JLt5NADojz2Xs4p.png" alt="image-20210219105238282"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NIO中的ServerSocketChannel功能类似ServerSocket，SocketChannel功能类似Socket</span><br><span class="line"></span><br><span class="line">selector.select()<span class="comment">//阻塞</span></span><br><span class="line">selector.select(<span class="number">1000</span>);<span class="comment">//阻塞1000毫秒，在1000毫秒后返回</span></span><br><span class="line">selector.wakeup();<span class="comment">//唤醒selector</span></span><br><span class="line">selector.selectNow();<span class="comment">//不阻塞，立马返还</span></span><br></pre></td></tr></table></figure>



<h2 id="4-4-NIO非阻塞网络编程原理分析图"><a href="#4-4-NIO非阻塞网络编程原理分析图" class="headerlink" title="4.4 NIO非阻塞网络编程原理分析图"></a>4.4 NIO非阻塞网络编程原理分析图</h2><p><img src="https://i.loli.net/2021/02/19/shoaevGNpW3Adjx.png" alt="image-20210219104937000"></p>
<p>对上图的说明：</p>
<p>1）当客户端连接时，会通过ServerSocketChannel得到SocketChannel</p>
<p>2）selector进行监听，select方法返回有事件发生的通道的个数</p>
<p>3）将SocketChannel注册到Selector上，对应的方法是SocketChannel的register(Selector sel,int ops)，一个selector上可以注册多个SocketChannel，ips可以指定的参数对应的操作分别有(读事件，写事件，创建连接事件，连接已经创建完毕事件)</p>
<p>4）注册后返回一个SelectionKey，会和该Selector关联（集合）</p>
<p>5）Selector通过select方法进行监听，返回有事件发生的通道的个数，进一步得到有事件发生的SelectionKey</p>
<p>6）再根据SelectionKey通过channel()反向获取SocketChannel</p>
<p>7）通过得到的channel，完成业务逻辑的处理</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>BIO介绍</title>
    <url>/2021/01/29/netty/4.BIO%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="一、BIO基本介绍"><a href="#一、BIO基本介绍" class="headerlink" title="一、BIO基本介绍"></a>一、BIO基本介绍</h1><p>Java BIO就是传统的java IO，BIO(blocking I/O)：同步阻塞，服务器实现模式为一个连接一个线程处理</p>
<h2 id="1-1-工作原理图"><a href="#1-1-工作原理图" class="headerlink" title="1.1 工作原理图"></a>1.1 工作原理图</h2><p><img src="https://i.loli.net/2021/01/29/mncf3kpxiZ21TVN.png" alt="image-20210129105150413"></p>
<h2 id="1-2-BIO编程简单流程"><a href="#1-2-BIO编程简单流程" class="headerlink" title="1.2 BIO编程简单流程"></a>1.2 BIO编程简单流程</h2><p>1）服务器端启动一个ServerSocket</p>
<p>2）客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户创建一个线程与之通讯</p>
<p>3）客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝</p>
<p>4）如果有响应，客户端线程会等待请求结束后，再继续执行</p>
<h2 id="1-3-Java-BIO应用实例"><a href="#1-3-Java-BIO应用实例" class="headerlink" title="1.3 Java BIO应用实例"></a>1.3 Java BIO应用实例</h2><p>案例说明：</p>
<p>1）使用BIO模型编写一个服务器端，监听6666端口，当有客户端连接时，就启动一个线程与之通讯。</p>
<p>2）要求使用线程池机制改善，可以连接多个客户端。</p>
<p>3）服务器端可以接收客户端发送的数据（Telnet方式即可）。</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> BIOServer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> TYS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/1/29 9:27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//线程池机制</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1.创建一个线程池</span></span><br><span class="line">        <span class="comment">//2.如果有客户端连接，则创建一个线程与之通讯（单独写一个方法）</span></span><br><span class="line">        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个serverSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器启动了"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//监听，等待客户端连接</span></span><br><span class="line">            System.out.println(<span class="string">"等待连接......阻塞中"</span>);</span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">"连接到一个客户端"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//就创建一个线程，与之通讯</span></span><br><span class="line">            newCachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//重写run方法，和客户端通讯</span></span><br><span class="line">                    handler(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个handler方法和客户端通讯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程信息 id = "</span> + Thread.currentThread().getId() + <span class="string">" 名字="</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket获取一个输入流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环读取客户端发送的数据</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程信息 id = "</span> + Thread.currentThread().getId() + <span class="string">" 名字="</span> + Thread.currentThread().getName());</span><br><span class="line">                System.out.println(<span class="string">"read......阻塞中"</span>);</span><br><span class="line">                <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">                <span class="keyword">if</span>(read != -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//输出客户端发送的数据</span></span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,read));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭和connect连接"</span>);</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用telnet 命令向服务端创建连接发送数据</p>
<p><img src="https://i.loli.net/2021/01/29/KpfCAHSuqvlLsIe.png" alt="image-20210129104628450"></p>
<p><img src="https://i.loli.net/2021/01/29/aDZziOX4EfkrLbP.png" alt="image-20210129104535348"></p>
<h2 id="1-4-Java-BIO问题分析"><a href="#1-4-Java-BIO问题分析" class="headerlink" title="1.4 Java BIO问题分析"></a>1.4 Java BIO问题分析</h2><p>1）每个请求都需要创建独立的线程，与对应的客户端进行数据Read，业务处理，数据Write。</p>
<p>2）当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大</p>
<p>3）连接建立后，如果当前线程暂时没有数据可以读取，则线程会阻塞在read操作上，造成线程资源浪费</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>3.IO模型</title>
    <url>/2021/01/28/netty/3.IO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="一、IO模型"><a href="#一、IO模型" class="headerlink" title="一、IO模型"></a>一、IO模型</h1><h2 id="1-1-BIO"><a href="#1-1-BIO" class="headerlink" title="1.1 BIO"></a>1.1 BIO</h2><p>BIO是Java的原生阻塞IO，特点如下：</p>
<p>1）每一个客户端请求都需要服务端单独启动一个线程创建跟客户端的连接处理请求，在闲置时会造成资源的浪费，BIO方式适用于链接数目比较小且固定的架构，这种方式对服务器资源要求比较高，开发局限于应用中，是以前JDK1.4以前的唯一选择，但程序简单易理解。</p>
<p>示意图如下</p>
<p><img src="https://i.loli.net/2021/01/28/DGNY7RmcQxC2aqp.png" alt="image-20210128155516877"></p>
<h2 id="1-2-NIO"><a href="#1-2-NIO" class="headerlink" title="1.2 NIO"></a>1.2 NIO</h2><p>NIO是同步非阻塞IO，特点如下：</p>
<p>1）服务器端不会每次都单独开启一个线程去创建连接处理请求，对于多个请求而是开辟多个线程，每个线程可以依赖于选择器处理多个请求，NIO方式适用于链接数目多且连接比较短的的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较负责，JDK1.4开始支持。</p>
<p><img src="https://i.loli.net/2021/01/28/LGkzbqQmZ13avFV.png" alt="image-20210128160008628"></p>
<h2 id="1-3-AIO"><a href="#1-3-AIO" class="headerlink" title="1.3 AIO"></a>1.3 AIO</h2><p>异步非阻塞，未得到广泛应用，暂时了解即可。</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>2.netty的应用场景</title>
    <url>/2021/01/28/netty/2.netty%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h1 id="一、Netty的应用场景"><a href="#一、Netty的应用场景" class="headerlink" title="一、Netty的应用场景"></a>一、Netty的应用场景</h1><p>1）互联网行业：在分布式系统中，各个节点之间需要需要远程服务调用，高性能的RPC框架必不可少，Netty作为异步高性能的通信框架，往往作为基础通信组件被这些RPC框架使用</p>
<p>​    典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，DU币博协议默认使用netty作为基础通信组件，用于各进程节点之间的内时部通信。</p>
<p>2）游戏行业： 无论是手游服务端还是大型的网络游戏，Java语言得到了越来越广泛的应用；Netty作为高性能的基础通信组件/，提供了TCP/UDP和HTTP协议栈，方便定制和开发私有协议栈，账号登录服务器；地图服务器之间可以方便的通过Netty进行高性能的通信</p>
<p>3）大数据领域：经典的Hadoop的高性能通信和系列化组件(AVRO 实现数据文件的共享)的RPC框架，默认采用Netty进行跨节点通信，它的Netty Service基于Netty框架二次封装实现</p>
<p>4）常用的开源项目：比如Flink，Spark等需要网络通信的开源项目 </p>
<p>推荐书籍：Netty In Action</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>1.netty是什么</title>
    <url>/2021/01/27/netty/1.netty%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h1 id="一、Netty是什么？"><a href="#一、Netty是什么？" class="headerlink" title="一、Netty是什么？"></a>一、Netty是什么？</h1><p>1）Netty是由Jboss提供的一个Java开源框架，现为Github的开源项目。</p>
<p>2）Netty是一个异步的、基于事件驱动的网络应用框架，用于快速开发高性能，高可靠性的网络IO程序。</p>
<p>3）Netty主要针对在TCP协议下，面向Clients端的高并发应用，或者Peer to Peer场景下的大量数据持续传输的应用。</p>
<p>4）Netty本质上是一个NIO框架，适用于服务器通讯相关的多种应用场景。</p>
<p>5）要彻底理解Netty，需要先学习NIO，这样才能阅读Netty源码。 </p>
<p><img src="https://i.loli.net/2021/01/27/GUDvjw2s6h78T1S.png" alt="image-20210127100019837"></p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>netty课程说明</title>
    <url>/2021/01/27/netty/netty%E8%AF%BE%E7%A8%8B%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="一、Netty介绍和应用场景"><a href="#一、Netty介绍和应用场景" class="headerlink" title="一、Netty介绍和应用场景"></a>一、Netty介绍和应用场景</h1><h2 id="1-1-课程学习要求"><a href="#1-1-课程学习要求" class="headerlink" title="1.1 课程学习要求"></a>1.1 课程学习要求</h2><p>1）要求已经掌握了Java编程，主要技术构成：OOP编程，Java多线程编程，Java IO编程，Java网络编程，常用的Java设计模式（比如 观察者模式，命令模式了，职责链模式），常用的数据结构（比如链表）</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2021/01/26/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1-天气预报案例需求"><a href="#1-天气预报案例需求" class="headerlink" title="1.天气预报案例需求"></a>1.天气预报案例需求</h1><p>1)   气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去(比如发布到自己的网站或第三方)。</p>
<p>2)   需要设计开放型 <strong>API</strong>，便于其他第三方也能接入气象站获取数据。</p>
<p>3)   提供温度、气压和湿度的接口</p>
<p>4)   测量数据更新时，要能实时的通知给第三方</p>
<h1 id="2-天气预报方案-普通方案"><a href="#2-天气预报方案-普通方案" class="headerlink" title="2.天气预报方案-普通方案"></a>2.天气预报方案-普通方案</h1><h2 id="2-1-传统的设计方案"><a href="#2-1-传统的设计方案" class="headerlink" title="2.1 传统的设计方案"></a>2.1 传统的设计方案</h2><p><img src="https://i.loli.net/2021/01/26/zogxnDvH4Rc28I1.jpg" alt="img"></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="https://i.loli.net/2021/01/26/zogxnDvH4Rc28I1.jpg" alt="img"></td>
</tr>
</tbody></table>
<h2 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建接入方 currentConditions</span></span><br><span class="line">CurrentConditions currentConditions = <span class="keyword">new</span> CurrentConditions();</span><br><span class="line"><span class="comment">//创建 WeatherData 并将 接入方 currentConditions 传递到 WeatherData 中</span></span><br><span class="line">WeatherData weatherData = <span class="keyword">new</span> WeatherData(currentConditions);</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新天气情况weatherData.setData(30, 150, 40);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//天气情况变化</span></span><br><span class="line">System.out.println(<span class="string">"============天气情况变化============="</span>);</span><br><span class="line">weatherData.setData(<span class="number">40</span>, <span class="number">160</span>, <span class="number">20</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*	显示当前天气情况（可以理解成是气象站自己的网站）</span></span><br><span class="line"><span class="comment">*	<span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditions</span> </span>&#123;</span><br><span class="line"><span class="comment">// 温度，气压，湿度private float temperature; private float pressure; private float humidity;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更新 天气情况，是由 WeatherData 来调用，我使用推送模式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>&#123; <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line"><span class="keyword">this</span>.pressure = pressure; <span class="keyword">this</span>.humidity = humidity; display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"***Today mTemperature: "</span> + temperature + <span class="string">"***"</span>); System.out.println(<span class="string">"***Today mPressure: "</span> + pressure + <span class="string">"***"</span>); System.out.println(<span class="string">"***Today mHumidity: "</span> + humidity + <span class="string">"***"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.observer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	类是核心</span></span><br><span class="line"><span class="comment">*	1. 包含最新的天气情况信息</span></span><br><span class="line"><span class="comment">*	2. 含有 CurrentConditions 对象</span></span><br><span class="line"><span class="comment">*	3.  当数据有更新时，就主动的调用	CurrentConditions 对象 update 方法(含 display),  这样他们（接入方）就看到最新的信息</span></span><br><span class="line"><span class="comment">*	<span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> </span>&#123; <span class="keyword">private</span> <span class="keyword">float</span> temperatrue; <span class="keyword">private</span> <span class="keyword">float</span> pressure; <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line"><span class="keyword">private</span> CurrentConditions currentConditions;</span><br><span class="line"><span class="comment">//加入新的第三方</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">(CurrentConditions currentConditions)</span> </span>&#123; <span class="keyword">this</span>.currentConditions = currentConditions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTemperature</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> temperatrue;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPressure</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pressure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getHumidity</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> humidity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用 接入方的 update</span></span><br><span class="line">currentConditions.update(getTemperature(), getPressure(), getHumidity());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当数据有更新时，就调用 setData</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>&#123; <span class="keyword">this</span>.temperatrue = temperature;</span><br><span class="line"><span class="keyword">this</span>.pressure = pressure; <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line"><span class="comment">//调用 dataChange， 将最新的信息 推送给 接入方 currentConditions</span></span><br><span class="line">dataChange();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-问题分析"><a href="#2-3-问题分析" class="headerlink" title="2.3 问题分析"></a>2.3 问题分析</h2><p>1)   其他第三方接入气象站获取数据的问题</p>
<p>2)   无法在运行时动态的添加第三方 (新浪网站)</p>
<p>3)   违反 ocp 原则=&gt;观察者模式</p>
<p>//在 WeatherData 中，当增加一个第三方，都需要创建一个对应的第三方的公告板对象，并加入到 dataChange, 不利于维护，也不是动态加入</p>
<p>public void dataChange() {</p>
<p>currentConditions.update(getTemperature(), getPressure(), getHumidity());</p>
<p>}</p>
<h1 id="3-天气预报方案-观察者模式方案"><a href="#3-天气预报方案-观察者模式方案" class="headerlink" title="3.天气预报方案-观察者模式方案"></a>3.天气预报方案-观察者模式方案</h1><h2 id="3-1-分析"><a href="#3-1-分析" class="headerlink" title="3.1 分析"></a>3.1 分析</h2><p>1)   观察者模式类似订牛奶业务</p>
<p>2)   奶站/气象局：Subject</p>
<p>3)   用户/第三方网站：Observer</p>
<p>Ø Subject：登记注册、移除和通知</p>
<p>1)   registerObserver 注 册</p>
<p>2)   removeObserver 移 除</p>
<p>3)   notifyObservers() 通知所有的注册的用户，根据不同需求，可以是更新数据，让用户来取，也可能是实施推送， 看具体需求定</p>
<p>Ø Observer：接收输入</p>
<p>Ø 观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为 Subject，依赖的对象为 Observer，Subject</p>
<p>通知 Observer 变化,比如这里的奶站是 Subject，是 1 的一方。用户时 Observer，是多的一方。</p>
<h2 id="3-2-类图说明"><a href="#3-2-类图说明" class="headerlink" title="3.2 类图说明"></a>3.2 类图说明</h2><p><img src="https://i.loli.net/2021/01/26/1kjOwmeUrYGit7F.png" alt="image-20210126172415141"></p>
<h2 id="3-3-代码实现"><a href="#3-3-代码实现" class="headerlink" title="3.3 代码实现"></a>3.3 代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.observer.improve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaiduSite</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 温度，气压，湿度private float temperature; private float pressure; private float humidity;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  更新  天气情况，是由  WeatherData  来调用，我使用推送模式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.temperature = temperature;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.pressure = pressure; <span class="keyword">this</span>.humidity = humidity; display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显 示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"===百度网站===="</span>);</span><br><span class="line">System.out.println(<span class="string">"***百度网站 气温 : "</span> + temperature + <span class="string">"***"</span>);</span><br><span class="line">System.out.println(<span class="string">"***百度网站 气压: "</span> + pressure + <span class="string">"***"</span>);</span><br><span class="line">System.out.println(<span class="string">"***百度网站 湿度: "</span> + humidity + <span class="string">"***"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.observer.improve;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//创建一个 WeatherData</span></span><br><span class="line">WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建观察者</span></span><br><span class="line">CurrentConditions currentConditions = <span class="keyword">new</span> CurrentConditions();</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">BaiduSite baiduSite = <span class="keyword">new</span> BaiduSite();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注 册 到 weatherData weatherData.registerObserver(currentConditions); weatherData.registerObserver(baiduSite);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测 试                                                         System.out.println("通知各个注册的观察者, 看看信息"); weatherData.setData(10f, 100f, 30.3f);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">weatherData.removeObserver(currentConditions);</span><br><span class="line"><span class="comment">//测试System.out.println();</span></span><br><span class="line">System.out.println(<span class="string">"通知各个注册的观察者, 看看信息"</span>); weatherData.setData(<span class="number">10f</span>, <span class="number">100f</span>, <span class="number">30.3f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.observer.improve;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditions</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 温度，气压，湿度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> pressure; <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 天气情况，是由 WeatherData 来调用，我使用推送模式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>&#123; <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line"><span class="keyword">this</span>.pressure = pressure; <span class="keyword">this</span>.humidity = humidity; display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显 示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"***Today mTemperature: "</span> + temperature + <span class="string">"***"</span>); System.out.println(<span class="string">"***Today mPressure: "</span> + pressure + <span class="string">"***"</span>); System.out.println(<span class="string">"***Today mHumidity: "</span> + humidity + <span class="string">"***"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.observer.improve;</span><br><span class="line"></span><br><span class="line"><span class="comment">//观察者接口，有观察者来实现 public interface Observer &#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.observer.improve;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口, 让 WeatherData 来实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.observer.improve;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	类是核心</span></span><br><span class="line"><span class="comment">*	1. 包含最新的天气情况信息</span></span><br><span class="line"><span class="comment">*	2. 含有 观察者集合，使用 ArrayList 管理</span></span><br><span class="line"><span class="comment">*	3.  当数据有更新时，就主动的调用	ArrayList, 通知所有的（接入方）就看到最新的信息</span></span><br><span class="line"><span class="comment">*	<span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123; <span class="keyword">private</span> <span class="keyword">float</span> temperatrue;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line"><span class="comment">//观察者集合</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Observer&gt; observers;</span><br><span class="line"><span class="comment">//加入新的第三方public WeatherData() &#123;</span></span><br><span class="line">observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTemperature</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> temperatrue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPressure</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pressure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getHumidity</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> humidity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用 接入方的 update</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">notifyObservers();</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当数据有更新时，就调用 setData</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>&#123; <span class="keyword">this</span>.temperatrue = temperature;</span><br><span class="line"><span class="keyword">this</span>.pressure = pressure; <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line"><span class="comment">//调用 dataChange， 将最新的信息 推送给 接入方 currentConditions</span></span><br><span class="line">dataChange();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册一个观察者 @Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub observers.add(o);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除一个观察者 @Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub if(observers.contains(o)) &#123;</span></span><br><span class="line">observers.remove(o);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历所有的观察者，并通知 @Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub for(int i = 0; i &lt; observers.size(); i++) &#123;</span></span><br><span class="line">observers.get(i).update(<span class="keyword">this</span>.temperatrue, <span class="keyword">this</span>.pressure, <span class="keyword">this</span>.humidity);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-4-观察者模式的好处"><a href="#3-4-观察者模式的好处" class="headerlink" title="3.4 观察者模式的好处"></a>3.4 观察者模式的好处</h2><p>1)   观察者模式设计后，会以集合的方式来管理用户(Observer)，包括注册，移除和通知。</p>
<p>2)   这样，我们增加观察者(这里可以理解成一个新的公告板)，就不需要去修改核心类 WeatherData 不会修改代码， 遵守了 ocp 原则。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>linux中java web的服务注册流程</title>
    <url>/2021/01/18/linux%E4%B8%ADjava-web%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>资料参考链接：<a href="https://zhuanlan.zhihu.com/p/81527659" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/81527659</a></p>
<p>步骤如下：</p>
<p>1.创建可执行的shell脚本执行java web程序 start.sh</p>
<p>shell脚本的绝对路径为：/home/redpeak/shanmei/largeScreen/merge/start.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/jdk64/jdk1.8.0_112</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">nohup java -jar /home/redpeak/shanmei/largeScreen/merge/customer-analysis-0.0.1-SNAPSHOT.jar 1&gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>2.注册服务</p>
<p>vim /etc/systemd/system/shanmeilargeScreen.service</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Java web shanmei largeScreen service</span><br><span class="line"></span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line"></span><br><span class="line">ExecStart=/bin/bash /home/redpeak/shanmei/largeScreen/merge/start.sh</span><br><span class="line">ExecStop=/bin/kill -s QUIT $MAINPID</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>3.设置服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">systemctl daemon-reload</span></span><br><span class="line"><span class="meta">#</span><span class="bash">systemctl start shanmeilargeScreen.service</span></span><br><span class="line"><span class="meta">#</span><span class="bash">systemctl <span class="built_in">enable</span> shanmeilargeScreen.service</span></span><br><span class="line"><span class="meta">#</span><span class="bash">systemctl status shanmeilargeScreen.service</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>4.Flink任务调度原理</title>
    <url>/2021/01/08/flink/4.Flink%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="任务调度原理"><a href="#任务调度原理" class="headerlink" title="任务调度原理"></a>任务调度原理</h1><p><img src="https://i.loli.net/2021/01/08/fAl7MEDvPsinOHX.png" alt="image-20210108192445820"></p>
<p> 1）怎么实现并行计算？</p>
<p>多线程，不同的任务在不同的线程上运行</p>
<p>2）并行的任务需要多少个slot？</p>
<p>跟最大并行度有关</p>
<p>3）一个流处理程序，到底包含多少个任务？</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Flink</category>
      </categories>
  </entry>
  <entry>
    <title>3.flink任务提交流程</title>
    <url>/2021/01/07/flink/3.flink%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-Flink任务提交流程（YARN）"><a href="#1-Flink任务提交流程（YARN）" class="headerlink" title="1.Flink任务提交流程（YARN）"></a>1.Flink任务提交流程（YARN）</h1><p>1）Flink client向Dispatcher提交应用程序</p>
<p>2）Dispatcher将应用程序转发给JobManager</p>
<p>3）JobManager向Flink ResourceManager申请运行作业需要的资源</p>
<p>4）Flink ResourceManager向资源管理框架YARN的resourceManager申请任务运行需要的资源</p>
<p>5）YARN ResourceManager到可用的NodeManager上启动container，启动applicationMaster</p>
<p>6）再到可用的NodeManager上启动taskManager，taskManager向YARN ResourceManager注册启动的资源</p>
<p>7）启动的taskManager向JobManager提供slot资源</p>
<p>8）JobManager将任务提交到taskManager上运行</p>
<p><img src="https://i.loli.net/2021/01/08/igS9TfpWl5zaNuq.png" alt="image-20210108190528386"></p>
<p><img src="https://i.loli.net/2021/01/08/IuWiBVHSjQ81MeG.png" alt="image-20210108190635964"></p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Flink</category>
      </categories>
  </entry>
  <entry>
    <title>2.flink运行时架构</title>
    <url>/2021/01/07/flink/2.flink%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="1-Flink运行架构"><a href="#1-Flink运行架构" class="headerlink" title="1.Flink运行架构"></a>1.Flink运行架构</h1><h2 id="1-1-Flink运行时组件"><a href="#1-1-Flink运行时组件" class="headerlink" title="1.1 Flink运行时组件"></a>1.1 Flink运行时组件</h2><p><img src="https://i.loli.net/2021/01/07/JLigmDrAGUHS2s9.png" alt="image-20210107200452768"></p>
<p>1）JobManager</p>
<pre><code>控制一个应用程序执行的主进程，也就是说，每个应用程序都会被一个不同的JobManager所控制执行。</code></pre><p>​    JobManager会先接收到需要执行的应用程序，这个应用程序会包括：作业图（JobGraph）,逻辑数据流图(logical dataflow graph)和打包了所有的类，库和其它资源的JAR包。</p>
<p>​    JobManager会把JobGraph转换成一个物理层面的数据流图-ExecutionGraph，包含了所有可以并发执行的任务。    </p>
<p>​    JobManager会向资源管理器请求执行任务必要的资源，也就是taskManager的slot。一旦它获取了足够的资源，就会将executionGraph分发到真正运行它们的taskManager上。在运行过程中，JobManager会负责所有需要中央协调的操作，比如说检查点的协调。</p>
<p>2）TaskManager</p>
<p>​    taskManager是flink中的工作进程，通常在flink中会有多个taskManager运行，每一个taskManager都包含了一定数量的插槽（slots）。插槽数量限制了taskManager能够执行的任务数量。</p>
<p>​    在taskManager启动之后，taskManager会向资源管理器注册它的插槽；收到资源管理器的指令后，taskManager就会将一个或多个插槽供给JobManager调用。JobManager就可以向插槽分配任务(task)来执行了。</p>
<p>​    在执行过程中，一个taskManager可以跟其它运行同一应用程序的taskManager交换数据。</p>
<p>3）ResourceManager</p>
<pre><code>主要负责管理taskManager的slot。taskManager的slot是flink中定义的处理资源单元。</code></pre><p>​    Flink为不同的环境和资源管理工具提供了不同资源管理器，比如YARN，Mesos,K8s,以及standalone部署</p>
<p>​    当JobManager申请slot资源时，resourceManager会将有空闲插槽的taskManager分配给JobManager。如果resourceManager没有足够的slot来满足JobManager的请求，它还可以向资源提供平台发起会话，以提供启动taskManager的容器</p>
<p>4）Dispatcher</p>
<pre><code>为应用提交提供了REST接口。当一个应用被提交执行时，分发器就会启动并将应用移交给一个JobManager。Dispatcher也会启动一个Web UI，用来方便地展示和监控作业执行的信息。</code></pre><p>​    Dispatcher在架构中可能并不是必需的，这取决于应用提交运行的方式。</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Flink</category>
      </categories>
  </entry>
  <entry>
    <title>1.flink入门</title>
    <url>/2021/01/06/flink/1.flink%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="第一章-flink概述"><a href="#第一章-flink概述" class="headerlink" title="第一章 flink概述"></a>第一章 flink概述</h1><h2 id="1-1-什么是flink"><a href="#1-1-什么是flink" class="headerlink" title="1.1 什么是flink"></a>1.1 什么是flink</h2><p>apache flink是一个同时具备低延迟、高吞吐、高性能基于事件驱动的的分布式流式处理引擎，在2014年12月份成为apache基金会的顶级项目</p>
<h2 id="1-2-flink特点"><a href="#1-2-flink特点" class="headerlink" title="1.2 flink特点"></a>1.2 flink特点</h2><p>1）低延迟、高吞吐、高性能</p>
<p>2）支持事件时间</p>
<p>3）支持有状态计算</p>
<p>4）支持exactly once精准一次行消费</p>
<p>5）基于轻量级分布式快照实现的容错</p>
<h1 id="第二章-flink部署"><a href="#第二章-flink部署" class="headerlink" title="第二章 flink部署"></a>第二章 flink部署</h1><h2 id="2-1-local"><a href="#2-1-local" class="headerlink" title="2.1 local"></a>2.1 local</h2><h2 id="2-2-standalone"><a href="#2-2-standalone" class="headerlink" title="2.2 standalone"></a>2.2 standalone</h2><h2 id="2-3-yarn"><a href="#2-3-yarn" class="headerlink" title="2.3 yarn"></a>2.3 yarn</h2><p>1）session-cluster模式</p>
<p><img src="https://i.loli.net/2021/01/06/AWiIRVxyrsTgNLE.png" alt="image-20210106200804148"></p>
<p>基于当前的yarn session会话创建的flink集群，所有提交的job都是基于当前的会话提交到同一个集群中，资源永远保持不变，如果资源满了，下一个job就无法提交，只能等到yarn中的其中一个作业执行完成后，释放了资源，下个作业才会正常提交。所有作业共享Dispatcher和ResourceManager；共享资源；适合规模小执行时间短的作业。</p>
<p>启动yarn-session</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">./yarn-session.sh -n <span class="number">2</span> -s <span class="number">2</span> -jm <span class="number">1024</span> -tm <span class="number">1024</span> -nm test -d</span><br><span class="line">其中：</span><br><span class="line">-n(--container)：<span class="type">TaskManager</span>的数量。</span><br><span class="line">-s(--slots)：	每个<span class="type">TaskManager</span>的slot数量，默认一个slot一个core，默认每个taskmanager的slot的个数为<span class="number">1</span>，有时可以多一些taskmanager，做冗余。</span><br><span class="line">-jm：<span class="type">JobManager</span>的内存（单位<span class="type">MB</span>)。</span><br><span class="line">-tm：每个taskmanager的内存（单位<span class="type">MB</span>)。</span><br><span class="line">-nm：yarn 的appName(现在yarn的ui上的名字)。 </span><br><span class="line">-d：后台执行。</span><br></pre></td></tr></table></figure>

<p>执行任务</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">/flink run -c com.atguigu.wc.<span class="type">StreamWordCount</span>  <span class="type">FlinkTutorial</span><span class="number">-1.0</span>-<span class="type">SNAPSHOT</span>-jar-<span class="keyword">with</span>-dependencies.jar</span><br></pre></td></tr></table></figure>

<p>取消yarn session</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">yarn application --kill application_1577588252906_0001</span><br></pre></td></tr></table></figure>



<p>2）per-job-cluster</p>
<p><img src="https://i.loli.net/2021/01/06/QJ8SdBlN2GZAYRc.png" alt="image-20210106200848099"></p>
<p>一个Job会对应一个集群，每提交一个作业会根据自身的情况，都会单独向yarn申请资源，直到作业执行完成，一个作业的失败不会影响到其它作业。独享Dispatcher和ResourceManager，按需接收资源申请；适合规模大长时间运行的作业。任务之间互不影响方便管理。适合大规模长时间占用资源的作用。</p>
<p>不用启动yarn-session，直接执行job</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">./flink run –m yarn-cluster -c com.atguigu.wc.<span class="type">StreamWordCount</span>  <span class="type">FlinkTutorial</span><span class="number">-1.0</span>-<span class="type">SNAPSHOT</span>-jar-<span class="keyword">with</span>-dependencies.jar</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>大数据</category>
        <category>Flink</category>
      </categories>
  </entry>
  <entry>
    <title>查看隔壁WiFi密码</title>
    <url>/2021/01/06/%E6%97%A5%E5%B8%B8%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4/%E6%9F%A5%E7%9C%8B%E9%9A%94%E5%A3%81WiFi%E5%AF%86%E7%A0%81%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>1.在cmd中输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netsh wlan show profiles "wifi名称" key=clear</span><br></pre></td></tr></table></figure>

<p>2.其中安全设置中的关键内容就是密码</p>
<p>示例：</p>
<p><img src="https://i.loli.net/2021/01/21/IRYBsHzN1L8uJ73.png" alt="image-20210121163326109"></p>
<p><img src="https://i.loli.net/2021/01/21/7Pd1cpXrngvURIe.png" alt="image-20210121163346109"></p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
  </entry>
  <entry>
    <title>登录状态的环境变量</title>
    <url>/2020/06/29/%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>登录脚本的执行顺序【注：仅适用于bash shell】</p>
<h1 id="1-Login-Shell"><a href="#1-Login-Shell" class="headerlink" title="1.Login Shell"></a>1.Login Shell</h1><p>​    是指登录时，需要提供用户名密码的shell，如 su - user1,图形登录，ctrl+alt+F2-6进入的登录界面</p>
<p>​    这种Login shell执行脚本的顺序：</p>
<p>①/etc/profile 【全局profile文件；它定义了LoginUser的PATH，USER，LOGNAME（登录使用者账号）】</p>
<p>②/etc/profile.d/目录下的脚本</p>
<p>③~/.bash_profile【搜索命令的路径——登录级别  环境变量配置文件】</p>
<p>④~/.bashrc 【存储用户设定的别名和函数—-shell级别  环境变量配置文件】</p>
<p>⑤/etc/bashrc 【全局bashrc文件；它主要定义一些Function和Alias；更改/etc/bashrc会影响到所有用户，由root用户管理】</p>
<h1 id="2-Non-Login-shell"><a href="#2-Non-Login-shell" class="headerlink" title="2.Non-Login shell"></a>2.Non-Login shell</h1><p>登录终端后，使用ssh登录其它机器</p>
<p>​    非登录shell指的是，不需要输入用户名密码的shell，如图形化界面中右键terminal打开的shell</p>
<p>​    这种Non-Login shell执行登录脚本的顺序：</p>
<p>​    ①~/.bashrc</p>
<p>​    ②/etc/bashrc    </p>
<p>​    ③/etc/profile.d/目录下的脚本</p>
<p>每次开启shell时，系统都会加载一些预先定义的脚本，这些脚本中有一些预先定义的变量！</p>
<p>可以在  用户家目录/.bashrc文件中添加：</p>
<p>source /etc/profile</p>
<p>在No-Login shell,多见于集群的群起命令，中可以读取到/etc/profile配置的变量！</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
  </entry>
  <entry>
    <title>HBase</title>
    <url>/2020/06/22/HBase/</url>
    <content><![CDATA[<h1 id="一、NoSQL简介"><a href="#一、NoSQL简介" class="headerlink" title="一、NoSQL简介"></a>一、NoSQL简介</h1><p>​    是什么？</p>
<p>​        NoSQL是Not Only SQL三个单词的缩写！目前泛指非关系型数据库！</p>
<p>​        NoSQL数据库通常是一个分布式系统，基于CAP定理设计，性能通常比关系型数据库要强悍！但是在一致性上，一般情况下，为了性能会牺牲部分一致性！大部分NoSQL都是最终一致性！</p>
<p>​        CAP定理：任何分布式系统只能在强一致性，高可用性，分区容错性中选择其中的两个优势进行开发，无法三者兼顾！</p>
<p>​        NoSQL和关系型数据库相辅相成，各自有各自的使用场景，谁也不能完全替代谁！</p>
<h1 id="二、HBase简介"><a href="#二、HBase简介" class="headerlink" title="二、HBase简介"></a>二、HBase简介</h1><h2 id="1-由来"><a href="#1-由来" class="headerlink" title="1.由来"></a>1.由来</h2><p>​    由Google的BigTable论文实现而来，是Hadoop生态的一部分！</p>
<h2 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2.介绍"></a>2.介绍</h2><p>​    HBase是一个分布式，可扩展的基于版本号的，大数据存储的NoSQL数据库！</p>
<p>​    HBase基于HDFS！</p>
<p>​    使用场景：当需要对十亿行*百万列的表，进行实时和随机读写！</p>
<h2 id="3-随机读写"><a href="#3-随机读写" class="headerlink" title="3.随机读写"></a>3.随机读写</h2><p>​    HDFS只支持追加写，不支持随机写！</p>
<p>​    insert     追加写</p>
<p>​    update+delete     随机写</p>
<p>​    实现随机写的update+delete，需要</p>
<p>​    1）借助hdfs追加操作+时间戳（版本号）</p>
<p>​    2）只允许客户端返回时间戳最新（版本号最大）的数据</p>
<h2 id="4-实时读写"><a href="#4-实时读写" class="headerlink" title="4.实时读写"></a>4.实时读写</h2><p>​    如何做到海量数据的实时读写？</p>
<p>​    1）海量数据，那必须是分布式的</p>
<p>​    2）要快，那就要借助内存，将数据不管是读还是写全部放入内存</p>
<p>​    3）同时还要用到索引     LSMtree</p>
<p>​    4）K-V结构存储</p>
<p>​    5）列式存储（HFile）</p>
<p>​    6）布隆过滤器（在查询时，判断数据库是否一定没有这条数据或者可能有这条数据）</p>
<h1 id="三、安装"><a href="#三、安装" class="headerlink" title="三、安装"></a>三、安装</h1><h2 id="1-环境要求"><a href="#1-环境要求" class="headerlink" title="1.环境要求"></a>1.环境要求</h2><p>1）安装了ZK，启动ZK</p>
<p>2）安装了Hadoop，启动HDFS</p>
<p>3）安装了JDK，配置了JAVA_HOME</p>
<h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h2><p>1）编辑conf/hbase-env.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">不适用HBase自带的zk,使用自己集群安装的</span></span><br><span class="line">export HBASE_MANAGES_ZK=false</span><br></pre></td></tr></table></figure>

<p>2）编辑hbase-site.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--hbase在hdfs上存储的根目录 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span>     </span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span>     </span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop102:9820/HBase<span class="tag">&lt;/<span class="name">value</span>&gt;</span>   </span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--是否以分布式启动hbase --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span>   </span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--hbase使用的zk实例的地址 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span>    </span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	     <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102,hadoop103,hadoop104<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--每个版本的hbase，都是基于自己的hadoop编译的 </span></span><br><span class="line"><span class="comment">	当前版本的hbase 默认对应的是 2.8.5的hadoop</span></span><br><span class="line"><span class="comment">	如果集群的hadoop不是 2.8.5，会报错兼容性问题，加上以下两个参数，否则Master进程无法启动</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	解决： 下载hbase当前版本的源码，在编译时，指定编译的hadoop环境为集群对应的版本(3.1)，就不需要加以下两个参数</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.unsafe.stream.capability.enforce<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.wal.provider<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>filesystem<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="四、启动"><a href="#四、启动" class="headerlink" title="四、启动"></a>四、启动</h1><h2 id="1-单启"><a href="#1-单启" class="headerlink" title="1.单启"></a>1.单启</h2><p>master</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase-daemon.sh start master</span><br></pre></td></tr></table></figure>

<p>regionserver</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase-daemon.sh start regionserver</span><br></pre></td></tr></table></figure>

<h2 id="2-验证启动"><a href="#2-验证启动" class="headerlink" title="2.验证启动"></a>2.验证启动</h2><p>1）jps查看</p>
<p>2）访问web页面</p>
<table>
<thead>
<tr>
<th>进程名</th>
<th>协议</th>
<th>端口</th>
</tr>
</thead>
<tbody><tr>
<td>master</td>
<td>RPC</td>
<td>16000</td>
</tr>
<tr>
<td>master</td>
<td>HTTP</td>
<td>16010</td>
</tr>
<tr>
<td>regionserver</td>
<td>RPC</td>
<td>16020</td>
</tr>
<tr>
<td>regionserver</td>
<td>HTTP</td>
<td>16030</td>
</tr>
</tbody></table>
<h2 id="3-群起"><a href="#3-群起" class="headerlink" title="3.群起"></a>3.群起</h2><p>集群通常是启动一个master，除非是HA，会启动备用的master</p>
<p>通常是regionserver希望群起多个！</p>
<p>实现：希望在哪个机器上运行群起命令，就编辑哪个机器的conf/regionservers文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/hbase-daemons.sh start regionserver</span><br></pre></td></tr></table></figure>

<h2 id="4-一键启动"><a href="#4-一键启动" class="headerlink" title="4.一键启动"></a>4.一键启动</h2><p>以下命令停止当前机器的master进程，停止所有的regionserver，以下命令在master进程所在的机器上使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stop-hbase.sh</span><br></pre></td></tr></table></figure>

<p>执行以下脚本时，会启动当前机器的master，再读取conf/regionservers，启动文件中配置的节点的regionserver!</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start-hbase.sh</span><br></pre></td></tr></table></figure>



<h1 id="五、核心概念"><a href="#五、核心概念" class="headerlink" title="五、核心概念"></a>五、核心概念</h1><p>namespace：hbase中的库，在hdfs上就是一个目录！</p>
<p>table：hbase中的表，在hdfs上就是库下的一层子目录！</p>
<p>region：region是表目录下的子目录！</p>
<p>column family：列族是region下的一层目录</p>
<p>数据：数据以文件的形式存储在列族的目录下！每个文件称为一个StoreFile！文件的格式是HFile格式！</p>
<p>​    </p>
<h1 id="六、使用HBase"><a href="#六、使用HBase" class="headerlink" title="六、使用HBase"></a>六、使用HBase</h1><h2 id="1-同步集群时间"><a href="#1-同步集群时间" class="headerlink" title="1.同步集群时间"></a>1.同步集群时间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xcall.sh sudo ntpdate -u 'ntp1.alliyun.com'</span><br></pre></td></tr></table></figure>



<h2 id="2-使用hbase-shell"><a href="#2-使用hbase-shell" class="headerlink" title="2.使用hbase shell"></a>2.使用hbase shell</h2><p>注意：1）命令后不跟分号</p>
<p>​            2）如果误输入分号，需要两下’（单引号）结束</p>
<p>​            3）help ‘命令’：查看某个命令的帮助</p>
<p>​            4）不支持中文</p>
<h1 id="七、读写流程"><a href="#七、读写流程" class="headerlink" title="七、读写流程"></a>七、读写流程</h1><h2 id="1-读流程"><a href="#1-读流程" class="headerlink" title="1.读流程"></a>1.读流程</h2><p>get可以由scan一条记录实现，其实get都会转化为scan</p>
<p>get ‘t1’,’r1’,’cf1’,’name’</p>
<p>数据可能存在以下三个地方，列族的memstore中,HFile (Store File)中，BlockCache中，读请求需要RegionServer来进行处理！</p>
<p>请求哪个regionserver？</p>
<p>①1个region对应一个regionserver，先确定要查询的数据到底在哪个region中</p>
<p>​    在查询时，根据要查询数据所在的表名，就可以查到这个表有哪些region！</p>
<p>​    再根据要查询数据的rowkey，参考region的startkey和endkey就可以确定当前数据所在的region！</p>
<p>②再找到这个region对应的regionserver</p>
<p>​    不管是region和regionserver的对应信息，还是region的startkey和endkey，这些都属于表的元数据信息，所有的元数据信息都存储在hbase:meta中</p>
<p>读流程：</p>
<p>①客户端，向hbase所在的zk集群，查询/hbase/meta-region-server,获取hbase-metab表所在的regionserver</p>
<p>②请求，hbase:meta表所在的regionserver，获取hbase中表的元数据信息，将信息缓存到客户端本地，方便之后的查询</p>
<p>③根据hbase中表的元数据信息，获取当前要查询的数据在哪个region，以及这个region对应的regionserver</p>
<p>④向regionserver发送读请求</p>
<p>⑤regionserver处理读请求，从memstore中，HFile（StoreFile）中，BlockCache中取出指定的数据，将数据合并后，只返回指定时间戳或最新时间戳的数据。</p>
<p>​    regionserver在处理读请求时，根据所查询的store，初始化两种扫描器</p>
<p>​            MemstoreScanner：负责扫描store的memstore</p>
<p>​            StoreFileScanner：负责扫描列族下的storefile文件！在扫描StoreFile文件时，先查看blockcache中返回数据，无需再扫描storefile文件！</p>
<p>​            如果blockcache中没有数据，只能扫描storefile，将扫描到的数据放入到blockcache,供下次查询！</p>
<p>​            blockcache默认占用Regionserver所在堆的40%，blockcache默认会采用LRU(less recent use)的回收策略</p>
<p>，对符合条件的对象进行回收！blockcache在storefile中的数据更新时，缓存也会自动失效！</p>
<h2 id="2-写流程"><a href="#2-写流程" class="headerlink" title="2.写流程"></a>2.写流程</h2><h3 id="2-1写流程概述"><a href="#2-1写流程概述" class="headerlink" title="2.1写流程概述"></a>2.1写流程概述</h3><p>put ‘t1’,’r1’,’cf1:name’,”jack”</p>
<p>①数据要写入哪个region</p>
<p>②这个region由哪个regionserver</p>
<p>写流程：</p>
<p>①客户端，向hbase所在的zk集群，查询/hbase/meta-region-server，获取hbase-meta表所在的regionserver</p>
<p>②请求，hbase:meta表所在regionserver，获取hbase中表的元数据信息，将信息缓存到客户端本地，方便之后的查询</p>
<p>③根据hbase中表的元数据信息，获取当前要写的数据要写入哪个region，以及这个region对应的regionserver</p>
<p>④向regionserver发送写请求</p>
<p>⑤写请求会被当前regionserver的wal对象，将写的信息持久化到wal Logs中</p>
<p>⑥将数据写入到指定region所对应的store对象的memstore中</p>
<p>⑦响应客户端，写入完成！</p>
<h3 id="2-2-写流程源码"><a href="#2-2-写流程源码" class="headerlink" title="2.2 写流程源码"></a>2.2 写流程源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doMiniBatchMutate</span><span class="params">(BatchOperation&lt;?&gt; batchOp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// STEP 1. 尝试获取尽可能多的写入操作需要使用的锁</span></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      <span class="comment">// STEP 2.如果插入的value没有指定时间戳，尝试使用服务器(regionserver所在机器)上最新的时间戳作为value的时间戳</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">      <span class="comment">// STEP 3. 构建一个WAL Edit对象</span></span><br><span class="line">     </span><br><span class="line">      <span class="comment">// STEP 4. 将最新的写操作的信息，封装到一个WALEdit对象中，将对象追加到</span></span><br><span class="line">        <span class="comment">// WALEdits集合中，再sync(将对象中的数据持久化到磁盘的log文件中).</span></span><br><span class="line">     </span><br><span class="line">      <span class="comment">// STEP 5. 将数据写入到列族的memstore中</span></span><br><span class="line">      <span class="comment">// <span class="doctag">NOTE:</span> writeEntry can be null here</span></span><br><span class="line">      writeEntry = batchOp.writeMiniBatchOperationsToMemStore(miniBatchOp, writeEntry);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// STEP 6. CP ： Cooprocessor（协处理器，类似Mysql中的触发器）</span></span><br><span class="line">        <span class="comment">// 在最后，WAL对象sync操作(将数据持久化到磁盘时),如果发生错误，就执行后续处理</span></span><br><span class="line">       </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h1 id="八、hbase的其它操作"><a href="#八、hbase的其它操作" class="headerlink" title="八、hbase的其它操作"></a>八、hbase的其它操作</h1><h2 id="1-flush"><a href="#1-flush" class="headerlink" title="1.flush"></a>1.flush</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>flush：将memstore中的数据，刷写到StoreFile文件中</p>
<h3 id="1-2-意义"><a href="#1-2-意义" class="headerlink" title="1.2 意义"></a>1.2 意义</h3><p>①memstore将写入的数据缓存在内存中，一旦内存满了，一定要刷写</p>
<p>②在刷写时，hbase还会将一些无用的数据，进行舍弃，节省磁盘空间</p>
<p>③在刷写时，还会对memstore中的rowkey进行排序，方面后面检索</p>
<p>列族的{NAME =&gt; ‘cf1’,VERSIONS=’3’}属性，代表每个StoreFile中最多存3个版本</p>
<h3 id="1-3-手动刷写"><a href="#1-3-手动刷写" class="headerlink" title="1.3 手动刷写"></a>1.3 手动刷写</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush &#39;表名&#39;</span><br><span class="line">flush &#39;region&#39;</span><br></pre></td></tr></table></figure>

<p>通过以下命令查看书写的HFile文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase org.apache.hadoop.hbase.io.hfile.HFile -p -f ‘hdfs路径’</span><br></pre></td></tr></table></figure>

<h3 id="1-4自动刷写"><a href="#1-4自动刷写" class="headerlink" title="1.4自动刷写"></a>1.4自动刷写</h3><h4 id="①基于memstore的刷写"><a href="#①基于memstore的刷写" class="headerlink" title="①基于memstore的刷写"></a>①基于memstore的刷写</h4><p>​    当某个memstore的大小达到了hbase.hregion.memstore.flush.size(默认128M)，其所在region的所有memstore都会被刷写。</p>
<p>​    这也是HBase不建议设置过多列族的原因之一，因为列族过多，刷写时，系统的IO压力越大！</p>
<p>​    当memstore的大小达到了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase.hregion.memstore.flush.size（默认值128M）</span><br><span class="line">*</span><br><span class="line">hbase.hregion.memstore.block.multiplier（默认值4）</span><br></pre></td></tr></table></figure>

<p>时，会阻止继续往该memstore写数据</p>
<h4 id="②基于RegionServer的刷写"><a href="#②基于RegionServer的刷写" class="headerlink" title="②基于RegionServer的刷写"></a>②基于RegionServer的刷写</h4><p>一旦一个RegionServer所负责的多个region的memstore的总大小总和超过以下值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java_heapsize</span><br><span class="line">*hbase.regionserver.global.memstore.size（默认值0.4）</span><br><span class="line">*hbase.regionserver.global.memstore.size.lower.limit（默认值0.95）</span><br></pre></td></tr></table></figure>

<p>整个RegionServer所负责的所有memstore由大到小，依次刷写，直到低于上述值</p>
<p>当一个RegionServer所负责的多个Region的memstore大小总和超过以下值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java_heapsize</span><br><span class="line">*hbase.regionserver.global.memstore.size（默认值0.4）</span><br></pre></td></tr></table></figure>

<p>当前regionserver的所有memstore都会阻塞</p>
<h4 id="③基于默认刷写时间的刷写"><a href="#③基于默认刷写时间的刷写" class="headerlink" title="③基于默认刷写时间的刷写"></a>③基于默认刷写时间的刷写</h4><p>默认每</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase.regionserver.optionalcacheflushinterval（默认1小时）</span><br></pre></td></tr></table></figure>

<h4 id="④基于wal文件的刷写"><a href="#④基于wal文件的刷写" class="headerlink" title="④基于wal文件的刷写"></a>④基于wal文件的刷写</h4><p>​    当前wal文件的数量超过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase.regionserver.max.logs</span><br></pre></td></tr></table></figure>

<p>​    也会触发memstore的刷写！</p>
<h2 id="2-Compaction"><a href="#2-Compaction" class="headerlink" title="2.Compaction"></a>2.Compaction</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>​    HBase需要借助hdfs进行存储！数据以HFile(StoreFile)的形式存储在hdfs上！</p>
<p>​    HDFS不适合存储大量的小文件，会降低NameNode服役能力！</p>
<p>现象：每次flush，都会生成一个文件，不是所有memstore flush时，都是满足128M才触发的！</p>
<p>解决：hbase会定期自动执行compact合并，将多个小文件，合并重写为1个文件！</p>
<h3 id="2-2-分类"><a href="#2-2-分类" class="headerlink" title="2.2 分类"></a>2.2 分类</h3><p>minorCompaction: 小合并</p>
<p>majorCompaction: 主合并</p>
<p>majorCompaction会将整个列族目录中所有的StoreFile都进行运算，合并，并且会清理掉过期和删除的数据！</p>
<p>minorCompaction每次只会合并一定数量（默认是10个）的HFile合并成一个较大HFile，但不会清理过期和删除的数据！</p>
<h3 id="2-3-手动合并"><a href="#2-3-手动合并" class="headerlink" title="2.3 手动合并"></a>2.3 手动合并</h3><p>minorcompact</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compact</span><br></pre></td></tr></table></figure>

<p>majorcompact</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">major_compact</span><br></pre></td></tr></table></figure>



<h2 id="3-RegionSplit"><a href="#3-RegionSplit" class="headerlink" title="3.RegionSplit"></a>3.RegionSplit</h2><p>​    每张表，一开始只有一个region，一旦region中的数据，不断增多，达到一定条件，hbase会自动切割region!切割后，将region一分为二，将region交给不同的regionserver，目的是负载均衡！</p>
<p>​    当前2.2.4使用org.apache.hadoop.hbase.regionserver.SteppingSplitPolicy作为切分策略！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">getSizeToCheck</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> tableRegionsCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tableRegionsCount == <span class="number">1</span>  ? <span class="keyword">this</span>.initialSize : getDesiredMaxFileSize();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​    regionserver调用getSizeToChec()，来检查当前region是否达到切分的条件！</p>
<p>​    tableRegionsCount： 为当前Region Server中属于该Table的region的个数。</p>
<p>​        策略： 如果当前Region Server中属于该Table的region的个数为1，那么一旦这个region大小达到initialSize时，就切分。否则，只要Region Server中属于该Table的region的个数不为1，那么就尝试获取hbase.hregion.max.filesize所配置的参数值，如果没有配置，默认为10G。</p>
<p>initialSize如何确定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureForRegion</span><span class="params">(HRegion region)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.configureForRegion(region);</span><br><span class="line">    Configuration conf = getConf();</span><br><span class="line">    <span class="comment">//从配置中读取hbase.increasing.policy.initial.size，如果没有配置，默认为-1</span></span><br><span class="line">    <span class="comment">// 如果用户配置了此参数， initialSize=用户定义的值</span></span><br><span class="line">    initialSize = conf.getLong(<span class="string">"hbase.increasing.policy.initial.size"</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (initialSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取region对应的表的描述</span></span><br><span class="line">    TableDescriptor desc = region.getTableDescriptor();</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取表memstore刷写的大小 * 2 </span></span><br><span class="line">      initialSize = <span class="number">2</span> * desc.getMemStoreFlushSize();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果自己配的值非法</span></span><br><span class="line">    <span class="keyword">if</span> (initialSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 重新赋值为2*128M</span></span><br><span class="line">      initialSize = <span class="number">2</span> * conf.getLong(HConstants.HREGION_MEMSTORE_FLUSH_SIZE,</span><br><span class="line">                                     TableDescriptorBuilder.DEFAULT_MEMSTORE_FLUSH_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>initialSize 如果不定义，默认就为256M！</p>
<p>T3表，一开始只有1个Region,由regionserver 102 负责，</p>
<p>一旦这个region，默认在256M时，一分为二。</p>
<p>情形一： region1 由102负责</p>
<p>​                region2 由103负责</p>
<p>​        下次102的region1达到256M,再自动切分！</p>
<p>情形二： region1 由102负责</p>
<p>​                region2 由102负责</p>
<p>​        下次region1 /region2 其中一个达到10G时，再切分！</p>
<h1 id="九、API"><a href="#九、API" class="headerlink" title="九、API"></a>九、API</h1><h2 id="1-Connection"><a href="#1-Connection" class="headerlink" title="1.Connection"></a>1.Connection</h2><p>​    Connection会产生一个低级别的直连hbase的连接，还包含一个连接zk集群的连接</p>
<p>可以通过以下方式创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection connection = ConnectionFactory.createConnection(configuration);</span><br></pre></td></tr></table></figure>

<p>​    Connection的生命周期由调用者管理，执行close关闭连接，释放资源！</p>
<p>​    Connection可以自动连接master，定位region等！这些功能以及集群的连接，可以被Connection创建出的Table和Admin实例共享！</p>
<p>​    Connection的创建是重量级的，不建议经常创建，通常一个客户端创建一次即可！Connection是线程安全的，可以在不同的线程中共享一个实例！</p>
<p>​    Admin和Table是轻量级的，不是线程安全的，因此每个线程都有自己的Table和Admin对象，不建议池化或缓存！</p>
<h2 id="2-Table"><a href="#2-Table" class="headerlink" title="2.Table"></a>2.Table</h2><p>​    Table是和hbase的某个表进行交流的实例，可以使用Table对象，进行put，get，scan，delete等操作！</p>
<p>​    获取Table：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection.getTable()</span><br></pre></td></tr></table></figure>

<p>​    关闭：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Table.close()</span><br></pre></td></tr></table></figure>

<h2 id="3-Admin"><a href="#3-Admin" class="headerlink" title="3.Admin"></a>3.Admin</h2><p>​    Admin负责进行list,create,alter,enable等管理性的操作</p>
<p>​    创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection.getAdmin()</span><br></pre></td></tr></table></figure>

<p>​    关闭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Admin.close()</span><br></pre></td></tr></table></figure>

<h2 id="4-NameSpaceDescriptor"><a href="#4-NameSpaceDescriptor" class="headerlink" title="4.NameSpaceDescriptor"></a>4.NameSpaceDescriptor</h2><p>​    NameSpaceDescriptor代表一个namespace的描述对象，这个对象中记录了NameSpace所有的属性，例如库名，库的属性等！</p>
<h2 id="5-HTableDescriptor"><a href="#5-HTableDescriptor" class="headerlink" title="5.HTableDescriptor"></a>5.HTableDescriptor</h2><p>​    HTableDescriptor代表了一个表的描述！</p>
<h1 id="十、整合Hive"><a href="#十、整合Hive" class="headerlink" title="十、整合Hive"></a>十、整合Hive</h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h2><p>HBase:本质是数据库，主要用于大表的实时读写</p>
<p>Hive：数据仓库中的数据分析软件，将HQL语句翻译为Map Reduce程序，对HDFS上已经存储的结构化数据进行计算！计算之前，需要根据HDFS上数据的形态进行建表映射！</p>
<p>Hive和HBase集成的目的是，使用Hive来分析HBase存储的数据</p>
<p>HBase本质上是一个NoSQL数据库，不支持使用SQL进行查询，数据分析工程师最熟悉和最常使用的就是SQL！如果没有Hive，可以自己编写MR程序对HBase上的数据进行一些复杂逻辑的分析！</p>
<h2 id="2-配置环境"><a href="#2-配置环境" class="headerlink" title="2.配置环境"></a>2.配置环境</h2><p>​    Hive默认只能分析HDFS上的数据，现在需要让Hive可以可以访问HBase！Hive作为客户端，读写HBase的数据，需要使用ZK信息。在hive-site.xml中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102,hadoop103,hadoop104<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>The list of ZooKeeper servers to talk to. This is only needed for read/write locks.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.zookeeper.client.port<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>The port of ZooKeeper servers to talk to. This is only needed for read/write locks.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3.使用场景"></a>3.使用场景</h2><h3 id="3-1-场景一"><a href="#3-1-场景一" class="headerlink" title="3.1 场景一"></a>3.1 场景一</h3><p>​    还没有将数据导入到hbase中，需要通过hive，将数据导入到hbase中！</p>
<p>​    建表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TABLE</span> ns2_person(</span><br><span class="line"> <span class="keyword">id</span> <span class="keyword">string</span>,</span><br><span class="line"> age <span class="built_in">int</span>,</span><br><span class="line"> <span class="keyword">name</span> <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">STORED</span> <span class="keyword">BY</span> <span class="string">'org.apache.hadoop.hive.hbase.HBaseStorageHandler'</span></span><br><span class="line"><span class="keyword">WITH</span> SERDEPROPERTIES (<span class="string">"hbase.columns.mapping"</span> = <span class="string">":key,info:age,cf1:name"</span>)</span><br><span class="line">TBLPROPERTIES (<span class="string">"hbase.table.name"</span> = <span class="string">"ns2:person"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-2-场景2"><a href="#3-2-场景2" class="headerlink" title="3.2 场景2"></a>3.2 场景2</h3><p>​    数据已经导入到hbase中，只需要在Hive上建表，映射，在hive上操作数据！</p>
<p>建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> ns2_t2(</span><br><span class="line"> <span class="keyword">id</span> <span class="keyword">string</span>,</span><br><span class="line"> age <span class="built_in">int</span>,</span><br><span class="line"> <span class="keyword">name</span> <span class="keyword">string</span>,</span><br><span class="line"> <span class="keyword">num</span> <span class="built_in">int</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">STORED</span> <span class="keyword">BY</span> <span class="string">'org.apache.hadoop.hive.hbase.HBaseStorageHandler'</span></span><br><span class="line"><span class="keyword">WITH</span> SERDEPROPERTIES (<span class="string">"hbase.columns.mapping"</span> = <span class="string">":key,cf1:age,cf1:name,cf1:num"</span>)</span><br><span class="line">TBLPROPERTIES (<span class="string">"hbase.table.name"</span> = <span class="string">"ns2:t2"</span>);</span><br></pre></td></tr></table></figure>



<p>注意：①hive的表名可以任意</p>
<p>​            ②hive中列的数量要和hbase表列的数据一致（rowkey是一个特殊的列）</p>
<p>​            ③hive中字段的数据类型，必须和hbase中的数据类型兼容</p>
<p>​            ④stored by ‘类名’是固定写法。stored by的含义是使用指定的类帮助完成数据的读写</p>
<p>​            ⑤hbase.columns.mapping代表hbase和hive中表字段的关系映射</p>
<p>​                hive中字段的顺序，要和映射关系中映射的字段顺序一致</p>
<p>​            ⑥hbase.table.name代表hive表要映射的hbase表的表名</p>
<p>​            ⑦目前的数据是存储在hbase上，如果是内部表，代表hive负责数据的生命周期。只能创建外部表</p>
<p>本地表和非本地表</p>
<p>​    本地表：hive表中的数据是直接存储在hdfs上，可以指定row format,指定store as</p>
<p>​    非本地表：hive表中的数据不是直接存储在hdfs上</p>
<p>​        不能写row format,不能写store as ,因为不同的存储设备对存储的格式是有不同的要求的，需要写 store by ‘类名’（这个类名，如果是去hbase中读取数据，就写hbase相应的类名，如果是去kafka中读数据，就写kafka对应的类名）</p>
<h1 id="十一、优化"><a href="#十一、优化" class="headerlink" title="十一、优化"></a>十一、优化</h1><h1 id="十二、Phoenix"><a href="#十二、Phoenix" class="headerlink" title="十二、Phoenix"></a>十二、Phoenix</h1><h2 id="1-表关系映射"><a href="#1-表关系映射" class="headerlink" title="1.表关系映射"></a>1.表关系映射</h2><table>
<thead>
<tr>
<th>Phoenix</th>
<th>HBase</th>
</tr>
</thead>
<tbody><tr>
<td>database</td>
<td>namespace</td>
</tr>
<tr>
<td>table</td>
<td>table</td>
</tr>
<tr>
<td>主键列</td>
<td>rowkey</td>
</tr>
<tr>
<td>其它列</td>
<td>cf:cq</td>
</tr>
</tbody></table>
<p>如果Phoenix中的主键是联合主键，联合主键整体拼接后和hbase的rowkey映射！</p>
<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><p>第一种情形：数据还没有在hbase中存储，希望通过Phoenix来创建一个表，使用Phoenix的语句向表中插入数据！</p>
<p>建表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> us_population(</span><br><span class="line">state <span class="built_in">char</span>(<span class="number">2</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">city <span class="built_in">varchar</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">population <span class="built_in">bigint</span>,</span><br><span class="line"><span class="keyword">constraint</span> my_pk primary <span class="keyword">key</span>(state,city)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>操作：</p>
<p>增/改：</p>
<p>upsert into us_population values(‘NY’,’abc’,10000);</p>
<p>删：</p>
<p>delete from us_population where population &gt; 10000;</p>
<p>查：</p>
<p>select * from us_population;</p>
<p>注意：</p>
<p>sqlline.py默认会将小写自动转为大写！如果不希望转换，可使用双引号！</p>
<p>如果在建表时，没有指定列族，hbase会自动创建名称为0的列族！</p>
<p>第二种情形：数据已经在hbase中（有表），希望通过Phoenix创建一个表来映射HBase中的表，执行操作！</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>大数据</category>
        <category>HBase</category>
      </categories>
  </entry>
  <entry>
    <title>kafka</title>
    <url>/2020/06/10/kafka/</url>
    <content><![CDATA[<h3 id="第1章-kafka概述"><a href="#第1章-kafka概述" class="headerlink" title="第1章 kafka概述"></a>第1章 kafka概述</h3><h4 id="1-1-kafka的定义"><a href="#1-1-kafka的定义" class="headerlink" title="1.1 kafka的定义"></a>1.1 kafka的定义</h4><p>​    kafka是一个分布式的基于发布/订阅模式的消息队列，主要应用于大数据实时处理领域。</p>
<h4 id="1-2-消息队列"><a href="#1-2-消息队列" class="headerlink" title="1.2 消息队列"></a>1.2 消息队列</h4><h4 id="1-3-kafka基础架构"><a href="#1-3-kafka基础架构" class="headerlink" title="1.3 kafka基础架构"></a>1.3 kafka基础架构</h4><h5 id="1-3-1-重点综述"><a href="#1-3-1-重点综述" class="headerlink" title="1.3.1 重点综述"></a>1.3.1 重点综述</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）kafka集群</span><br><span class="line">	kafka集群可以有N台奇迹，每台称之为broker，每台机器都有自己的id，因此kafka集群中的N机器为：broker1,broker2,broker3...brokern</span><br><span class="line">2）Topic</span><br><span class="line">	kafka集群中可以创建N个Topic</span><br><span class="line">	每个Topic可以有多个分区（partition）</span><br><span class="line">	每个topic的每个分区可以有多个副本（replication），一个是leader，其它副本都是follower</span><br><span class="line">	同一个topic的多个分区可以存在于kafka集群的一个机器，但是同一个topic的同一个分区的多个副本不能存在于kafka集群的一个机器上</span><br><span class="line"></span><br><span class="line">3）消费者组</span><br><span class="line">	kafka是以消费者组为单位进行消息消费的</span><br><span class="line">	一个消费者组可以有一个或多个消费者</span><br><span class="line">4）Topic和消费者组</span><br><span class="line">	一个消费者组中的一个消费者可以同时消费一个topic中的多个分区的数据		</span><br><span class="line">	一个topic中的一个分区只能被同一个消费者组中的一个消费者消费</span><br><span class="line">	但是可以同时被多个消费者组中的一个消费者消费</span><br><span class="line">5）zookeeper</span><br><span class="line">	kafka集群工作需要基于zk</span><br><span class="line">	kafka的topic，partition，热评里餐厅等需要存储在zk中</span><br><span class="line">	在kafka0.9版本之前，消费者组的offset（消息队列读取消息的偏移量）也需要维护在zk中</span><br><span class="line">	但是0.9版本之后建议维护到kafka本地，当前2.4.1版本中已经不再支持zk维护offset</span><br></pre></td></tr></table></figure>



<h3 id="第2章-kafka架构深入"><a href="#第2章-kafka架构深入" class="headerlink" title="第2章 kafka架构深入"></a>第2章 kafka架构深入</h3><h4 id="2-1-kafka工作流程及文件存储机制"><a href="#2-1-kafka工作流程及文件存储机制" class="headerlink" title="2.1 kafka工作流程及文件存储机制"></a>2.1 kafka工作流程及文件存储机制</h4><p>​    Kafka中消息是以<strong>topic</strong>进行分类的，生产者生产消息，消费者消费消息，都是面向topic的。</p>
<p>​    topic是逻辑上的概念，而partition是物理上的概念，每个对应于一个目录，该目录中存储的就是生产的数据。生产的数据会被不断追加到该文件末端，且每条数据都有自己的。消费者组中的每个消费者，都会实时记录自己消费到了哪个，以便出错恢复时，从上次的位置继续消费。</p>
<p>​    由于生产者生产的消息会不断追加到log文件末尾，为防止log文件过大导致数据定位效率低下，Kafka采取了<strong>分片</strong>和<strong>索引</strong>机制，将每个partition分为多个segment。每个segment对应两个文件——“.index”文件和“.log”文件。这些文件位于一个文件夹下，该文件夹的命名规则为：topic名称+分区序号。例如，first这个topic有三个分区，则其对应的文件夹为first-0,first-1,first-2。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000000000000000.index</span><br><span class="line">00000000000000000000.log</span><br><span class="line">00000000000000170410.index</span><br><span class="line">00000000000000170410.log</span><br><span class="line">00000000000000239430.index</span><br><span class="line">00000000000000239430.log</span><br></pre></td></tr></table></figure>

<p>​    index和log文件以当前segment的第一条消息的offset命名。 “.index”文件存储大量的索引信息，“.log”文件存储大量的数据，索引文件中的元数据指向对应数据文件中message的物理偏移地址。  </p>
<h4 id="2-2-kafka生产者"><a href="#2-2-kafka生产者" class="headerlink" title="2.2 kafka生产者"></a>2.2 kafka生产者</h4><h5 id="2-2-1-分区策略"><a href="#2-2-1-分区策略" class="headerlink" title="2.2.1 分区策略"></a>2.2.1 分区策略</h5><p>1）分区的原因</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）方便在集群中扩展。topic是由多个分区组成的，分区是可以扩展的，因此整个集群就可以适应任意大小的数据了</span><br><span class="line">（2）可以提高并发。因为一个topic可以有partition组成，那么一个消费者组就可以同时对一个topic的不同分区进行消费了</span><br></pre></td></tr></table></figure>



<p>2）分区的原则</p>
<p>​    首先在producer发送数据的时候需要先将数据封装为一个ProducerRecorder对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）在构造ProducerRecord对象(topic,partition,value)  &#x2F; (topic,partition,key,value)</span><br><span class="line">	因为具体指定过partition, 消息会发布到指定的partition中.</span><br><span class="line">        </span><br><span class="line">（2）在构造ProducerRecord对象(topic,key,value)</span><br><span class="line">	没有具体指定partition,但是提供了key, kafka会按照key的hash值对partition的个数取余，</span><br><span class="line">	得出当前消息发布到哪个partition</span><br><span class="line">（3）在构造ProducerRecord对象(topic,value)</span><br><span class="line">        在老版本中:  第一次随机生成一个数字N，对partition的个数取余，得出发布到哪个partition，后续每次会执行N++的操作，再对partition的个数取余，得出发布到哪个partition。实际上就是轮询的效果.</span><br><span class="line">该效果在老版本中是通过DefaultPartition类来实现的.在当前版本中,是通过RoundRobinPartitioner类实现的.</span><br><span class="line"></span><br><span class="line">        在当前版本中:   既没有 partition 值又没有 key 值的情况下， kafka采用Sticky Partition(黏性分区器)，会随机一个分区, 然后尽可能一直使用该分区，待该分区的缓冲区(batch)满或者 超过指定时间后，会重新随机一个分区来使用.该效果在当前版本中是通过DefaultPartition类来实现的</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-数据可靠性保证"><a href="#2-2-2-数据可靠性保证" class="headerlink" title="2.2.2 数据可靠性保证"></a>2.2.2 数据可靠性保证</h5><p>1）生产者发送数据到topic partition的可靠性保证</p>
<p>​    为保证producer发送的数据，能可靠的发送到指定的topic，topic的每个partition收到producer发送的数据后，都需要向producer发送ack（acknowledgement确认收到），如果producer收到ack，就会进行下一轮的发送，否则重新发送数据。</p>
<p>2）Topic partition存储数据的可靠性保证</p>
<p>（1）<strong>副本数据同步策略</strong></p>
<table>
<thead>
<tr>
<th><strong>方案</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>半数以上完成同步，就发送ack</strong></td>
<td>延迟低</td>
<td>选举新的leader时，容忍n台节点的故障，需要2n+1个副本</td>
</tr>
<tr>
<td><strong>全部完成同步，才发送ack</strong></td>
<td>选举新的leader时，容忍n台节点的故障，需要n+1个副本</td>
<td>延迟高</td>
</tr>
</tbody></table>
<p>Kafka选择了第二种方案，原因如下：</p>
<p>​    （a）同样为了容忍n台节点的故障，第一种方案需要2n+1个副本，而第二种方案只需要n+1个副本，而Kafka的每个分区都有大量的数据，第一种方案会造成大量数据的冗余。</p>
<p>​    （b）虽然第二种方案的网络延迟会比较高，但网络延迟对Kafka的影响较小。</p>
<p>（2）ISR</p>
<p>​    采用第二种方案之后，设想以下情景：leader收到数据，所有follower都开始同步数据，但有一个follower，因为某种故障，迟迟不能与leader进行同步，那leader就要一直等下去，直到它完成同步，才能发送ack。这个问题怎么解决呢？</p>
<p>​    Leader维护了一个动态的，意为和保持同步的集合。当中的完成数据的同步之后，就会给发送。如果长时间未向同步数据，则该将被踢出，该时间阈值由参数设定。发生故障之后，就会从中选举新的。</p>
<p>（3）ack应答机制</p>
<p>​    对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失，所以没必要等ISR中的follower全部接收成功。  </p>
<p>​    所以Kafka为用户提供了<strong>三种可靠性级别，</strong>用户根据对可靠性和延迟的要求进行权衡，选择以下的配置。</p>
<p><strong><em>ack的参数配置</em></strong></p>
<p><strong>acks</strong>：</p>
<p>0：这一操作提供了一个最低的延迟，partition的leader接收到消息还没有写入磁盘就已经返回ack，当leader故障时有可能丢失数据（返回ack后在将数据写入磁盘前故障了，数据就丢失了，但是producer收到了ack就会以为收到了不会再发了）；</p>
<p>1： partition的leader落盘成功后返回ack，如果在follower同步成功之前leader故障，那么将会丢失数据（在follow同步leader的数据前leader故障了，会重新选举leader，之前的还未同步的数据就丢失了）；</p>
<p>-1（all）： partition的leader和follower全部落盘成功后才返回ack。但是如果在follower同步完成后，broker发送ack之前，leader发生故障，那么会造成<strong>数据重复</strong>。（数据全部落盘了，leader返回ack之前，leader故障，producer未收到应答，则会重新发送数据，则会造成数据重复）</p>
<p>3）leader和follower故障处理细节</p>
<p>​    首先有两个概念：LEO(Log End Offset)是指每个副本中的最后一个offset，HW(High Watermark)是值所有副本中最小的LEO，HW之前的数据才对Consumer可见</p>
<p><strong>LEO</strong>：指的是每个副本最大的offset；</p>
<p><strong>HW</strong>：指的是消费者能见到的最大的offset，ISR队列中最小的LEO。</p>
<p>（1）follower故障</p>
<p>follower发生故障后会被临时踢出ISR，待该follower恢复后，follower会读取本地磁盘记录的上次的HW，并将log文件高于HW的部分截取掉，从HW开始向leader进行同步。等该<strong>follower**</strong>的LEO<strong><strong>大于等于该Partition</strong></strong>的HW**，即follower追上leader之后，就可以重新加入ISR了。</p>
<p>（2）leader故障</p>
<p>leader发生故障之后，会从ISR中选出一个新的leader，之后，为保证多个副本之间的数据一致性，其余的follower会先将各自的log文件高于HW的部分截掉，然后从新的leader同步数据。</p>
<p>注意：这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</p>
<h5 id="2-2-3-Exactly-Once语义"><a href="#2-2-3-Exactly-Once语义" class="headerlink" title="2.2.3 Exactly Once语义"></a>2.2.3 Exactly Once语义</h5><p>​    将服务器的ACK级别设置为-1，可以保证Producer到Server之间不会丢失数据，即At Least Once语义。相对的，将服务器ACK级别设置为0，可以保证生产者每条消息只会被发送一次，即At Most Once语义。</p>
<p>​    At Least Once可以保证数据不丢失，但是不能保证数据不重复；相对的，At Least Once可以保证数据不重复，但是不能保证数据不丢失。但是，对于一些非常重要的信息，比如说交易数据，下游数据消费者要求数据既不重复也不丢失，即Exactly Once语义。在0.11版本以前的Kafka，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。</p>
<p>0.11版本的Kafka，引入了一项重大特性<strong>：幂等性</strong>。所谓的幂等性就是指Producer不论向Server发送多少次重复数据，Server端都只会持久化一条。幂等性结合At Least Once语义，就构成了Kafka的Exactly Once语义。即：<strong>At Least Once +</strong> <strong>幂等性 = Exactly Once</strong></p>
<p>​    要启用幂等性，只需要将Producer的参数中<strong>enable.idompotence</strong>设置为true即可。Kafka的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的Producer在初始化的时候会被分配一个PID，发往同一Partition的消息会附带Sequence Number。而Broker端会对&lt;PID, Partition, SeqNumber&gt;做缓存，当具有相同主键的消息提交时，Broker只会持久化一条。</p>
<p>​    但是PID重启就会变化，同时不同的Partition也具有不同主键，所以幂等性无法保证跨分区跨会话的Exactly Once（可以通过事务来解决这个问题）。</p>
<h4 id="2-3-kafka消费者"><a href="#2-3-kafka消费者" class="headerlink" title="2.3 kafka消费者"></a>2.3 kafka消费者</h4><h5 id="2-3-1-消费方式"><a href="#2-3-1-消费方式" class="headerlink" title="2.3.1 消费方式"></a>2.3.1 消费方式</h5><p>​    consumer采用pull（拉）模式从broker中读取数据。</p>
<p>​    push（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。它的目标是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而pull模式则可以根据consumer的消费能力以适当的速率消费消息。</p>
<p>​    pull模式不足之处是，如果kafka没有数据，消费者可能会陷入循环中，一直返回空数据。针对这一点，Kafka的消费者在消费数据时会传入一个时长参数timeout，如果当前没有数据可供消费，consumer会等待一段时间之后再返回，这段时长即为timeout。</p>
<h5 id="2-3-2-分区分配策略"><a href="#2-3-2-分区分配策略" class="headerlink" title="2.3.2 分区分配策略"></a>2.3.2 分区分配策略</h5><p>​    一个consumer group中有多个consumer，一个 topic有多个partition，所以必然会涉及到partition的分配问题，即确定那个partition由哪个consumer来消费。</p>
<p>​    Kafka有两种分配策略，一种是RoundRobin，一种是Range。</p>
<h5 id="2-3-3-offset的维护"><a href="#2-3-3-offset的维护" class="headerlink" title="2.3.3 offset的维护"></a>2.3.3 offset的维护</h5><p>​    由于consumer在消费过程中可能会出现断电宕机等故障，consumer恢复后，需要从故障前的位置的继续消费，所以consumer需要实时记录自己消费到了哪个offset，以便故障恢复后继续消费。</p>
<p>​    Kafka 0.9版本之前，consumer默认将offset保存在Zookeeper中，从0.9版本开始，consumer默认将offset保存在Kafka一个内置的topic中，该topic为<strong>__consumer_offsets</strong>。</p>
<h4 id="2-4-kafka高效读数据"><a href="#2-4-kafka高效读数据" class="headerlink" title="2.4 kafka高效读数据"></a>2.4 kafka高效读数据</h4><h4 id="2-5-Zookeeper在kafka中的作用"><a href="#2-5-Zookeeper在kafka中的作用" class="headerlink" title="2.5 Zookeeper在kafka中的作用"></a>2.5 Zookeeper在kafka中的作用</h4><h4 id="2-6-kafka事务"><a href="#2-6-kafka事务" class="headerlink" title="2.6 kafka事务"></a>2.6 kafka事务</h4><p>​    Kafka从0.11版本开始引入了事务支持。事务可以保证Kafka在Exactly Once语义的基础上，生产和消费可以跨分区和会话，要么全部成功，要么全部失败。</p>
<h5 id="2-6-1-Producer事务"><a href="#2-6-1-Producer事务" class="headerlink" title="2.6.1 Producer事务"></a>2.6.1 Producer事务</h5><p>​    为了实现跨分区会话的事务，需要引入一个全局唯一的TranactionID，并将Producer获得的PID和Tranaction ID绑定。这样当Producer重启后就可以通过正在进行的Transaction ID获得原来的PID。</p>
<p>​    为了管理Tranaction，Kafka引入了一个新的组件Tranaction Coordinator。Producer就是通过和Tranaction Coordinator交互获得Tranaction ID对应的任务状态。Tranaction Coordinator还负责将事务所有写入kafka的一个内部Topic，这样，即使重启，由于事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。</p>
<h5 id="2-6-2-Consumer事务（精准一次性消费）"><a href="#2-6-2-Consumer事务（精准一次性消费）" class="headerlink" title="2.6.2 Consumer事务（精准一次性消费）"></a>2.6.2 Consumer事务（精准一次性消费）</h5><p>​    上述事务机制主要是从Producer方面考虑，对于Consumer而言，事务的保证就会相对较弱，尤其时无法保证Commit的信息被精确消费。这是由于Consumer可以通过offset访问任意信息，而且不同的Segment File生命周期不同，同一事务的消息可能会出现重启后被删除的情况。</p>
<p>​    如果想完成Consumer端的精准一次性消费，那么需要kafka消费端将消费过程和提交offset过程做原子绑定（如果在消费了数据后提交offset的时候consumer故障了，那offset未提交成功，可能后面就会导致重新消费，所以需要将消费过程和提交offset的过程做原子绑定）。此时我们需要将kafka的offset保存到支持事务的自定义介质（比如mysql）。这部分知识会在后续项目部分涉及。</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Kafka</category>
      </categories>
  </entry>
  <entry>
    <title>flume</title>
    <url>/2020/06/08/flume/</url>
    <content><![CDATA[<h3 id="第1章-flume概述"><a href="#第1章-flume概述" class="headerlink" title="第1章 flume概述"></a>第1章 flume概述</h3><h4 id="1-1-Flume定义"><a href="#1-1-Flume定义" class="headerlink" title="1.1 Flume定义"></a>1.1 Flume定义</h4><p>​    Flume是Cloudera提供的一个高可用的，高可靠的，分布式的海量日志采集，聚合和传输的系统。Flume基于流式架构，灵活简单。Flume最主要的作用就是，实时读取服务器日志数据，然后将数据写入到HDFS</p>
<h4 id="1-2-Flume基础架构"><a href="#1-2-Flume基础架构" class="headerlink" title="1.2 Flume基础架构"></a>1.2 Flume基础架构</h4><h5 id="1-2-1-Agent"><a href="#1-2-1-Agent" class="headerlink" title="1.2.1 Agent"></a>1.2.1 Agent</h5><p>​    Agent是一个JVM进程，一个Agent可以看作是一个flume进程，它以事件的形式将数据从源头送至目的地。</p>
<p>​    Agent主要有3个部分组成，Source，Channel，Sink</p>
<h5 id="1-2-2-Source"><a href="#1-2-2-Source" class="headerlink" title="1.2.2 Source"></a>1.2.2 Source</h5><p>​    Source是负责接收数据到Flume Agent的组件。Source组件可以处理各种类型，各种格式的数据，包括avro,thrift,exec,jms,spooling directory,netcat,sequence generator,syslog,http,legacy</p>
<h5 id="1-2-3-Sink"><a href="#1-2-3-Sink" class="headerlink" title="1.2.3 Sink"></a>1.2.3 Sink</h5><p>​    Sink不断地轮询Channel中的事件并且批量地移除（处理）它们，并将这些事件批量写入到存储或索引系统，或者被发送给另一个Flume Agent</p>
<p>​    Sink组件目的地包括hdfs，logger,avro,thrift,ipc,file,HBase,solr,自定义。    </p>
<h5 id="1-2-4-Channel"><a href="#1-2-4-Channel" class="headerlink" title="1.2.4 Channel"></a>1.2.4 Channel</h5><p>​    Channel是位于Source和Sink之间的缓冲区。因此，Channel允许Source和Sink    运作在不同的速率上。Channel是线程安全的，可以同时处理几个source的写入操作和几个Sink的读取操作。</p>
<p>​    Flume自带两种Channel：Memory Channel和File Channel</p>
<p>​    Memory Channel是内存中的队列。Memory Channel在不需要关心数据丢失的情景下适用。如果需要关心数据丢失，那么Memory Channel就不应该使用，因为程序死亡、机器宕机或者重启都会导致数据丢失。</p>
<p>​    File Channel将所有事件写到磁盘。因此在程序关闭或机器宕机的情况下不会丢失数据。</p>
<h5 id="1-2-5-Event"><a href="#1-2-5-Event" class="headerlink" title="1.2.5 Event"></a>1.2.5 Event</h5><p>​    传输单元，Flume数据传输的基本单元，以Event的形式将数据从源头送至目的地。Event由Header和Body两部分组成。Header用来存放该event的一些属性，为K-V结构，Body用来存放该数据，形式为字节数组。</p>
<h3 id="第2章-Flume的入门"><a href="#第2章-Flume的入门" class="headerlink" title="第2章 Flume的入门"></a>第2章 Flume的入门</h3><h4 id="2-1-Flume安装部署"><a href="#2-1-Flume安装部署" class="headerlink" title="2.1 Flume安装部署"></a>2.1 Flume安装部署</h4><h4 id="2-2-Flume入门案例"><a href="#2-2-Flume入门案例" class="headerlink" title="2.2 Flume入门案例"></a>2.2 Flume入门案例</h4><h3 id="第3章-Flume进阶"><a href="#第3章-Flume进阶" class="headerlink" title="第3章 Flume进阶"></a>第3章 Flume进阶</h3><h4 id="3-1-Flume事务"><a href="#3-1-Flume事务" class="headerlink" title="3.1 Flume事务"></a>3.1 Flume事务</h4><h4 id="3-2-FlumeAgent-内部原理"><a href="#3-2-FlumeAgent-内部原理" class="headerlink" title="3.2 FlumeAgent 内部原理"></a>3.2 FlumeAgent 内部原理</h4><h4 id="3-3-Flume拓扑结构"><a href="#3-3-Flume拓扑结构" class="headerlink" title="3.3  Flume拓扑结构"></a>3.3  Flume拓扑结构</h4><h4 id="3-4-Flume企业开发案例"><a href="#3-4-Flume企业开发案例" class="headerlink" title="3.4 Flume企业开发案例"></a>3.4 Flume企业开发案例</h4><h4 id="3-5-自定义Interceptor"><a href="#3-5-自定义Interceptor" class="headerlink" title="3.5 自定义Interceptor"></a>3.5 自定义Interceptor</h4><h4 id="3-6-自定义Source"><a href="#3-6-自定义Source" class="headerlink" title="3.6 自定义Source"></a>3.6 自定义Source</h4><h4 id="3-7-自定义Sink"><a href="#3-7-自定义Sink" class="headerlink" title="3.7 自定义Sink"></a>3.7 自定义Sink</h4><h4 id="3-8-Flume数据流监控"><a href="#3-8-Flume数据流监控" class="headerlink" title="3.8 Flume数据流监控"></a>3.8 Flume数据流监控</h4><h3 id="第4章-知识点小结"><a href="#第4章-知识点小结" class="headerlink" title="第4章 知识点小结"></a>第4章 知识点小结</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1.Flume是分布式的，高可用的，用于海量日志的收集，聚合，传输的框架</span><br><span class="line"> </span><br><span class="line"> 2.Flume架构：</span><br><span class="line"> 	Agent：jvm进程，可以看作是一个flume</span><br><span class="line"> 	source：对接日志的来源（采集日志）</span><br><span class="line"> 	channel：用于source到sink的缓冲</span><br><span class="line"> 	sink：对接日志的去向（比如传输到hdfs）</span><br><span class="line"> </span><br><span class="line"> 3.Source的类型</span><br><span class="line"> 	常用的有以下几种：</span><br><span class="line"> 	netstat source：从端口采集日志数据</span><br><span class="line"> 	exec source：从执行的Linux命令结果中采集数据。一般都是tail -F，从某个文件中采集数据</span><br><span class="line"> 	spooling directory source（重要，常用）：从某个目录下的多个文件中采集数据，用于监控新文件，没有断电续传功能</span><br><span class="line"> 	tail dir source（重要，常用）：从某个目录下的多个文件中采集数据，支持断点续传</span><br><span class="line"> 	avro source（重要，常用）：从avro sink中采集数据</span><br><span class="line"> 	</span><br><span class="line"> 4.Channel的类型</span><br><span class="line"> 	Memory channel（常用）：event数据存储在内存中</span><br><span class="line"> 	File channel：event数据存储在磁盘中</span><br><span class="line"> </span><br><span class="line"> 5.Sink的类型</span><br><span class="line">	Logger sink：通过日志的方式打印采集到的日志数据</span><br><span class="line">   Hdfs sink（重要，常用）：将日志数据写到hdfs中</span><br><span class="line">   Avro sink（重要，常用）：对接Avro source</span><br><span class="line">   File_roll sink：将采集到的日志数据往本地磁盘写</span><br><span class="line">   </span><br><span class="line">6.channel selector（一个source对接多个channel）</span><br><span class="line">	replicating channel selector:副本&#x2F;复制</span><br><span class="line">	multiplexing channel selector:多路复用</span><br><span class="line"> </span><br><span class="line"> 7.Sink processor（一个channel对接多个sink）</span><br><span class="line"> 		DefaultSinkProcessor：默认的，只对接一个sink</span><br><span class="line"> 			LoadBalancingSinkProcessor：负载均衡，可以配置轮询或随机策略（round_bin&#x2F;random）</span><br><span class="line"> 			FilaOverSinkProcessor：故障转移，可以配置sink的优先级，优先级高的有数据时优先获取，故障时会有退避时间（这个时间内故障的机器不能继续服务，退避时间过后机器正常可以再继续服务），退避时间内其它优先级低sink的可以暂时取代优先级高的sink服务。</span><br><span class="line"> 			</span><br><span class="line">8.Flume Agent的内部流程</span><br><span class="line">	日志--&gt;source（将日志数据封装为event）--&gt; channel processor --&gt; 将事件传递给interceptor--&gt;</span><br><span class="line">	将每个event都交给 channel selector --&gt; 告诉channel processor应该选择哪个channel处理 --&gt;</span><br><span class="line">	channel --&gt; sinkprocessor --&gt; sink --&gt; 例如HDFS</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>大数据</category>
        <category>Flume</category>
      </categories>
  </entry>
  <entry>
    <title>hive</title>
    <url>/2020/06/01/hive/</url>
    <content><![CDATA[<h3 id="0-前置知识"><a href="#0-前置知识" class="headerlink" title="0.前置知识"></a>0.前置知识</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）SQL技能：如MySQL</span><br><span class="line">2）Hadoop框架：HDFS + MapReduce</span><br></pre></td></tr></table></figure>

<h3 id="1-Hive是什么"><a href="#1-Hive是什么" class="headerlink" title="1. Hive是什么"></a>1. Hive是什么</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hive是FaceBook开源的海量结构化数据的分析框架，Hive的本质是将结构化的数据映射为一张表，最终表将翻译成MR程序，底层还是通过MR作为计算引擎，HDFS作为存储，YARN作为资源调度</span><br></pre></td></tr></table></figure>

<h3 id="2-Hive的架构"><a href="#2-Hive的架构" class="headerlink" title="2. Hive的架构"></a>2. Hive的架构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hive计算的数据存储在HDFS中，Hive的元数据信息（表的信息）存储在第三方的数据库中，默认使用的是Derby，可以切换成其它数据库，如MySQL</span><br></pre></td></tr></table></figure>

<h4 id="2-1-架构原理"><a href="#2-1-架构原理" class="headerlink" title="2.1 架构原理"></a>2.1 架构原理</h4><p>​    Hive通过给用户提供一系列交互接口，接受到用户的指令（SQL），使用自己的Driver，结合元数据（MetaStore），将这些指令翻译成MapReduce，提交到Hadoop中执行，最后将执行返回的结果输出到用户交互接口。</p>
<h3 id="3-Hive数据类型"><a href="#3-Hive数据类型" class="headerlink" title="3. Hive数据类型"></a>3. Hive数据类型</h3><h4 id="3-1基本数据类型"><a href="#3-1基本数据类型" class="headerlink" title="3.1基本数据类型"></a>3.1基本数据类型</h4><table>
<thead>
<tr>
<th>Hive数据类型</th>
<th>Java数据类型</th>
<th>长度</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>byte</td>
<td>1byte有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>SAMLLINT</td>
<td>short</td>
<td>2byte有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>INT</td>
<td>int</td>
<td>4byte有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>BIGINT</td>
<td>long</td>
<td>8byte有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>BOOLEAN</td>
<td>boolean</td>
<td>布尔类型true or false</td>
<td>TRUE</td>
</tr>
<tr>
<td>FLOAT</td>
<td>float</td>
<td>单精度浮点数</td>
<td>3.12</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>double</td>
<td>双精度浮点数</td>
<td>3.1524</td>
</tr>
<tr>
<td>STRING</td>
<td>string</td>
<td>字符系列。可以指定字符集。可以使用单引号或者双引号</td>
<td>‘now is the time’ “for all good men”</td>
</tr>
<tr>
<td>TIMSTAMP</td>
<td></td>
<td>时间类型</td>
<td></td>
</tr>
<tr>
<td>BINARY</td>
<td></td>
<td>字节数组</td>
<td></td>
</tr>
</tbody></table>
<p>​         对于Hive的String类型相当于数据库的varchar类型，该类型是一个可变的字符串，不过它不能声明其中最多能存储多少个字符，理论上它可以存储2GB的字符数。  </p>
<h4 id="3-2集合数据类型"><a href="#3-2集合数据类型" class="headerlink" title="3.2集合数据类型"></a>3.2集合数据类型</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>语法示例</th>
</tr>
</thead>
<tbody><tr>
<td>STRUCT</td>
<td>和C语言中的struct类似，都可以通过点符号访问元素内容。例如，如果某个列的数据类型是STRUTCT{first STRING,last STRING}，那么第1个元素可以通过字段.first来引用，struct的item就是指里面的属性</td>
<td><code>struct&lt;street:string,city:string&gt;</code></td>
</tr>
<tr>
<td>MAP</td>
<td>MAP是一组键-值对组集合，使用数组表示法可以访问数据。例如，如果某个列的数据类型是MAP，其中键-&gt;值是’first’-&gt;’John’和’last’-&gt;’Doe’，那么可以通过字段[‘last’]获取最后一个元素</td>
<td><code>map&lt;string,int&gt;</code></td>
</tr>
<tr>
<td>ARRAY</td>
<td>数组是一组具有相同类型和名称的变量的集合。这些变量称为数组的元素，每个数组元素都有一个编号，编号从零开始。例如，数组值为[‘John’,’Doe’]，那么第2个元素可以通过数组名[1]进行引用</td>
<td><code>array&lt;string&gt;</code></td>
</tr>
</tbody></table>
<h3 id="4-DDL数据定义"><a href="#4-DDL数据定义" class="headerlink" title="4. DDL数据定义"></a>4. DDL数据定义</h3><h3 id="5-DML数据操作"><a href="#5-DML数据操作" class="headerlink" title="5. DML数据操作"></a>5. DML数据操作</h3><h3 id="6-查询"><a href="#6-查询" class="headerlink" title="6. 查询"></a>6. 查询</h3><h4 id="6-1-全局排序"><a href="#6-1-全局排序" class="headerlink" title="6.1 全局排序"></a>6.1 全局排序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">order by：全局排序，只有一个reducer</span><br><span class="line">ASC：升序（默认）</span><br><span class="line">DESC：降序</span><br></pre></td></tr></table></figure>

<h4 id="6-2-每个MapReduce内部排序-Sort-by"><a href="#6-2-每个MapReduce内部排序-Sort-by" class="headerlink" title="6.2 每个MapReduce内部排序(Sort by)"></a>6.2 每个MapReduce内部排序(Sort by)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sort by:对于大规模的数据集order by的效率非常低。在很多情况下。并不需要全局排序，此时可以使用sort by</span><br><span class="line">sort by为每个reducer产生一个排序文件。每个reducer内部进行排序</span><br><span class="line"></span><br><span class="line"> 关注点: 有多个reducer，也就是有多个分区</span><br><span class="line"> 注意点: 有多个reducer,单独使用sort by, 数据会被随机分到每个reducer中，在每个reducer中sort by会将数据排序。</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）设置reduce个数</span><br><span class="line">hive (default)&gt; set mapreduce.job.reduces&#x3D;3;</span><br><span class="line">2）根据部门编号降序查看员工信息</span><br><span class="line">hive (default)&gt; select * from emp sort by deptno desc;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-分区排序（Distribute-by）"><a href="#6-3-分区排序（Distribute-by）" class="headerlink" title="6.3 分区排序（Distribute by）"></a>6.3 分区排序（Distribute by）</h4><p>​    Distribute By：在有些情况下，我们需要控制某个特定行应该要到哪个reducer，通常是为了进行后续的聚集操作。distribute by字句可以做这件事。distribute by类似MR中的partition（自定义分区），进行分区，结合sort by使用。</p>
<p>​    对于distribute by进行测试，一定要分配多reduce处理，否则无法看到distribute by的效果</p>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from emp distribute by deptno  sort by  empno desc ;</span><br></pre></td></tr></table></figure>

<h4 id="6-4-cluster-by-分区排序"><a href="#6-4-cluster-by-分区排序" class="headerlink" title="6.4 cluster by 分区排序"></a>6.4 cluster by 分区排序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关注点: 相当于distribute by 和sort by同时用， 并且分区和排序的字段是同一个，并且排序是升序的情况.</span><br><span class="line"></span><br><span class="line">select * from emp distribute by deptno sort by deptno asc ; </span><br><span class="line">等同于</span><br><span class="line">select * from emp cluster by deptno ;</span><br></pre></td></tr></table></figure>



<h3 id="7-分区表和分桶表"><a href="#7-分区表和分桶表" class="headerlink" title="7. 分区表和分桶表"></a>7. 分区表和分桶表</h3><h4 id="7-1-分区表"><a href="#7-1-分区表" class="headerlink" title="7.1 分区表"></a>7.1 分区表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分区表实际就是对应一个HDFS文件系统上的独立的文件夹，该文件夹下是该分区所有的数据文件。Hive分区表的分区其实就是分目录，把一个大的数据集根据业务需求分割成小的数据集。在查询时通过where子句中的表达式选择查询所需要的指定分区，就不用暴力扫描所有的数据了，这样查询效率会提高很多。</span><br></pre></td></tr></table></figure>

<h4 id="7-1-1-分区表基本操作"><a href="#7-1-1-分区表基本操作" class="headerlink" title="7.1.1 分区表基本操作"></a>7.1.1 分区表基本操作</h4><p>1）引入分区表的数据（需求是根据日志对日志进行管理，通过部门信息模拟）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dept_20200401.log</span><br><span class="line">dept_20200402.log</span><br><span class="line">dept_20200403.log</span><br></pre></td></tr></table></figure>

<p>2）创建分区表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt;create table dept_partition(deptno int,dname string,loc string) </span><br><span class="line">partitioned by(day string)</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;;</span><br></pre></td></tr></table></figure>

<p>3）加载数据到分区表中</p>
<p>（1）数据准备</p>
<p>dept_20200401.log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10	ACCOUNTING	1700</span><br><span class="line">20	RESEARCH	1800</span><br></pre></td></tr></table></figure>

<p>dept_20200402.log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30	SALES	1900</span><br><span class="line">40	OPERATIONS	1700</span><br></pre></td></tr></table></figure>

<p>dept_20200403.log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">50	TEST	2000</span><br><span class="line">60	DEV	1900</span><br></pre></td></tr></table></figure>



<p>（2）加载数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;dept_20200401.log&#39; into table dept_partition partition(day&#x3D;&#39;20200401&#39;);</span><br><span class="line"></span><br><span class="line">hive (default)&gt; load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;dept_20200402.log&#39; into table dept_partition partition(day&#x3D;&#39;20200402&#39;);</span><br><span class="line"></span><br><span class="line">hive (default)&gt; load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;dept_20200403.log&#39; into table dept_partition partition(day&#x3D;&#39;20200403&#39;);</span><br></pre></td></tr></table></figure>



<p>4）</p>
<p>单分区查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; select * from dept_partition where day&#x3D;&#39;20200401&#39;;</span><br></pre></td></tr></table></figure>



<p>多分区联合查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; select * from dept_partition where day&#x3D;&#39;20200401&#39;</span><br><span class="line">              union</span><br><span class="line">              select * from dept_partition where day&#x3D;&#39;20200402&#39;</span><br><span class="line">              union</span><br><span class="line">              select * from dept_partition where day&#x3D;&#39;20200403&#39;;</span><br><span class="line">              </span><br><span class="line">hive (default)&gt; select * from dept_partition where day&#x3D;&#39;20200401&#39; or</span><br><span class="line">                day&#x3D;&#39;20200402&#39; or day&#x3D;&#39;20200403&#39; ;</span><br></pre></td></tr></table></figure>



<p>5）增加分区</p>
<p>创建单个分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; alter table dept_partition add partition(day&#x3D;&#39;20200404&#39;);</span><br></pre></td></tr></table></figure>

<p>同时创建多个分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; alter table dept_partition add partition(day&#x3D;&#39;20200405&#39;) partition(day&#x3D;&#39;20200406&#39;);</span><br></pre></td></tr></table></figure>

<p>6）删除分区</p>
<p>删除单个分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; alter table dept_partition drop partition(day&#x3D;&#39;20200404&#39;);</span><br></pre></td></tr></table></figure>

<p>删除多个分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt;alter table dept_partition drop partition(day&#x3D;&#39;20200405&#39;),parition(day&#x3D;&#39;20200406&#39;);</span><br></pre></td></tr></table></figure>

<p>7）查看分区表有多少分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt;show partitions dept_partition;</span><br></pre></td></tr></table></figure>

<p>8）查看分区表结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; desc formatted dept_partition;</span><br></pre></td></tr></table></figure>

<h4 id="7-1-2-分区表注意事项"><a href="#7-1-2-分区表注意事项" class="headerlink" title="7.1.2 分区表注意事项"></a>7.1.2 分区表注意事项</h4><p>如果一天的日志数据量很大，也是可以创建二级分区表的</p>
<p>1）创建二级分区表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; create table dept_parition2(deptno int,dname string,loc string)</span><br><span class="line">partitioned by (day string,hour string)</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;;</span><br></pre></td></tr></table></figure>

<p>2）正常的加载数据</p>
<p>（1）加载数据到二级分区表中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt;load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;dept_20200401.log&#39; into table dept_parition2 partition(day&#x3D;&#39;20200401&#39;,hour&#x3D;&#39;12&#39;);</span><br></pre></td></tr></table></figure>

<p>（2）查询分区数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; select * from dept_partition2 where day&#x3D;&#39;20200401&#39; and hour &#x3D; &#39;12&#39;;</span><br></pre></td></tr></table></figure>

<p>3）把数据上传到分区目录上，让分区表和数据产生关联的三种方式</p>
<p>（1）方式一：上传数据后修复</p>
<p>上传数据到HDFS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; dfs -mkdir -p</span><br><span class="line"> &#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;mydb.db&#x2F;dept_partition2&#x2F;day&#x3D;20200401&#x2F;hour&#x3D;13;</span><br><span class="line"> </span><br><span class="line">hive (default)&gt; dfs -put &#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;dept_20200401.log  </span><br><span class="line">&#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;mydb.db&#x2F;dept_partition2&#x2F;day&#x3D;20200401&#x2F;hour&#x3D;13;</span><br></pre></td></tr></table></figure>

<p>查询数据（查询不到刚上传的数据，因为没有相应的元数据信息）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; select * from dept_partition2 where day&#x3D;&#39;20200401&#39; and hour&#x3D;&#39;13&#39;;</span><br></pre></td></tr></table></figure>

<p>执行修复命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; msck repair table dept_partition2;</span><br></pre></td></tr></table></figure>

<p>再次查询数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; select * from dept_partition2 where day&#x3D;&#39;20200401&#39; and hour&#x3D;&#39;13&#39;;</span><br></pre></td></tr></table></figure>



<p>（2）方式二：上传数据后添加分区</p>
<p>上传数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; dfs -mkdir -p</span><br><span class="line"> &#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;mydb.db&#x2F;dept_partition2&#x2F;day&#x3D;20200401&#x2F;hour&#x3D;14;</span><br><span class="line"> </span><br><span class="line">hive (default)&gt; dfs -put &#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;dept_20200401.log  &#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;mydb.db&#x2F;dept_partition2&#x2F;day&#x3D;20200401&#x2F;hour&#x3D;14;</span><br></pre></td></tr></table></figure>

<p>执行添加分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; alter table dept_partition2 add partition(day&#x3D;&#39;201709&#39;,hour&#x3D;&#39;14&#39;);</span><br></pre></td></tr></table></figure>

<p>查询数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; select * from dept_partition2 where day&#x3D;&#39;20200401&#39; and hour&#x3D;&#39;14&#39;;</span><br></pre></td></tr></table></figure>

<h4 id="7-1-3-动态分区调整"><a href="#7-1-3-动态分区调整" class="headerlink" title="7.1.3 动态分区调整"></a>7.1.3 动态分区调整</h4><p>​    关系型数据库中，对分区表Insert数据时候，数据库自动会根据分区字段的值，将数据插入到相应的分区中，Hive中也提供了类似的机制，即动态分区(Dynamic Partition)，只不过，使用Hive的动态分区，需要进行相应的配置。</p>
<p>1）开启动态分区参数设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）开启动态分区功能（默认true，开启）</span><br><span class="line">hive.exec.dynamic.partition&#x3D;true</span><br><span class="line">（2）设置为非严格模式（动态分区的模式，默认strict，表示必须指定至少一个分区为静态分区，nonstrict模式表示允许所有的分区字段都可以使用动态分区。）</span><br><span class="line">hive.exec.dynamic.partition.mode&#x3D;nonstrict</span><br><span class="line">（3）在所有执行MR的节点上，最大一共可以创建多少个动态分区。默认1000</span><br><span class="line">hive.exec.max.dynamic.partitions&#x3D;1000</span><br><span class="line">（4）在每个执行MR的节点上，最大可以创建多少个动态分区。该参数需要根据实际的数据来设定。比如：源数据中包含了一年的数据，即day字段有365个值，那么该参数就需要设置成大于365，如果使用默认值100，则会报错。</span><br><span class="line">hive.exec.max.dynamic.partitions.pernode&#x3D;100</span><br><span class="line">（5）整个MR Job中，最大可以创建多少个HDFS文件。默认100000</span><br><span class="line">hive.exec.max.created.files&#x3D;100000</span><br><span class="line">（6）当有空分区生成时，是否抛出异常。一般不需要设置。默认false</span><br><span class="line">hive.error.on.empty.partition&#x3D;false</span><br></pre></td></tr></table></figure>

<p>2）案例实操</p>
<p>​    需求：将dept表中的数据按照地区（loc字段），插入到目标表dept_partition的相应分区中。</p>
<p>（1）创建目标分区表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; create table dept_partition_dy(id int,name string)</span><br><span class="line">partitioned by(loc int)</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;;</span><br></pre></td></tr></table></figure>

<p>（2）设置动态分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set hive.exec.dynamic.partition.mode &#x3D; nonstrict;</span><br><span class="line">hive(default)&gt; insert into table dept_partition_dy partition(loc) </span><br><span class="line">select deptno,dname,loc from dept;</span><br></pre></td></tr></table></figure>



<h3 id="7-2-分桶表"><a href="#7-2-分桶表" class="headerlink" title="7.2 分桶表"></a>7.2 分桶表</h3><p>​    分区表提供一个隔离数据和优化查询的便利方式。不过，并非所有的数据集都可以形成合力的分区。对于一张表或分区，Hive可进一步组织成桶，也就是更细粒度的数据范围划分。</p>
<p>​    分桶是将数据集分解成更容易管理的若干部分的另一个技术。</p>
<p>​    分区针对的是数据的存储路径，分为多个目录，而分桶针对是数据文件，会把原来的文件根据分桶规则将数据分到不同的数据文件。</p>
<p>1）先创建分桶表，通过直接导入数据文件的方式</p>
<p>（1）数据准备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1001	ss1</span><br><span class="line">1002	ss2</span><br><span class="line">1003	ss3</span><br><span class="line">1004	ss4</span><br><span class="line">1005	ss5</span><br><span class="line">1006	ss6</span><br><span class="line">1007	ss7</span><br><span class="line">1008	ss8</span><br><span class="line">1009	ss9</span><br><span class="line">1010	ss10</span><br><span class="line">1011	ss11</span><br><span class="line">1012	ss12</span><br><span class="line">1013	ss13</span><br><span class="line">1014	ss14</span><br><span class="line">1015	ss15</span><br><span class="line">1016	ss16</span><br></pre></td></tr></table></figure>

<p>（2）创建分桶表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table stu_buck(id int,name string)</span><br><span class="line">clustered by(id)</span><br><span class="line">into 4 buckets</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;;</span><br></pre></td></tr></table></figure>

<p>（3）查看表结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default) &gt; desc formatted stu_buck;</span><br></pre></td></tr></table></figure>

<p>（4）导入数据到分桶表中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;dive&#x2F;datas&#x2F;student.txt&#39; into table stu_buck;</span><br></pre></td></tr></table></figure>

<p>（5）通过web到对应的目录下查看创建的分通表中是否分为4个桶</p>
<p>（6）查询分桶的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; select * from stu_buck;</span><br></pre></td></tr></table></figure>

<p>分桶规则：HIve的分桶采用对分桶字段的值进行哈希，然后除以桶的个数取余的方式决定该条记录存放在哪个桶当中</p>
<h3 id="7-3-抽样查询"><a href="#7-3-抽样查询" class="headerlink" title="7.3 抽样查询"></a>7.3 抽样查询</h3><p>​    对于非常大的数据集，有时用户需要使用的是一个具有代表性的查询结果而不是全部结果。可以通过对表进行抽样来满足这个需求。</p>
<p>​    查询表stu_buck中的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; select * from stu_buck tablesample(bucket 1 out of 4 on id);</span><br></pre></td></tr></table></figure>

<p>注：tablesample是抽样语句，语法：tablesample(bucket x out of y)</p>
<p>y必须是table总bucket数的倍数或者因子。hive根据y的大小，决定抽象的比例。例如：table总共分了4份，当y=2时，抽取（4/2）=2个bucket 的数据，当y=8时，抽取（4/8）=1/个bucket的数据。</p>
<p>x表示从哪个bucket开始抽取，如果需要取多个分区，以后的分区号为当前分区号加上y。例如，table总bucket数为4。</p>
<p>x的值必须小于y的值</p>
<h3 id="8-函数"><a href="#8-函数" class="headerlink" title="8. 函数"></a>8. 函数</h3><h4 id="8-1-系统内置函数"><a href="#8-1-系统内置函数" class="headerlink" title="8.1 系统内置函数"></a>8.1 系统内置函数</h4><p>1）查看系统自带的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive &gt; show functions;</span><br></pre></td></tr></table></figure>

<p>2）显示自带函数的用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive &gt; desc function upper;</span><br></pre></td></tr></table></figure>

<p>3）详细显示自带的函数的用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive &gt; desc function extended upper;</span><br></pre></td></tr></table></figure>



<h4 id="8-2-常用内置函数"><a href="#8-2-常用内置函数" class="headerlink" title="8.2 常用内置函数"></a>8.2 常用内置函数</h4><h5 id="8-2-1-空字段复制"><a href="#8-2-1-空字段复制" class="headerlink" title="8.2.1 空字段复制"></a>8.2.1 空字段复制</h5><h5 id="8-2-2-CASE-WHEN"><a href="#8-2-2-CASE-WHEN" class="headerlink" title="8.2.2 CASE WHEN"></a>8.2.2 CASE WHEN</h5><h5 id="8-2-3-行转列"><a href="#8-2-3-行转列" class="headerlink" title="8.2.3 行转列"></a>8.2.3 行转列</h5><p>1）相关函数说明</p>
<p>​    CONCAT(string A/col, string B/col…)：返回输入字符串连接后的结果，支持任意个输入字符串。</p>
<p>​    CONCAT_WS(separator, str1, str2,…)：它是一个特殊形式的 CONCAT()。第一个参数剩余参数间的分隔符。分隔符可以是与剩余参数一样的字符串。如果分隔符是 NULL，返回值也将为 NULL。这个函数会跳过分隔符参数后的任何 NULL 和空字符串。分隔符将被加到被连接的字符串之间。</p>
<p>​    COLLECT_SET(col)：函数只接受基本数据类型，它的主要作用是将某字段的值进行去重汇总，产生array类型字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="8-2-4-列转行"><a href="#8-2-4-列转行" class="headerlink" title="8.2.4 列转行"></a>8.2.4 列转行</h5><p>1）函数说明</p>
<p>​    split()：将给定的字符串，通过给定的分隔符进行分割，返回array</p>
<p>​    explode()：将一列中的array或者map等拆分成多行</p>
<p>​    lateral view：侧写</p>
<p>2）数据准备</p>
<p>表6-7 数据准备</p>
<table>
<thead>
<tr>
<th>movie</th>
<th>category</th>
</tr>
</thead>
<tbody><tr>
<td>《疑犯追踪》</td>
<td>悬疑,动作,科幻,剧情</td>
</tr>
<tr>
<td>《Lie to me》</td>
<td>悬疑,警匪,动作,心理,剧情</td>
</tr>
<tr>
<td>《战狼2》</td>
<td>战争,动作,灾难</td>
</tr>
</tbody></table>
<p>3）需求</p>
<p>​    将电影分类中的数组数据展开，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">《疑犯追踪》      悬疑</span><br><span class="line">《疑犯追踪》      动作</span><br><span class="line">《疑犯追踪》      科幻</span><br><span class="line">《疑犯追踪》      剧情</span><br><span class="line">《Lie to me》   悬疑</span><br><span class="line">《Lie to me》   警匪</span><br><span class="line">《Lie to me》   动作</span><br><span class="line">《Lie to me》   心理</span><br><span class="line">《Lie to me》   剧情</span><br><span class="line">《战狼2》        战争</span><br><span class="line">《战狼2》        动作</span><br><span class="line">《战狼2》        灾难</span><br></pre></td></tr></table></figure>

<p>4）创建本地movie.txt，导入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">atguigu@hadoop102 datas]$ vi movie_info.txt</span><br><span class="line">《疑犯追踪》	悬疑,动作,科幻,剧情</span><br><span class="line">《Lie to me》	悬疑,警匪,动作,心理,剧情</span><br><span class="line">《战狼2》	战争,动作,灾难</span><br></pre></td></tr></table></figure>

<p>5）创建hive表并导入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table movie_info(</span><br><span class="line">    movie string, </span><br><span class="line">    category string) </span><br><span class="line">row format delimited fields terminated by &quot;\t&quot;;</span><br><span class="line">load data local inpath &quot;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;movie_info.txt&quot; into table movie_info;</span><br></pre></td></tr></table></figure>

<p>6）按需求查询数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select movie,category_name</span><br><span class="line">from movie_info</span><br><span class="line">lateral view</span><br><span class="line">explode(split(category,&quot;,&quot;))movie_info_tpm as category_name;</span><br></pre></td></tr></table></figure>



<h5 id="8-2-5-窗口函数"><a href="#8-2-5-窗口函数" class="headerlink" title="8.2.5 窗口函数"></a>8.2.5 窗口函数</h5><p>1）相关函数说明</p>
<p>​    over():指定分析函数工作的数据窗口大小，这个数据窗口的大小可能会随着行的变化而变化</p>
<p>​    current row：当前行</p>
<p>​    n preceding：往前n行数据</p>
<p>​    n following：往后n行数据</p>
<p>​    unbounded：起点</p>
<p>​        unbounded preceding 表示从前面的起点</p>
<p>​        unbounded following 表示到后面的终点</p>
<p>​    lag(col,n,default_val)：往前第n行数据，没有数据则用默认值代替</p>
<p>​    lead(col,default_val)：往后第n行数据，没有数据则用默认值代替</p>
<p>​    ntile(n)：把有序窗口的行分发到指定数据的组中，各个组有编号，编号从1开始，对于每一行，ntile返回此行所属的组的编号。其中n必须为Int类型</p>
<p>2）数据准备：name，orderdate，cost</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jack,2017-01-01,10</span><br><span class="line">tony,2017-01-02,15</span><br><span class="line">jack,2017-02-03,23</span><br><span class="line">tony,2017-01-04,29</span><br><span class="line">jack,2017-01-05,46</span><br><span class="line">jack,2017-04-06,42</span><br><span class="line">tony,2017-01-07,50</span><br><span class="line">jack,2017-01-08,55</span><br><span class="line">mart,2017-04-08,62</span><br><span class="line">mart,2017-04-09,68</span><br><span class="line">neil,2017-05-10,12</span><br><span class="line">mart,2017-04-11,75</span><br><span class="line">neil,2017-06-12,80</span><br><span class="line">mart,2017-04-13,94</span><br></pre></td></tr></table></figure>

<p>3）创建本地business.txt，导入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ vim business.txt</span><br></pre></td></tr></table></figure>

<p>4）创建hive表并导入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table business(</span><br><span class="line">name string, </span><br><span class="line">orderdate string,</span><br><span class="line">cost int</span><br><span class="line">) ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;,&#39;;</span><br><span class="line">create table business(</span><br><span class="line">name string, </span><br><span class="line">orderdate string,</span><br><span class="line">cost int</span><br><span class="line">) ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;,&#39;;</span><br><span class="line">load data local inpath &quot;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;business.txt&quot; into table business;</span><br></pre></td></tr></table></figure>

<p>6）按需求查询数据<br>（1）查询在2017年4月份购买过的顾客及总人数,输出如下<br>     NAME    total<br>     jack     2<br>     tony     2</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--分析：</span></span><br><span class="line"><span class="comment">--a.首先将2017年4月份的数据查出来</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span> <span class="keyword">from</span> business <span class="keyword">where</span> orderdate <span class="keyword">like</span> <span class="string">'2017-04%'</span>;</span><br><span class="line"><span class="comment">--或者</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span> <span class="keyword">from</span> business <span class="keyword">where</span> <span class="keyword">MONTH</span>(orderdate) = <span class="string">'04'</span>;</span><br><span class="line"><span class="comment">--b.然后将4月份的数据总人数通过开窗函数查出来(这里是对字表t1的数据开窗)</span></span><br><span class="line"><span class="keyword">select</span> t1.name,<span class="keyword">count</span>(t1.name) <span class="keyword">over</span>()</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span> <span class="keyword">from</span> business <span class="keyword">where</span> <span class="keyword">MONTH</span>(orderdate) = <span class="string">'04'</span>)t1</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t1.name;</span><br></pre></td></tr></table></figure>

<p>（2）查询顾客的购买明细及月购买总额（这里是指所有顾客的月购买总额）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">month</span>(orderdate)) allcustomer_month_sum_cost</span><br><span class="line"><span class="keyword">from</span> business;</span><br></pre></td></tr></table></figure>

<p>（3）查询顾客的购买明细及月购买总额（这里指每个顾客的月购买总额）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span>,<span class="keyword">month</span>(orderdate)) current_customer_month_costs</span><br><span class="line"><span class="keyword">from</span> business;</span><br></pre></td></tr></table></figure>

<p>（4）每个顾客的购买明细，及所有顾客的cost按照日期进行累加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--分析：为每条数据的开窗的大小为：从结果集开始的位置到当前行</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span></span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate)sum_cost</span><br><span class="line"><span class="keyword">from</span> business;</span><br><span class="line"><span class="comment">--等同于</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">current</span> <span class="keyword">row</span>)sum_cost</span><br><span class="line"><span class="keyword">from</span> business;</span><br></pre></td></tr></table></figure>

<p>（5）每个顾客的购买明细    及  </p>
<p>​        所有顾客的cost按照日期累加</p>
<p>​        所有顾客的cost按照日期上一行与当前行的累加</p>
<p>​        所有顾客的cost按照日期当前行与下一行的累加</p>
<p>​        所有顾客的cost按照日期上一行 当前行 下一行的累加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">unbounded</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">current</span> <span class="keyword">row</span>) sum_costs1,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="keyword">current</span> <span class="keyword">row</span>) sum_cost2,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">current</span> <span class="keyword">row</span> <span class="keyword">and</span> <span class="number">1</span> <span class="keyword">following</span>) sum_cost3,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">preceding</span> <span class="keyword">and</span> <span class="number">1</span> <span class="keyword">following</span>) sum_cost4</span><br><span class="line"><span class="keyword">from</span> business;</span><br></pre></td></tr></table></figure>

<p>（6）每个顾客的购买明细 及</p>
<p>​        所有顾客的cost按照日期    上一行与下一行的累加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--分析</span></span><br><span class="line"><span class="comment">--a.将每条数据的上一行和下一行的cost提取到当前行</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span>,</span><br><span class="line">lag(<span class="keyword">cost</span>,<span class="number">1</span>,<span class="number">0</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate) prev_cost,</span><br><span class="line"><span class="keyword">lead</span>(<span class="keyword">cost</span>,<span class="number">1</span>,<span class="number">0</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate) next_cost</span><br><span class="line"><span class="keyword">from</span> business;            <span class="comment">-----&gt; t1</span></span><br><span class="line"><span class="comment">--b.求prev_cost和next_cost的和</span></span><br><span class="line"><span class="keyword">select</span> t1.name,t1.orderdate,t1.cost,t1.prev_cost,t1.next_cost,t1.prev_cost+t1.next_cost p_n_cost</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span>,</span><br><span class="line">lag(<span class="keyword">cost</span>,<span class="number">1</span>,<span class="number">0</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate) prev_cost,</span><br><span class="line"><span class="keyword">lead</span>(<span class="keyword">cost</span>,<span class="number">1</span>,<span class="number">0</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate) next_cost</span><br><span class="line"><span class="keyword">from</span> business)t1;</span><br></pre></td></tr></table></figure>

<p>（7）查询每个顾客上次的购买时间和下次的购买时间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,<span class="keyword">cost</span>,orderdate current_od,</span><br><span class="line">lag(orderdate,<span class="number">1</span>,<span class="string">'1970-01-01'</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate) prev_od,</span><br><span class="line"><span class="keyword">lead</span>(orderdate,<span class="number">1</span>,<span class="string">'9999-01-01'</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate) next_od</span><br><span class="line"><span class="keyword">from</span> business;</span><br></pre></td></tr></table></figure>

<p>（8）查询每个顾客上次的购买时间和下次的购买时间 及每个顾客的cost按照日期累加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,<span class="keyword">cost</span>,orderdate current_od,</span><br><span class="line">lag(orderdate,<span class="number">1</span>,<span class="string">'1970-01-01'</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate) prev_od,</span><br><span class="line"><span class="keyword">lead</span>(orderdate,<span class="number">1</span>,<span class="string">'9999-01-01'</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate) next_od,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">cost</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">order</span> <span class="keyword">by</span> orderdate) sum_cost</span><br><span class="line"><span class="keyword">from</span> business;</span><br></pre></td></tr></table></figure>

<p>（9）查询前20%时间的订单信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--按订单时间排序，分为5组然后取第一组</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span>,</span><br><span class="line">ntile(<span class="number">5</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate) gid</span><br><span class="line"><span class="keyword">from</span> business;          <span class="comment">----&gt;t1</span></span><br><span class="line"><span class="comment">--取5组里面的第一组数据，即前20%的数据</span></span><br><span class="line"><span class="keyword">select</span> t1.name,t1.orderdate,t1.cost</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">name</span>,orderdate,<span class="keyword">cost</span>,</span><br><span class="line">ntile(<span class="number">5</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> orderdate) gid</span><br><span class="line"><span class="keyword">from</span> business)t1</span><br><span class="line"><span class="keyword">where</span> t1.gid = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<h5 id="8-2-6-Rank"><a href="#8-2-6-Rank" class="headerlink" title="8.2.6 Rank"></a>8.2.6 Rank</h5><p>1）相关函数说明</p>
<p>​    rank()：考虑并列情况，总数不会变</p>
<p>​    dense_rank()：考虑并列情况，总数会较少</p>
<p>​    row_number()：按照顺序排序</p>
<p>2）数据准备</p>
<table>
<thead>
<tr>
<th>name</th>
<th>subject</th>
<th>score</th>
</tr>
</thead>
<tbody><tr>
<td>孙悟空</td>
<td>语文</td>
<td>87</td>
</tr>
<tr>
<td>孙悟空</td>
<td>数学</td>
<td>95</td>
</tr>
<tr>
<td>孙悟空</td>
<td>英语</td>
<td>68</td>
</tr>
<tr>
<td>大海</td>
<td>语文</td>
<td>94</td>
</tr>
<tr>
<td>大海</td>
<td>数学</td>
<td>56</td>
</tr>
<tr>
<td>大海</td>
<td>英语</td>
<td>84</td>
</tr>
<tr>
<td>宋宋</td>
<td>语文</td>
<td>64</td>
</tr>
<tr>
<td>宋宋</td>
<td>数学</td>
<td>86</td>
</tr>
<tr>
<td>宋宋</td>
<td>英语</td>
<td>84</td>
</tr>
<tr>
<td>婷婷</td>
<td>语文</td>
<td>65</td>
</tr>
<tr>
<td>婷婷</td>
<td>数学</td>
<td>85</td>
</tr>
<tr>
<td>婷婷</td>
<td>英语</td>
<td>78</td>
</tr>
</tbody></table>
<p>4）创建本地score.txt,导入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 datas]$ vim score.txt</span><br></pre></td></tr></table></figure>

<p>5）创建hive表并导入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table score(</span><br><span class="line">name string,</span><br><span class="line">subject string, </span><br><span class="line">score int) </span><br><span class="line">row format delimited fields terminated by &quot;\t&quot;;</span><br><span class="line">load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;score.txt&#39; into table score;</span><br></pre></td></tr></table></figure>

<p>6）需求：计算每科成绩排名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,subject,score,</span><br><span class="line"><span class="keyword">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> subject <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) rk,</span><br><span class="line"><span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> subject <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) drk,</span><br><span class="line">row_number() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> subject <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) rn</span><br><span class="line"><span class="keyword">from</span> score;</span><br></pre></td></tr></table></figure>



<h5 id="8-2-7-其它常用函数"><a href="#8-2-7-其它常用函数" class="headerlink" title="8.2.7 其它常用函数"></a>8.2.7 其它常用函数</h5><h4 id="8-3-自定义函数"><a href="#8-3-自定义函数" class="headerlink" title="8.3 自定义函数"></a>8.3 自定义函数</h4><p>1）Hive 自带了一些函数，比如：max/min等，但是数量有限，自己可以通过自定义UDF来方便的扩展。</p>
<p>2）此时就可以考虑使用用户自定义函数（UDF：user-defined function）。</p>
<p>3）根据用户自定义函数类别分为以下三种</p>
<p>（1）UDF（User-Defined Function）</p>
<p>​    一进一出</p>
<p>（2）UDAF（User-Defined Aggregation Function）</p>
<p>​    聚集函数：多进一出 类似于 count/max/min</p>
<p>（3）UDTF（User-Defined Table_Generating Functions）</p>
<p>​    一进多出  如lateral view explode()</p>
<p>4）官方文档地址</p>
<p>5）编程步骤</p>
<p>（1）继承Hive提供的类</p>
<p>​    org.apache.hadoop.hive.ql.udf.generic.GenericUDF</p>
<p>​    org.apache.hadoop.hive.ql.udf.generic.GenericUDTF;</p>
<p>（2）实现类中的抽象方法</p>
<p>（3）在hive的命令行窗口创建函数</p>
<p>添加jar</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add jar linux_jar_path</span><br></pre></td></tr></table></figure>

<p>创建function和刚添加的jar关联起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create [temporary] function [dbname.]function name as class_name;</span><br></pre></td></tr></table></figure>

<p>（4）在hive的命令行窗口删除函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop [temporary] function [if exists] [dbname.]function name;</span><br></pre></td></tr></table></figure>





<h4 id="8-4-自定义UDF函数"><a href="#8-4-自定义UDF函数" class="headerlink" title="8.4 自定义UDF函数"></a>8.4 自定义UDF函数</h4><p>0）需求：</p>
<p>​    自定义一个UDF实现计算给定字符串的长度，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; select my_len(&quot;abcd&quot;);</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>1）创建一个maven工程hive</p>
<p>2）导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hive<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive-exec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3）创建一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.hive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDFArgumentException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDFArgumentLengthException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDFArgumentTypeException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.metadata.HiveException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.udf.generic.GenericUDF;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	自定义UDF函数，需要继承GenericUDF类</span></span><br><span class="line"><span class="comment">*	需求：计算指定字符串的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStringLength</span> <span class="keyword">extends</span> <span class="title">GenericUDF</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arguments 输入参数类型的鉴别器对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回值类型的鉴别器对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UDFArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectInspector <span class="title">initialize</span><span class="params">(ObjectInspector[] arguments)</span><span class="keyword">throws</span> UDFArgumentException</span>&#123;</span><br><span class="line">        <span class="comment">//判断输入参数的个数</span></span><br><span class="line">        <span class="keyword">if</span>(arguments.length != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UDFArgumentLegthException(<span class="string">"Input Args Length Error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断输入参数的类型</span></span><br><span class="line">        <span class="keyword">if</span>(!argument[<span class="number">0</span>].getCategory().equals(ObjectInspector.Category.PRIMITIVE))&#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> UDFArgumentTypeException(<span class="number">0</span>,<span class="string">"Input Args Type Error!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//函数本身返回值为int,需要返回int类型鉴别器对象</span></span><br><span class="line">        <span class="keyword">return</span> PrimitiveObjectInspectorFactory.javaIntObjectInspector;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 函数的逻辑处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arguments 输入的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> HiveException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">evaluate</span><span class="params">(DeferedObject[] arguments)</span><span class="keyword">throws</span> HiveException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arguments[<span class="number">0</span>].get() == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> argument[<span class="number">0</span>].get.toString().length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDisplayString</span><span class="params">(String[] children)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）打成jar包上传到服务器/opt/module/hive/datas/myudf.jar</p>
<p>5）将jar包添加到hive的classpath</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; add jar &#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;myudf.jar</span><br></pre></td></tr></table></figure>

<p>6）创建临时函数与开发好的java class关联</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; create temporary function my_len as &quot;com.atguigu.hive.MyStringLength&quot;;</span><br></pre></td></tr></table></figure>

<p>7）即可在hql使用自定义的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; select my_len(&#39;abcd&#39;);</span><br><span class="line">4</span><br></pre></td></tr></table></figure>



<h4 id="8-5-自定义UDTF函数"><a href="#8-5-自定义UDTF函数" class="headerlink" title="8.5 自定义UDTF函数"></a>8.5 自定义UDTF函数</h4><p>0）需求</p>
<p>自定义一个UDTF实现将一个任意分隔符的字符串切割成独立的单词，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive(default)&gt; select myudtf(&quot;hello,world,hadoop,hive&quot;, &quot;,&quot;);</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hadoop</span><br><span class="line">hive</span><br></pre></td></tr></table></figure>

<p>1）代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.hive.udtf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDFArgumentException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.metadata.HiveException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.udf.generic.GenericUDTF;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.StructField;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义UDTF函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 需要继承 GenericUDTF类，并重写抽象方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 函数的使用: select myudtf('hive,hadoop,flume,kafka',',');</span></span><br><span class="line"><span class="comment"> *      结果:  word</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *            hive</span></span><br><span class="line"><span class="comment"> *            hadoop</span></span><br><span class="line"><span class="comment"> *            flume</span></span><br><span class="line"><span class="comment"> *            kafka</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  扩展:</span></span><br><span class="line"><span class="comment"> *  select myudtf2('hadoop-niupi,java-lihai,songsong-kuai,dahai-lang',',','-');</span></span><br><span class="line"><span class="comment"> *  结果: word1    word2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       hadoop   niupi</span></span><br><span class="line"><span class="comment"> *       java     lihai</span></span><br><span class="line"><span class="comment"> *       songsong kuai</span></span><br><span class="line"><span class="comment"> *       dahai    lang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringSplitUDTF</span> <span class="keyword">extends</span> <span class="title">GenericUDTF</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">private</span> ArrayList&lt;String&gt; outList  = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法  约定函数的返回值类型  和 函数的返回值列名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> argOIs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UDFArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> StructObjectInspector <span class="title">initialize</span><span class="params">(StructObjectInspector argOIs)</span><span class="keyword">throws</span> UDFArgumentException</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//基本判断</span></span><br><span class="line">        List&lt;? extends StructField&gt; fieldRefs = argOIs.getAllStructFieldRefs();</span><br><span class="line">		<span class="keyword">if</span>(fieldRefs.size()!=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UDFArgumentException(<span class="string">"Input Args Length Error!!！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//约定函数返回的列的名字</span></span><br><span class="line">        ArrayList&lt;String&gt; fieldNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    	fieldNames.add(<span class="string">"word"</span>);</span><br><span class="line">        <span class="comment">//约定函数返回的列的类型</span></span><br><span class="line">         ArrayList&lt;ObjectInspector&gt; fieldOIs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         fieldOIs.add(PrimitiveObjectInspectorFactory.javaStringObjectInspector);</span><br><span class="line">         <span class="keyword">return</span> ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames, fieldOIs);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 函数的逻辑处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> HiveException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        String argsData =  args[<span class="number">0</span>].toString();</span><br><span class="line">        String argsSplit = args[<span class="number">1</span>].toString();</span><br><span class="line">        <span class="comment">//切分数据</span></span><br><span class="line">        String[] words = argsData.split(argsSplit);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写出数据 每个单词一行</span></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="comment">//因为集合是重用的，所以每次要先清空</span></span><br><span class="line">            outList.clear();</span><br><span class="line">            <span class="comment">//将当前的单词放到集合中</span></span><br><span class="line">            outList.add(word);</span><br><span class="line">            <span class="comment">//将当前的单词作为一行写出去</span></span><br><span class="line">            forward(outList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需求扩展</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select myudtf2(&#39;hadoop-niupi,java-lihai,songsong-kuai,dahai-lang&#39;,&#39;,&#39;,&#39;-&#39;);</span><br><span class="line"> 结果: word1    word2</span><br><span class="line">      hadoop   niupi</span><br><span class="line">      java     lihai</span><br><span class="line">      songsong kuai</span><br><span class="line">      dahai    lang</span><br></pre></td></tr></table></figure>

<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringSplitUDTF2</span> <span class="keyword">extends</span> <span class="title">GenericUDTF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; outList  = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法  约定函数的返回值类型  和 函数的返回值列名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> argOIs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UDFArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StructObjectInspector <span class="title">initialize</span><span class="params">(StructObjectInspector argOIs)</span> <span class="keyword">throws</span> UDFArgumentException </span>&#123;</span><br><span class="line">        <span class="comment">//基本判断</span></span><br><span class="line">        List&lt;? extends StructField&gt; fieldRefs = argOIs.getAllStructFieldRefs();</span><br><span class="line">        <span class="keyword">if</span>(fieldRefs.size()!=<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UDFArgumentException(<span class="string">"Input Args Length Error!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//约定函数返回的列的名字</span></span><br><span class="line">        ArrayList&lt;String&gt; fieldNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        fieldNames.add(<span class="string">"word1"</span>);</span><br><span class="line">        fieldNames.add(<span class="string">"word2"</span>);</span><br><span class="line">        <span class="comment">//约定函数返回的列的类型</span></span><br><span class="line">        ArrayList&lt;ObjectInspector&gt; fieldOIs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        fieldOIs.add(PrimitiveObjectInspectorFactory.javaStringObjectInspector);</span><br><span class="line">        fieldOIs.add(PrimitiveObjectInspectorFactory.javaStringObjectInspector);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames, fieldOIs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 函数的逻辑处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> HiveException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line">        <span class="comment">//获取参数</span></span><br><span class="line">        String argsData = args[<span class="number">0</span>].toString(); <span class="comment">// hadoop-niupi,java-lihai,songsong-kuai,dahai-lang</span></span><br><span class="line">        String rowSplit = args[<span class="number">1</span>].toString(); <span class="comment">// ,</span></span><br><span class="line">        String colSplit = args[<span class="number">2</span>].toString(); <span class="comment">// -</span></span><br><span class="line">        <span class="comment">//切分数据</span></span><br><span class="line">        String[] rows = argsData.split(rowSplit);</span><br><span class="line">        <span class="keyword">for</span> (String row : rows) &#123;</span><br><span class="line">            <span class="comment">//因为集合是复用的，使用前先清空</span></span><br><span class="line">            outList.clear();</span><br><span class="line">            <span class="comment">// row : hadoop-niupi</span></span><br><span class="line">            String[] cols = row.split(colSplit);</span><br><span class="line">            <span class="keyword">for</span> (String word : cols) &#123;</span><br><span class="line">                outList.add(word);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//写出</span></span><br><span class="line">            forward(outList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-压缩和存储"><a href="#9-压缩和存储" class="headerlink" title="9. 压缩和存储"></a>9. 压缩和存储</h3><h4 id="9-1-Hadoop压缩配置"><a href="#9-1-Hadoop压缩配置" class="headerlink" title="9.1 Hadoop压缩配置"></a>9.1 Hadoop压缩配置</h4><h5 id="9-1-1-MR支持的压缩编码"><a href="#9-1-1-MR支持的压缩编码" class="headerlink" title="9.1.1 MR支持的压缩编码"></a>9.1.1 MR支持的压缩编码</h5><table>
<thead>
<tr>
<th>压缩格式</th>
<th>算法</th>
<th>文件扩展名</th>
<th>是否可切分</th>
</tr>
</thead>
<tbody><tr>
<td>DEFLATE</td>
<td>DEFLATE</td>
<td>.deflate</td>
<td>否</td>
</tr>
<tr>
<td>Gzip</td>
<td>DEFLATE</td>
<td>.gz</td>
<td>否</td>
</tr>
<tr>
<td>bzip2</td>
<td>bzip2</td>
<td>.bz2</td>
<td>是</td>
</tr>
<tr>
<td>LZO</td>
<td>LZO</td>
<td>.lzo</td>
<td>是</td>
</tr>
<tr>
<td>Snappy</td>
<td>Snappy</td>
<td>.snappy</td>
<td>否</td>
</tr>
</tbody></table>
<p>为了支持多种压缩/解压缩算法，Hadoop引入了编码/解码器，如下表所示：</p>
<table>
<thead>
<tr>
<th>压缩格式</th>
<th>对应的编码/解码器</th>
</tr>
</thead>
<tbody><tr>
<td>DEFLATE</td>
<td>org.apache.hadoop.io.compress.DefaultCodec</td>
</tr>
<tr>
<td>gzip</td>
<td>org.apache.hadoop.io.compress.GzipCodec</td>
</tr>
<tr>
<td>bzip2</td>
<td>org.apache.hadoop.io.compress.BZip2Codec</td>
</tr>
<tr>
<td>LZO</td>
<td>com.hadoop.compression.lzo.LzopCodec</td>
</tr>
<tr>
<td>Snappy</td>
<td>org.apache.hadoop.io.compress.SnappyCodec</td>
</tr>
</tbody></table>
<p>压缩性能的比较：</p>
<table>
<thead>
<tr>
<th>压缩算法</th>
<th>原始文件大小</th>
<th>压缩文件大小</th>
<th>压缩速度</th>
<th>解压速度</th>
</tr>
</thead>
<tbody><tr>
<td>gzip</td>
<td>8.3GB</td>
<td>1.8GB</td>
<td>17.5MB/s</td>
<td>58MB/s</td>
</tr>
<tr>
<td>bzip2</td>
<td>8.3GB</td>
<td>1.1GB</td>
<td>2.4MB/s</td>
<td>9.5MB/s</td>
</tr>
<tr>
<td>LZO</td>
<td>8.3GB</td>
<td>2.9GB</td>
<td>49.3MB/s</td>
<td>74.6MB/s</td>
</tr>
</tbody></table>
<p><a href="http://google.github.io/snappy/" target="_blank" rel="noopener">http://google.github.io/snappy/</a></p>
<p>On a single core of a Core i7 processor in 64-bit mode, Snappy compresses at about 250 MB/sec or more and decompresses at about 500 MB/sec or more.</p>
<p>用到比较多的是snappy和lzo</p>
<h5 id="9-1-2-压缩参数配置"><a href="#9-1-2-压缩参数配置" class="headerlink" title="9.1.2 压缩参数配置"></a>9.1.2 压缩参数配置</h5><p>​    要在Hadoop中启用压缩，可以配置如下参数（mapred-site.xml文件中）</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>默认值</th>
<th>阶段</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td>io.compression.codecs    （在core-site.xml中配置）</td>
<td>org.apache.hadoop.io.compress.DefaultCodec, org.apache.hadoop.io.compress.GzipCodec,  org.apache.hadoop.io.compress.BZip2Codec,  org.apache.hadoop.io.compress.Lz4Codec</td>
<td>输入压缩</td>
<td>Hadoop使用文件扩展名判断是否支持某种编解码器</td>
</tr>
<tr>
<td>mapreduce.map.output.compress</td>
<td>false</td>
<td>mapper输出</td>
<td>这个参数设为true启用压缩</td>
</tr>
<tr>
<td>mapreduce.map.output.compress.codec</td>
<td>org.apache.hadoop.io.compress.DefaultCodec</td>
<td>mapper输出</td>
<td>使用LZO、LZ4或snappy编解码器在此阶段压缩数据</td>
</tr>
<tr>
<td>mapreduce.output.fileoutputformat.compress</td>
<td>false</td>
<td>reducer输出</td>
<td>这个参数设为true启用压缩</td>
</tr>
<tr>
<td>mapreduce.output.fileoutputformat.compress.codec</td>
<td>org.apache.hadoop.io.compress. DefaultCodec</td>
<td>reducer输出</td>
<td>使用标准工具或者编解码器，如gzip和bzip2</td>
</tr>
<tr>
<td>mapreduce.output.fileoutputformat.compress.type</td>
<td>RECORD</td>
<td>reducer输出</td>
<td>SequenceFile输出使用的压缩类型：NONE和BLOCK</td>
</tr>
</tbody></table>
<h4 id="9-2-开启Map端输出阶段压缩（MR引擎）"><a href="#9-2-开启Map端输出阶段压缩（MR引擎）" class="headerlink" title="9.2 开启Map端输出阶段压缩（MR引擎）"></a>9.2 开启Map端输出阶段压缩（MR引擎）</h4><p>​    开启map输出阶段压缩可以减少job中map和ReduceTask间的数据传输率。具体配置如下</p>
<p>1）案例实操</p>
<p>（1）开启hive中间传输数据压缩功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt;set hive.exec.compress.intermediate&#x3D;true;</span><br></pre></td></tr></table></figure>

<p>（2）开启MapReduce中map输出压缩功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt;set mapreduce.map.output.compress&#x3D;true;</span><br></pre></td></tr></table></figure>

<p>（3）设置MapReduce中map输出数据的压缩方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt;set mapreduce.map.output.compress.codec&#x3D;</span><br><span class="line"> org.apache.hadoop.io.compress.SnappyCodec;</span><br></pre></td></tr></table></figure>

<p>（4）执行查询语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; select count(ename) name from emp;</span><br></pre></td></tr></table></figure>



<h4 id="9-3-开启Reduce输出阶段压缩"><a href="#9-3-开启Reduce输出阶段压缩" class="headerlink" title="9.3 开启Reduce输出阶段压缩"></a>9.3 开启Reduce输出阶段压缩</h4><p>​    当Hive将输出写到表中时，输出内容同样可以进行压缩。属性hive.exec.compress.output控制着这个功能。用户可能需要保持默认设置文件中的默认值false，这样默认的输出就是非压缩的纯文本文件了。用户可以通过在查询语句或执行脚本中设置这个值为true，来开启输出结果压缩功能。</p>
<p>1）案例实操</p>
<p>（1）开启hive最终输出数据压缩功能  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt;set hive.exec.compress.output&#x3D;true;</span><br></pre></td></tr></table></figure>

<p>（2）开启mapreduce最终输出数据压缩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt;set mapreduce.output.fileoutputformat.compress&#x3D;true;</span><br></pre></td></tr></table></figure>

<p>（3）设置mapreduce最终数据输出压缩方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; set mapreduce.output.fileoutputformat.compress.codec &#x3D;</span><br><span class="line"> org.apache.hadoop.io.compress.SnappyCodec;</span><br></pre></td></tr></table></figure>

<p>（4）设置mapreduce最终数据输出压缩为块压缩  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; set mapreduce.output.fileoutputformat.compress.type&#x3D;BLOCK;</span><br></pre></td></tr></table></figure>

<p>（5）测试一下输出结果是否是压缩文件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; insert overwrite local directory</span><br><span class="line"> &#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;distribute-result&#39; select * from emp distribute by deptno sort by empno desc;</span><br></pre></td></tr></table></figure>

<h4 id="9-4-文件存储格式"><a href="#9-4-文件存储格式" class="headerlink" title="9.4 文件存储格式"></a>9.4 文件存储格式</h4><p>​    HIve支持的存储数据的格式有：TEXTFILE,SEQUENCEFILE,QRC,PARQUET。</p>
<h4 id="9-4-1-列式存储和行式存储"><a href="#9-4-1-列式存储和行式存储" class="headerlink" title="9.4.1 列式存储和行式存储"></a>9.4.1 列式存储和行式存储</h4><p>1）行存储的特点</p>
<p>​    查询满足条件的一整行数据的时候，列存储则需要去每个聚集的字段找到对应的每个列的值，行存储只需要找到其中一个值，其余的值都在相邻地方，所以此时行存储查询的速度更快。</p>
<p>2）列存储的特点</p>
<p>​    因为每个字段的数据聚集存储，在查询只需要少数几个字段的时候，能大大减少读取的数据量；每个字段的数据类型一定是相同的，列式存储可以针对性的设计更好的设计压缩算法。</p>
<p>​    TEXTFIlE和SEQUENCEFILE的存储格式都是基于行存储的</p>
<p>​    ORC和PARQUET是基于列式存储的</p>
<p>​    因为通常查询的时候大多数情况都不会去查询所有的字段，而是查询某些属性，或对某几个字段进行计算，所以大多数情况还是列式存储，这样查询效率会更快一点。</p>
<h5 id="9-4-2-TextFile格式"><a href="#9-4-2-TextFile格式" class="headerlink" title="9.4.2 TextFile格式"></a>9.4.2 TextFile格式</h5><p>​    默认格式，数据不做压缩，磁盘开销大，磁盘开销大，数据解析开销大。可结合Gzip和Bzip2使用，但是用Gzip这种方式，hive不会对数据进行切分，从而无法对数据进行并行操作。</p>
<h4 id="9-4-3-Orc格式"><a href="#9-4-3-Orc格式" class="headerlink" title="9.4.3 Orc格式"></a>9.4.3 Orc格式</h4><p>​    Orc(Optimized Row Columnar)是Hive0.11版里引入的新的存储格式。</p>
<p>​    每个Orc文件由1个或多个stripe组成，每个stripe一般为HDFS的块大小，每一个stripe包含多条记录，这些记录按照列进行独立存储，对应到Parquet中的row group的概念。每个Stripe里有三部分组成，分别是Index Data，Row Data，Stripe Footer。</p>
<p>1）Index Data：一个轻量级的index，默认是每隔1W行做一个索引。这里做的索引应该只是记录某行的各字段在Row Data中的offset。</p>
<p>2）Row Data：存的是具体的数据，先取部分行，然后对这些行按列进行存储。对每个列进行了编码，分成多个Stream来存储。</p>
<p>3）Stripe Footer：存的是各个Stream的类型，长度等信息。</p>
<p>​    每个文件有一个File Footer，这里面存的是每个Stripe的行数，每个Column的数据类型信息等；每个文件的尾部是一个PostScript，这里面记录了整个文件的压缩类型以及FileFooter的长度信息等。在读取文件时，会seek到文件尾部读PostScript，从里面解析到File Footer长度，再读FileFooter，从里面解析到各个Stripe信息，再读各个Stripe，即从后往前读。</p>
<h5 id="9-4-4-Parquet格式"><a href="#9-4-4-Parquet格式" class="headerlink" title="9.4.4 Parquet格式"></a>9.4.4 Parquet格式</h5><p>​    Parquet文件是以二进制方式存储的，所以是不可以直接读取的，文件中包括该文件的数据和元数据，因此Parquet格式是自解析的。</p>
<p>（1）行组(Row Group)：每一个行组包含一定的行数，在一个HDFS文件中至少存储一个行组，类似于orc的stripe的概念  </p>
<p>（2）列块(Column Chunk)：在一个行组中每一列保存在一个列块中，行组中的所有列连续的存储在这个行组文件中。一个列块中的值都是相同类型的，不同的列块可能使用不同的算法进行压缩。</p>
<p>（3）页(Page)：每一个列块划分为多个页，一个页是最小的编码的单位，在同一个列块的不同页可能使用不同的编码方式。  </p>
<p>​    通常情况下，在存储Parquet数据的时候会按照Block大小设置行组的大小，由于一般情况下每一个Mapper任务处理数据的最小单位是一个Block，这样可以把每一个行组由一个Mapper任务处理，增大任务执行并行度。</p>
<h5 id="9-4-5-主流文件存储格式对比试验"><a href="#9-4-5-主流文件存储格式对比试验" class="headerlink" title="9.4.5 主流文件存储格式对比试验"></a>9.4.5 主流文件存储格式对比试验</h5><p>1）准备测试数据</p>
<p>2）TextFile</p>
<p>（1）创建表，存储数据格式为TEXTFILE</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> log_text (</span><br><span class="line">track_time <span class="keyword">string</span>,</span><br><span class="line"><span class="keyword">url</span> <span class="keyword">string</span>,</span><br><span class="line">session_id <span class="keyword">string</span>,</span><br><span class="line">referer <span class="keyword">string</span>,</span><br><span class="line">ip <span class="keyword">string</span>,</span><br><span class="line">end_user_id <span class="keyword">string</span>,</span><br><span class="line">city_id <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span></span><br><span class="line"><span class="keyword">stored</span> <span class="keyword">as</span> textfile;</span><br></pre></td></tr></table></figure>

<p>（2）向表中加载数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; load data local inpath &#39;&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas&#x2F;log.data&#39; into table log_text ;</span><br></pre></td></tr></table></figure>

<p>（3）查看表中数据大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; dfs -du -h &#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;log_text;</span><br></pre></td></tr></table></figure>

<p>3）ORC</p>
<p>（11）创建表，存储数据格式为ORC</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> log_orc(</span><br><span class="line">track_time <span class="keyword">string</span>,</span><br><span class="line"><span class="keyword">url</span> <span class="keyword">string</span>,</span><br><span class="line">session_id <span class="keyword">string</span>,</span><br><span class="line">referer <span class="keyword">string</span>,</span><br><span class="line">ip <span class="keyword">string</span>,</span><br><span class="line">end_user_id <span class="keyword">string</span>,</span><br><span class="line">city_id <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span></span><br><span class="line"><span class="keyword">stored</span> <span class="keyword">as</span> orc</span><br><span class="line">tblproperties(<span class="string">"orc.compress"</span> = <span class="string">"NONE"</span>);<span class="comment">--设置ORC存储不能使用压缩</span></span><br></pre></td></tr></table></figure>

<p>（2）向表中加载数据</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; insert into table log_orc select * from log_text ;</span><br></pre></td></tr></table></figure>

<p>（3）查看表中数据大小</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; dfs -du -h /user/hive/warehouse/log_orc/ ;</span><br></pre></td></tr></table></figure>

<p>4）Parquet</p>
<p>（1）创建表，存储数据格式为parquet</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table log_parquet(</span><br><span class="line">track_time string,</span><br><span class="line">url string,</span><br><span class="line">session_id string,</span><br><span class="line">referer string,</span><br><span class="line">ip string,</span><br><span class="line">end_user_id string,</span><br><span class="line">city_id string</span><br><span class="line">)</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;</span><br><span class="line">stored as parquet;</span><br></pre></td></tr></table></figure>

<p>（2）向表中加载数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; insert into table log_parquet select * from log_text ;</span><br></pre></td></tr></table></figure>

<p>（3）查看表中数据大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; dfs -du -h &#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;log_parquet&#x2F; ;</span><br></pre></td></tr></table></figure>

<p>存储文件的对比总结：</p>
<p>ORC &gt; Parquet &gt; textFile</p>
<p>可以通过测试发现这三种格式存储的文件查询速度相近</p>
<h4 id="9-5-存储和压缩结合"><a href="#9-5-存储和压缩结合" class="headerlink" title="9.5 存储和压缩结合"></a>9.5 存储和压缩结合</h4><h4 id="9-5-1-测试存储和压缩"><a href="#9-5-1-测试存储和压缩" class="headerlink" title="9.5.1 测试存储和压缩"></a>9.5.1 测试存储和压缩</h4><p>官网：<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+ORC" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+ORC</a></p>
<p>ORC存储方式的压缩</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Default</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>orc.compress</td>
<td>ZLIB</td>
<td>high level  compression (one of NONE, ZLIB, SNAPPY)</td>
</tr>
<tr>
<td>orc.compress.size</td>
<td>262,144</td>
<td>number of bytes  in each compression chunk</td>
</tr>
<tr>
<td>orc.stripe.size</td>
<td>268,435,456</td>
<td>number of bytes in each stripe</td>
</tr>
<tr>
<td>orc.row.index.stride</td>
<td>10,000</td>
<td>number of rows between index entries (must be &gt;= 1000)</td>
</tr>
<tr>
<td>orc.create.index</td>
<td>true</td>
<td>whether to create  row indexes</td>
</tr>
<tr>
<td>orc.bloom.filter.columns</td>
<td>“”</td>
<td>comma separated list of column names for which bloom filter should be  created</td>
</tr>
<tr>
<td>orc.bloom.filter.fpp</td>
<td>0.05</td>
<td>false positive probability for bloom filter (must &gt;0.0 and &lt;1.0)</td>
</tr>
</tbody></table>
<p>​    注意：所有关于ORCFile的参数都是在HQL语句的TBLPROPERTIES字段里面出现</p>
<p>1）创建一个ZLIB压缩的ORC存储方式</p>
<p>（1）建表语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table log_orc_zlib(</span><br><span class="line">track_time string,</span><br><span class="line">url string,</span><br><span class="line">session_id string,</span><br><span class="line">referer string,</span><br><span class="line">ip string,</span><br><span class="line">end_user_id string,</span><br><span class="line">city_id string</span><br><span class="line">)</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;</span><br><span class="line">stored as orc</span><br><span class="line">tblproperties(&quot;orc.compress&quot;&#x3D;&quot;ZLIB&quot;);</span><br></pre></td></tr></table></figure>

<p>（2）插入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into log_orc_zlib select * from log_text;</span><br></pre></td></tr></table></figure>

<p>（3）查看插入后数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; dfs -du -h &#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;log_orc_zlib&#x2F; ;</span><br></pre></td></tr></table></figure>

<p>2）创建一个snappy压缩的ORC存储方式</p>
<p>（1）建表语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table log_orc_snappy(</span><br><span class="line">track_time string,</span><br><span class="line">url string,</span><br><span class="line">session_id string,</span><br><span class="line">referer string,</span><br><span class="line">ip string,</span><br><span class="line">end_user_id string,</span><br><span class="line">city_id string</span><br><span class="line">)</span><br><span class="line">row format delimited fields terminated by &#39;\t&#39;</span><br><span class="line">stored as orc</span><br><span class="line">tblproperties(&quot;orc.compress&quot;&#x3D;&quot;SNAPPY&quot;);</span><br></pre></td></tr></table></figure>

<p>（2）插入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into log_orc_snappy select * from log_text;</span><br></pre></td></tr></table></figure>

<p>（3）查看插入后数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; dfs -du -h &#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;log_orc_snappy&#x2F; ;</span><br></pre></td></tr></table></figure>

<p>……</p>
<p>4）存储方式和压缩总结</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在实际的项目开发当中，hive表的数据存储格式一般选择：orc或parquet。压缩方式一般选择snappy，lzo。</span><br></pre></td></tr></table></figure>



<h3 id="10-企业级调优"><a href="#10-企业级调优" class="headerlink" title="10 . 企业级调优"></a>10 . 企业级调优</h3><h3 id="11-Hive实战"><a href="#11-Hive实战" class="headerlink" title="11. Hive实战"></a>11. Hive实战</h3><h4 id="11-1-需求描述"><a href="#11-1-需求描述" class="headerlink" title="11.1 需求描述"></a>11.1 需求描述</h4><p>统计硅谷影音视频网站的常规指标，各种TopN指标：</p>
<p>– 统计视频观看数Top10</p>
<p>– 统计视频类别热度Top10</p>
<p>– 统计出视频观看数最高的20个视频的所属类别以及类别包含Top20视频的个数</p>
<p>– 统计视频观看数Top50所关联视频的所属类别Rank</p>
<p>– 统计每个类别中的视频热度Top10,以Music为例</p>
<p>– 统计每个类别视频观看数Top10</p>
<p>– 统计上传视频最多的用户Top10以及他们上传的视频观看次数在前20的视频 </p>
<h4 id="11-2-数据结构"><a href="#11-2-数据结构" class="headerlink" title="11.2 数据结构"></a>11.2 数据结构</h4><p>1）视频表</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>备注</th>
<th>详细描述</th>
</tr>
</thead>
<tbody><tr>
<td>videoId</td>
<td>视频唯一id（String）</td>
<td>11位字符串</td>
</tr>
<tr>
<td>uploader</td>
<td>视频上传者（String）</td>
<td>上传视频的用户名String</td>
</tr>
<tr>
<td>age</td>
<td>视频年龄（int）</td>
<td>视频在平台上的整数天</td>
</tr>
<tr>
<td>category</td>
<td>视频类别（Array<String>）</td>
<td>上传视频指定的视频分类</td>
</tr>
<tr>
<td>length</td>
<td>视频长度（Int）</td>
<td>整形数字标识的视频长度</td>
</tr>
<tr>
<td>views</td>
<td>观看次数（Int）</td>
<td>视频被浏览的次数</td>
</tr>
<tr>
<td>rate</td>
<td>视频评分（Double）</td>
<td>满分5分</td>
</tr>
<tr>
<td>Ratings</td>
<td>流量（Int）</td>
<td>视频的流量，整型数字</td>
</tr>
<tr>
<td>conments</td>
<td>评论数（Int）</td>
<td>一个视频的整数评论数</td>
</tr>
<tr>
<td>relatedId</td>
<td>相关视频id（Array<String>）</td>
<td>相关视频的id，最多20个</td>
</tr>
</tbody></table>
<p>2）用户表</p>
<table>
<thead>
<tr>
<th><strong>字段</strong></th>
<th><strong>备注</strong></th>
<th><strong>字段类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td>uploader</td>
<td>上传者用户名</td>
<td>string</td>
</tr>
<tr>
<td>videos</td>
<td>上传视频数</td>
<td>int</td>
</tr>
<tr>
<td>friends</td>
<td>朋友数量  （关注的人）</td>
<td>int</td>
</tr>
</tbody></table>
<h4 id="11-3-准备工作"><a href="#11-3-准备工作" class="headerlink" title="11.3 准备工作"></a>11.3 准备工作</h4><h5 id="11-3-1-ETL"><a href="#11-3-1-ETL" class="headerlink" title="11.3.1 ETL"></a>11.3.1 ETL</h5><p>​    通过观察原始数据形式，可以发现，视频可以有多个所属分类，每个所属分类用&amp;符号分割，且分割的两边有空格字符，同时相关视频也是可以有多个元素，多个相关视频又用“\t”进行分割。为了分析数据时方便对存在多个子元素的数据进行操作，我们首先进行数据重组清洗操作。即：将所有的类别用“&amp;”分割，同时去掉两边空格，多个相关视频id也使用“&amp;”进行分割。</p>
<p>1）ETL之封装工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ETLUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	* 数据清洗方法</span></span><br><span class="line"><span class="comment"> 	*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String  <span class="title">etlData</span><span class="params">(String srcData)</span></span>&#123;</span><br><span class="line">        StringBuffer resultData = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">//1. 先将数据通过\t 切割</span></span><br><span class="line">        String[] datas = srcData.split(<span class="string">"\t"</span>);</span><br><span class="line">        <span class="comment">//2. 判断长度是否小于9</span></span><br><span class="line">        <span class="keyword">if</span>(datas.length &lt;<span class="number">9</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 将数据中的视频类别的空格去掉</span></span><br><span class="line">        datas[<span class="number">3</span>]=datas[<span class="number">3</span>].replaceAll(<span class="string">" "</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="comment">//4. 将数据中的关联视频id通过&amp;拼接</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; datas.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">9</span>)&#123;</span><br><span class="line">                <span class="comment">//4.1 没有关联视频的情况</span></span><br><span class="line">                <span class="keyword">if</span>(i == datas.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    resultData.append(datas[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    resultData.append(datas[i]).append(<span class="string">"\t"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//4.2 有关联视频的情况</span></span><br><span class="line">                <span class="keyword">if</span>(i == datas.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    resultData.append(datas[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    resultData.append(datas[i]).append(<span class="string">"&amp;"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultData.toString();</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2）ETL之Mapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清洗谷粒影音的原始数据</span></span><br><span class="line"><span class="comment"> * 清洗规则</span></span><br><span class="line"><span class="comment"> *  1. 将数据长度小于9的清洗掉</span></span><br><span class="line"><span class="comment"> *  2. 将数据中的视频类别中间的空格去掉   People &amp; Blogs</span></span><br><span class="line"><span class="comment"> *  3. 将数据中的关联视频id通过&amp;符号拼接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EtlMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>,<span class="title">Text</span>, <span class="title">NullWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Text k = <span class="keyword">new</span> Text();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">       <span class="comment">//获取一行</span></span><br><span class="line">        String line = value.toString();</span><br><span class="line">        <span class="comment">//清洗</span></span><br><span class="line">        String resultData = ETLUtil.etlData(line);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(resultData != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//写出</span></span><br><span class="line">            k.set(resultData);</span><br><span class="line">            context.write(k,NullWritable.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）ETL之Driver</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.atguigu.gulivideo.etl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.NullWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EtlDriver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job  = Job.getInstance(conf);</span><br><span class="line">        job.setJarByClass(EtlDriver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapperClass(EtlMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(NullWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(NullWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setNumReduceTasks(<span class="number">0</span>);</span><br><span class="line">        FileInputFormat.setInputPaths(job,<span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job,<span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">        job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）将ETL程序打包为etl.jar并上传到Linux的/opt/module/hive/datas目录下</p>
<p>5）上传原始数据到HDFS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 datas] pwd</span><br><span class="line">&#x2F;opt&#x2F;module&#x2F;hive&#x2F;datas</span><br><span class="line">[atguigu@hadoop102 datas] hadoop fs -mkdir -p  &#x2F;gulivideo&#x2F;video</span><br><span class="line">[atguigu@hadoop102 datas] hadoop fs -mkdir -p  &#x2F;gulivideo&#x2F;user</span><br><span class="line">[atguigu@hadoop102 datas] hadoop fs -put gulivideo&#x2F;user&#x2F;user.txt   &#x2F;gulivideo&#x2F;user</span><br><span class="line">[atguigu@hadoop102 datas] hadoop fs -put gulivideo&#x2F;video&#x2F;*.txt   &#x2F;gulivideo&#x2F;video</span><br></pre></td></tr></table></figure>

<p>6）ETL数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 datas] hadoop jar  etl.jar  com.atguigu.hive.etl.EtlDriver &#x2F;gulivideo&#x2F;video &#x2F;gulivideo&#x2F;video&#x2F;output</span><br></pre></td></tr></table></figure>

<h5 id="11-3-2-准备表"><a href="#11-3-2-准备表" class="headerlink" title="11.3.2 准备表"></a>11.3.2 准备表</h5><p>​    1）需要准备的表</p>
<p>​    2）创建原始数据表</p>
<p>​    3）创建ORC存储格式带snappy压缩的表</p>
<h5 id="11-3-3-安装Tez引擎"><a href="#11-3-3-安装Tez引擎" class="headerlink" title="11.3.3 安装Tez引擎"></a>11.3.3 安装Tez引擎</h5>]]></content>
      <categories>
        <category>大数据</category>
        <category>Hive</category>
      </categories>
  </entry>
  <entry>
    <title>Hadoop HA</title>
    <url>/2020/05/30/Hadoop-HA/</url>
    <content><![CDATA[<h3 id="Hadoop-HA高可用"><a href="#Hadoop-HA高可用" class="headerlink" title="Hadoop HA高可用"></a>Hadoop HA高可用</h3><ol start="0">
<li><p>问题引入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目前Hadoop集群存在的问题:</span><br><span class="line">如果NameNode故障后，应该怎么办?</span><br><span class="line">      </span><br><span class="line">1)因为NameNode是HDFS的中心.所有的DN都要围绕着NN工作,如果NN故障后，整个HDFS不能在正常进行服务.</span><br><span class="line">      </span><br><span class="line">2)如上的问题就是比较典型的单点故障.</span><br><span class="line">      </span><br><span class="line">3)解决办法是: 搭建多个NameNode,其中一个是Active状态，就是正常对外提供服务.其他的NameNode都是standby状态,是不能对外提供服务的.只有当Active的NN故障后,StandBy状态的NN才有机会上位，代替之前的NN对外提供服务.</span><br><span class="line">4)待解决问题:</span><br><span class="line">a. 多个StandBy NN 如何保证与 Active NN 中的数据保持一致?</span><br><span class="line">	使用journalNode做为共享存储， ActiveNN 将edits写到JN中， StandByNN 从JN中读取edits在内存中进行重构，重构完后，就能保障StantByNN 和ActiveNN元数据一致.</span><br><span class="line">	   </span><br><span class="line">b. 多个StandBy NN 之间的争夺上位问题 </span><br><span class="line">脑裂问题: 一个集群中出现多个Active的NN</span><br><span class="line">手动故障转移: 完全由开发人员控制.</span><br><span class="line"></span><br><span class="line">	自动故障转移: 争抢. 每个NN都对应一个ZKFC进程(由hadoop提供的，可以访问Zookeeper的客户端对象), ZKFC负责监控NN的健康状态以及故障转移. ZKFC会在自己所维护的NN为健康状态的情况下，到ZK中争抢znode锁，如果获取锁成功，则将自己所维护的NN切换为Active状态.如果ZKFC所维护的NN为Active状态，当NN不健康后(ZKFC认为的),zkfc会断开与zk的连接,这样的话，在zk中拥有的锁也就释放，别的ZKFC发现没有别的ZKFC拥有锁的情况下，会尝试获取Znode锁，如果获取成功，则将自己所维护的NN切换为Active状态. 从而实现自动故障转移.</span><br><span class="line"></span><br><span class="line">	自动故障转移如何解决脑裂问题:</span><br><span class="line">	一个ZKFC所负责的NN为Active状态,当ZKFC认为NN不健康后，会触发自动故障转移,此时，其他的ZKFC会尝试获取znode锁，假如获取成功, 为了保证不出现脑裂问题，会SSH到原先ActiveNN的机器，执行Kill Namenode的命令. 扫清一切障碍后,然后才会将自己负责的NN切换为Active状态.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.2  如果ResourceManager故障后，应该怎么办?</span><br><span class="line">	跟NameNode处理类似</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol>
<li><p>HA概述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）所谓HA（High Availability），即高可用（7*24小时不中断服务）</span><br><span class="line">2）实现高可用的关键的策略是消除单点故障（单个重要节点出现问题，整个集群都可不用）。HA严格来说应该分为各个组件的HA机制：HDFS的HA和YARN的HA</span><br><span class="line">3）Hadoop2.0之前，在HDFS集群中NameNode存在单点故障SPOF（Single Points Of Failure）</span><br><span class="line">4）NameNode主要在以下两个方面影响HDFS集群</span><br><span class="line">	NameNode机器发生意外，如宕机，集群将无法使用，直到管理员重启</span><br><span class="line">	NameNode机器需要升级，包括软件，硬件升级，此时集群将无法使用</span><br><span class="line">	HDFS HA功能通过配置Active&#x2F;Standby两个NameNodes实现在集群中对NameNode的热备来解决上述问题。如果出现故障，如机器崩溃或机器需要实现维护升级，这时可通过此种方式将NameNode很快的切换到另外一台机器。</span><br></pre></td></tr></table></figure>
</li>
<li><p>HDFS HA搭建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）安装Hadoop，根据参考文档修改配置文件</span><br><span class="line">2）修改环境变量HADOOP_HOME，配置化为ha集群的位置，例如HADOOP_HOME&#x3D;&#x2F;opt&#x2F;module&#x2F;ha&#x2F;hadoop-3.1.3</span><br><span class="line">3）为了避免一些不必要的问题，删除每台机器&#x2F;tmp目录下的内容</span><br><span class="line">4）分发配置好的ha</span><br><span class="line">5）在每台机器上启动JN</span><br><span class="line">	hdfs --daemon start journalnode</span><br><span class="line">6）在任意一台nn上进行格式化操作，例如nn1</span><br><span class="line">	nn1: hdfs namenode -format</span><br><span class="line">7）启动nn1,然后其它namenode同步nn1的数据</span><br><span class="line">	nn1: hdfs --daemon start namenode</span><br><span class="line">	nn2: hdfs namenode -bootstrapStandBy</span><br><span class="line">	nn3: hdfs namenode -bootstrapStandBy</span><br><span class="line">8）启动nn2,nn3</span><br><span class="line">	nn2: hdfs --daemon start namenode</span><br><span class="line">	nn3: hdfs --daemon start namenode</span><br><span class="line">9）在每台机器上启动DN</span><br><span class="line">	hdfs --daemon start datenode</span><br><span class="line">10）将其中一个nn切换为Active状态</span><br><span class="line">	hdfs haadmin -transitionToActive nn1</span><br><span class="line">按照上面的步骤就配好了，可以从浏览器中访问NameNode查看各自的状态，但是这里不会自动进行故障转移处理</span><br><span class="line">自动故障转移还需要下面的配置</span><br><span class="line">自动故障转移HDFS HA集群规划(Zookeeper的搭建跟HA没关系，只要配置文件中配置了Zookeeper的位置，可以通过Hadoop提供的ZKFC客户端能连接到Zookeeper使用就可以了)：</span><br><span class="line">hadoop102: NameNode DataNode JournalNode ZKFC Zookeeper</span><br><span class="line">hadoop103: NameNode DataNode JournalNode ZKFC Zookeeper</span><br><span class="line">hadoop104: NameNOde DataNode JournalNode ZKFC Zookeeper</span><br><span class="line">	</span><br><span class="line">自动故障转移HDFSHA搭建</span><br><span class="line">1）根据参考文档添加相应的配置</span><br><span class="line">2）搭建Zookeeper集群并启动</span><br><span class="line">3）关闭hdfs服务</span><br><span class="line">	stop-dfs.sh</span><br><span class="line">4）初始化HA在zk中的状态</span><br><span class="line">	hdfs zkfc -formatZK</span><br><span class="line">5）启动hdfs服务</span><br><span class="line">	start-dfs.sh</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>YARN HA搭建  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YARN HA集群规划</span><br><span class="line">hadoop102 :   Namenode  Datanode JournalNode   ZKFC  ZK  ResourceManager  NodeManager</span><br><span class="line">hadoop103 :   Namenode  Datanode JournalNode   ZKFC  ZK  ResourceManager  NodeManager</span><br><span class="line">hadoop104 :   Namenode  Datanode JournalNode   ZKFC  ZK  ResourceManager  NodeManager</span><br><span class="line"></span><br><span class="line">YARN HA 搭建过程</span><br><span class="line">1）根据参考文档添加相应的配置</span><br><span class="line">2）启动</span><br><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>可能遇到的问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）搭建好HA后，通过start-dfs.sh启动集群,发现NameNode会掉.但是重新启动NameNode后，就正常运行，这是因为在HA集群中,NameNode启动后，需要找到JN，但是start-dfs.sh脚本启动的顺序是先起NN，后起JN，因此可能因为NN启动后，尝试连接JN，但是JN还没有启动起来. 超时以后，NN自动掉了. </span><br><span class="line">相关的两个配置</span><br><span class="line">1) 最大重试次数</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">	&lt;name&gt;ipc.client.connect.max.retries&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;value&gt;10&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">  2) 每次重试的间隔</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">      &lt;name&gt;ipc.client.connect.retry.interval&lt;&#x2F;name&gt;</span><br><span class="line">      &lt;value&gt;1000&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
  </entry>
  <entry>
    <title>zookeeper基本介绍</title>
    <url>/2020/05/29/zookeeper%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.  基本介绍"></a>1.  基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Zookeeper是一个开源的分布式，为分布式应用提供协调服务的Apache。</span><br><span class="line">Zookeeper从设计模式角度来理解，是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生了变化，Zookeeper就负责通知已经在Zookeeper上注册的那些观察者做出相应的反应.</span><br><span class="line">Zookeeper &#x3D; 文件系统 + 通知机制</span><br></pre></td></tr></table></figure>

<h4 id="1-1-Zookeeper特点"><a href="#1-1-Zookeeper特点" class="headerlink" title="1.1 Zookeeper特点"></a>1.1 Zookeeper特点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）Zookeeper：由一个Leader，多个Follower组成的集群</span><br><span class="line">2）集群中只要有半数以上的节点存活，Zookeeper集群就能正常服务</span><br><span class="line">3）全局数据一致；每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的</span><br><span class="line">4）更新要求顺序进行，来自同一个Client的更新请求按其发送顺序依次执行</span><br><span class="line">5）数据更新原子性，一次数据要么更新成功，要么失败</span><br><span class="line">6）实时性，在一定时间范围内，Client能读到最新数据</span><br></pre></td></tr></table></figure>



<h4 id="1-2-数据结构"><a href="#1-2-数据结构" class="headerlink" title="1.2 数据结构"></a>1.2 数据结构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Zookeeper数据模型的结构与Linux文件系统很类似，整体上可以看作是一棵树，每个节点称作为一个ZNode，每一个ZNode默认能够存储1MB的数据，每个ZNode都可以通过唯一路径进行标识。</span><br></pre></td></tr></table></figure>

<h4 id="1-3-应用场景"><a href="#1-3-应用场景" class="headerlink" title="1.3 应用场景"></a>1.3 应用场景</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提供更多服务包括：统一命名服务，统一配置管理，统一集群管理，服务器节点动态上下线，软负载均衡等。</span><br></pre></td></tr></table></figure>



<h4 id="1-4-下载地址"><a href="#1-4-下载地址" class="headerlink" title="1.4 下载地址"></a>1.4 下载地址</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;zookeeper.apache.org</span><br></pre></td></tr></table></figure>



<h3 id="2-Zookeeper内部原理"><a href="#2-Zookeeper内部原理" class="headerlink" title="2. Zookeeper内部原理"></a>2. Zookeeper内部原理</h3><h4 id="2-1-节点类型"><a href="#2-1-节点类型" class="headerlink" title="2.1 节点类型"></a>2.1 节点类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）持久节点：客户端和zk服务断开连接后，持久节点不会被删除（除非手动删除）</span><br><span class="line">	（1）普通持久节点</span><br><span class="line">	（2）带序号的短暂节点（序号是Zookeeper自己维护的）</span><br><span class="line">2）短暂节点：客户端与zk服务断开连接后，短暂节点会自动删除</span><br><span class="line">	（1）普通短暂节点</span><br><span class="line">	（2）带序号的短暂节点（序号是Zookeeper自己维护的）</span><br></pre></td></tr></table></figure>

<h4 id="2-2-监听器原理"><a href="#2-2-监听器原理" class="headerlink" title="2.2 监听器原理"></a>2.2 监听器原理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）创建Zk客户端对象时，会对应着创建两个线程，一个是connect线程，一个是listener线程</span><br><span class="line">2）connect线程：负责zk客户端与zk服务的通信，例如心跳等等</span><br><span class="line">3）listener线程：负责监听的事情。当zk客户端在zk服务中心注册的监听事件发生后，zk服务会通知到listener线程，listener线程会调用内部的process方法做出相应</span><br></pre></td></tr></table></figure>

<h4 id="2-3-Zookeeper选举机制"><a href="#2-3-Zookeeper选举机制" class="headerlink" title="2.3 Zookeeper选举机制"></a>2.3 Zookeeper选举机制</h4><h5 id="2-3-1-基于ZAB协议"><a href="#2-3-1-基于ZAB协议" class="headerlink" title="2.3.1 基于ZAB协议"></a>2.3.1 基于ZAB协议</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基于消息传递且保证数据一致性的一种算法（协议）</span><br><span class="line">ZAB协议的目标：</span><br><span class="line">1）没有leader的情况选取leader</span><br><span class="line">2）有leader的情况，去尽可能保证数据一致</span><br></pre></td></tr></table></figure>

<h5 id="2-3-2-半数机制"><a href="#2-3-2-半数机制" class="headerlink" title="2.3.2  半数机制"></a>2.3.2  半数机制</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">整个Zookeeper集群中，只有有半数以上的机器存活，Zookeeper集群就能够对外提供服务，也就意味着在启动Zookeeper集群时，只要启动的机器超过半数，leader也就能选举出来</span><br></pre></td></tr></table></figure>

<h5 id="2-3-2-Zookeeper集群中的机器角色"><a href="#2-3-2-Zookeeper集群中的机器角色" class="headerlink" title="2.3.2 Zookeeper集群中的机器角色"></a>2.3.2 Zookeeper集群中的机器角色</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）leader：领导者（只有一个）</span><br><span class="line">2）follower：跟随者（可有多个）</span><br></pre></td></tr></table></figure>

<h5 id="2-3-3-leader选举过程"><a href="#2-3-3-leader选举过程" class="headerlink" title="2.3.3 leader选举过程"></a>2.3.3 leader选举过程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1) 新的集群启动: </span><br><span class="line">          </span><br><span class="line">	  关注点: 集群中的每台机器中都没有存储任何数据(生来平等:zxid都一样)</span><br><span class="line">	 </span><br><span class="line">	  选择过程:   有5台机器,分别给5台机器进行编号(myid)，例如: 1 2 3 4 5 ， </span><br><span class="line">	              假设按照1 2 3 4 5 的顺序启动机器(且假设真正启动起来的顺序也是1 2 3 4 5 )</span><br><span class="line">	  </span><br><span class="line">	  投票: 自私原则 ，墙头草随风倒.</span><br><span class="line">         </span><br><span class="line">	  启动server1: 第一票投给自己(1,zxid),此时，机器数没有达到半数,leader未选举</span><br><span class="line">	  启动server2: 第一票投给自己(2,zxid), </span><br><span class="line">	           server2将(2,zxid)投给server1， server1将(1,zxid)投给server2，</span><br><span class="line">		       server2比较自己的投票(2,zxid) 与 server1的投票(1,zxid)， 2 &gt;1 , 则server2保持自己的投票</span><br><span class="line">		       server1比较自己的投票(1,zxid) 与 server2的投票(2,zxid）  1 &lt;2 , 技不如人，改变投票，server1改投(2,zxid)</span><br><span class="line">		       因此最终server2有两票. 但是机器数没有达到半数，leader未选举</span><br><span class="line"></span><br><span class="line">      启动server3: 第一票投给自己(3,zxid)</span><br><span class="line">	           server3接收到server1的(1,zxid), server2的(2,zxid) ,3 &gt; 2 &gt;1  ，server3保持自己的投票(3,zxid)</span><br><span class="line">		       server2接收到server3的(3,zxid), serser1的(1,zxid) , 2 &lt; 3 ,   改变投票为(3,zxid)</span><br><span class="line">		       server1接收到server3的(3,zxid), server2的(2,zxid) , 1 &lt; 2&lt; 3, 改变投票为(3,zxid)</span><br><span class="line">		       因此最终server3有3票, 机器数也达到半数， server3当选为leader, server1 和 server2 为follower</span><br><span class="line">          </span><br><span class="line">	  启动server4: 因为集群已经有leader存在， server4注定就是follower </span><br><span class="line">	  启动server5: 因为集群已经有leader存在， server5注定就是follower</span><br><span class="line">	  </span><br><span class="line"></span><br><span class="line">2) 集群工作中，leader故障后的选举: </span><br><span class="line">          </span><br><span class="line">	  当集群工作中，leader故障后，只要剩下的机器数大于半数， 集群能够正常工作，但是需要重新选举leader。</span><br><span class="line"></span><br><span class="line">	  选举的过程还是进行投票, 因为集群是在工作中，因此每台机器的zxid有可能不同.</span><br><span class="line">	  那么每次投出的票(myid,zxid) , 先比较zxid，再比较myid，因此集群中剩余的机器中zxid最大的当选为leader,</span><br><span class="line">	  如果zxid都一样，理论情况下myid最大的当选leader.</span><br><span class="line"></span><br><span class="line">	  zxid: 某种意义上，可以表示当前机器中存储的数据的完整度.</span><br></pre></td></tr></table></figure>

<h4 id="2-4-写数据流程"><a href="#2-4-写数据流程" class="headerlink" title="2.4 写数据流程"></a>2.4 写数据流程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）客户端连接Zookeeper集群的任意一台机器，发送写请求</span><br><span class="line">2）如果客户端连接的Zookeeper集群不是leader，则当前这台机器会将客户端的写请求转发给leader</span><br><span class="line">3）当leader接收到写请求后，会将当次的写操作构建成一个事务，对应一个zxid，然后将写的操作广播给每个follower</span><br><span class="line">4）每个follower接受到写操作后，先将写操作存入队列中（FIFO队列），并向leader反馈表示自己可以执行当前的写操作</span><br><span class="line">5）当leader接受到集群中半数以上的follower的反馈，则代表本次的写操作可以正常进行，leader会再次广播给各个follower，让follower将写操作进行commit（真正写数据）</span><br><span class="line">6）各个follower将写操作成功commit以后，再次向leader反馈写操作完成</span><br><span class="line">7）当leader接受到集群中半数以上的的反馈，，表示此次写操作成功</span><br><span class="line">8）最后由客户端所连接的Zookeeper集群中的机器，向客户端发送响应，说数据写成功</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
  </entry>
  <entry>
    <title>Yarn资源调度器</title>
    <url>/2020/05/28/Yarn%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
    <content><![CDATA[<h3 id="Yarn资源调度器"><a href="#Yarn资源调度器" class="headerlink" title="Yarn资源调度器"></a>Yarn资源调度器</h3><ol>
<li><p>基本介绍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yarn是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台，而MapReduce等运算程序则相当于操作系统之上的应用程序。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Yarn的基本架构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YARN主要有ResourceManager，NodeManager，ApplicationMaster和Container等组件构成</span><br></pre></td></tr></table></figure>
</li>
<li><p>作业提交的全过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）作业提交</span><br><span class="line">	第1步：Client调用job.waitForCompletion方法，向整个集群提交MapReduce作业</span><br><span class="line">	第2步：Client向RM申请一个作业id</span><br><span class="line">	第3步：RM给client返回该job资源的提交路径和作业id</span><br><span class="line">	第4步：client提交jar包，切片信息和配置文件到指定的资源提交路径</span><br><span class="line">	第5步：Client提交完资源后，向RM申请运行MrAppMaster</span><br><span class="line">（2）作业初始化</span><br><span class="line">	第6步：当RM收到Client的请求后，将该job添加到容量调度器中</span><br><span class="line">	第7步：某一个空闲的NM领取到该job</span><br><span class="line">	第8步：该NM创建Container，并产生MrAppMaster</span><br><span class="line">	第9步：下载Client提交的资源到本地</span><br><span class="line">（3）任务分配</span><br><span class="line">	第10步：MrAPPMaster向RM申请运行多个MaTask任务资源</span><br><span class="line">	第11步：RM将运行MapTask任务分配给另外的NodeManager，领导MapTask任务的NodeManager创建容器</span><br><span class="line">（4）任务运行</span><br><span class="line">	第12步：MrAppMaster向接受到任务的NodeManager发送程序启动脚本，接受到任务的NodeManager分别启动MapTask，MapTask对数据分区排序</span><br><span class="line">	第13步：MrAPPMaster等待所有MapTask运行完毕后，向RM申请容器，运行ReduceTask</span><br><span class="line">	第14步：ReduceTask向MapTask获取相应分区的数据</span><br><span class="line">	第15步：程序运行完毕后，MR会向RM申请注销自己</span><br><span class="line">（5）进度和状态更新</span><br><span class="line">	YARN中的任务将其进度和状态（包括counter）返回给应用管理器，客户端每秒（通过mapreduce.client.progressmonitor.pollinterval设置）向应用管理器请求进度更新，展示给客户</span><br><span class="line">（6）作业完成</span><br><span class="line">	除了向应用管理器请求作业进度外，客户端每5秒都会通过调用waitForCompletion（）来检查作业是否完成。时间间隔可以通过通过mapreduce.client.progressmonitor.pollinterval设置。作业完成之后，应用管理器和Container会清理工作状态。作业的信息会被历史服务器存储以备用户核查</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>资源调度器</p>
<p>目前Hadoop作业调度器主要有3中：FIFO，Capacity Scheduler，Fair Scheduler。Hadoop3.1.3默认的资源调度器是Capacity Scheduler</p>
<p>具体设置详见yarn-default.xml文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;description&gt;The <span class="class"><span class="keyword">class</span> <span class="title">to</span> <span class="title">use</span> <span class="title">as</span> <span class="title">the</span> <span class="title">resource</span> <span class="title">scheduler</span>.&lt;/<span class="title">description</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">name</span>&gt;<span class="title">yarn</span>.<span class="title">resourcemanager</span>.<span class="title">scheduler</span>.<span class="title">class</span>&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">value</span>&gt;<span class="title">org</span>.<span class="title">apache</span>.<span class="title">hadoop</span>.<span class="title">yarn</span>.<span class="title">server</span>.<span class="title">resourcemanager</span>.<span class="title">scheduler</span>.</span></span><br><span class="line"><span class="class">        <span class="title">capacity</span>.<span class="title">CapacityScheduler</span>&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">property</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   4.1 FIFO 先进先出调度器</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  Hadoop最初设计目的是支持大数据批处理作业，如日志挖掘、Web索引等作业，为此，Hadoop仅提供了一个非常简单的调度机制：FIFO，即先来先服务，在该调度机制下，所有作业被统一提交到一个队列中，Hadoop按照提交顺序依次运行这些作业。</span><br><span class="line">  但随着Hadoop的普及，单个Hadoop集群的用户量越来越大，不同用户提交的应用程序往往具有不同的服务质量要求，典型的应用有以下几种：</span><br><span class="line">1.批处理作业：这种作业往往耗时较长，对时间完成一般没有严格要求，如数据挖掘、机器学习等方面的应用程序。</span><br><span class="line">2.交互式作业：这种作业期望能及时返回结果，如SQL查询（Hive）等。</span><br><span class="line">3.生产性作业：这种作业要求有一定量的资源保证，如统计值计算、垃圾数据分析等。</span><br><span class="line">  此外，这些应用程序对硬件资源需求量也是不同的，如过滤、统计类作业一般为CPU密集型作业，而数据挖掘、机器学习作业一般为I&#x2F;O密集型作业。因此，简单的FIFO调度策略不仅不能满足多样化需求，也不能充分利用硬件资源.</span><br></pre></td></tr></table></figure>



<pre><code>4.2 Capacity Scheduler</code></pre>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">容量调度器有以下特点</span><br><span class="line">1）支持多个队列，每个队列可配置一定的资源量，每个队列采用FIFO调度策略</span><br><span class="line">2）为了防止同一个用户的作业独占队列中的资源，该调度器会对同一用户提交的作业所占资源量进行限制</span><br><span class="line">3）首先，计算每个队列中正在运行的任务数与其应该分得的计算资源之间的比值，选择一个最小的队列，即最闲的队列</span><br><span class="line">4）其次，按照作业优先级和提交时间排序，同时考虑用户资源量限制和内存限制对队列内任务排序</span><br><span class="line"></span><br><span class="line">	Capacity Scheduler 是Yahoo开发的多用户调度器，它以队列为单位划分资源，每个队列可设定一定比例的资源最低保证和使用上限，同时，每个用户也可设定一定的资源使用上限以防止资源滥用。而当一个队列的资源有剩余时，可暂时将剩余资源共享给其他队列。</span><br><span class="line"></span><br><span class="line">	总结：</span><br><span class="line">1）可以配置多条队列，每条队列可以设置资源占比</span><br><span class="line">2）每条队列的队首的job可以同时执行（从侧面解决了大Job拖慢小job完成时间的问题）</span><br><span class="line">3）每条队列的空闲资源可临时借调给别的队列使用.</span><br><span class="line">4）每条队列可以设置最小和最大资源占比 </span><br><span class="line">5）每条队列可以控制访问用户</span><br></pre></td></tr></table></figure>



<p>   4.3 Fair Scheduler</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fair Scheduler是Facebook开发的多用户调度器</span><br><span class="line">	公平调度器的目的是让所有的作业随着时间的推移，都能平均地获取等同的共享资源！当有作业提交上来，系统会将空闲的资源分配给新的作业！每个任务大致上会获取平等数量的资源！和传统的调度策略不同的是</span><br><span class="line">它会让小的任务在合理的时间完成，同时不会让需要长时间运行的耗费大量资源的应用挨饿！</span><br><span class="line">	</span><br><span class="line">	同Capacity Scheduler类似，它以队列为单位划分资源，每个队列可设定一定比例的资源最低保证和使用上限，同时，每个用户也可设定一定的资源使用上限以防止资源滥用；当一个队列的资源有剩余时，可暂时将剩余资源共享给其他队列。</span><br><span class="line">	当然，Fair Scheduler也存在很多与Capacity Scheduler不同之处，这主要体现在以下几个方面</span><br><span class="line">	资源公平共享。在每个队列中，Fair Scheduler 可选择按照FIFO、Fair或DRF策略为应用程序分配资源。其中，Fair 策略(默认)是一种基于最大最小公平算法实现的资源多路复用方式，默认情况下，每个队列内部采用该方式分配资源。这意味着，如果一个队列中有两个应用程序同时运行，则每个应用程序可得到1&#x2F;2的资源；如果三个应用程序同时运行，则每个应用程序可得到1&#x2F;3的资源</span><br><span class="line">	</span><br><span class="line">最大最小公平算法：</span><br><span class="line">	</span><br><span class="line">	1）不加权</span><br><span class="line">	有一四个用户的集合,资源需求分别是2, 2.6 , 4, 5,其资源总能力为10,为其计算最大最小公平分配</span><br><span class="line">解决方法:</span><br><span class="line">我们通过几轮的计算来计算最大最小公平分配.</span><br><span class="line">第一轮,我们暂时将资源划分成4个大小为2.5的.由于这超过了用户1的需求,这使得剩了0.5个均匀的分配给剩下的3个人资源,给予他们每个2.66.这又超过了用户2的需求,所以我们拥有额外的0.066…来分配给剩下的两个用户,给予每个用户2.5+0.66…+0.033…&#x3D;2.7.因此公平分配是:用户1得到2,用户2得到2.6,用户3和用户4每个都得到2.7.</span><br><span class="line"></span><br><span class="line">	2）加权</span><br><span class="line">	有一四个用户的集合,资源需求分别是4,2,10,4,权重分别是2.5,4,0.5,1,资源总能力是16,为其计算最大最小公平分配.</span><br><span class="line">解决方法:</span><br><span class="line">第一步是标准化权重,将最小的权重设置为1.这样权重集合更新为5,8,1,2.这样需要的资源是5+8+1+2&#x3D;16份.因此将资源划分成16份.在资源分配的每一轮,我们按照权重的比例来划分资源,因此,在第一轮,,用户分别获得5,8,1,2单元的资源,用户1得到了5个资源,但是只需要4,所以多了1个资源,同样的,用户2多了6个资源.用户3和用户4拖欠了,因为他们的配额低于需求.现在我们有7个资源可以分配给用户3和用户4.他们的权重分别是1和2,给予用户3额外的7 × 1&#x2F;3资源和用户4额外的7 × 2&#x2F;3资源.这会导致用户4的配额达到了2 + 7 × 2&#x2F;3 &#x3D; 6.666,超过了需求.所以我们将额外的2.666单元给用户3,最终获得1 + 7&#x2F;3 + 2.666 &#x3D; 6单元.最终的分配是,4,2,6,4,这就是带权重的最大最小公平分配.</span><br><span class="line"></span><br><span class="line">DRF</span><br><span class="line">DRF(Dominant Resource Fairness)。我们之前说的资源，都是单一标准，例如只考虑内存(也是yarn默认的情况)。但是很多时候我们资源有很多种，例如内存，CPU，网络带宽等，这样我们很难衡量两个应用应用应该分配的资源比例</span><br><span class="line">那么在YARN中，我们用DRF来决定如何调度：假设集群有10T mem和100 CPU，而应用A需要(2 CPU, 300GB)，应用B需要(6 CPU, 100GB)。则两种应用分别需要系统(2%, 3%)和(6%, 1%)的资源，这就意味着A是mem主导的, B是CPU主导的，并且它俩的比例是3% : 6% &#x3D; 1:2。这样两者就按照1:2的比例去分配资源。</span><br><span class="line"></span><br><span class="line">	支持资源抢占。当某个队列中有剩余资源时，调度器会将这些资源共享给其他队列，而当该队列中有新的应用程序提交时，调度器要为它回收资源。为了尽可能降低不必要的计算浪费，调度器采用了先等待再强制回收的策略，即如果等待一段时间后尚有未归还的资源，则会进行资源抢占：从那些超额使用资源的队列中杀死一部分任务，进而释放资源。</span><br><span class="line">yarn.scheduler.fair.preemption&#x3D;true 通过该配置开启资源抢占。</span><br><span class="line">	负载均衡。Fair Scheduler提供了一个基于任务数目的负载均衡机制，该机制尽可能将系统中的任务均匀分配到各个节点上。此外，用户也可以根据自己的需要设计负载均衡机制。</span><br><span class="line">	调度策略配置灵活。Fair Scheduler允许管理员为每个队列单独设置调度策略（当前支持FIFO、Fair或DRF三种）。</span><br><span class="line">	提高小应用程序响应时间。由于采用了最大最小公平算法，小作业可以快速获取资源并运行完成</span><br></pre></td></tr></table></figure>







<ol start="5">
<li>任务的推测执行</li>
</ol>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
  </entry>
  <entry>
    <title>MapReduce</title>
    <url>/2020/05/22/MapReduce/</url>
    <content><![CDATA[<h3 id="第1章-MapReduce概述"><a href="#第1章-MapReduce概述" class="headerlink" title="第1章 MapReduce概述"></a>第1章 MapReduce概述</h3><h3 id="第2章-Hadoop序列化"><a href="#第2章-Hadoop序列化" class="headerlink" title="第2章 Hadoop序列化"></a>第2章 Hadoop序列化</h3><h3 id="第3章-MapReduce框架原理"><a href="#第3章-MapReduce框架原理" class="headerlink" title="第3章 MapReduce框架原理"></a>第3章 MapReduce框架原理</h3><p>MapReduce的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.数据流：</span><br><span class="line">	输入数据---&gt;InputFormat---&gt;Mapper---&gt;shuffle---&gt;Reducer---&gt;OutputFormat---&gt;输出数据</span><br><span class="line"><span class="number">2</span>.过程</span><br><span class="line">	简单划分：Map阶段 shuffle阶段 Reduce阶段</span><br><span class="line"><span class="number">3</span>.代码角度划分</span><br><span class="line"><span class="number">1</span>）MapTask中的run()：MapTask：map(<span class="number">67</span>%)  sort(<span class="number">33</span>%)</span><br><span class="line"> <span class="keyword">if</span> (isMapTask()) &#123;</span><br><span class="line">        <span class="comment">// If there are no reducers then there won't be any sort. Hence the map </span></span><br><span class="line">        <span class="comment">// phase will govern the entire attempt's progress.</span></span><br><span class="line">      <span class="keyword">if</span> (conf.getNumReduceTasks() == <span class="number">0</span>) &#123;</span><br><span class="line">        mapPhase = getProgress().addPhase(<span class="string">"map"</span>, <span class="number">1.0f</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If there are reducers then the entire attempt's progress will be </span></span><br><span class="line">        <span class="comment">// split between the map phase (67%) and the sort phase (33%).</span></span><br><span class="line">        mapPhase = getProgress().addPhase(<span class="string">"map"</span>, <span class="number">0.667f</span>);</span><br><span class="line">        sortPhase  = getProgress().addPhase(<span class="string">"sort"</span>, <span class="number">0.333f</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="number">2</span>）ReduceTask类中的run():  ReduceTask :  copy   sort   reduce </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isMapOrReduce()) &#123;</span><br><span class="line">        copyPhase = getProgress().addPhase(<span class="string">"copy"</span>);</span><br><span class="line">        sortPhase  = getProgress().addPhase(<span class="string">"sort"</span>);</span><br><span class="line">        reducePhase = getProgress().addPhase(<span class="string">"reduce"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="number">3</span>）MapReduce的代码角度得到的过程结果为：</span><br><span class="line">    map--&gt;sort--&gt;copy--&gt;sort--&gt;reduce</span><br></pre></td></tr></table></figure>



<h4 id="3-1-InputFormat数据输入"><a href="#3-1-InputFormat数据输入" class="headerlink" title="3.1 InputFormat数据输入"></a>3.1 InputFormat数据输入</h4><h5 id="3-1-1-重要的类和方法"><a href="#3-1-1-重要的类和方法" class="headerlink" title="3.1.1 重要的类和方法"></a>3.1.1 重要的类和方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.重要的方法</span><br><span class="line">getSpilts()：生成切片的方法</span><br><span class="line">createRecordReader()：创建RecordReader对象，真正负责数据读取的对象</span><br><span class="line">2.重要的子抽象类 FileInputFormat</span><br><span class="line">getSpilts(): 做出了具体的实现</span><br><span class="line">createRecordReader(): 没有做任何的改动</span><br><span class="line">isSplitable(): 当前数据的数据集是否可以切分</span><br><span class="line">3.FileInputFormat的具体实现类</span><br><span class="line">TextInputFormat：MapReduce默认使用的InputFormat</span><br><span class="line">CombineTextInputFormat</span><br></pre></td></tr></table></figure>

<h5 id="3-1-2-切片"><a href="#3-1-2-切片" class="headerlink" title="3.1.2 切片"></a>3.1.2 切片</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.相关的两个概念</span><br><span class="line">	块：HDFS存数据的基本单位，是把要存储到HDFS的文件以设置好的块的大小，对文件进行物理切分然后分块存储</span><br><span class="line">	切片：MapReduce计算数据的单位，是把要在Map中计算的数据从逻辑上按照切片的大小划分为N个切片</span><br><span class="line">2.切片的大小</span><br><span class="line">	切片的大小默认情况是等于块的大小</span><br><span class="line">3.切片的源码解读</span><br><span class="line">FileInputFormat的getSpilts方法：</span><br><span class="line">1） long minSize &#x3D; Math.max(getFormatMinSplitSize(), getMinSplitSize(job));   &#x2F;&#x2F; 1 </span><br><span class="line">相关配置项:   &quot;mapreduce.input.fileinputformat.split.minsize&quot;&#x3D;&quot;0&quot;   </span><br><span class="line">long maxSize &#x3D; getMaxSplitSize(job);  &#x2F;&#x2F; Long.MAX_VALUE</span><br><span class="line">相关配置项:   &quot;mapreduce.input.fileinputformat.split.maxsize&quot;  默认没有配置这一项</span><br><span class="line">2）  long blockSize &#x3D; file.getBlockSize();  &#x2F;&#x2F;获取文件的块大小   </span><br><span class="line">如果是集群环境，获取到的就是集群中设置的块大小，如果是本地环境，本地默认的块大小32M (33554432)</span><br><span class="line">3）                                   32M        1      Long.MAX_VALUE</span><br><span class="line">   long splitSize &#x3D; computeSplitSize(blockSize, minSize, maxSize);</span><br><span class="line">   &#x3D;&#x3D;&gt;return Math.max(minSize, Math.min(maxSize, blockSize));</span><br><span class="line">4） while (((double) bytesRemaining)&#x2F;splitSize &gt; SPLIT_SLOP)  &#x2F;&#x2F; SPLIT_SLOP &#x3D; 1.1 </span><br><span class="line">如果剩余待切片的数据除以块大小，大于1.1，才会继续切片，如果不大于，则直接将剩余的数据进行切片</span><br><span class="line"></span><br><span class="line">切片的总结：</span><br><span class="line">	1）每个切片都需要由一个MapTask来处理</span><br><span class="line">	2）切片的大小默认情况下等于块的大小</span><br><span class="line">	3）切片的时候每个文件单独切片，不会整体切片</span><br><span class="line">	4）切片的个数不是越多越好，也不是越少越好，按照实际情况，处理成合适的切片数（通过改变splitSize）</span><br></pre></td></tr></table></figure>

<h5 id="3-1-3-TextInputFormat：默认使用的InputFormat类"><a href="#3-1-3-TextInputFormat：默认使用的InputFormat类" class="headerlink" title="3.1.3 TextInputFormat：默认使用的InputFormat类"></a>3.1.3 TextInputFormat：默认使用的InputFormat类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">切片的规则：用的就是父类FileInputFormat中的切片规则</span><br><span class="line">读取数据：LineRecordReader 按行读取数据</span><br></pre></td></tr></table></figure>

<h5 id="3-1-4-CombineTextInputFormat"><a href="#3-1-4-CombineTextInputFormat" class="headerlink" title="3.1.4 CombineTextInputFormat"></a>3.1.4 CombineTextInputFormat</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）用户处理小文件过多的场景，解决过多的小文件最终生成太多的切片的问题</span><br><span class="line">2）在Driver中设置</span><br><span class="line">job.setInputFormatClass(CombinTextInputFormat.class)</span><br><span class="line">CombineTextInputFormat.setMaxInputSplitSize(job,20911520);&#x2F;&#x2F;20M</span><br><span class="line">3）会按照设置的虚拟存储大小进行数据数据的逻辑上的规划</span><br><span class="line">如果文件的大小小于MaxInputSplitSize，则文件规划成一个</span><br><span class="line">如果文件的大小大于MaxInputSplitSize，但是小于MaxInputSplitSize*2，则文件规划成两个（数据对半分）</span><br><span class="line">如果文件的大小大于MaxInputSplitSize*2，先按照MaxInputSplitSize的大小先规划成一个，剩余的再进行规划</span><br><span class="line">最终按照MaxInputSplitSize大小来生成切片</span><br><span class="line">将规划好的每个虚拟文件逐个累加，只要不超过MaxInputSplitSize大小，则都是规划到一个切片中</span><br></pre></td></tr></table></figure>



<h4 id="3-2-MapReduce工作流程"><a href="#3-2-MapReduce工作流程" class="headerlink" title="3.2 MapReduce工作流程"></a>3.2 MapReduce工作流程</h4><h4 id="3-3-Shuffle机制"><a href="#3-3-Shuffle机制" class="headerlink" title="3.3 Shuffle机制"></a>3.3 Shuffle机制</h4><h5 id="3-3-1-shuffle关键点"><a href="#3-3-1-shuffle关键点" class="headerlink" title="3.3.1 shuffle关键点"></a>3.3.1 shuffle关键点</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）map方法之后，reduce方法之前的处理过程就是shuffle过程</span><br><span class="line">2）map方法写出去的kv，会被一个收集线程收集到缓冲区中</span><br><span class="line">3）缓冲区的大小默认是100M，达到80%发生溢写（将数据写入硬盘）</span><br><span class="line">4）缓冲区中记录的是kv,kv的下标，kv的分区等信息</span><br><span class="line">5）溢写的时候，是按照kv的分区进行排序（快排，只拍索引），再按照分区溢写 ---&gt; map端的第一次排序</span><br><span class="line">6）每个MapTask有可能发生多次有可能发生多次溢写，最终需要将多次溢写的文件归并成一个大的文件---&gt;map端的第二次排序</span><br><span class="line">7）溢写和归并过程中，都可以采用combiner</span><br><span class="line">8）每个ReduceTask按照所需处理的分区，到每个MapTask中拷贝对应的分区的数据，拷贝过程中，先放内存，放不下写硬盘，等数据全部都拷贝过来后，进行归并排序 ---&gt;reduce端的排序</span><br><span class="line">9）reduce端排好序的数据进行分组，然后进入reduce方法进行业务处理</span><br></pre></td></tr></table></figure>



<h5 id="3-3-2-分区"><a href="#3-3-2-分区" class="headerlink" title="3.3.2 分区"></a>3.3.2 分区</h5><ol>
<li><p>分区的概念</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将数据按照条件输出到多个文件中</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么设置reduce的个数可以实现分区的效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）在MapTask类中的NewOutputCollector()方法中</span><br><span class="line">partitions = jobContext.getNumReduceTasks();<span class="comment">//获取哦reduce的个数。reduce的个数是在driver中设置的</span></span><br><span class="line"><span class="keyword">if</span>(partitions &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果说reducce的个数大于1， 会尝试获取一个分区器类,通过mapreduce.job.partitioner.class参数获取  ，</span></span><br><span class="line">    <span class="comment">// 默认mapreduce.job.partitioner.class没有配置，则直接返回HashPartitioner.class 。</span></span><br><span class="line">    <span class="comment">// 当然还有一种可能就是我们自己设置过分区器类，则此处会获取到我们自己设置的分区器类。</span></span><br><span class="line">   partitioner = (org.apache.hadoop.mapreduce.Partitioner&lt;K,V&gt;)</span><br><span class="line">   ReflectionUtils.newInstance(jobContext.getPartitionerClass(), job);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//如果reduce的个数不大于1，最终的分区号就是固定的0号分区</span></span><br><span class="line">     partitioner = <span class="keyword">new</span> org.apache.hadoop.mapreduce.Partitioner&lt;K,V&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(K key, V value, <span class="keyword">int</span> numPartitions)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> partitions - <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>）获取到的分区器在哪里使用？</span><br><span class="line">    在MapTask中的NewOutputCollector内部类中的write方法</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(K key, V value)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">           collector.collect(key, value,partitioner.getPartition(key, value, partitions)); <span class="comment">//将kv收集到缓冲区的时候，要计算出来kv对应的分区号</span></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）分区的数据是如何分的？</span><br><span class="line">    （<span class="number">1</span>）数据的分区是由分区器来决定的</span><br><span class="line">    （<span class="number">2</span>）Hadoop由默认的分区器对象HashPartitioner</span><br><span class="line">    HashPartitioner会按照k的hash值对Reduce的个数进行取余操作得到k所对应的分区</span><br><span class="line">    （<span class="number">3</span>）hadoop也支持用户自定义分区器</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>默认的分区器HashPartitioner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>). 默认的分区器就会按照key的hashcode值 先对Integer的最大值做&amp;运算，在对reduce的个数取余，得到分区号。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(K key, V value,<span class="keyword">int</span> numReduceTasks)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> (key.hashCode() &amp; Integer.MAX_VALUE) % numReduceTasks;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）自定义分区类继承Partitioner类，并重写getPartition()</span><br><span class="line">2）在driver类中通过job.setPartitionerClass(xxxPartitioner.class)设置使用的分区</span><br><span class="line">3）设置reduce的个数，正常情况下，根据分区器业务来决定设置多少个，最好是分区器的逻辑会产生多少个分区，就设置好多少个reduce</span><br><span class="line"></span><br><span class="line">分区使用的注意事项：</span><br><span class="line">1）reduce个数的设置：如果不设置，reduce的个数默认为1，如果1&lt;reduce个数&lt;分区数，报错；如果reduce个数&gt;分区数，不报错，多少的reduce会白跑，产生空文件；最佳是reduce的个数就设置为实际的分区数</span><br><span class="line">2）分区号只能从0开始，逐一累加</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="3-3-3-排序"><a href="#3-3-3-排序" class="headerlink" title="3.3.3 排序"></a>3.3.3 排序</h5><ol>
<li><p>排序是MR中最重要的操作之一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在MapTask中有两次排序 ---&gt;溢写前排序，将溢写文件归并成一个大文件的归并排序</span><br><span class="line">在ReduceTask中有一次排序---&gt;归并排序</span><br></pre></td></tr></table></figure>
</li>
<li><p>在MR中，排序是默认的行为，默认会对KV中K进行排序，默认采用字典序进行排序</p>
</li>
<li><p>排序的分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）全排序：所有的数据整体排序，要求只能有一个分区</span><br><span class="line">2）区内排序：每个分区内的数据整体排序</span><br><span class="line">3）辅助排序：分组排序，数据进入reduce之前进行的排序</span><br><span class="line">4）二次排序：比较规则中用到两个条件</span><br></pre></td></tr></table></figure>
</li>
<li><p>排序的前提</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">排序的前提是待排序的数据可以进行比较，需要实现WritableComparable接口</span><br></pre></td></tr></table></figure>
</li>
<li><p>Hadoop排序时是如何比较的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在MapTask中的 MapOutputBuffer 类中的init方法中</span><br><span class="line">       </span><br><span class="line">      comparator = job.getOutputKeyComparator();  <span class="comment">// 获取key的比较器对象</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> RawComparator <span class="title">getOutputKeyComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Class&lt;? extends RawComparator&gt; theClass = getClass(</span><br><span class="line">         JobContext.KEY_COMPARATOR, <span class="keyword">null</span>, RawComparator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	 <span class="comment">// 参数: mapreduce.job.output.key.comparator.class  默认没有配置</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (theClass != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ReflectionUtils.newInstance(theClass, <span class="keyword">this</span>);  <span class="comment">//如果能通过参数获取到，则通过反射创建比较器对象</span></span><br><span class="line">         </span><br><span class="line">	 <span class="comment">//如果通过参数获取不到，则获取到在driver中设置的map的输出的key的类型，</span></span><br><span class="line">	 <span class="comment">// 并判断key的类型是否属于writableComparable类型</span></span><br><span class="line">	 <span class="comment">// 再尝试为key获取比较器对象.</span></span><br><span class="line">         <span class="keyword">return</span> WritableComparator.get(getMapOutputKeyClass().asSubclass(WritableComparable<span class="class">.<span class="keyword">class</span>), <span class="title">this</span>)</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WritableComparator <span class="title">get</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          Class&lt;? extends WritableComparable&gt; c, Configuration conf)</span> </span>&#123;</span><br><span class="line">	   <span class="comment">// 从comparators中尝试获取key的比较器对象</span></span><br><span class="line">	   <span class="comment">// 如果key是我们自己定义的类型，则获取不到</span></span><br><span class="line">	   <span class="comment">// 如果key是hadoop的序列化类型，例如 Text, Intwriable等，则能获取到。</span></span><br><span class="line">           WritableComparator comparator = comparators.get(c);</span><br><span class="line">    <span class="keyword">if</span> (comparator == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// force the static initializers to run</span></span><br><span class="line">      forceInit(c);  <span class="comment">//强制进行类加载,防止因中途进行垃圾回收使得类不再内存中</span></span><br><span class="line">      <span class="comment">// look to see if it is defined now</span></span><br><span class="line">      comparator = comparators.get(c);   <span class="comment">// 再次进行获取</span></span><br><span class="line">      <span class="comment">// if not, use the generic one</span></span><br><span class="line">      <span class="keyword">if</span> (comparator == <span class="keyword">null</span>) &#123; </span><br><span class="line">      <span class="comment">// 如果还获取不到，则直接new一个对象出来。</span></span><br><span class="line">         comparator = <span class="keyword">new</span> WritableComparator(c, conf, <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Newly passed Configuration objects should be used.</span></span><br><span class="line">       ReflectionUtils.setConf(comparator, conf);</span><br><span class="line">       <span class="keyword">return</span> comparator;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  总结：Hadoop自身的序列化类型（比如Text），在类加载时，会把类型以及对应的比较器对象注册到WritableCompartor中的comparators这个Map中，如果key是我们自定义的类型，则我们必须要为该类型提交比较器对象。</span><br><span class="line">  不管是hadoop自身的序列化类型还是我们自己定义的类型，只要作为key来使用，则必须要有对应的比较器对象才能够进行比较，才能实现排序。</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较器WritableComparator</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2): 底层的实现，我们不动，会调用第2个方法</span><br><span class="line">2. public int compare(WritableComparable a, WritableComparable b)： 我们可以重写，实现比较规则，如果不重写，则默认是a.CompareTo(b)</span><br><span class="line">3. public int compare(Object a, Object b): 还是会调用到第2个方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总结：作为key来使用的类型，需要提供比较器对象，还要求key的类型必须是WritableComparable</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较接口WritableComparable</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.要求所有作为key来使用的类型，都需要实现WritableComparable接口</span><br><span class="line">2.该接口中可以通过compareTo定义比较规则</span><br></pre></td></tr></table></figure>
</li>
<li><p>排序大总结</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）一个接口和一个类</span><br><span class="line">	接口：WritableComparable：用于定于默认的比较规则</span><br><span class="line">	类：WritableComparator: 用于定于临时的比较规则</span><br><span class="line">	</span><br><span class="line">2）Hadoop的排序，都是对key的排序，排序时需要比较，比较的时候都是用key类型对应的比较器对象进行比较</span><br><span class="line"></span><br><span class="line">3）对于key的类型来说，如果提供了对应的比较器对象，则使用我们自己提供的；如果没有提供对应的比较器对象，则Hadoop会帮我们创建一个比较器对象</span><br><span class="line"></span><br><span class="line">4）hadoop对key的比较，默认调用的是比较器中的compare（WritableComparable a，WritableComparable b）方法</span><br><span class="line">	第一种情况：如果自定义的比较器中，重写了compare方法，则使用重写后的方法进行比较。</span><br><span class="line">	第二种情况：如果自定义的比较器中，则使用的是WritableComparator中的。compare（WritableComparable a，WritableComparable b）方法，默认的实现是a.compareTo(b),因此会调用到key中的compareTo()方法进行比较。</span><br><span class="line">	第三种情况：如果没有提供比较器队形，则hadoop默认会帮我们创建一个比较器对象，但是hadoop默认创建的比较器对象还是使用WritableComparator中的compare（WritableComparable a，WritableComparable b）方法，因此默认的实现还是a.compareTo(b)，所以最终还是会调用到key中的compareTo()方法进行比较。</span><br><span class="line">	</span><br><span class="line">5）实际使用：</span><br><span class="line">	按照hadoop的设计来说，我们需要提供比较器对象WritableComparator，key需要实现WritableComparable。</span><br><span class="line">	按照我们实际使用(偷懒), 不用提交比较器对象，直接实现WritableComparable接口，重写compareTo即可。</span><br><span class="line">	 一般来讲， WritableComparable是用来定义默认的比较规则的， WritableComparator用来定义临时的比较规则的。</span><br></pre></td></tr></table></figure>
</li>
<li><p>全排序和区内排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">全排序就是将排序的规则定义好，只有一个分区一个reduce，数据整体有序</span><br><span class="line">区内排序就是在全排序的基础之上，加上自定义分区即可.</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<ol start="10">
<li><p>分组排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）数据在进入到reduce方法之前，一定要保证数据是有序的，才可以进行所谓的分组. 最终的效果就是要保证相同key的多个kv对进入到一个reduce方法。</span><br><span class="line"><span class="number">2</span>）hadoop是如何进行分组比较的</span><br><span class="line"> 在ReduceTask中的run方法中 ：</span><br><span class="line">	  RawComparator comparator = job.getOutputValueGroupingComparator();</span><br><span class="line"></span><br><span class="line">	  <span class="function"><span class="keyword">public</span> RawComparator <span class="title">getOutputValueGroupingComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              Class&lt;? extends RawComparator&gt; theClass = getClass(</span><br><span class="line">               JobContext.GROUP_COMPARATOR_CLASS, <span class="keyword">null</span>, RawComparator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	       <span class="comment">//配置项:  mapreduce.job.output.group.comparator.class</span></span><br><span class="line">	               </span><br><span class="line">              <span class="keyword">if</span> (theClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> getOutputKeyComparator();</span><br><span class="line">              &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> ReflectionUtils.newInstance(theClass, <span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line">          </span><br><span class="line">	  <span class="function"><span class="keyword">public</span> RawComparator <span class="title">getOutputKeyComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              Class&lt;? extends RawComparator&gt; theClass = getClass(</span><br><span class="line">              JobContext.KEY_COMPARATOR, <span class="keyword">null</span>, RawComparator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	        配置项:  mapreduce.job.output.key.comparator<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">              <span class="title">if</span> (<span class="title">theClass</span> !</span>= <span class="keyword">null</span>)</span><br><span class="line">                 <span class="keyword">return</span> ReflectionUtils.newInstance(theClass, <span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> WritableComparator.get(getMapOutputKeyClass().asSubclass(WritableComparable<span class="class">.<span class="keyword">class</span>), <span class="title">this</span>)</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>) 真相:  </span><br><span class="line">	在分组比较时， hadoop会获取当前key的类型对应的分组比较器对象，如果获取不到，则</span><br><span class="line">尝试获取当前key的类型对应的排序比较器对象. 如果还获取不到，则hadoop会创建一个比较器对象，最终调用到key的类中的compareTo方法.</span><br></pre></td></tr></table></figure>







</li>
</ol>
<h5 id="3-3-4-OutputFormat数据输出"><a href="#3-3-4-OutputFormat数据输出" class="headerlink" title="3.3.4  OutputFormat数据输出"></a>3.3.4  OutputFormat数据输出</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.相关方法</span><br><span class="line">	getRecorderWriter():获取RecorderWriter对象，负责数据的写出</span><br><span class="line">	checkOutputSpecs():检查输出路径</span><br><span class="line">2.子抽象类FileOutputFormat</span><br><span class="line">	对checkOutputSpecs()做了具体实现，相关异常：&quot;Output directory&quot; + outDir + &quot;already exists&quot;</span><br><span class="line">3.具体实现类</span><br><span class="line">	TextOutputFormat hadoop默认使用的</span><br><span class="line">		LineRecordWriter</span><br><span class="line">	SequenceFileOutputFormat: 最终写出的文件是二进制格式的，所谓的sequenceFile</span><br><span class="line">4.自定义OutputFormat</span><br><span class="line">	1）自定义类继承FileOutputFormat</span><br><span class="line">	2）自定义RecordWriter对象，完成数据的写出操作</span><br></pre></td></tr></table></figure>



<h4 id="3-4-Combiner"><a href="#3-4-Combiner" class="headerlink" title="3.4 Combiner"></a>3.4 Combiner</h4><ol>
<li><p>combiner有什么用呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目的就是在内个MapTask中将输出的kv提前进行合并。能够降低map到reduce传输的数据流以及reduce最终处理的数据流</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>combiner的工作位置</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.工作位置：kv从缓冲区中溢写到磁盘时可以使用combiner（只要设置无条件使用）；每个MapTask的所有数据都从缓冲区写到磁盘后，在进行归并的时候可以使用combiner（满足条件使用，溢写次数&gt;&#x3D;3）</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><p>Combiner使用限制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在不改变业务逻辑的情况下才能使用combiner，比如求和的业务可以，但比如求平均值的业务就不行了，最终可能得到不一样的结果。</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>相关介绍</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.Combiner是MR程序中Mapper和Reducer之外的一种组件，可以选择，并不是常驻组件</span><br><span class="line">2.Combiner组件的父类就是Reducer</span><br><span class="line">3.Combiner和Reducer的区别在于运行的位置</span><br><span class="line">	Combiner是在每一个MapTask所在的节点运行；</span><br><span class="line">	Reducer是接收全局所有Mapper的输出结果</span><br><span class="line">4.Combiner的意思就是对每一个MapTask的输出进行局部汇总，以减小网络传输量</span><br><span class="line">5.Combiner能够应用的前提是不能影响最终的业务逻辑，而且，Combiner输出的kv应该跟Reducer的输入kv类型要对应起来</span><br></pre></td></tr></table></figure>







</li>
</ol>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
  </entry>
  <entry>
    <title>hdfs架构</title>
    <url>/2020/05/18/hdfs%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h3 id="第1章-HDFS概述"><a href="#第1章-HDFS概述" class="headerlink" title="第1章 HDFS概述"></a>第1章 HDFS概述</h3><h3 id="第2章-HDFS的Shell操作"><a href="#第2章-HDFS的Shell操作" class="headerlink" title="第2章 HDFS的Shell操作"></a>第2章 HDFS的Shell操作</h3><h3 id="第3章-HDFS的客户端"><a href="#第3章-HDFS的客户端" class="headerlink" title="第3章 HDFS的客户端"></a>第3章 HDFS的客户端</h3><h3 id="第4章-HDFS的数据流"><a href="#第4章-HDFS的数据流" class="headerlink" title="第4章 HDFS的数据流"></a>第4章 HDFS的数据流</h3><h3 id="第5章-NameNode和SecondaryNameNode"><a href="#第5章-NameNode和SecondaryNameNode" class="headerlink" title="第5章 NameNode和SecondaryNameNode"></a>第5章 NameNode和SecondaryNameNode</h3><h4 id="5-1-NN和2NN工作机制"><a href="#5-1-NN和2NN工作机制" class="headerlink" title="5.1 NN和2NN工作机制"></a>5.1 NN和2NN工作机制</h4><h5 id="5-1-1-问题引入"><a href="#5-1-1-问题引入" class="headerlink" title="5.1.1 问题引入"></a>5.1.1 问题引入</h5><ol>
<li><p>NameNode是干啥的？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NameNode最主要的作用就是对HDFS中数据的元数据进行管理</span><br></pre></td></tr></table></figure>
</li>
<li><p>NameNode管理的元数据存在哪里呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">内存+磁盘</span><br><span class="line">分析：考虑数据的安全性跟可靠性，元数据存放在磁盘中比较安全</span><br><span class="line">如果数据维护到磁盘，数据的安全可以保证，但是带来的问题是，访问效率低，因为对HDFS数据的操作或多或少会伴随着元数据修改，元数据的修改在磁盘上效率是很低的。</span><br><span class="line">考虑到效率的问题，元数据存储到内存效率很高，带来的问题是数据不安全。因为内存的数据容易丢失，比如服务器掉电或者故障。</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何在实现高效操作元数据的情况下，还能实现内存+磁盘的维护方案？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HDFS通过fsimage（镜像文件）+edits（编辑日志）的方案来解决问题</span><br><span class="line">镜像文件：某个时刻对NN内存中元数据的一个快照</span><br><span class="line">编辑日志：记录对HDFS的修改操作，只作追加操作效率是很高的</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一直往edits文件中追加内容，该文件会变得非常大，且会越来越大，因此需要隔一段时间或者在合适的时机进行fsimage+edits文件的合并工作，从而生成新的fsimage。新的fsimage = 旧的fsimage+edits。那将fsimage和edits的合并工作交给谁完成呢，由于NameNode本身的负载就高，所以交给SecondaryNameNode来完成这项工作。大致的合并过程如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将NameNode机器对应磁盘上的fsimage和edits文件拉取到SecondaryNameNode机器中，在SecondaryNameNode中将fsimage和edits加到内存中合并，生成新的fsimage,再推送到NameNode机器中的磁盘上，NameNode中旧的fsimage会保留，而新的fsimage作为将要使用的镜像，同时生成新的edits文件。</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h4 id="5-2-Fsimage和Edits解析"><a href="#5-2-Fsimage和Edits解析" class="headerlink" title="5.2 Fsimage和Edits解析"></a>5.2 Fsimage和Edits解析</h4><ol>
<li>Fsimage和Edits概念</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NameNode被格式化之后，将在&#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3&#x2F;data&#x2F;name&#x2F;current目录中产生如下文件</span><br><span class="line">fsimage_000000000000</span><br><span class="line">fsimage_000000000000.md5</span><br><span class="line">seen.txid</span><br><span class="line">VERSION</span><br><span class="line">（1）Fsimage文件：HDFS文件系统元数据的一个永久性的检查点，其中包含HDFS文件系统的所有目录和文件inode的序列化信息</span><br><span class="line">（2）Edits文件：存放HDFS文件系统的所有更新操作，文件系统客户端执行的所有写操作首先会被记录到Edits文件中</span><br><span class="line">（3）seen_txid：文件中保存的是一个数字，就是正在使用的edits_的数字</span><br><span class="line">（4）每次NameNode启动的时候都会将fsimage文件读入内存，加载Edits里面的更新操作，保证内存中的元数据信息是最新的，同步的，可以看成NameNode启动的时候就将fsimage和Edits文件进行了合并</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>ovi查看fsimage文件</p>
<p>1）基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdfs oiv -p 文件类型 -i镜像文件 -o 转换后文件输出路径</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   2）案例实操</p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 current]$ pwd</span><br><span class="line">/opt/module/hadoop-3.1.3/data/tmp/dfs/name/current</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop102 current]$ hdfs oiv -p XML -i fsimage_0000000000000000025 -o /opt/module/hadoop-3.1.3/fsimage.xml</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><p>oev查看Edits文件</p>
<p>1）基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hdfs oev -p 文件类型 -i编辑日志 -o 转换后文件输出路径</span><br></pre></td></tr></table></figure>

<p>2）案例实操</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 current]$ hdfs oev -p XML -i edits_0000000000000000012-0000000000000000013 -o /opt/module/hadoop-3.1.3/edits.xml</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop102 current]$ cat /opt/module/hadoop-3.1.3/edits.xml</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="5-3-CheckPoint时间设置"><a href="#5-3-CheckPoint时间设置" class="headerlink" title="5.3 CheckPoint时间设置"></a>5.3 CheckPoint时间设置</h4><ol>
<li><p>通常情况下，SecondaryNameNode每个一个小时执行一次，有必要的话可以修改配置</p>
<p>[hdfs-default.xml]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.namenode.checkpoint.period&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;3600&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>一分钟检查一次操作次数，当操作次数达到一百万时，SecondaryNameNode执行一次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.namenode.checkpoint.txns&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;1000000&lt;&#x2F;value&gt;</span><br><span class="line">&lt;description&gt;操作动作次数&lt;&#x2F;description&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.namenode.checkpoint.check.period&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;60&lt;&#x2F;value&gt;</span><br><span class="line">&lt;description&gt; 1分钟检查一次操作次数&lt;&#x2F;description&gt;</span><br><span class="line">&lt;&#x2F;property &gt;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="5-4-NameNode故障管理"><a href="#5-4-NameNode故障管理" class="headerlink" title="5.4 NameNode故障管理"></a>5.4 NameNode故障管理</h4><p>NameNode故障后，可以采用如下方法恢复数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）将SecondaryNameNode中数据拷贝到NameNode存储数据的目录</span><br><span class="line">（1）kill -9 NameNode进程</span><br><span class="line">（2） 删除NameNode存储的数据（&#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3&#x2F;data&#x2F;name）</span><br><span class="line">[atguigu@hadoop102 hadoop-3.1.3]$ rm -rf &#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3&#x2F;data&#x2F;name&#x2F;*</span><br><span class="line">（3）拷贝SecondaryNameNode中数据到原NameNode存储数据目录</span><br><span class="line">[atguigu@hadoop102 dfs]$ scp -r atguigu@hadoop104:&#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3&#x2F;data&#x2F;tmp&#x2F;dfs&#x2F;namesecondary&#x2F;* .&#x2F;name&#x2F;</span><br><span class="line">（4）重新启动NameNode</span><br><span class="line">[atguigu@hadoop102 hadoop-3.1.3]$ hdfs --daemon start namenode</span><br></pre></td></tr></table></figure>



<h4 id="5-5-集群安全模式"><a href="#5-5-集群安全模式" class="headerlink" title="5.5 集群安全模式"></a>5.5 集群安全模式</h4><h4 id="5-6-NameNode多目录配置"><a href="#5-6-NameNode多目录配置" class="headerlink" title="5.6 NameNode多目录配置"></a>5.6 NameNode多目录配置</h4><h3 id="第6章-DataNode"><a href="#第6章-DataNode" class="headerlink" title="第6章 DataNode"></a>第6章 DataNode</h3><h3 id="第7章-小文件存档"><a href="#第7章-小文件存档" class="headerlink" title="第7章 小文件存档"></a>第7章 小文件存档</h3><h3 id="第8章-回收站"><a href="#第8章-回收站" class="headerlink" title="第8章 回收站"></a>第8章 回收站</h3><h3 id="第9章-纠删码"><a href="#第9章-纠删码" class="headerlink" title="第9章 纠删码"></a>第9章 纠删码</h3>]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
  </entry>
  <entry>
    <title>hadoop</title>
    <url>/2020/05/13/hadoop/</url>
    <content><![CDATA[<h3 id="第1章-大数据概论"><a href="#第1章-大数据概论" class="headerlink" title="第1章 大数据概论"></a>第1章 大数据概论</h3><h3 id="第2章-从Hadoop框架讨论大数据生态"><a href="#第2章-从Hadoop框架讨论大数据生态" class="headerlink" title="第2章 从Hadoop框架讨论大数据生态"></a>第2章 从Hadoop框架讨论大数据生态</h3><p>​    2.1 Hadoop是什么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hadoop是Apache基金会开发的分布式系统架构，主要是用来解决海量数据的存储的和分析计算问题</span><br></pre></td></tr></table></figure>



<p>​    2.2 Hadoop发展历史</p>
<p>​    2.3 Hadoop三大发行版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hadoop三大发行版本：Apache,Cloudera,Hortonworks</span><br><span class="line">Apache版本最原始的版本，对于入门学习最好</span><br><span class="line">Cloudera内部集成了很多大数据框架。对应产品CDH</span><br><span class="line">Hortonworks文档较好。对应产品HDP</span><br></pre></td></tr></table></figure>

<ol>
<li><p>Apache Hadoop</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官网地址：http:&#x2F;&#x2F;hadoop.apache.org&#x2F;releases.html</span><br><span class="line">下载地址：https:&#x2F;&#x2F;archive.apache.org&#x2F;dist&#x2F;hadoop&#x2F;common&#x2F;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>Cloudera Hadoop</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官网地址：https:&#x2F;&#x2F;www.cloudera.com&#x2F;downloads&#x2F;cdh&#x2F;5-10-0.html</span><br><span class="line">下载地址：http:&#x2F;&#x2F;archive-primary.cloudera.com&#x2F;cdh5&#x2F;cdh&#x2F;5&#x2F;</span><br><span class="line">（1）2008年成立的Cloudera是最早将Hadoop商用的公司，为合作伙伴提供Hadoop的商用解决方案，主要是包括支持、咨询服务、培训。</span><br><span class="line">（2）2009年Hadoop的创始人Doug Cutting也加盟Cloudera公司。Cloudera产品主要为CDH，Cloudera Manager，Cloudera Support</span><br><span class="line">（3）CDH是Cloudera的Hadoop发行版，完全开源，比Apache Hadoop在兼容性，安全性，稳定性上有所增强。Cloudera的标价为每年每个节点10000美元。</span><br><span class="line">（4）Cloudera Manager是集群的软件分发及管理监控平台，可以在几个小时内部署好一个Hadoop集群，并对集群的节点及服务进行实时监控。</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>Hortonworks Hadoop</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官网地址：https:&#x2F;&#x2F;hortonworks.com&#x2F;products&#x2F;data-center&#x2F;hdp&#x2F;</span><br><span class="line">下载地址：https:&#x2F;&#x2F;hortonworks.com&#x2F;downloads&#x2F;#data-platform</span><br><span class="line">（1）2011年成立的Hortonworks是雅虎与硅谷风投公司Benchmark Capital合资组建。</span><br><span class="line">（2）公司成立之初就吸纳了大约25名至30名专门研究Hadoop的雅虎工程师，上述工程师均在2005年开始协助雅虎开发Hadoop，贡献了Hadoop80%的代码。</span><br><span class="line">（3）Hortonworks的主打产品是Hortonworks Data Platform（HDP），也同样是100%开源的产品，HDP除常见的项目外还包括了Ambari，一款开源的安装和管理系统。</span><br><span class="line">（4）Hortonworks目前已经被Cloudera公司收购。</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>​    2.4 Hadoop的优势</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）高可靠性：Hadoop底层维护了多个数据副本，所以即使Hadoop某个个计算元素出现存储故障，也不会出现数据的丢失</span><br><span class="line">2）高扩展性：可在集群工作的时候，灵活的往集群中扩展节点</span><br><span class="line">3）高效性：在MapReduce的思想下，Hadoop是并行工作的，以加快任务处理的速度</span><br><span class="line">4）高容错性：能够自动将失败的任务重新分配</span><br></pre></td></tr></table></figure>



<p>​    2.5 Hadoop组成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hadoop的组成：</span><br><span class="line">	hadoop1.x：HDFS（存）+ MapReduce（算+资源（内存，CPU，磁盘，网络...）调度）</span><br><span class="line">	hadoop2.x&#x2F;3.x：HDFS（存）+ MapReduce（算）+ Yarn（资源调度）</span><br></pre></td></tr></table></figure>

<p>​        2.5.1 HDFS架构概述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HDFS是Hadoop分布式文件系统，文件系统是用于对文件进行存储和管理。分布式可以理解为由多台机器共同构成一个完成的文件系统。</span><br><span class="line">NameNode(nn)：负责管理HDFS中所有文件的元数据信息，维护着文件系统树和整棵树内所有的文件和目录。元数据：用于描述真实数据的数据就是元数据。例如：一个真实的数据文件a.txt。它的元数据为：文件名 文件大小 文件权限 文件的目录结构 文件对应的块  在哪个dn存。</span><br><span class="line">注意：要想找到HDFS的真实数据必须通过NameNode所维护的元数据才能定位到DataNode中存储的真实数据。</span><br><span class="line">DataNode（dn）：负责管理HDFS的所有的真实文件数据</span><br><span class="line">SecondaryNameNode（2nn）：辅助的NameNode工作，主要的作用是定期合并空间镜像（fsimage）和编辑日志（edits）</span><br></pre></td></tr></table></figure>

<p>​        2.5.2 YARN架构概述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yarn：资源调度和管理的框架。管理和调度的资源就是整个Hadoop集群的资源</span><br><span class="line">ResourceManager（RM）：是Yarn的大哥，负责管理和调度整个集群的资源。负责处理客户端的请求。负责为Job启动ApplicationMaster。</span><br><span class="line">NodeManager（NM）：是每台机器资源的管理者。实际上只是将本机器的资源对ResourceManager做一个汇报。对于资源的分配必须听从ResourceManager的指令。</span><br><span class="line">ApplicationMaster（AM）：对应每一个Job（MapReduce程序），负责为Job向ResourceManager去申请资源，申请到资源以后，负责告诉NodeManager去运行相应的任务。并且负责监控任务的运行状态和任务的容错。</span><br><span class="line">Container：对多维度资源的封装。方便管理资源及防止资源被侵占</span><br></pre></td></tr></table></figure>

<p>​        简单模拟一个任务的提交过程和资源调度过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 客户端提交Job到ResourceManager</span><br><span class="line">2. ResourceManager 为 Job 启动 ApplicationMaster ,ApplicationMaster的运行也需要资源，因此ApplicationMaster启动起来以后，就会有一个Container封装ApplicationMaster运行所用的资源. 因为资源都是在NodeManager上，所以ApplicationMaster是运行在某一个NodeManager上。</span><br><span class="line">3. ApplicationMaster 会根据Job的情况向 ResourceManager申请资源来运行每个Task，当前Job总共有3个Task，每个Task都是单独运行，因此需要申请3份资源, 也就意味着又有3个Container运行.</span><br><span class="line">4. 所有的资源的分配都是ResourceManager下达指令给NodeManager进行分配的.</span><br><span class="line">5. ApplicationMaster为Job成功申请到资源以后，会告诉NodeManager去运行对应的Task,每个Task可能运行到不同的机器，也有可能多个Task运行到同一个机器，要看当时集群的资源情况.</span><br><span class="line">6. 当Job的每个Task都开始运行，ApplicationMaster负责监控整个Job的状态. 要负责容错相关的事情.</span><br><span class="line">7. 当Job的每个Task都执行成功后，意味着Job运行完成，此时ApplicationMaster会找ResourceMananger申请注销自己，所有为当前Job申请的资源得到释放.</span><br></pre></td></tr></table></figure>

<p>​        2.5.3 MapReduce架构概述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MapReduce将计算过程分为两个阶段：</span><br><span class="line">1）Map阶段并行处理输入数据</span><br><span class="line">2）Reduce阶段对Map结果进行汇总</span><br></pre></td></tr></table></figure>



<p>​    2.6 大数据技术生态体系</p>
<h3 id="第3章-Hadoop运行环境搭建"><a href="#第3章-Hadoop运行环境搭建" class="headerlink" title="第3章 Hadoop运行环境搭建"></a>第3章 Hadoop运行环境搭建</h3><ol>
<li><p>安装JDK</p>
</li>
<li><p>安装Hadoop</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hadoop的下载地址：https:&#x2F;&#x2F;archive.apache.org&#x2F;dist&#x2F;hadoop&#x2F;common&#x2F;hadoop-3.1.3&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置JDK和Hadoop的环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打开&#x2F;etc&#x2F;profile.d&#x2F;my_env.sh</span><br><span class="line">在文件中添加</span><br><span class="line">JAVA_HOME&#x3D;&#x2F;opt&#x2F;module&#x2F;jdk1.8.0_212</span><br><span class="line">HADOOP_HOME&#x3D;&#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$HADOOP_HOME&#x2F;bin:$HADOOP_HOME&#x2F;sbin</span><br><span class="line">export PATH JAVA_HOME HADOOP_HOME</span><br><span class="line"></span><br><span class="line">然后通过java -version</span><br><span class="line">hadoop version 验证安装是否成功</span><br></pre></td></tr></table></figure>
</li>
<li><p>hadoop的几个重要的目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）bin目录： 存放对Hadoop相关服务（HDFS,YARN）进行操作的脚本</span><br><span class="line">（2）etc目录： Hadoop的配置文件目录，存放Hadoop的配置文件</span><br><span class="line">（3）lib 目录： 存放Hadoop的本地库（对数据进行压缩解压缩功能）</span><br><span class="line">（4）sbin目录：存放启动或停止Hadoop相关服务的脚本</span><br><span class="line">（5）share目录：存放Hadoop的依赖jar包、文档、和官方案例</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="第4章-Hadoop运行模式"><a href="#第4章-Hadoop运行模式" class="headerlink" title="第4章 Hadoop运行模式"></a>第4章 Hadoop运行模式</h3><p>Hadoop的运行模式有3种：本地运行模式，伪分布式模式，完全分布式模式</p>
<p>常用的通信端口</p>
<table>
<thead>
<tr>
<th>NameNode</th>
<th>内部通信端口</th>
<th>9820</th>
</tr>
</thead>
<tbody><tr>
<td>NameNode</td>
<td>Web通信端口</td>
<td>9870</td>
</tr>
<tr>
<td><strong>SecondaryNameNode</strong></td>
<td>内部通信端口</td>
<td>9869</td>
</tr>
<tr>
<td>SecondaryNameNode</td>
<td>Web通信端口</td>
<td>9868</td>
</tr>
<tr>
<td><strong>ResourceManager</strong></td>
<td>内部通信端口</td>
<td>8032</td>
</tr>
<tr>
<td>ResourceManager</td>
<td>Web通信端口</td>
<td>8088</td>
</tr>
</tbody></table>
<p>配置文件说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）默认的配置文件：</span><br><span class="line">core-default.xml</span><br><span class="line">hdfs-default.xml</span><br><span class="line">yarn-default.xml</span><br><span class="line">mapred-default.xml</span><br><span class="line">2）用户自定义的配置文件</span><br><span class="line">core-site.xml</span><br><span class="line">hdfs-site.xml</span><br><span class="line">yarn-site.xml</span><br><span class="line">mapred-site.xml</span><br><span class="line"></span><br><span class="line">优先级：</span><br><span class="line">用户自定义的配置文件&gt;默认的配置文件，hadoop启动的时候会先加载xxx-default.xml，再加载xxx-site.xml,配置到xxx-site.xml中的配置会覆盖xxx-default中的配置。</span><br></pre></td></tr></table></figure>





<p>4.1 完全分布式运行模式</p>
<p>4.1.1 搭建集群步骤分析</p>
<ol>
<li>准备好集群的机器</li>
<li>安装JDK，Hadoop，配置环境变量</li>
<li>配置集群</li>
<li>单点启动</li>
<li>配置ssh</li>
<li>群起集群</li>
</ol>
<p>4.1.2 编写集群分发脚本xsync</p>
<ol>
<li>scp（secure copy）安全拷贝</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  （1）scp定义：scp可以实现服务器与服务器之间的数据拷贝。（from server1 to server2）</span><br><span class="line">  （2）基本语法</span><br><span class="line">scp   -r  $pdir&#x2F;$fname          $user@hadoop$host:$pdir&#x2F;$fname</span><br><span class="line">命令  递归  要拷贝的文件路径&#x2F;名称    目的用户@主机:目的路径&#x2F;名称</span><br><span class="line">  （3）案例实操</span><br><span class="line">   前提：在 hadoop102  hadoop103  hadoop104 都已经创建好的 &#x2F;opt&#x2F;module</span><br><span class="line">           &#x2F;opt&#x2F;software 两个目录， 并且已经把这两个目录修改为atgu</span><br><span class="line">  （a）在hadoop101上，将hadoop101中&#x2F;opt&#x2F;module目录下的软件拷贝到hadoop102上igu:atguigu</span><br><span class="line">          [atguigu@hadoop101 &#x2F;]$ scp -r &#x2F;opt&#x2F;module  </span><br><span class="line">  （b）在hadoop103上，将hadoop101服务器上的&#x2F;opt&#x2F;module目录下的软件拷贝到hadoop103上</span><br><span class="line">          [atguigu@hadoop103 opt]$ scp -r atguigu@hadoop101:&#x2F;opt&#x2F;module atguigu@hadoop103:&#x2F;opt&#x2F;module</span><br><span class="line">  （c）在hadoop103上操作将hadoop101中&#x2F;opt&#x2F;module目录下的软件拷贝到hadoop104上</span><br><span class="line">		  [atguigu@hadoop103 opt]$ scp -r atguigu@hadoop101:&#x2F;opt&#x2F;module atguigu@hadoop104:&#x2F;opt&#x2F;module</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>rsync远程同步工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）rsync定义</span><br><span class="line">rsync主要用于备份和镜像。具有速度快、避免复制相同内容和支持符号链接的优点。</span><br><span class="line">rsync和scp区别：用rsync做文件的复制要比scp的速度快，rsync只对差异文件做更新。scp是把所有文件都复制过去。</span><br><span class="line">（2）基本语法</span><br><span class="line">rsync    -av       $pdir&#x2F;$fname              $user@hadoop$host:$pdir&#x2F;$fname</span><br><span class="line">命令   选项参数   要拷贝的文件路径&#x2F;名称    目的用户@主机:目的路径&#x2F;名称</span><br><span class="line">选项参数说明:</span><br><span class="line">-a  归档拷贝</span><br><span class="line">-v	显示复制过程</span><br><span class="line">（3）案例实操</span><br><span class="line">（a）把hadoop101机器上的&#x2F;opt&#x2F;software目录同步到hadoop102服务器的&#x2F;opt&#x2F;software目录下</span><br><span class="line">[atguigu@hadoop101 opt]$ rsync -av &#x2F;opt&#x2F;software&#x2F; atguigu@hadoop102:&#x2F;atguigu &#x2F;software</span><br></pre></td></tr></table></figure>
</li>
<li><p>xsync集群分发脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">（1）需求：循环复制文件到所有节点的相同目录下:</span><br><span class="line">（2）期望脚本：基于rsync技术将文件从一个节点同步到其他所有节点</span><br><span class="line">	xsync  要同步的文件名称  </span><br><span class="line">（3）脚本实现</span><br><span class="line">（a）在/home/atguigu目录下创建bin目录，并在bin目录下创建xsync文件</span><br><span class="line">说明：在/home/atguigu/bin这个目录下存放的脚本，atguigu用户可以在系统任何地方直接执行。因为/home/atguigu/bin在系统的PATH环境变量中</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 bin] vim xsync</span><br><span class="line">在文件中编辑如下代码</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1. 判断参数个数</span></span><br><span class="line">if [ $# -lt 1 ]</span><br><span class="line">then</span><br><span class="line">  echo Not Enough Arguement!</span><br><span class="line">  exit;</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash">2. 遍历集群所有机器</span></span><br><span class="line">for host in hadoop102 hadoop103 hadoop104</span><br><span class="line">do</span><br><span class="line">  echo ====================  $host  ====================</span><br><span class="line"><span class="meta">  #</span><span class="bash">3. 遍历所有目录，挨个发送</span></span><br><span class="line">  for file in $@</span><br><span class="line">  do</span><br><span class="line">    #4 判断文件是否存在</span><br><span class="line">    if [ -e $file ]</span><br><span class="line">    then</span><br><span class="line">      #5. 获取父目录</span><br><span class="line">      pdir=$(cd -P $(dirname $file); pwd)</span><br><span class="line">      #6. 获取当前文件的名称</span><br><span class="line">      fname=$(basename $file)</span><br><span class="line">      ssh $host "mkdir -p $pdir"</span><br><span class="line">      rsync -av $pdir/$fname $host:$pdir</span><br><span class="line">    else</span><br><span class="line">      echo $file does not exists!</span><br><span class="line">    fi</span><br><span class="line">  done</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">（b）修改脚本 xsync 具有执行权限</span><br><span class="line">chmod +x xsync</span><br><span class="line">（c）测试脚本</span><br><span class="line">xsync /home/atguigu/a.txt</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>4.1.2 集群配置</p>
<ol>
<li><p>集群部署规划</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：NameNode和SecondaryNameNode不要安装在同一台服务器</span><br><span class="line">注意：ResourceManager也很消耗内存，不要和NameNode、SecondaryNameNode配置在同一台机器上。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>hadoop102</th>
<th>hadoop103</th>
<th>hadoop104</th>
</tr>
</thead>
<tbody><tr>
<td>HDFS</td>
<td>NameNode DataNode</td>
<td>DataNode</td>
<td>SecondaryNameNode DataNode</td>
</tr>
<tr>
<td>YARN</td>
<td>NodeManager</td>
<td>RecourceManager</td>
<td>NodeManager</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="2">
<li><p>配置集群</p>
<p>（1）在hadoop-env.sh中配置JAVA_HOME路径</p>
<p>（2）核心配置文件core-site.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd $HADOOP_HOME&#x2F;etc&#x2F;hadoop</span><br><span class="line">vim core-site.xml</span><br><span class="line">文件内容如下：</span><br><span class="line">&lt;!-- 指定NameNode的地址 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;hdfs:&#x2F;&#x2F;hadoop102:9820&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;!-- 指定hadoop数据的存储目录官方配置文件中的配置项是hadoop.tmp.dir ,用来指定hadoop数据的存储目录,此次配置用的hadoop.data.dir是自己定义的变量， 因为在hdfs-site.xml中会使用此配置的值来具体指定namenode 和 datanode存储数据的目录</span><br><span class="line">--&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.data.dir&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;&#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3&#x2F;data&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;!-- 下面是兼容性配置，先跳过 --&gt;</span><br><span class="line">&lt;!-- 配置该atguigu(superUser)允许通过代理访问的主机节点 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.proxyuser.atguigu.hosts&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;*&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;!-- 配置该atguigu(superuser)允许代理的用户所属组 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.proxyuser.atguigu.groups&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;*&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;!-- 配置该atguigu(superuser)允许代理的用户--&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.proxyuser.atguigu.users&lt;&#x2F;name&gt;</span><br><span class="line">		&lt;value&gt;*&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure>

<p>（3）HDFS配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 指定副本数  --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;3&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定NameNode数据的存储目录 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.namenode.name.dir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;file:&#x2F;&#x2F;$&#123;hadoop.data.dir&#125;&#x2F;name&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 指定Datanode数据的存储目录 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.datanode.data.dir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;file:&#x2F;&#x2F;$&#123;hadoop.data.dir&#125;&#x2F;data&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">    </span><br><span class="line">&lt;!-- 指定SecondaryNameNode数据的存储目录 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.namenode.checkpoint.dir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;file:&#x2F;&#x2F;$&#123;hadoop.data.dir&#125;&#x2F;namesecondary&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">   </span><br><span class="line">&lt;!-- 兼容配置，先跳过 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.client.datanode-restart.timeout&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;30s&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- nn web端访问地址--&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.namenode.http-address&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;hadoop102:9870&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 2nn web端访问地址--&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.namenode.secondary.http-address&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;hadoop104:9868&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure>

<p>（4）YARN配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;!-- 指定ResourceManager的地址--&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;hadoop103&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;!-- 环境变量的继承 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.env-whitelist&lt;&#x2F;name&gt;</span><br><span class="line">	                                                     &lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;!--  取消虚拟内存的限制 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;false&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure>

<p>（5）配置mapred-site.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 指定MapReduce程序运行在Yarn上 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.framework.name&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;yarn&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<ol start="3">
<li><p>在集群上分发配置好的hadoop</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xsync &#x2F;opt&#x2F;module&#x2F;hadoop-3.1.3</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li>在其他节点查看文件分发情况</li>
</ol>
<p>4.1.3 集群单点启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）如果集群是第一次启动需要格式化NameNode</span><br><span class="line">hdfs namenode -format</span><br><span class="line">2）在hadoop102上启动NameNode</span><br><span class="line">hdfs --daemon start namenode</span><br><span class="line">3）完成后执行jps命令，看到namenode进程已启动</span><br><span class="line">3461 NameNode</span><br><span class="line">4）在hadoop102，hadoop103以及hadoop上执行如下命令，启动DataNode</span><br><span class="line">hdfs --daemon start datanode</span><br><span class="line">5）在hadoop104上启动SecondaryNameNode</span><br><span class="line">hdfs --daemon start secondnamenode</span><br><span class="line">6）在hadoop103机器上启动ResourceManager</span><br><span class="line">yarn --daemon start resourcemanager</span><br><span class="line">7）在hadoop102,hadoop103以及hadoop104上执行如下命令，启动nodemanager</span><br><span class="line">yarn --daemon start nodemanager</span><br></pre></td></tr></table></figure>

<p>4.1.4 SSH无密登录配置</p>
<p>4.1.5 群起集群</p>
<h3 id="第5章-Hadoop3-x和2-x主要区别"><a href="#第5章-Hadoop3-x和2-x主要区别" class="headerlink" title="第5章 Hadoop3.x和2.x主要区别"></a>第5章 Hadoop3.x和2.x主要区别</h3><p>​    </p>
<h3 id="第6章-Hadoop源码编译"><a href="#第6章-Hadoop源码编译" class="headerlink" title="第6章 Hadoop源码编译"></a>第6章 Hadoop源码编译</h3><h3 id="第7章-常见错误及解决方案"><a href="#第7章-常见错误及解决方案" class="headerlink" title="第7章  常见错误及解决方案"></a>第7章  常见错误及解决方案</h3>]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
  </entry>
  <entry>
    <title>shell</title>
    <url>/2020/05/12/shell/</url>
    <content><![CDATA[<h3 id="第1章-Shell概述"><a href="#第1章-Shell概述" class="headerlink" title="第1章 Shell概述"></a>第1章 Shell概述</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shell是一个命令行解释器，它接受应用程序/用户命令，然后调用操作系统内核。shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性强</span><br></pre></td></tr></table></figure>

<p>可以通过cat /etc/shells查看Linux提供的shell解析器，centos默认的解析器是bash</p>
<h3 id="第2章-shell脚本入门"><a href="#第2章-shell脚本入门" class="headerlink" title="第2章 shell脚本入门"></a>第2章 shell脚本入门</h3><p>1）脚本格式</p>
<p>​    脚本以#!/bin/bash开头（指定解析器）</p>
<p>2）案例实操：创建一个shell脚本，输出helloworld</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ touch helloworld.sh</span><br><span class="line">[root@hadoop101 datas]$ vi helloworld.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "helloworld"</span><br></pre></td></tr></table></figure>

<p>（3）脚本的常用执行方式</p>
<p>第一种：采用bash或sh脚本的相对路径或绝对路径（不用赋予脚本+x权限）</p>
<p>sh+脚本的相对路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ sh helloworld.sh</span><br></pre></td></tr></table></figure>

<p>第二种：采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限+x）</p>
<p>(a)首先要赋予helloworld.sh脚本的+x权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ chmod 744 helloworld.sh</span><br></pre></td></tr></table></figure>

<p>(b)执行脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ ./helloworld.sh</span><br></pre></td></tr></table></figure>

<p>注意：第一种执行方法，本质是bash解析器帮你执行脚本，所以脚本本身不需要执行权限。第二种执行方法，本质是脚本需要自己执行，所以需要执行权限。</p>
<p>第三种：在脚本的路径前加上“.</p>
<h3 id="第3章-变量"><a href="#第3章-变量" class="headerlink" title="第3章 变量"></a>第3章 变量</h3><h4 id="3-1-系统预定义变量"><a href="#3-1-系统预定义变量" class="headerlink" title="3.1 系统预定义变量"></a>3.1 系统预定义变量</h4><p>1）常用系统常量</p>
<p>$HOME,$PWD,$SHELL,$USER</p>
<p>2）案例实操</p>
<p>（1）查看系统变量的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ echo $HOME</span><br></pre></td></tr></table></figure>

<p>（2）显示当前shell中所有变量：set</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ set</span><br><span class="line">BASH=/bin/bash</span><br><span class="line">BASH_ALIASES=()</span><br><span class="line">BASH_ARGC=()</span><br><span class="line">BASH_ARGV=()</span><br></pre></td></tr></table></figure>



<h4 id="3-2-自定义变量"><a href="#3-2-自定义变量" class="headerlink" title="3.2 自定义变量"></a>3.2 自定义变量</h4><h4 id="3-3-特殊变量"><a href="#3-3-特殊变量" class="headerlink" title="3.3 特殊变量"></a>3.3 特殊变量</h4><h3 id="第4章-运算符"><a href="#第4章-运算符" class="headerlink" title="第4章 运算符"></a>第4章 运算符</h3><h3 id="第5章-条件判断"><a href="#第5章-条件判断" class="headerlink" title="第5章 条件判断"></a>第5章 条件判断</h3><h3 id="第6章-流程控制（重点）"><a href="#第6章-流程控制（重点）" class="headerlink" title="第6章 流程控制（重点）"></a>第6章 流程控制（重点）</h3><h3 id="第7章-read读取控制台输入"><a href="#第7章-read读取控制台输入" class="headerlink" title="第7章 read读取控制台输入"></a>第7章 read读取控制台输入</h3><ol>
<li>基本语法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">read(选项)(参数)</span><br><span class="line">选项：</span><br><span class="line">-p：指定读取值时的提示符；</span><br><span class="line">-t：指定读取值时等待的时间（秒）</span><br><span class="line">参数</span><br><span class="line">	变量：指定读取值的变量名</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>案例实操</li>
</ol>
<p>提示7秒内，读取控制台输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ touch read.sh</span><br><span class="line">[root@hadoop101 datas]$ vim read.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">read -t 7 -p &quot;Enter your name in 7 seconds&quot; NAME</span><br><span class="line">echo $NAME</span><br><span class="line">[root@hadoop101 datas]$ .&#x2F;read.sh</span><br></pre></td></tr></table></figure>



<h3 id="第8章-函数"><a href="#第8章-函数" class="headerlink" title="第8章 函数"></a>第8章 函数</h3><h5 id="8-1-系统函数"><a href="#8-1-系统函数" class="headerlink" title="8.1 系统函数"></a>8.1 系统函数</h5><ol>
<li><p>basename</p>
<p>​    1）基本语法</p>
<p>​    basename[string/pathname] [suffix]   功能描述：basename命令会删除所有的前缀包括最后一个/字符，然后将字符串内容显示出来。选项：suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉</p>
<p>​    2）案例实操</p>
<p>​    截取该/home/atguigu/banzhang.txt路径 的文件名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ basename /home/atguigu/banzhang.txt</span><br><span class="line">banzhang.txt</span><br><span class="line">[root@hadoop101 datas]$ basename /home/atguigu/banzhang.txt .txt</span><br><span class="line">banzhang</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>dirname</p>
<p>​    1）基本语法</p>
<p>​    dirname 文件绝对路径    功能描述：从给定的包含绝对路径的文件名中取出文件名（非目录的部分），然后返回剩下的路径（目录的部分）</p>
<p>​    2）案例实操</p>
<p>​    获取banzhang.txt文件的路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ dirname /home/atguigu/banzhang.txt</span><br><span class="line">/home/atguigu</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="8-2-自定义函数"><a href="#8-2-自定义函数" class="headerlink" title="8.2 自定义函数"></a>8.2 自定义函数</h4><p>​    1）基本语法</p>
<p>​        [function] funname[()]</p>
<p>​        {    </p>
<p>​            Action;</p>
<p>​            [return int;]</p>
<p>​        }</p>
<p>​    2）经验技巧</p>
<p>​        （1）必须在调用函数地方之前，先声明函数，shell脚本是逐行解释运行，不会像其它语言一样先编译。</p>
<p>​        （2）函数返回值，只能通过$?系统变量获得，可以显示加：return返回，如果不加，将以最后一条命令运行结果，作为返回值。return后跟数值n（0-255）</p>
<p>​    3）案例实操</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ touch fun.sh</span><br><span class="line">[root@hadoop101 datas]$ vim fun.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">function sum()</span><br><span class="line">&#123;</span><br><span class="line">	s=0</span><br><span class="line">	s=$[ $1 + $2 ]</span><br><span class="line">	echo "$s"</span><br><span class="line">&#125;</span><br><span class="line">read -p "please input the number1: " n1;</span><br><span class="line">read -p "please input the number2: " n2;</span><br><span class="line">sum $n1 $n2;</span><br><span class="line"></span><br><span class="line">[root@hadoop101 datas]$ chmod 777 fun.sh</span><br><span class="line">[root@hadoop101 datas]$ ./fun.sh</span><br></pre></td></tr></table></figure>



<h3 id="第9章-Shell工具（重点）"><a href="#第9章-Shell工具（重点）" class="headerlink" title="第9章 Shell工具（重点）"></a>第9章 Shell工具（重点）</h3><h4 id="9-1-cut"><a href="#9-1-cut" class="headerlink" title="9.1 cut"></a>9.1 cut</h4><h4 id="9-2-sed-了解"><a href="#9-2-sed-了解" class="headerlink" title="9.2 sed(了解)"></a>9.2 sed(了解)</h4><h4 id="9-3-awk"><a href="#9-3-awk" class="headerlink" title="9.3 awk"></a>9.3 awk</h4><p>​    一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。</p>
<p>1）基本用法</p>
<p>​    awk[选项参数]  ‘pattern1{action1} pattern2{action2}…’    filename</p>
<p>​    pattern: 表示awk在数据中查找的内容，就是匹配模式</p>
<p>​    action：在找到匹配内容时所执行的一系列命令</p>
<p>2）选项参数说明</p>
<p>​    </p>
<table>
<thead>
<tr>
<th>选项参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-F</td>
<td>指定输入文件折分隔符</td>
</tr>
<tr>
<td>-v</td>
<td>赋值一个用户定义变量</td>
</tr>
</tbody></table>
<p>3）案例实操</p>
<p>​    （1）数据准备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ sudo cp /etc/passed ./</span><br></pre></td></tr></table></figure>

<p>​    （2）搜索passwd文件以root关键字开头的所有行，并输出该行的第7列</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ awk -F: '/^root/&#123;print $7&#125;' passwd </span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>



<p>​    （3）搜索passwd文件以root关键字开头的所有行，并输出该行的第1列和第7列，中间用“，”分割</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ awk -F: '/^root/&#123;print $1","$7&#125;' passwd </span><br><span class="line">root,/bin/bash</span><br></pre></td></tr></table></figure>

<p>​    （4）只显示/etc/passwd的第一列和第七列，以逗号分割，且在所有行前面添加列名user，shell在最后一行添加”dahaige，/bin/zuishuai”。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ awk -F 'BEGIN&#123;print "user,shell"&#125; &#123;print $1","$7&#125; END&#123;print "dahaige,/bin/zuishuai"&#125;' passwd</span><br></pre></td></tr></table></figure>

<p>注意2：BEGIN在所有数据读取行之前执行;END在所有数据执行之后执行。</p>
<p> （5）将passwd 文件中的用户id增加数值1并输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]awk -v i=1 -F: '&#123;print $3+i&#125;' passwd</span><br></pre></td></tr></table></figure>



<p>4）awk的内置变量</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>FILENAME</td>
<td>文件名</td>
</tr>
<tr>
<td>NR</td>
<td>已读的记录数（已读的行数,可用于显示对应的行号）</td>
</tr>
<tr>
<td>NF</td>
<td>浏览记录的域的个数（切割后，列的个数）</td>
</tr>
</tbody></table>
<p>5）案例实操</p>
<p>​    （1）统计passwd文件名，每行的行号，每行的列数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ awk -F : '&#123;print "filename:" FILENAME  ",linenumber: " NR ",columns:" NF&#125;' passwd</span><br></pre></td></tr></table></figure>

<p>​    （2）切割IP</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ ifconfig | grep "netmask" | awk -F "inet" </span><br><span class="line">'&#123;print $2&#125;' | awk -F " " '&#123;print $1&#125;'</span><br></pre></td></tr></table></figure>

<p>​    （3）查询sed.txt中空行所在的行号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ awk '/^$/&#123;print NR&#125;' sed.txt</span><br></pre></td></tr></table></figure>





<h4 id="9-4-sort"><a href="#9-4-sort" class="headerlink" title="9.4 sort"></a>9.4 sort</h4><h4 id="9-5-wc-word-count"><a href="#9-5-wc-word-count" class="headerlink" title="9.5 wc(word count)"></a>9.5 wc(word count)</h4><p>​    wc命令来计算数字。利用wc指令我们可以计算文件的byte数，字数或是列数。</p>
<p>1）基本语法</p>
<p>wc[选项参数]filename</p>
<table>
<thead>
<tr>
<th>选项参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td>统计文件行数</td>
</tr>
<tr>
<td>-w</td>
<td>统计文件的单词数</td>
</tr>
<tr>
<td>-m</td>
<td>统计文件的字符数</td>
</tr>
</tbody></table>
<p>2）案例实操</p>
<p>统计/etc/profile文件的行数，单词数，字节数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]# wc -l /etc/profile</span><br><span class="line">[root@hadoop101 datas]# wc -w /etc/profile</span><br><span class="line">[root@hadoop101 datas]# wc -m /etc/profile</span><br></pre></td></tr></table></figure>



<h3 id="第10章-正则表达式入门"><a href="#第10章-正则表达式入门" class="headerlink" title="第10章 正则表达式入门"></a>第10章 正则表达式入门</h3><p>​         正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。在Linux中，grep，sed，awk等命令都支持通过正则表达式进行模式匹配。  </p>
<h4 id="10-1常规匹配"><a href="#10-1常规匹配" class="headerlink" title="10.1常规匹配"></a>10.1常规匹配</h4><p>​    一串不包含特殊字符的正则表达式匹配它自己，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]cat /etc/passwd | grep atguigu</span><br></pre></td></tr></table></figure>



<h4 id="10-2常用特殊字符"><a href="#10-2常用特殊字符" class="headerlink" title="10.2常用特殊字符"></a>10.2常用特殊字符</h4><p>​    1）特殊字符：^</p>
<p>​    ^匹配一行的开头，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ cat /etc/passwd | grep ^a</span><br></pre></td></tr></table></figure>

<p>会匹配出所有以a开头的行</p>
<p>​    2）特殊字符：$</p>
<p>​    $匹配一行的结束，例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ cat /etc/passwd | grep t$</span><br></pre></td></tr></table></figure>

<p>会匹配出所有以t结尾的行</p>
<p>​    3）特殊字符：.</p>
<p>.匹配一个任意的字符，例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ cat /etc/passed | grep r..t</span><br></pre></td></tr></table></figure>



<p>​    4）特殊字符：*</p>
<p>​    *不单独使用，他和上一个字符连用，表示匹配上一个字符0次或多次，例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas] cat /etc/passwd | grep ro*t</span><br></pre></td></tr></table></figure>

<p>会匹配rt,rot,root,rooot,roooot等所有行</p>
<p>​    5）特殊字符：[]</p>
<p>​    [ ] 表示匹配某个范围内的一个字符，例如</p>
<p>​    [6,8]——匹配6或者8</p>
<p>​    [a-z]——匹配一个a-z之间的字符</p>
<p>​    [a-z]*—–匹配任意字母字符串</p>
<p>​    [a-c, e-f]-匹配a-c或者e-f之间的任意字符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ cat /etc/passwd | grep r[a,b,c]*t</span><br></pre></td></tr></table></figure>

<p>会匹配rt,rat,rabt,racbt,等所有行</p>
<p>​    6）特殊字符：\</p>
<p>​         \ 表示转义，并不会单独使用。由于所有特殊字符都有其特定匹配模式，当我们想匹配某一特殊字符本身时（例如，我想找出所有包含 ‘$’ 的行），就会碰到困难。此时我们就要将转义字符和特殊字符连用，来表示特殊字符本身，例如  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 datas]$ cat /etc/passwd | grep a\$b</span><br></pre></td></tr></table></figure>

<p>​         就会匹配所有包含 a$b 的行  </p>
<p>​    </p>
<h4 id="10-3其他特殊字符"><a href="#10-3其他特殊字符" class="headerlink" title="10.3其他特殊字符"></a>10.3其他特殊字符</h4><p>​    参考正则表达式语法</p>
<h3 id="第11章-面试题"><a href="#第11章-面试题" class="headerlink" title="第11章 面试题"></a>第11章 面试题</h3>]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title>Linux基本介绍</title>
    <url>/2020/05/05/linux%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><h3 id="1-Linux的目录"><a href="#1-Linux的目录" class="headerlink" title="1. Linux的目录"></a>1. Linux的目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F; 根目录</span><br><span class="line">&#x2F;bin 存放Linux的常用命令</span><br><span class="line">&#x2F;root 是root用户的主目录&#x2F;家目录</span><br><span class="line">&#x2F;home 是存放所有普通用户主目录的目录</span><br><span class="line">&#x2F;etc 存放Linux系统配置文件的目录</span><br><span class="line">&#x2F;opt 存放安装软件的目录</span><br><span class="line">&#x2F;tmp 存放临时文件的目录</span><br><span class="line">&#x2F;var 存放文件内容经常扩充变化的目录，习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件</span><br><span class="line">&#x2F;boot 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件，自己的安装别放这里</span><br></pre></td></tr></table></figure>

<h3 id="2-VI-VIM编辑器"><a href="#2-VI-VIM编辑器" class="headerlink" title="2. VI/VIM编辑器"></a>2. VI/VIM编辑器</h3><h4 id="2-1-一般模式"><a href="#2-1-一般模式" class="headerlink" title="2.1 一般模式"></a>2.1 一般模式</h4><p>​    通过vi/vim打开一个文件就直接进入一般模式了（默认模式），在一般模式中，可以通过上下左右按键来移动光标，可以使用删除字符或删除整行来处理档案内容，，也可以使用复制粘贴处理文件数据</p>
<p>常用的语法如下</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>yy</td>
<td>复制光标当前一行</td>
</tr>
<tr>
<td>dd</td>
<td>删除光标当前行</td>
</tr>
<tr>
<td>shift+^</td>
<td>删除一个词</td>
</tr>
<tr>
<td>shift+$</td>
<td>移动到行尾</td>
</tr>
<tr>
<td>数字n+shift+g</td>
<td>移动到目标行</td>
</tr>
<tr>
<td>shift+g</td>
<td>移动到页尾</td>
</tr>
</tbody></table>
<h4 id="2-2-编辑模式"><a href="#2-2-编辑模式" class="headerlink" title="2.2 编辑模式"></a>2.2 编辑模式</h4><p>​    在一般模式下可以进行删除，复制，粘贴等动作，但是却无法编辑文件内容的，要按下【i,a,o,I,A,O】中的任意一个字母才会进入编辑模式。进入编辑模式时，在画面的左下方会出现insert或replace的字样，此时才可以进行编辑。</p>
<p>​    退出编辑模式时按下<code>ESC</code>键即可</p>
<h4 id="2-3-指令模式"><a href="#2-3-指令模式" class="headerlink" title="2.3 指令模式"></a>2.3 指令模式</h4><p>​    在一般模式中，输入【:/?】3个中的任何一个按钮，就可以将光标移动到最底下那一行。在这个模式中，可以提供搜寻资料的工作，而读取，存盘，大量取代字符，离开vi，显示行号等动作是在此模式中达成的。</p>
<p>​    </p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>:w</td>
<td>保存</td>
</tr>
<tr>
<td>:q</td>
<td>退出</td>
</tr>
<tr>
<td>:!</td>
<td>强制执行</td>
</tr>
<tr>
<td>/要查找的词</td>
<td>n查找下一个，N往上查找</td>
</tr>
<tr>
<td>？要查找的词</td>
<td>n是查找上一个，shift+n是往下查找</td>
</tr>
<tr>
<td>:set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>关闭行号</td>
</tr>
<tr>
<td>:%s/old/new/g</td>
<td>替换内容</td>
</tr>
</tbody></table>
<p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:wq! --强制保存退出</span><br></pre></td></tr></table></figure>



<h3 id="3-网络配置和系统管理操作"><a href="#3-网络配置和系统管理操作" class="headerlink" title="3. 网络配置和系统管理操作"></a>3. 网络配置和系统管理操作</h3><h4 id="3-1-配置网络IP地址"><a href="#3-1-配置网络IP地址" class="headerlink" title="3.1 配置网络IP地址"></a>3.1 配置网络IP地址</h4><h5 id="3-1-1-ifconfig-查看网络接口"><a href="#3-1-1-ifconfig-查看网络接口" class="headerlink" title="3.1.1 ifconfig 查看网络接口"></a>3.1.1 ifconfig 查看网络接口</h5><ol>
<li><p>基本语法</p>
<p>ifconfig (功能描述：显示所有网络接口的配置信息)</p>
</li>
<li><p>案例实操</p>
<p>[root@hadoop100 ~]# ifconfig</p>
</li>
</ol>
<h5 id="3-1-2-ping-测试主机之间网络连通性"><a href="#3-1-2-ping-测试主机之间网络连通性" class="headerlink" title="3.1.2 ping 测试主机之间网络连通性"></a>3.1.2 ping 测试主机之间网络连通性</h5><ol>
<li><p>基本语法</p>
<p>ping 目的主机</p>
</li>
</ol>
<h5 id="3-1-3-修改IP地址"><a href="#3-1-3-修改IP地址" class="headerlink" title="3.1.3 修改IP地址"></a>3.1.3 修改IP地址</h5><ol>
<li><p>查看IP配置文件，并作相应修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop100 ~]#vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line">设置以下内容</span><br><span class="line">TYPE="Ethernet"    #网络类型（通常是Ethemet）</span><br><span class="line">PROXY_METHOD="none"</span><br><span class="line">BROWSER_ONLY="no"</span><br><span class="line">BOOTPROTO="static"   #IP的配置方法[none|static|bootp|dhcp]（引导时不 使用协议|静态分配IP|BOOTP协议|DHCP协议）</span><br><span class="line">DEFROUTE="yes"</span><br><span class="line">IPV4_FAILURE_FATAL="no"</span><br><span class="line">IPV6INIT="yes"</span><br><span class="line">IPV6_AUTOCONF="yes"</span><br><span class="line">IPV6_DEFROUTE="yes"</span><br><span class="line">IPV6_FAILURE_FATAL="no"</span><br><span class="line">IPV6_ADDR_GEN_MODE="stable-privacy"</span><br><span class="line">NAME="ens33"   </span><br><span class="line">UUID="e83804c1-3257-4584-81bb-660665ac22f6"   #随机id</span><br><span class="line">DEVICE="ens33"   #接口名（设备,网卡）</span><br><span class="line">ONBOOT="yes"   #系统启动的时候网络接口是否有效（yes/no）</span><br><span class="line"><span class="meta">#</span><span class="bash">IP地址</span></span><br><span class="line">IPADDR=192.168.202.100  </span><br><span class="line"><span class="meta">#</span><span class="bash">网关  </span></span><br><span class="line">GATEWAY=192.168.202.2      </span><br><span class="line"><span class="meta">#</span><span class="bash">域名解析器</span></span><br><span class="line">DNS1=192.168.202.2</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li>执行service network restart 重启网络</li>
</ol>
<h4 id="3-2-配置主机名"><a href="#3-2-配置主机名" class="headerlink" title="3.2 配置主机名"></a>3.2 配置主机名</h4><h5 id="3-2-1-修改主机名称"><a href="#3-2-1-修改主机名称" class="headerlink" title="3.2.1 修改主机名称"></a>3.2.1 修改主机名称</h5><ol>
<li><p>基本语法</p>
<p>hostname （功能描述：查看当前服务器的主机名称）</p>
</li>
<li><p>案例实操</p>
<p>（1） 查看当前服务器主机名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop100 ~]# hostname</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   （2）如果感觉此主机名不合适，可以通过编辑/etc/hostname文件进行修改</p>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop100 ~]# vim /etc/hostname</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-修改hosts映射文件"><a href="#3-2-2-修改hosts映射文件" class="headerlink" title="3.2.2 修改hosts映射文件"></a>3.2.2 修改hosts映射文件</h5><ol>
<li><p>修改linux的主机映射文件（hosts文件）后续在hadoop阶段，虚拟机会比较多，配置时通常会采用主机名的方式配置。 比较简单方便。不用刻意记地址。</p>
<p>vim打开/etc/hosts ，添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.202.100 hadoop100</span><br><span class="line">192.168.202.101 hadoop101</span><br><span class="line">192.168.202.102 hadoop102</span><br><span class="line">192.168.202.103 hadoop103</span><br><span class="line">192.168.202.104 hadoop104</span><br><span class="line">192.168.202.105 hadoop105</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>重启设备，查看主机名，已经修改成功</p>
<h4 id="3-3-关闭防火墙"><a href="#3-3-关闭防火墙" class="headerlink" title="3.3 关闭防火墙"></a>3.3 关闭防火墙</h4></li>
</ol>
<h4 id="3-4-关机重启命令"><a href="#3-4-关机重启命令" class="headerlink" title="3.4 关机重启命令"></a>3.4 关机重启命令</h4><h3 id="4-远程登录"><a href="#4-远程登录" class="headerlink" title="4. 远程登录"></a>4. 远程登录</h3><h3 id="5-常用基本命令"><a href="#5-常用基本命令" class="headerlink" title="5. 常用基本命令"></a>5. 常用基本命令</h3><h4 id="5-1-帮助命令"><a href="#5-1-帮助命令" class="headerlink" title="5.1 帮助命令"></a>5.1 帮助命令</h4><h5 id="5-1-1-man获得帮助信息"><a href="#5-1-1-man获得帮助信息" class="headerlink" title="5.1.1 man获得帮助信息"></a>5.1.1 man获得帮助信息</h5><p>1.基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man[命令或配置文件] （功能描述：获得帮助信息）</span><br></pre></td></tr></table></figure>

<p>2.显示说明</p>
<table>
<thead>
<tr>
<th>信息</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>NAME</td>
<td>命令的名称和单行描述</td>
</tr>
<tr>
<td>SYNOPSIS</td>
<td>怎样使用命令</td>
</tr>
<tr>
<td>DESCRIPTION</td>
<td>命令功能的深入讨论</td>
</tr>
<tr>
<td>EXAMPLES</td>
<td>怎样使用命令的例子</td>
</tr>
<tr>
<td>SEE ALSO</td>
<td>相关主题（通常是手册页）</td>
</tr>
</tbody></table>
<p>3.案例实操</p>
<p>（1）查看ls命令的帮助信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# man ls</span><br></pre></td></tr></table></figure>

<h5 id="5-1-2-help获得shell内置命令的帮助信息"><a href="#5-1-2-help获得shell内置命令的帮助信息" class="headerlink" title="5.1.2 help获得shell内置命令的帮助信息"></a>5.1.2 help获得shell内置命令的帮助信息</h5><p>1.基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help 命令  （功能描述：获得shell内置命令的帮助信息）</span><br></pre></td></tr></table></figure>

<p>2.案例实操</p>
<p>（1）查看cd命令的帮助信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# help cd</span><br></pre></td></tr></table></figure>

<h5 id="5-1-3-常用快捷键"><a href="#5-1-3-常用快捷键" class="headerlink" title="5.1.3 常用快捷键"></a>5.1.3 常用快捷键</h5><table>
<thead>
<tr>
<th>常用快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>ctrl+c</td>
<td>停止进程</td>
</tr>
<tr>
<td>ctrl+l</td>
<td>清屏；彻底清屏是：reset</td>
</tr>
<tr>
<td>ctrl+q</td>
<td>退出</td>
</tr>
<tr>
<td>tab键</td>
<td>提示，自动补全</td>
</tr>
<tr>
<td>上下键</td>
<td>查找执行过的命令</td>
</tr>
<tr>
<td>ctrl+alt</td>
<td>linux和Windows之间的切换</td>
</tr>
</tbody></table>
<h4 id="5-2-文件目录类"><a href="#5-2-文件目录类" class="headerlink" title="5.2 文件目录类"></a>5.2 文件目录类</h4><h5 id="5-2-1-pwd-显示当前工作目录的绝对路径"><a href="#5-2-1-pwd-显示当前工作目录的绝对路径" class="headerlink" title="5.2.1 pwd 显示当前工作目录的绝对路径"></a>5.2.1 pwd 显示当前工作目录的绝对路径</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwd:print working directory </span><br><span class="line">1.基本语法</span><br><span class="line">[root@hadoop101~]# pwd</span><br><span class="line">&#x2F;root</span><br></pre></td></tr></table></figure>

<h5 id="5-2-2-ls列出目录的内容"><a href="#5-2-2-ls列出目录的内容" class="headerlink" title="5.2.2 ls列出目录的内容"></a>5.2.2 ls列出目录的内容</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls: list 列出目录内容</span><br></pre></td></tr></table></figure>

<ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls [选项][目录或是文件]</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>全部的文件，连同隐藏（开头为.的文件）一起类出来（常用）</td>
</tr>
<tr>
<td>-l</td>
<td>长数据串列出，包含文件的属性与权限等等详细信息；可简写为ll</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>显示说明</p>
<p>每行列出的信息依次是： 文件类型与权限 链接数 文件属主 文件属组 文件大小用byte来表示 建立或最近修改的时间 名字 </p>
</li>
<li><p>案例实操</p>
<p>（1）查看当前目录的所有内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# ls -al</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="5-2-3-cd-切换目录"><a href="#5-2-3-cd-切换目录" class="headerlink" title="5.2.3 cd 切换目录"></a>5.2.3 cd 切换目录</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd: change directory</span><br></pre></td></tr></table></figure>

<ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd [参数]</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>参数说明</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>cd 绝对路径</td>
<td>切换路径</td>
</tr>
<tr>
<td>cd 相对路径</td>
<td>切换路径</td>
</tr>
<tr>
<td>cd ~或者cd</td>
<td>回到自己家目录</td>
</tr>
<tr>
<td>cd -</td>
<td>回到上一次所在目录</td>
</tr>
<tr>
<td>cd ..</td>
<td>回到当前目录的上一级目录</td>
</tr>
<tr>
<td>cd -p</td>
<td>跳转到实际物理路径，而非快捷方式（软链接）</td>
</tr>
</tbody></table>
</li>
<li><p>案例实操</p>
<p>（1）使用绝对路径切换到root目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# cd &#x2F;root</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   （2）使用相对路径切换到公共的目录</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# cd 公共的&#x2F;</span><br></pre></td></tr></table></figure>



<p>   （3） 回到自己的家目录，及是/root这个目录</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# cd ~</span><br></pre></td></tr></table></figure>



<p>   （4） cd - 回到上一次目录</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# cd -</span><br></pre></td></tr></table></figure>



<p>   （5） 回到当前目录的上一级目录</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# cd ..</span><br></pre></td></tr></table></figure>

<h5 id="5-2-4-mkdir-创建一个新的目录"><a href="#5-2-4-mkdir-创建一个新的目录" class="headerlink" title="5.2.4 mkdir 创建一个新的目录"></a>5.2.4 mkdir 创建一个新的目录</h5><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir: make directory</span><br><span class="line">mkdir[选项] 要创建的目录</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-p</td>
<td>创建多层目录</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<p>（1）创建一个目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# mkdir xiyou</span><br><span class="line">[root@hadoop101~]# mkdir xiyou&#x2F;minjie</span><br></pre></td></tr></table></figure>

<p>（2）创建一个多级目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# mkdir -p a&#x2F;b&#x2F;c</span><br></pre></td></tr></table></figure>

<h5 id="5-2-5-删除一个空目录"><a href="#5-2-5-删除一个空目录" class="headerlink" title="5.2.5 删除一个空目录"></a>5.2.5 删除一个空目录</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmdir: remove directory</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmdir 要删除的空目录</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# rm dir aa&#x2F;b&#x2F;c</span><br></pre></td></tr></table></figure>

<h5 id="5-2-6-创建空文件"><a href="#5-2-6-创建空文件" class="headerlink" title="5.2.6 创建空文件"></a>5.2.6 创建空文件</h5></li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch 文件名称</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# touch aa&#x2F;b.txt</span><br></pre></td></tr></table></figure>

<h5 id="5-2-7-复制文件或目录"><a href="#5-2-7-复制文件或目录" class="headerlink" title="5.2.7 复制文件或目录"></a>5.2.7 复制文件或目录</h5><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp [选项] source dest (功能描述：复制source文件到dest)</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<pre><code>2. 选项说明

   | 选项 | 功能               |
   | ---- | ------------------ |
   | -r   | 递归复制整个文件夹 |



3. 参数说明

   | 参数   | 功能     |
   | ------ | -------- |
   | source | 源文件   |
   | dest   | 目标文件 |



4. 经验技巧

   强制覆盖不提示的方法：\cp

5. 案例实操

   （1）复制文件

   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# cp aa&#x2F;b.txt aa&#x2F;b&#x2F;</span><br></pre></td></tr></table></figure>

   （2）递归复制整个文件夹

   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# cp -r aa&#x2F; .&#x2F;</span><br></pre></td></tr></table></figure></code></pre><h5 id="5-2-8-删除文件或目录"><a href="#5-2-8-删除文件或目录" class="headerlink" title="5.2.8 删除文件或目录"></a>5.2.8 删除文件或目录</h5><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm [选项] deleteFile (功能描述:递归删除目录中的所有内容)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>递归删除目录中的所有内容</td>
</tr>
<tr>
<td>-f</td>
<td>强制执行删除操作，而不提示用于进行确认</td>
</tr>
<tr>
<td>-v</td>
<td>显示指令的详细执行过程</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<p>（1）删除目录中的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# rm aa&#x2F;b&#x2F;b.txt</span><br></pre></td></tr></table></figure>

<p>（2）递归删除目录中的所有内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# rm -rf aa&#x2F;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-9-移动文件与目录或重命名"><a href="#5-2-9-移动文件与目录或重命名" class="headerlink" title="5.2.9 移动文件与目录或重命名"></a>5.2.9 移动文件与目录或重命名</h5></li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）mv oldNameFile newNameFile (功能描述：重命名)</span><br><span class="line">（2）mv &#x2F;temp&#x2F;movefile &#x2F;targetFolder (功能描述：移动文件)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<p>（1）重命名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# mv test.txt test1.txt</span><br></pre></td></tr></table></figure>



</li>
</ol>
<pre><code>（2）移动文件

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# mv test.txt aa&#x2F;</span><br></pre></td></tr></table></figure></code></pre><h5 id="5-2-10-cat-查看文件内容"><a href="#5-2-10-cat-查看文件内容" class="headerlink" title="5.2.10 cat 查看文件内容"></a>5.2.10 cat 查看文件内容</h5><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat [选项] 要查看的文件</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>-n</td>
<td>显示所有行的行号，包含空行</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>经验技巧</p>
<p>一般查看比较小的文件，一屏幕显示全的</p>
</li>
<li><p>案例实操</p>
<p>（1）查看文件内容并显示行号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# cat -n anaconda-ks.cfg</span><br></pre></td></tr></table></figure>

<h5 id="5-2-11-more-文件内容分屏查看器"><a href="#5-2-11-more-文件内容分屏查看器" class="headerlink" title="5.2.11 more 文件内容分屏查看器"></a>5.2.11 more 文件内容分屏查看器</h5><p>​    more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式显示文本文件的内容。more指令中内置了若干快捷键，详细操作参照说明。</p>
</li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">more 要查看的文件</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>操作说明</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>空白键（space）</td>
<td>代表向下翻一页</td>
</tr>
<tr>
<td>enter</td>
<td>代表向下翻一行</td>
</tr>
<tr>
<td>q</td>
<td>代表立即离开more，不再显示该文件内容</td>
</tr>
<tr>
<td>ctrl+F</td>
<td>向下滚动一屏</td>
</tr>
<tr>
<td>ctrl+B</td>
<td>返回上一屏</td>
</tr>
<tr>
<td>=</td>
<td>输出当前行的行号</td>
</tr>
<tr>
<td>:f</td>
<td>输出文件名和当前行的行号</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# more anaconda-ks.cfg</span><br></pre></td></tr></table></figure>

<h5 id="5-2-12-less分屏显示文件内容"><a href="#5-2-12-less分屏显示文件内容" class="headerlink" title="5.2.12 less分屏显示文件内容"></a>5.2.12 less分屏显示文件内容</h5><p>​    less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</p>
</li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less 要查看的文件</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>操作说明</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>空白键</td>
<td>向下翻动一页</td>
</tr>
<tr>
<td>pagedown</td>
<td>向下翻动一页</td>
</tr>
<tr>
<td>pageup</td>
<td>向上翻动一页</td>
</tr>
<tr>
<td>/字串</td>
<td>向下搜寻[字串]的功能：n:向下查找  N:向上查找</td>
</tr>
<tr>
<td>?字串</td>
<td>向上搜寻[字串]的功能：n:向上查找  N:向下查找</td>
</tr>
<tr>
<td>q</td>
<td>退出less查看</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>经验技巧</p>
<p>用secureCRT时pagedown和pageup可能会出现无法识别的问题</p>
</li>
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 ~]# less anaconda-ks.cfg</span><br></pre></td></tr></table></figure>

<h5 id="5-2-13-echo"><a href="#5-2-13-echo" class="headerlink" title="5.2.13 echo"></a>5.2.13 echo</h5><p>echo 输出内容到控制台</p>
</li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo [选项] [输出内容]</span><br></pre></td></tr></table></figure>

<p>​    选项： -e 支持反斜线控制的字符转换</p>
<table>
<thead>
<tr>
<th>控制字符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>输出\本身</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>制表符</td>
</tr>
</tbody></table>
</li>
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 ~]# echo &quot;hello\tworld&quot;</span><br><span class="line">hello\tworld</span><br><span class="line">[root@hadoop101 ~]# echo -e &quot;hello\tworld&quot;</span><br><span class="line">hello	world</span><br></pre></td></tr></table></figure>

<h5 id="5-2-14-head-显示文件头部内容"><a href="#5-2-14-head-显示文件头部内容" class="headerlink" title="5.2.14 head 显示文件头部内容"></a>5.2.14 head 显示文件头部内容</h5><p>​    head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容</p>
</li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head 文件 （功能描述：查看文件头10行内容）</span><br><span class="line">head -n 5 文件（功能描述：查看文件头5行内容）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-n&lt;行数&gt;</td>
<td>指定显示文件头部内容的行数</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 ~]# head -n 2 a.txt</span><br></pre></td></tr></table></figure>

<h5 id="5-2-15-tail输出文件尾部内容"><a href="#5-2-15-tail输出文件尾部内容" class="headerlink" title="5.2.15 tail输出文件尾部内容"></a>5.2.15 tail输出文件尾部内容</h5><p>​    tail用于输出文件中尾部的内容，默认情况下tail指令显示文件的后10行内容</p>
</li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）tail 文件  （功能描述：查看文件尾部10行内容）</span><br><span class="line">（2）tail -n 5 文件  （功能描述：查看文件尾部5行内容）</span><br><span class="line">（3）tail -f 文件  （功能描述：实时追踪该文档的所有更新，常用于查看日志日志文件的更新）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-n&lt;行数&gt;</td>
<td>输出文件尾部n行内容</td>
</tr>
<tr>
<td>-f</td>
<td>显示文件最新追加的内容，监视文件的变化</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）查看文件尾1行内容</span><br><span class="line">[root@hadoop101 ~]# tail -n b.txt</span><br><span class="line">（2）实时追踪该档的所有更新</span><br><span class="line">[root@hadoop101 ~]# tail -f b.txt</span><br></pre></td></tr></table></figure>

<h5 id="5-2-16-gt-输出重定向和-gt-gt-追加"><a href="#5-2-16-gt-输出重定向和-gt-gt-追加" class="headerlink" title="5.2.16 &gt; 输出重定向和 &gt;&gt; 追加"></a>5.2.16 &gt; 输出重定向和 &gt;&gt; 追加</h5></li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   （1） ls -l &gt; 文件 （功能描述：列表的内容写入文件中覆盖写）</span><br><span class="line">（2） ls al &gt;&gt; 文件 （功能描述：列表的内容追加到文件的末尾）</span><br><span class="line">   （3） cat 文件1 &gt; 文件2 （功能描述：将文件1的内容覆盖到文件2中）</span><br><span class="line">（4） echo &quot;内容&quot; &gt;&gt; 文件 （将指定内容追加到文件中）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）将ls查看信息写入到文件中</span><br><span class="line">[root@hadoop101 ~]# ls -l&gt;houge.txt</span><br><span class="line">（2）将ls查看信息追加到文件中</span><br><span class="line">[root@hadoop101 ~]# ls -l&gt;&gt;houge.txt</span><br><span class="line">（3）采用echo将hello单词追加到文件中</span><br><span class="line">[root@hadoop101 ~]# echo hello&gt;&gt;houge.txt</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="5-2-17-In-软链接"><a href="#5-2-17-In-软链接" class="headerlink" title="5.2.17 In 软链接"></a>5.2.17 In 软链接</h5><p>   ​    软链接也称为符号链接，类似于Windows里的快捷方式，有自己的数据库，主要存放了链接其它文件的路径</p>
<ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s [原文件或目录][软链接名]  （功能描述：给原文件创建一个软链接）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>经验技巧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">删除软链接：rm -rf 软链接名，而不是rm -rf 软链接名&#x2F;</span><br><span class="line">查询：通过ll就可以查看，列表属性第1位时1，尾部会有位置指向</span><br></pre></td></tr></table></figure>





</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）创建软链接</span><br><span class="line">[root@hadoop101 ~]# mv text.txt ab&#x2F;b&#x2F;</span><br><span class="line">[root@hadoop101 ~]# ln -s ab&#x2F;b&#x2F;text.txt .&#x2F;lianjie</span><br><span class="line">（2） 删除软链接</span><br><span class="line">[root@hadoop101 ~]# rm -rf lianjie</span><br><span class="line">（3） 进入软链接实际物理路径</span><br><span class="line">[root@hadoop101 ~]# ln -s ab&#x2F;b&#x2F;text.txt .&#x2F;lianjie</span><br><span class="line">[root@hadoop101 ~]# cd -P lianjie&#x2F;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="5-2-18-history-查看已经执行过的历史命令"><a href="#5-2-18-history-查看已经执行过的历史命令" class="headerlink" title="5.2.18 history 查看已经执行过的历史命令"></a>5.2.18 history 查看已经执行过的历史命令</h5><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">history （功能描述：查看已经执行过的历史命令）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）查看已经指令过的历史命令</span><br><span class="line">[root@hadoop101 ~]# history</span><br></pre></td></tr></table></figure>

<h4 id="5-3-时间日期类"><a href="#5-3-时间日期类" class="headerlink" title="5.3 时间日期类"></a>5.3 时间日期类</h4></li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date [option]...[+format]</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-d&lt;时间字符串&gt;</td>
<td>显示指定的“时间字符串”表示的时间，而非当前时间</td>
</tr>
<tr>
<td>-s&lt;日期时间&gt;</td>
<td>设置系统日期时间</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>参数说明</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;+日期时间格式&gt;</td>
<td>指定显示时使用的日期时间格式</td>
</tr>
</tbody></table>
<h4 id="5-3-1-date显示当前时间"><a href="#5-3-1-date显示当前时间" class="headerlink" title="5.3.1 date显示当前时间"></a>5.3.1 date显示当前时间</h4></li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）date  （功能描述：显示当前时间）</span><br><span class="line">（2）date+%Y （功能描述：显示当前月份）</span><br><span class="line">（3）date+%m （功能描述：显示当前月份）</span><br><span class="line">（4）date+%d （功能描述：显示当前是哪一天）</span><br><span class="line">（5）date&quot;+%Y-%m-%d%H:%M:%S&quot; （功能描述：显示年月日时分秒）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）显示当前时间信息</span><br><span class="line">[root@hadoop101~]# date</span><br><span class="line">（2）显示当前时间年月日</span><br><span class="line">[root@hadoop101~]# date +%Y%m%d</span><br><span class="line">（3）显示当前年月日时分秒</span><br><span class="line">[root@hadoop101~]# date &quot;+%Y-%m-%d %H:%M:%S&quot;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-2-date-显示非当前时间"><a href="#5-3-2-date-显示非当前时间" class="headerlink" title="5.3.2 date 显示非当前时间"></a>5.3.2 date 显示非当前时间</h5></li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）date -d &#39;1 days ago&#39; （功能描述：显示其前一天时间）</span><br><span class="line">（2）date -d &#39;-1 days ago&#39; （功能描述：显示明天时间）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# date -d &#39;1 days ago&#39;</span><br><span class="line">[root@hadoop101~]# date -d &#39;-1 days ago&#39;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-4-查看日历"><a href="#5-3-4-查看日历" class="headerlink" title="5.3.4 查看日历"></a>5.3.4 查看日历</h5></li>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cal [选项] （功能描述：不加选项，显示本月日历）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>具体某一年</td>
<td>显示这一年的日历</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）查看当前月的日历</span><br><span class="line">[root@hadoop101~]# cal</span><br><span class="line">（2）查看2017年的日历</span><br><span class="line">[root@hadoop101~]# cal 2020</span><br></pre></td></tr></table></figure>

<h4 id="5-4-用户管理命令"><a href="#5-4-用户管理命令" class="headerlink" title="5.4 用户管理命令"></a>5.4 用户管理命令</h4><h5 id="5-4-1-useraddd-添加新用户"><a href="#5-4-1-useraddd-添加新用户" class="headerlink" title="5.4.1 useraddd 添加新用户"></a>5.4.1 useraddd 添加新用户</h5></li>
<li><p>基本用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd 用户名  （功能描述：添加新用户）</span><br><span class="line">useradd -g 组名 用户名  （功能描述： 添加新用户到某个组）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）添加一个用户</span><br><span class="line">[root@hadoop101~]# useradd lisi</span><br><span class="line">[root@hadoop101~]# ll &#x2F;home&#x2F;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="5-4-2-passwd-设置用户密码"><a href="#5-4-2-passwd-设置用户密码" class="headerlink" title="5.4.2 passwd 设置用户密码"></a>5.4.2 passwd 设置用户密码</h5><ol>
<li><p>基本用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd 用户名  （功能描述：设置用户密码）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）设置用户的密码</span><br><span class="line">[root@hadoop101~]# passwd lisi</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="5-4-3-id-查看用户是否存在"><a href="#5-4-3-id-查看用户是否存在" class="headerlink" title="5.4.3 id 查看用户是否存在"></a>5.4.3 id 查看用户是否存在</h5><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id 用户名</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# id lisi</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="5-4-4-cat-etc-passwd-查看创建了哪些用户"><a href="#5-4-4-cat-etc-passwd-查看创建了哪些用户" class="headerlink" title="5.4.4 cat /etc/passwd 查看创建了哪些用户"></a>5.4.4 cat /etc/passwd 查看创建了哪些用户</h5><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# cat &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="5-4-5-su-切换用户"><a href="#5-4-5-su-切换用户" class="headerlink" title="5.4.5 su 切换用户"></a>5.4.5 su 切换用户</h5><pre><code>su : switch user</code></pre><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su 用户名称  （功能描述：切换用户，只能获得用户的执行权限，不能获得环境变量）</span><br><span class="line">su - 用户名称  （功能描述：切换到用户并获得该用户的环境变量及执行权限）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）切换用户</span><br><span class="line">[root@hadoop101~]# su lisi</span><br><span class="line">[root@hadoop101~]# echo $PATH</span><br><span class="line">[root@hadoop101~]# su - lisi</span><br><span class="line">[root@hadoop101~]# echo $PATH</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="5-4-6-userdel-删除用户"><a href="#5-4-6-userdel-删除用户" class="headerlink" title="5.4.6 userdel 删除用户"></a>5.4.6 userdel 删除用户</h5><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）userdel 用户名  （功能描述：删除用户但保存主目录）</span><br><span class="line">（2）userdel -r 用户名 （功能描述：删除用户并且删除与用户相关的所有文件）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>删除用户的同时，删除和用户相关的所有文件</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）删除用户但保存其用户主目录</span><br><span class="line">[root@hadoop101~]# userdel lisi</span><br><span class="line">[root@hadoop101~]# ll &#x2F;home&#x2F;</span><br><span class="line">（2）删除用户和用户主目录，都删除</span><br><span class="line">[root@hadoop101~]# userdel -r atguigu</span><br><span class="line">[root@hadoop101~]# ll &#x2F;home&#x2F;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="5-4-7-who-查看登录用户信息"><a href="#5-4-7-who-查看登录用户信息" class="headerlink" title="5.4.7 who 查看登录用户信息"></a>5.4.7 who 查看登录用户信息</h5><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）whoami  （功能描述：显示自身用户名称）</span><br><span class="line">（2）who am i  （功能描述：显示登录用户的用户名）</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>案例实操</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# whoami</span><br><span class="line">[root@hadoop101~]# who am i</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="5-4-8-sudo-设置普通用户具有root权限"><a href="#5-4-8-sudo-设置普通用户具有root权限" class="headerlink" title="5.4.8 sudo 设置普通用户具有root权限"></a>5.4.8 sudo 设置普通用户具有root权限</h5><ol>
<li><p>添加atguigu用户，并对其设置密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# useradd atguigu</span><br><span class="line">[root@hadoop101~]# passwd atguigu</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>修改配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101~]# vim /etc/sudoers</span><br><span class="line">修改/etc/sudoers文件，找到下面一行（91行），在root下面添加一行，如下所示</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Allow root to run any commands anywhere</span></span></span><br><span class="line">root ALL=(ALL) ALL</span><br><span class="line">atguigu ALL=(ALL) ALL</span><br><span class="line">或者配置成采用sudo命令时，不需要输入密码</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Allow root to run any commands anywhere</span></span></span><br><span class="line">root      ALL=(ALL)     ALL</span><br><span class="line">atguigu   ALL=(ALL)     NOPASSWD:ALL</span><br><span class="line"></span><br><span class="line">修改完毕，现在可以用atguigu帐号登录，然后用命令 sudo ，即可获得root权限进行操作。</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）用普通用户在&#x2F;opt目录下创建一个文件夹</span><br><span class="line">[atguigu@hadoop101 opt]$ sudo mkdir module</span><br><span class="line">[root@hadoop101 opt]# chown atguigu:atguigu module&#x2F;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="5-4-9-usermod-修改用户"><a href="#5-4-9-usermod-修改用户" class="headerlink" title="5.4.9 usermod 修改用户"></a>5.4.9 usermod 修改用户</h5><ol>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod -g 用户组 用户名</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-g</td>
<td>修改用户的初始登录组，给定的组必须存在。默认组id是1</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<p>（1）将用户加入到用户组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop100 opt]# usermod -g root zhangsan</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="5-5-用户组管理命令"><a href="#5-5-用户组管理命令" class="headerlink" title="5.5 用户组管理命令"></a>5.5 用户组管理命令</h4>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux系统对用户组的规定有所不同。</span><br><span class="line">如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</span><br><span class="line">用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对&#x2F;etc&#x2F;group文件更新。</span><br></pre></td></tr></table></figure>

<h5 id="5-5-1-groupadd-新增组"><a href="#5-5-1-groupadd-新增组" class="headerlink" title="5.5.1 groupadd 新增组"></a>5.5.1 groupadd 新增组</h5><h5 id="5-5-2-groupdel-删除组"><a href="#5-5-2-groupdel-删除组" class="headerlink" title="5.5.2 groupdel 删除组"></a>5.5.2 groupdel 删除组</h5><h5 id="5-5-3-groupmod-修改组"><a href="#5-5-3-groupmod-修改组" class="headerlink" title="5.5.3 groupmod 修改组"></a>5.5.3 groupmod 修改组</h5><h4 id="5-6-文件权限类"><a href="#5-6-文件权限类" class="headerlink" title="5.6 文件权限类"></a>5.6 文件权限类</h4><h4 id="5-7-搜索查找类"><a href="#5-7-搜索查找类" class="headerlink" title="5.7 搜索查找类"></a>5.7 搜索查找类</h4><h4 id="5-8-压缩和解压类"><a href="#5-8-压缩和解压类" class="headerlink" title="5.8 压缩和解压类"></a>5.8 压缩和解压类</h4><h4 id="5-9-磁盘分区类"><a href="#5-9-磁盘分区类" class="headerlink" title="5.9 磁盘分区类"></a>5.9 磁盘分区类</h4><h4 id="5-10-进程线程类"><a href="#5-10-进程线程类" class="headerlink" title="5.10 进程线程类"></a>5.10 进程线程类</h4><h4 id="5-11-crontab-系统定时任务"><a href="#5-11-crontab-系统定时任务" class="headerlink" title="5.11 crontab 系统定时任务"></a>5.11 crontab 系统定时任务</h4><h3 id="6-软件包管理"><a href="#6-软件包管理" class="headerlink" title="6. 软件包管理"></a>6. 软件包管理</h3><h4 id="6-1-RPM"><a href="#6-1-RPM" class="headerlink" title="6.1 RPM"></a>6.1 RPM</h4><h5 id="6-1-1-RPM-概述"><a href="#6-1-1-RPM-概述" class="headerlink" title="6.1.1 RPM 概述"></a>6.1.1 RPM 概述</h5><p>   ​    RPM（RedHat Package Manager）,RedHat软件包管理工具，类似Windows里面的setup.exe是Linux这系列操作系统里面的打包安装工具，它虽然是RedHat的标志，但理念是通用的。</p>
<p>   ​    RPM包的名称格式</p>
<p>   ​    Apache-1.3.23-11.i386.rpm</p>
<pre><code>&quot;apache&quot;    软件名称</code></pre><p>   ​            “1.3.23-11”    软件的版本号，主版本和子版本</p>
<p>   ​            “i386”    是软件所运行的硬件平台，Intel32位微处理器的统称</p>
<p>   ​            “rpm”    文件扩展名，代表RPM包</p>
<p>   ​    </p>
<h5 id="6-1-2-RPM查询命令（rpm-qa）"><a href="#6-1-2-RPM查询命令（rpm-qa）" class="headerlink" title="6.1.2 RPM查询命令（rpm -qa）"></a>6.1.2 RPM查询命令（rpm -qa）</h5><ol>
<li><p>基本语法    （功能描述：查询所安装的所有rpm软件包）</p>
</li>
<li><p>经验技巧</p>
<p>由于软件包比较多，一般都会采取过滤。rpm -qa | grep rpm软件包</p>
</li>
<li><p>案例实操</p>
<p>（1）查询firefox软件安装情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 Packages]# rpm -qa | grep firefox</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="6-1-3-RPM卸载命令-rpm-e"><a href="#6-1-3-RPM卸载命令-rpm-e" class="headerlink" title="6.1.3 RPM卸载命令(rpm -e)"></a>6.1.3 RPM卸载命令(rpm -e)</h5><ol>
<li><p>基本语法</p>
<p>（1）rpm -e RPM软件包</p>
<p>（2）rpm -e –nodeps 软件包</p>
</li>
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-e</td>
<td>卸载软件包</td>
</tr>
<tr>
<td>–nodeps</td>
<td>卸载软件时，不检查依赖。这样的话，那样使用该软件包的软件在此之后可能就不能正常工作了</td>
</tr>
</tbody></table>
</li>
<li><p>案例实操</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop100 Packages]# rpm -e firefox</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="6-1-4RPM安装命令（rpm-ivh）"><a href="#6-1-4RPM安装命令（rpm-ivh）" class="headerlink" title="6.1.4RPM安装命令（rpm -ivh）"></a>6.1.4RPM安装命令（rpm -ivh）</h5><ol>
<li><p>基本语法</p>
<p>rpm -ivh RPM 包全名</p>
</li>
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-i</td>
<td>-i=install 安装</td>
</tr>
<tr>
<td>-v</td>
<td>-v=verbose显示详细信</td>
</tr>
<tr>
<td>-h</td>
<td>-h=hash进度条</td>
</tr>
<tr>
<td>–nodeps</td>
<td>–nodeps不检测依赖进度</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>案例实操</p>
<p>（1）安装Firefox软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop101 ~]# pwd</span><br><span class="line">[root@hadoop101 ~]# rpm -ivh firefox-45.0.1-1.el6.centos.x86_64.rpm</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="6-2-YUM仓库配置"><a href="#6-2-YUM仓库配置" class="headerlink" title="6.2 YUM仓库配置"></a>6.2 YUM仓库配置</h4><h5 id="6-2-1-YUM概述"><a href="#6-2-1-YUM概述" class="headerlink" title="6.2.1 YUM概述"></a>6.2.1 YUM概述</h5><p>   ​         YUM（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装  。类似Java中的maven工具。</p>
<h5 id="6-2-2-YUM的常用命令"><a href="#6-2-2-YUM的常用命令" class="headerlink" title="6.2.2 YUM的常用命令"></a>6.2.2 YUM的常用命令</h5><ol>
<li><p>基本语法</p>
<p>yum [选项] [参数]</p>
</li>
<li><p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-y</td>
<td>对所有提问都回答“yes”</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>参数说明</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>install</td>
<td>安装rpm软件包</td>
</tr>
<tr>
<td>update</td>
<td>更新rpm软件包</td>
</tr>
<tr>
<td>check-update</td>
<td>检查是否有可用的更新rpm软件包</td>
</tr>
<tr>
<td>remove</td>
<td>删除指定的rpm软件包</td>
</tr>
<tr>
<td>list</td>
<td>显示软件包信息</td>
</tr>
<tr>
<td>clean</td>
<td>清理yum过期的缓存</td>
</tr>
<tr>
<td>deplist</td>
<td>显示yum软件包的所有依赖关系</td>
</tr>
</tbody></table>
<h4 id="4-案例实操"><a href="#4-案例实操" class="headerlink" title="4. 案例实操"></a>4. 案例实操</h4><p>（1）采用yum方式安装Firefox</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hadoop100~]#yum -y install firefox.86_64</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="6-2-3-修改网络YUM源"><a href="#6-2-3-修改网络YUM源" class="headerlink" title="6.2.3 修改网络YUM源"></a>6.2.3 修改网络YUM源</h5><h3 id="7-克隆虚拟机"><a href="#7-克隆虚拟机" class="headerlink" title="7. 克隆虚拟机"></a>7. 克隆虚拟机</h3>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>maven介绍</title>
    <url>/2020/05/04/maven%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="1-什么是maven"><a href="#1-什么是maven" class="headerlink" title="1.什么是maven"></a>1.什么是maven</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maven是一款自动化构建工具，专注服务于Java平台的项目构建和依赖管理。</span><br><span class="line">构建：构建就是以我们编写的Java代码，框架配置文件，国际化等其它资源文件，jsp页面和图片等静态资源作为原材料，去生成出一个可以运行的项目的过程。</span><br><span class="line">构建的环节：</span><br><span class="line">1）clean：删除以前的编译结果，为重新编译做准备</span><br><span class="line">2）compile：将Java源程序编译为字节码文件</span><br><span class="line">3）test：针对项目中的关键点进行测试，确保项目在开发过程中关键部分的正确性</span><br><span class="line">4）report：在每一次测试后以标准的格式记录和展示测试结果</span><br><span class="line">5）package：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java工程对应Jar包，web工程对应war包</span><br><span class="line">5）install：在Maven环境下特指将打包的结果--jar包或war包安装到本地仓库中</span><br><span class="line">6）deploy：将打包的结果部署到远程仓库或将war包部署到服务器上运行</span><br></pre></td></tr></table></figure>



<h3 id="2-为什么要用maven"><a href="#2-为什么要用maven" class="headerlink" title="2.为什么要用maven"></a>2.为什么要用maven</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）使用maven后每个jar包只在本地仓库中保存一份，需要jar包的工程只需要维持一个jar包的坐标引用，不用像传统方式那样每个项目中都需要导入jar包</span><br><span class="line">2）maven会自动导入我们所需jar包的依赖jar包，自动管理jar包间的依赖关系</span><br><span class="line">3）会自动处理jar包间的冲突，解决冲突的依赖原则：1.最短路径优先 2.路径相同则先生命者优先</span><br><span class="line">4）可实现项目的分布式部署</span><br></pre></td></tr></table></figure>



<h3 id="3-maven的安装"><a href="#3-maven的安装" class="headerlink" title="3.maven的安装"></a>3.maven的安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）maven是使用Java开发的，首先检查是否配置JAVA_HOME环境变量</span><br><span class="line">2）解压maven的核心程序，如将apache-maven-3.5.4-bin.zip解压到非中文无空格的目录下</span><br><span class="line">3）配置环境变量，MAVEN_HOME和path</span><br><span class="line">4）使用mvn -v 命令检查安装是否正确</span><br></pre></td></tr></table></figure>

<h3 id="4-maven工程的目录结构-Hello项目为例"><a href="#4-maven工程的目录结构-Hello项目为例" class="headerlink" title="4. maven工程的目录结构(Hello项目为例)"></a>4. maven工程的目录结构(Hello项目为例)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line">	src</span><br><span class="line">	--main</span><br><span class="line">	----java</span><br><span class="line">	----resouces</span><br><span class="line">	--test</span><br><span class="line">	----java</span><br><span class="line">	----resources</span><br><span class="line">	pom.xml</span><br></pre></td></tr></table></figure>

<h3 id="5-配置本地仓库"><a href="#5-配置本地仓库" class="headerlink" title="5.配置本地仓库"></a>5.配置本地仓库</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">	maven的核心程序并不包含具体功能，仅负责宏观调度。具体功能由插件来完成。maven核心程序会到本地仓库中查找插件。如果本地仓库中没有就会从远程中央仓库下载。此时如果不能上网则无法执行maven的具体功能。为了解决这个问题，我们可以将maven的本地仓库指向一个在联网情况下下载好的目录。</span><br><span class="line">	maven默认的本地仓库：~\.m2\repository目录，~表示当前用户的家目录</span><br><span class="line">	<span class="number">1</span>.设置本地仓库：找到maven的核心配置文件conf目录下的settings.xml文件，配置本地仓库的位置</span><br><span class="line">&lt;localRepository&gt;准备好的仓库位置，如E:\localRepo&lt;/localRepositroy&gt;</span><br><span class="line">	<span class="number">2</span>.默认的中央仓库在国外，为了以后下载jar包方便，配置阿里云镜像</span><br><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line">    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">    &lt;name&gt;Nexus aliyun&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http:<span class="comment">//maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span></span><br><span class="line">&lt;/mirror&gt;</span><br><span class="line">	<span class="number">3</span>.修改maven编译的版本</span><br><span class="line">&lt;profile&gt;</span><br><span class="line">  &lt;id&gt;jdk-1.8&lt;/id&gt;</span><br><span class="line">  &lt;activation&gt;</span><br><span class="line">	&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">	&lt;jdk&gt;1.8&lt;/jdk&gt;</span><br><span class="line">  &lt;/activation&gt;</span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">	  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">	  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">	  &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line">&lt;/profile&gt;</span><br></pre></td></tr></table></figure>





<h3 id="5-在idea中使用maven"><a href="#5-在idea中使用maven" class="headerlink" title="5.在idea中使用maven"></a>5.在idea中使用maven</h3><h3 id="6-maven的核心概念"><a href="#6-maven的核心概念" class="headerlink" title="6.maven的核心概念"></a>6.maven的核心概念</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）pom</span><br><span class="line">	Project Object Model：项目对象模型。将Java工程的相关信息封装为对象作为便于操作和管理的模型</span><br><span class="line"><span class="number">2</span>）约定的目录结构</span><br><span class="line">	约定&gt;配置&gt;编码。意思就是能用配置解决的问题就不编码，能基于约定的就不进行配置。而maven正是因为指定了文件保存的目录才能对我们的Java工程进行自动化构建</span><br><span class="line"><span class="number">3</span>）坐标</span><br><span class="line">	使用以下<span class="number">3</span>个变量在Maven的仓库中唯一确定一个maven工程</span><br><span class="line">	groupId: 公司或组织的域名倒序+项目名称</span><br><span class="line">	artifactId: 当前项目的模块名称</span><br><span class="line">	version: 当前模块的版本</span><br><span class="line">	如：</span><br><span class="line">	&lt;groupId&gt;com.atguigui.maven&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;Hello&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.1.0SNAPSHOT&lt;/version&gt;</span><br><span class="line">	如何通过坐标到仓库中查找jar包？</span><br><span class="line">	首先将gav三个变量连接起来 com.atgugui.maven + Hello + <span class="number">1.1</span><span class="number">.0</span>SNAPSHOT，然后以连接字来的字符串作为目录结构到仓库中查找com/atguigu/maven/Hello-<span class="number">1.1</span><span class="number">.1</span>SNAPSHOT.jar。需要注意的是我们自己的maven工程必须执行安装操作才会进入仓库,安装命令是mvn install。</span><br><span class="line"><span class="number">4</span>）依赖</span><br><span class="line">	依赖的范围：compile,test,provided,其它的如runtime,<span class="keyword">import</span>,system等，主要是前面<span class="number">3</span>个比较常用</span><br><span class="line">compile: main目录下的家java代码可以访问这个范围的依赖;test目录下的Java代码可以访问这个范围的依赖；由于主程序需要用到这个依赖，所以需要将这个依赖部署到Tomcat服务器上运行时的WEB-INF的lib目录下	 	d</span><br><span class="line">test: main目录下的Java代码不能访问这个范围的依赖；test目录下的Java代码可以访问这个范围的依赖；因为这个依赖仅仅是用于测试，所以不需要部署到Tomcat服务器上的WEB-INF的lib目录下</span><br><span class="line">provided: main目录下的代码可以访问这个范围的依赖；test目录下的Java代码可以访问这个范围的依赖；部署到tomcat服务器上运行时不会放在WEB-INF的lib目录下，因为服务器上会提供</span><br><span class="line">	依赖的传递性：compile依赖范围的jar包是具有依赖的传递性的</span><br><span class="line">	依赖的排除：有的时候为了确保程序正确可以将可能重复的间接依赖排除，示例代码如下</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;OurFriends&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--依赖排除--&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">	依赖jar包版本的统一管理：示例代码如下</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;spring.version&gt;4.0.0.RELEASE&lt;/spring.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"><span class="number">5</span>）仓库</span><br><span class="line">    本地仓库：为当前本机电脑上的所有maven工程服务</span><br><span class="line">    远程仓库：<span class="number">1</span>.私服：架设在当前局域网环境下，为当前局域网范围内的所有maven工程服务 <span class="number">2</span>.中央仓库：架设在Internet上，为全世界所有maven工程服务 <span class="number">3</span>.中央仓库的镜像：架设在各大洲，为中央仓库分担流量。减轻中央仓库的压力，同时更快响应用户的请求。</span><br><span class="line">    仓库中包含以下文件：maven的插件；我们自己开发的项目模块；第三方框架或工具的jar包</span><br><span class="line"><span class="number">6</span>）生命周期</span><br><span class="line">    maven的生命周期定义了各个构建环节的执行顺序，有了这个清单，maven就可以自动化的构建命令了。</span><br><span class="line">    maven有三套相互独立的生命周期，分别是：</span><br><span class="line">    Clean Lifecycle 在进行真正的构建之前进行一些清理工作</span><br><span class="line">    Default Lifecycle 构建的核心部分：编译，测试，打包，安装，部署等待</span><br><span class="line">    Site Lifecycle 生成项目报告，站点，发布站点</span><br><span class="line">    它们是相互独立的，可以仅仅调用clean来清理工作目录，仅仅调用site来生成站点，当然也可以直接运行mvn clean install site运行所有这三套生命周期。</span><br><span class="line">    </span><br><span class="line">clean生命周期</span><br><span class="line">Clean生命周期一共包含了三个阶段：</span><br><span class="line">	pre-clean 执行一些需要在clean之前完成的工作 </span><br><span class="line">clean 移除所有上一次构建生成的文件 </span><br><span class="line">	post-clean 执行一些需要在clean之后立刻完成的工作 </span><br><span class="line">    </span><br><span class="line">Site生命周期</span><br><span class="line">	pre-site 执行一些需要在生成站点文档之前完成的工作</span><br><span class="line">	site 生成项目的站点文档</span><br><span class="line">	post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</span><br><span class="line">	site-deploy 将生成的站点文档部署到特定的服务器上</span><br><span class="line">这里经常用到的是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能，Manager比较喜欢，文档及统计数据自动生成，很好看。</span><br><span class="line"></span><br><span class="line">Default生命周期</span><br><span class="line">Default生命周期是Maven生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段：</span><br><span class="line">    validate</span><br><span class="line">    generate-sources</span><br><span class="line">    process-sources</span><br><span class="line">    generate-resources</span><br><span class="line">    process-resources 复制并处理资源文件，至目标目录，准备打包。</span><br><span class="line">compile 编译项目的源代码。</span><br><span class="line">    process-classes</span><br><span class="line">    generate-test-sources</span><br><span class="line">    process-test-sources</span><br><span class="line">    generate-test-resources</span><br><span class="line">    process-test-resources 复制并处理资源文件，至目标测试目录。</span><br><span class="line">    </span><br><span class="line">test-compile 编译测试源代码。</span><br><span class="line">	process-test-classes</span><br><span class="line">test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。</span><br><span class="line">	prepare-<span class="keyword">package</span></span><br><span class="line"><span class="keyword">package</span> 接受编译好的代码，打包成可发布的格式，如JAR。</span><br><span class="line">    pre-integration-test</span><br><span class="line">    integration-test</span><br><span class="line">    post-integration-test</span><br><span class="line">    verify</span><br><span class="line">install将包安装至本地仓库，以让其它项目依赖。</span><br><span class="line">deploy将最终的包复制到远程的仓库，以让其它开发人员与项目共享或部署到服务器上运行。</span><br><span class="line"><span class="number">7</span>）插件和目标</span><br><span class="line">	Maven的核心仅仅定义了抽象的生命周期，具体的任务都是交由插件完成的。每个插件都能实现多个功能，每个功能就是一个插件目标。Maven的生命周期与插件目标相互绑定，以完成某个具体的构建任务。</span><br><span class="line">	例如：compile就是插件maven-compiler-plugin的一个功能；pre-clean是插件maven-clean-plugin的一个目标。</span><br><span class="line"><span class="number">8</span>）继承</span><br><span class="line">    由于非compile范围的依赖信息是不能在“依赖链”中传递的，所以有需要的工程只能单独配置。假设此时如果项目需要将各个模块的junit版本统一为<span class="number">4.9</span>，那么到各个工程中手动修改无疑是非常不可取的。使用继承机制就可以将这样的依赖信息统一提取到父工程模块中进行统一管理。</span><br><span class="line">首先，创建父工程</span><br><span class="line">    &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;Parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;!--父工程的打包方式为pom  ,只用于配置的管理,不写任何代码--&gt;</span><br><span class="line">	&lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">	&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">然后，在子工程中引用父工程</span><br><span class="line">  	&lt;!--继承--&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;Parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;!--指定从当前pom.xml文件出发寻找父工程的pom.xml文件的相对路径--&gt;</span><br><span class="line">	&lt;relativePath&gt;../Parent/pom.xml&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt; </span><br><span class="line">此时如果子工程的groupId和version如果和父工程重复则可以删除。</span><br><span class="line">    </span><br><span class="line">在父工程中管理依赖（将Parent项目中的dependencies标签，用dependencyManagement标签括起来）</span><br><span class="line"> &lt;!--依赖管理--&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.0&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;   </span><br><span class="line">在子项目中重新指定需要的依赖，删除范围和版本号</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">    </span><br><span class="line">也可以父模块直接定义依赖，子类直接继承即可，如父类中有以下依赖</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.0&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">子模块直接继承即可</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;Parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;!--指定从当前pom.xml文件出发寻找父工程的pom.xml文件的相对路径--&gt;</span><br><span class="line">&lt;relativePath&gt;../Parent/pom.xml&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt;    </span><br><span class="line"><span class="number">9</span>）聚合</span><br><span class="line">   为什么要使用聚合？</span><br><span class="line">将多个工程拆分为模块后，需要手动逐个安装到仓库后依赖才能够生效。修改源码后也需要逐个手动进行clean操作。而使用了聚合之后就可以批量进行Maven工程的安装、清理工作。</span><br><span class="line">    如何配置聚合？</span><br><span class="line">在总的聚合工程中使用modules/<span class="keyword">module</span>标签组合，指定模块工程的相对路径即可</span><br><span class="line">&lt;!--聚合--&gt;</span><br><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;../MakeFriend&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;../OurFriends&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;../HelloFriend&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;../Hello&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure>

<h3 id="7-maven打包插件"><a href="#7-maven打包插件" class="headerlink" title="7. maven打包插件"></a>7. maven打包插件</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">	Maven本身的打包插件不负责将依赖的jar包一并打包到jar包中，如果项目所依赖的jar包在服务器中没有提供，则运行就会ClassNotFound的各种错，因此需要一款能够将项目所依赖的jar包一并导入到jar中的插件来解决这个问题。</span><br><span class="line">	</span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;descriptorRefs&gt;</span><br><span class="line">                    &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;</span><br><span class="line">                &lt;/descriptorRefs&gt;</span><br><span class="line">              &lt;archive&gt;</span><br><span class="line">                    &lt;manifest&gt;</span><br><span class="line">                     &lt;!-- 指定主类 --&gt;</span><br><span class="line">                        &lt;mainClass&gt;xxx.xxx.XXX&lt;/mainClass&gt;</span><br><span class="line">                    &lt;/manifest&gt;</span><br><span class="line">                &lt;/archive&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;make-assembly&lt;/id&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;single&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<h3 id="8-maven常用网站"><a href="#8-maven常用网站" class="headerlink" title="8.maven常用网站"></a>8.maven常用网站</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们可以到http:&#x2F;&#x2F;mvnrepository.com&#x2F;搜索需要的jar包的依赖信息。</span><br><span class="line">http:&#x2F;&#x2F;search.maven.org&#x2F;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>数据库连接池</title>
    <url>/2020/05/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<h3 id="JDBC-数据库连接池的必要性"><a href="#JDBC-数据库连接池的必要性" class="headerlink" title="JDBC 数据库连接池的必要性"></a>JDBC 数据库连接池的必要性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：　　</span><br><span class="line">1.在主程序（如servlet、beans）中建立数据库连接</span><br><span class="line">2.进行sql操作</span><br><span class="line">3.断开数据库连接</span><br><span class="line">这种模式开发，存在的问题:</span><br><span class="line">普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用.若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</span><br><span class="line">对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。</span><br><span class="line">这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 </span><br><span class="line">    </span><br><span class="line">数据库连接池 </span><br><span class="line">为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</span><br><span class="line">数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</span><br><span class="line">数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。</span><br><span class="line">数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</span><br></pre></td></tr></table></figure>

<h3 id="数据库连接池的优点"><a href="#数据库连接池的优点" class="headerlink" title="数据库连接池的优点"></a>数据库连接池的优点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.资源重用</span><br><span class="line">由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</span><br><span class="line">2.更快的系统反应速度</span><br><span class="line">数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</span><br><span class="line">3.新的资源分配手段</span><br><span class="line">对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</span><br><span class="line">4.统一的连接管理</span><br><span class="line">在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</span><br></pre></td></tr></table></figure>

<h3 id="常见的几种数据库连接池"><a href="#常见的几种数据库连接池" class="headerlink" title="常见的几种数据库连接池"></a>常见的几种数据库连接池</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.DBCP</span><br><span class="line">2.C3P0</span><br><span class="line">3.druid</span><br></pre></td></tr></table></figure>



<h3 id="druid数据库连接池使用示例"><a href="#druid数据库连接池使用示例" class="headerlink" title="druid数据库连接池使用示例"></a>druid数据库连接池使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*首先需要在项目中引入druid相关的jar包（如druid-1.1.9.jar）</span></span><br><span class="line"><span class="comment">示例代码*/</span></span><br><span class="line"><span class="comment">//1.未用配置文件</span></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">"jdbc:mysql://localhost:3306/jdbc"</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        DruidPooledConnection connection = dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用配置文件</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        InputStream inputStream = getClass().getClassLoader().getResourceAsStream(<span class="string">"druid.properties"</span>);</span><br><span class="line">        properties.load(inputStream);</span><br><span class="line">        DataSource datasource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        Connection connection = datasource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//配置文件主要配置如下</span></span><br><span class="line">driverClassName = com.mysql.jdbc.Driver</span><br><span class="line">url = jdbc:mysql:<span class="comment">//localhost:3306/jdbc</span></span><br><span class="line">username = root</span><br><span class="line">password = <span class="number">123456</span></span><br><span class="line">initialSize = <span class="number">3</span></span><br><span class="line">maxActive = <span class="number">50</span></span><br><span class="line">minIdle = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h1 id="DBUtils工具类"><a href="#DBUtils工具类" class="headerlink" title="DBUtils工具类"></a><code>DBUtils</code>工具类</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将常用的操作数据库的JDBC的类和方法集合在一起，就是DBUtils</span><br><span class="line">首先要先将相关的jar关联到项目中（如commons-dbutils-1.3.jar）</span><br></pre></td></tr></table></figure>

<h3 id="DBUtils使用示例代码"><a href="#DBUtils使用示例代码" class="headerlink" title="DBUtils使用示例代码"></a>DBUtils使用示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ResultSetHandler 作用是处理结果集数据.</span></span><br><span class="line"><span class="comment"> *      BeanListHandler 把结果集全部对象化, 前提 : 必须要有javabean类和表一一对应</span></span><br><span class="line"><span class="comment"> *      BeanHandler 把结果集中的第一条记录对象化, 前提 : 必须要有javabean类和表一一对应</span></span><br><span class="line"><span class="comment"> *      ArrayHandler 把结果集的第一条记录的所有数据取到一个Object[]中</span></span><br><span class="line"><span class="comment"> *      ScalarHandler 把结果集中的第一条记录的第一列的值取出来.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBUtilsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        String sql = <span class="string">"select * from student"</span>;</span><br><span class="line">        BeanListHandler&lt;Student&gt; beanListHandler = <span class="keyword">new</span> BeanListHandler&lt;Student&gt;(Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            List&lt;Student&gt; list = queryRunner.query(connection, sql, beanListHandler);</span><br><span class="line">            list.forEach(System.out::println);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            String sql = <span class="string">"select count(*) from teacher where id &gt; ?"</span>;</span><br><span class="line">            <span class="comment">// query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params)</span></span><br><span class="line">            <span class="comment">// ScalarHandler最简单, 取第一行第一列</span></span><br><span class="line">            ScalarHandler scalarHandler = <span class="keyword">new</span> ScalarHandler(); <span class="comment">// 标量</span></span><br><span class="line">            Object objcet = queryRunner.query(connection, sql, scalarHandler, <span class="number">0</span>);</span><br><span class="line">            System.out.println(objcet);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            String sql = <span class="string">"select name, id , age, salary, phone from teacher where id &gt; ?"</span>;</span><br><span class="line">            <span class="comment">// query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params)</span></span><br><span class="line">            <span class="comment">// ScalarHandler最简单, 取第一行第一列</span></span><br><span class="line">            ScalarHandler scalarHandler = <span class="keyword">new</span> ScalarHandler(); <span class="comment">// 标量</span></span><br><span class="line">            Object objcet = queryRunner.query(connection, sql, scalarHandler, <span class="number">0</span>);</span><br><span class="line">            System.out.println(objcet);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            String sql = <span class="string">"select id, name, age, salary, phone from teacher where id &gt; ?"</span>;</span><br><span class="line">            <span class="comment">// query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params)</span></span><br><span class="line">            <span class="comment">// ArrayHandler把结果集中的第一条记录的所有数据保存在一个Object[]中.</span></span><br><span class="line">            ArrayListHandler arrayListHandler = <span class="keyword">new</span> ArrayListHandler();</span><br><span class="line">            List&lt;Object[]&gt; list = queryRunner.query(connection, sql, arrayListHandler, <span class="number">0</span>);</span><br><span class="line">            Iterator&lt;Object[]&gt; iterator = list.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                Object[] array = iterator.next();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                    System.out.print(array[i] + <span class="string">"\t"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            String sql = <span class="string">"select id, name, age, salary, phone from teacher where id &gt; ?"</span>;</span><br><span class="line">            <span class="comment">// query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params)</span></span><br><span class="line">            <span class="comment">// ArrayHandler把结果集中的第一条记录的所有数据保存在一个Object[]中.</span></span><br><span class="line">            ArrayHandler arrayHandler = <span class="keyword">new</span> ArrayHandler();</span><br><span class="line">            Object[] array = queryRunner.query(connection, sql, arrayHandler, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                System.out.print(array[i] + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            String sql = <span class="string">"select * from teacher where id &gt; ?"</span>;</span><br><span class="line">            <span class="comment">// query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params)</span></span><br><span class="line">            <span class="comment">// BeanListHandler结果集处理器把结果集中的所有记录全部转换为javabean对象, 并保存在一个List集合中</span></span><br><span class="line">            BeanListHandler&lt;Teacher&gt; beanListHandler = <span class="keyword">new</span> BeanListHandler&lt;&gt;(Teacher<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            List&lt;Teacher&gt; list = queryRunner.query(connection, sql, beanListHandler, <span class="number">0</span>);</span><br><span class="line">            list.forEach(System.out::println);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            String sql = <span class="string">"select * from teacher"</span>;</span><br><span class="line">            <span class="comment">// query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params)</span></span><br><span class="line">            <span class="comment">// 把结果集中的第一条记录转换成实体的javabean对象, 对象的类型由构造器指定</span></span><br><span class="line">            BeanHandler&lt;Teacher&gt; beanHandler = <span class="keyword">new</span> BeanHandler&lt;&gt;(Teacher<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">// 需要类模板对象</span></span><br><span class="line">            Teacher t = queryRunner.query(connection, sql, beanHandler);</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            String sql = <span class="string">"select id, name, age, gender, phone from customer where id &gt; ?"</span>;</span><br><span class="line">            <span class="comment">// query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params)</span></span><br><span class="line">            <span class="comment">// BeanHandler处理器作用是把结果集中的第一条记录转换成实体的javabean对象, 对象的类型由构造器指定</span></span><br><span class="line">            BeanHandler&lt;Customer&gt; beanHandler = <span class="keyword">new</span> BeanHandler&lt;&gt;(Customer<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">// 需要类模板对象</span></span><br><span class="line">            Customer customer = queryRunner.query(connection, sql, beanHandler, <span class="number">1</span>);</span><br><span class="line">            System.out.println(customer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        <span class="comment">//update(Connection conn, String sql, Object... params)</span></span><br><span class="line">        Connection connection = JdbcUtil.getConnection();</span><br><span class="line">        <span class="keyword">int</span> n = queryRunner.update(connection, <span class="string">"delete from user where name = ?"</span>, <span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(n + <span class="string">" rows"</span>);</span><br><span class="line">        JdbcUtil.close(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>数据库事务</title>
    <url>/2020/05/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</span><br><span class="line">事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)到最初状态。</span><br><span class="line">为确保数据库中数据的一致性,数据的操纵应当是离散的成组的逻辑单元:当它全部完成时,数据的一致性可以保持,而当这个单元中的一部分操作失败,整个事务应全部视为错误,所有从起始点以后的操作应全部回退到开始状态。</span><br></pre></td></tr></table></figure>

<h3 id="事务的四个基本特性"><a href="#事务的四个基本特性" class="headerlink" title="事务的四个基本特性"></a>事务的四个基本特性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">事务的ACID(acid)属性    </span><br><span class="line">1. 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </span><br><span class="line">2. 一致性（Consistency）事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</span><br><span class="line">3. 隔离性（Isolation）事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</span><br><span class="line">4. 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响</span><br></pre></td></tr></table></figure>

<h3 id="JDBC-事务处理"><a href="#JDBC-事务处理" class="headerlink" title="JDBC 事务处理"></a>JDBC 事务处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚</span><br><span class="line">为了让多个 SQL 语句作为一个事务执行：</span><br><span class="line">1.调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务</span><br><span class="line">2.在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务</span><br><span class="line">3.在出现异常时，调用 rollback(); 方法回滚事务</span><br><span class="line">4.若此时 Connection 没有被关闭, 则需要恢复其自动提交状态</span><br></pre></td></tr></table></figure>

<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.设置自动提交为false</span></span><br><span class="line">        <span class="comment">//2.多个DML形成一个整体的事务</span></span><br><span class="line">        <span class="comment">//3.结束事务（</span></span><br><span class="line">        <span class="comment">//     3.1提交事务</span></span><br><span class="line">        <span class="comment">//      3.2回滚事务</span></span><br><span class="line">        <span class="comment">// 4.还原设置</span></span><br><span class="line">        <span class="comment">// ）</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            <span class="comment">//1.设置自动提交为false</span></span><br><span class="line">            connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//2.多个DML形成事务</span></span><br><span class="line"></span><br><span class="line">            CommonUtils.update(connection,<span class="string">"delete from country"</span>);</span><br><span class="line">            <span class="comment">//CommonUtils.update(connection,"delete from student");</span></span><br><span class="line">            <span class="comment">//3.提交事务</span></span><br><span class="line">            connection.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.rollback();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//4.还原事务设置</span></span><br><span class="line">                connection.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>jdbc</title>
    <url>/2020/04/29/jdbc/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统，通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库（java.sql）,使用这个类库可以用一种标准的方法，方便的访问数据库资源，JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。</span><br></pre></td></tr></table></figure>

<p>连接图如下：</p>
<h3 id="JDBC-体系结构"><a href="#JDBC-体系结构" class="headerlink" title="JDBC 体系结构"></a>JDBC 体系结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JDBC接口（API）包括两个层次：</span><br><span class="line">面向应用的API: Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）</span><br><span class="line">面向数据库的API: Java Driver API，供开发商开发数据库驱动程序使用</span><br><span class="line"></span><br><span class="line">JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。不同的数据库厂商，需要针对这套接口，提供不同的实现。不同的实现的集合，即为不同数据库的驱动。--面向接口编程</span><br></pre></td></tr></table></figure>

<h3 id="Driver-接口"><a href="#Driver-接口" class="headerlink" title="Driver 接口"></a>Driver 接口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.sql.Driver接口是所有JDBC驱动程序需要实现的接口，这个接口是提供给数据库厂商使用的，不同的数据库厂商提供不同的实现。</span><br><span class="line">在程序中不需要直接去访问实现了Driver接口的类，而是由驱动程序管理类（java.sql.DriverManager）去调用这些Driver实现。</span><br><span class="line"></span><br><span class="line">Driver实现</span><br><span class="line">-Oracle的驱动：oracle.jdbc.driver.Oracle.OracleDriver</span><br><span class="line">-mySql驱动：com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">比如使用mysql时，需要mysql的驱动程序jar包（比如：mysql-connector-java-5.1.7-bin.jar）导入到项目中</span><br></pre></td></tr></table></figure>

<h3 id="操纵数据库的步骤"><a href="#操纵数据库的步骤" class="headerlink" title="操纵数据库的步骤"></a>操纵数据库的步骤</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.加载与注册JDBC驱动  </span><br><span class="line">方式一：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</span><br><span class="line">Class.forName(“com.mysql.jdbc.Driver”);</span><br><span class="line">方式二：DriverManager 类是驱动程序管理器类，负责管理驱动程序</span><br><span class="line">DriverManager.registerDriver(com.mysql.jdbc.Driver);</span><br><span class="line">通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例</span><br><span class="line">   </span><br><span class="line"><span class="number">2</span>.建立连接</span><br><span class="line">可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</span><br><span class="line">User,password可以用“属性名=属性值”方式告诉数据库；</span><br><span class="line">JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</span><br><span class="line">JDBC URL的标准由三部分组成，各部分间用冒号分隔。 </span><br><span class="line">jdbc:子协议:子名称</span><br><span class="line">协议：JDBC URL中的协议总是jdbc </span><br><span class="line">子协议：子协议用于标识一个数据库驱动程序</span><br><span class="line">子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名</span><br><span class="line"></span><br><span class="line">协议：子协议：自名称</span><br><span class="line">jdbc:mysql:<span class="comment">//localhost:3306/test</span></span><br><span class="line"></span><br><span class="line">对于 Oracle 数据库连接，采用如下形式： </span><br><span class="line">jdbc:oracle:thin:<span class="meta">@localhost</span>:<span class="number">1521</span>:test</span><br><span class="line">对于 SQLServer 数据库连接，采用如下形式：</span><br><span class="line">jdbc:microsoft:sqlserver<span class="comment">//localhost:1433; DatabaseName=sid</span></span><br><span class="line">对于 MYSQL 数据库连接，采用如下形式：   </span><br><span class="line">jdbc:mysql:<span class="comment">//localhost:3306/test</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.通过连接获取sql执行体对象</span><br><span class="line">  <span class="number">1</span>）statement，效率相对比较低，而且由sql注入问题</span><br><span class="line">一旦获取了连接对象Connection, 还不可以执行SQL, 必须要从Connection连接对象获取执行体对象Statement才能执行SQL</span><br><span class="line">Connection connection = getConnection();</span><br><span class="line">Statement state = connection.createStatement();</span><br><span class="line"><span class="keyword">int</span> n = state.executeUpdate(“insert,update,delete…”);</span><br><span class="line">其中n是执行增删改后对表产生的影响的记录数</span><br><span class="line">如果执行一个查询则返回一个ResultSet结果集对象.</span><br><span class="line">  <span class="number">2</span>）PreparedStatement 预处理执行体对象，效率高</span><br><span class="line">可以通过调用 Connection 对象的 preparedStatement() 方法获取 PreparedStatement 对象</span><br><span class="line">PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</span><br><span class="line">PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 <span class="number">1</span> 开始)，第二个是设置的 SQL 语句中的参数的值</span><br><span class="line">    </span><br><span class="line">PreparedStatement vs Statement</span><br><span class="line">代码的可读性和可维护性. </span><br><span class="line">PreparedStatement 能最大可能提高性能：</span><br><span class="line">DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</span><br><span class="line">在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存.这样每执行一次都要对传入的语句编译一次.  </span><br><span class="line">(语法检查，语义检查，翻译成二进制命令，缓存)</span><br><span class="line">PreparedStatement 可以防止 SQL 注入 </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="number">4</span>.执行sql语句</span><br><span class="line">    </span><br><span class="line"><span class="number">5</span>.处理执行结果（ResltSet）</span><br><span class="line">ResultSet的说明：</span><br><span class="line"><span class="number">1</span>）查询需要调用 Statement 的 executeQuery(sql) 方法，查询结果是一个 ResultSet 对象</span><br><span class="line"><span class="number">2</span>）关于 ResultSet：代表结果集</span><br><span class="line">ResultSet: 结果集. 封装了使用 JDBC 进行查询的结果. </span><br><span class="line">调用 Statement 对象的 executeQuery(sql) 可以得到结果集.</span><br><span class="line">ResultSet 返回的实际上就是一张数据表. 有一个指针指向数据表的第一条记录的前面.</span><br><span class="line"><span class="number">3</span>）可以调用 next() 方法检测下一行是否有效. 若有效该方法返回 <span class="keyword">true</span>, 且指针下移. 相当于Iterator 对象的 hasNext() 和 next() 方法的结合体</span><br><span class="line"><span class="number">4</span>）当指针指向一行时, 可以通过调用 getXxx(<span class="keyword">int</span> index) 或 getXxx(<span class="keyword">int</span> columnName) 获取每一列的值. </span><br><span class="line">例如: getInt(<span class="number">1</span>), getString(<span class="string">"name"</span>)</span><br><span class="line"><span class="number">5</span>）ResultSet 当然也需要进行关闭</span><br><span class="line">   </span><br><span class="line">ResultSetMetaData的说明：</span><br><span class="line">可用于获取关于 ResultSet 对象中列的类型和属性信息的对象</span><br><span class="line">ResultSetMetaData meta = rs.getMetaData();</span><br><span class="line"><span class="number">1</span>）getColumnName(<span class="keyword">int</span> column)：获取指定列的名称</span><br><span class="line"><span class="number">2</span>）getColumnLabel(<span class="keyword">int</span> column)：获取指定列的别名</span><br><span class="line"><span class="number">3</span>）getColumnCount()：返回当前 ResultSet 对象中的列数。 </span><br><span class="line"><span class="number">4</span>）getColumnTypeName(<span class="keyword">int</span> column)：检索指定列的数据库特定的类型名称。 </span><br><span class="line"><span class="number">5</span>）getColumnDisplaySize(<span class="keyword">int</span> column)：指示指定列的最大标准宽度，以字符为单位。 </span><br><span class="line"><span class="number">6</span>）isNullable(<span class="keyword">int</span> column)：指示指定列中的值是否可以为 <span class="keyword">null</span>。 </span><br><span class="line"><span class="number">7</span>）isAutoIncrement(<span class="keyword">int</span> column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>.释放资源（close()）</span><br></pre></td></tr></table></figure>

<h3 id="JDBC-API小结"><a href="#JDBC-API小结" class="headerlink" title="JDBC API小结"></a>JDBC API小结</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.sql.DriverManager用来装载驱动程序，获取数据库连接。</span><br><span class="line">java.sql.Connection完成对某一指定数据库的连接</span><br><span class="line">java.sql.Statement在一个给定的连接中作为SQL执行声明的容器，他包含了两个重要的子类型。</span><br><span class="line">Java.sql.PreparedSatement 用于执行预编译的sql声明</span><br><span class="line">Java.sql.CallableStatement用于执行数据库中存储过程的调用</span><br><span class="line">java.sql.ResultSet对于给定声明取得结果的途径</span><br></pre></td></tr></table></figure>

<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement statement = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();<span class="comment">//通过封装的工具类获取连接对象</span></span><br><span class="line">            String sql = <span class="string">"select id,name,age,gender from student where id &gt; ? "</span>;</span><br><span class="line">            statement = connection.prepareStatement(sql);</span><br><span class="line">            statement.setObject(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            resultSet = statement.executeQuery();</span><br><span class="line">            <span class="comment">//想要进一步获取表结构信息，需要用ResultSetMetaData</span></span><br><span class="line">            ResultSetMetaData metaData = resultSet.getMetaData();</span><br><span class="line">            <span class="comment">//获取列标签</span></span><br><span class="line">            <span class="keyword">int</span> columnCount = metaData.getColumnCount();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line">                String columnLabel = metaData.getColumnLabel(i+<span class="number">1</span>);</span><br><span class="line">                System.out.print(columnLabel + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line">                    String columnLabel = metaData.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                    Object value = resultSet.getObject(columnLabel);</span><br><span class="line">                    System.out.print(value + <span class="string">"\t"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(connection,statement,resultSet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement statement = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            String sql = <span class="string">"select id,name ame,age,gender from student where id &gt; ? "</span>;</span><br><span class="line">            statement = connection.prepareStatement(sql);</span><br><span class="line">            statement.setObject(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//第一个？号赋值为0</span></span><br><span class="line">            resultSet = statement.executeQuery();</span><br><span class="line">            <span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line">                <span class="keyword">int</span> id = resultSet.getInt(<span class="string">"id"</span>);</span><br><span class="line">                String name = resultSet.getString(<span class="string">"name"</span>);<span class="comment">//列标签表示的是虚表中的列名</span></span><br><span class="line">                <span class="keyword">int</span> age = resultSet.getInt(<span class="string">"age"</span>);</span><br><span class="line">                String gender = resultSet.getString(<span class="string">"gender"</span>);</span><br><span class="line">                Student student = <span class="keyword">new</span> Student(id,name,age,gender);</span><br><span class="line">                list.add(student);</span><br><span class="line">                <span class="comment">//System.out.println(student);</span></span><br><span class="line">                <span class="comment">//System.out.println("id: " + id + "\tname: " + name + "\tage: " + age + "\tgender: " + gender);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtil.close(connection,statement,resultSet);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//list.stream().forEach((s) -&gt; System.out.println(s));</span></span><br><span class="line">        list.stream().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//工具类中主要的获取连接的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        InputStream inputStream = JdbcUtil.class.getClassLoader().getResourceAsStream("jdbc.properties");</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(inputStream);</span><br><span class="line">        String driverClass = properties.getProperty(<span class="string">"driverClass"</span>);</span><br><span class="line">        String url = properties.getProperty(<span class="string">"url"</span>);</span><br><span class="line">        String user = properties.getProperty(<span class="string">"user"</span>);</span><br><span class="line">        String password = properties.getProperty(<span class="string">"password"</span>);</span><br><span class="line">        Class.forName(driverClass);</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">批量处理JDBC语句提高处理速度</span><br><span class="line">当需要成批插入或者更新记录时。可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</span><br><span class="line">JDBC的批量处理语句包括下面两个方法(Statement)：</span><br><span class="line">addBatch(String)：添加需要批量处理的SQL语句或是参数；</span><br><span class="line">executeBatch()：执行批量处理语句；</span><br><span class="line">clearBatch():清空缓存的数据</span><br><span class="line">通常我们会遇到两种批量执行SQL语句的情况：</span><br><span class="line">多条SQL语句的批量处理；</span><br><span class="line">一个SQL语句的批量传参；</span><br><span class="line"></span><br><span class="line">批量处理步骤如下：</span><br><span class="line">...</span><br><span class="line">Statement st = conn.prepareStatement();</span><br><span class="line">st.addBatch(sql1);</span><br><span class="line">st.addBatch(sql2);</span><br><span class="line">st.addBatch(sql3);</span><br><span class="line">...</span><br><span class="line">st.addBatch(s1ln);</span><br><span class="line">st.executeBatch();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title>mysql基本介绍</title>
    <url>/2020/04/27/mysql%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql数据库工作模式是C&#x2F;S架构，mysqld.exe就是服务器，ServerSocket，mysql.exe就是客户端，Socket。通过Socket进行连接，要想连接服务器，必须要提供主机ip地址（-h）,端口号（-P），用户名（-u）,密码（-p）</span><br></pre></td></tr></table></figure>

<p>连接服务器可以编写.bat脚本,然后以管理员身份运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set MYSQL_HOME &#x3D; D:\MyWOrk\MySQL\mysql-5.7.28-winx64</span><br><span class="line">set PATH&#x3D;%MYSQL_HOME%\bin;%PATH%</span><br><span class="line">mysql -h127.0.0.1 -P3306 -uroot -p&quot;123456&quot;</span><br></pre></td></tr></table></figure>

<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）把外部的.sql文件中的数据导入到当前数据库中，右面的文件的路径以实际为准.</span><br><span class="line">source d:&#x2F;company.sql;</span><br><span class="line">2）丢弃数据库</span><br><span class="line">drop database company;</span><br><span class="line">3）查看表结构</span><br><span class="line">desc 库名.表名;（如果是当前库，可省略库名）</span><br><span class="line">4）查看表的建表语句</span><br><span class="line">show create table 表名;</span><br></pre></td></tr></table></figure>

<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">存储引擎：决定表如何存储数据以及如何处理数据......</span><br><span class="line">查询所有引擎：show engines;</span><br><span class="line">InnoDB是默认存储引擎：支持外键，事物等高级特性。</span><br><span class="line">比如下面的建表语句，默认是InnoDB</span><br><span class="line"> CREATE TABLE &#96;city&#96; (</span><br><span class="line">  &#96;ID&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;Name&#96; char(35) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">  &#96;CountryCode&#96; char(3) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">  &#96;District&#96; char(20) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">  &#96;Population&#96; int(11) NOT NULL DEFAULT &#39;0&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;ID&#96;),</span><br><span class="line">  KEY &#96;CountryCode&#96; (&#96;CountryCode&#96;),</span><br><span class="line">  CONSTRAINT &#96;city_ibfk_1&#96; FOREIGN KEY (&#96;CountryCode&#96;) REFERENCES &#96;country&#96; (&#96;Code&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4080 DEFAULT CHARSET&#x3D;latin1 </span><br><span class="line"></span><br><span class="line">其中&#96;表示反引号（或者飘号），专门在数据库中用来包围数据库对象的名称。数据库对象：数据库，表，列，索引等。</span><br><span class="line">MyISAM是mysql早期默认引擎：速度超快，不支持事物</span><br></pre></td></tr></table></figure>

<h3 id="查询语句的执行顺序"><a href="#查询语句的执行顺序" class="headerlink" title="查询语句的执行顺序"></a>查询语句的执行顺序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查询 : </span><br><span class="line">1) from 确定第一基表</span><br><span class="line">2) join 确定第二基表</span><br><span class="line">3) join 是内还是外</span><br><span class="line">4) 有join必须要有on </span><br><span class="line">5) 如果还有, 继续join和on </span><br><span class="line">6) where 针对以上的大基表进行基本的行过滤</span><br><span class="line">7) 是否要分组, 如果要分组, 使用group by, 分组依据的列很重要.</span><br><span class="line">8) 第一时间把分组依据的列放在select后面</span><br><span class="line">9) 继续考虑要选择哪些列..</span><br><span class="line">10) 产生了虚表后, 如果还相再进一步进行过滤,必须使用having </span><br><span class="line">11) 如果要排序, 再排序 order by </span><br><span class="line"></span><br><span class="line">from-&gt;where-&gt;group by-&gt;select-having-&gt;order by</span><br></pre></td></tr></table></figure>

<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-- 创建数据库</span><br><span class="line">create database if not exists 数据库名 charset 字符集;</span><br><span class="line">create database if not exists school charset utf8;</span><br><span class="line">-- 修改数据库:只能修改字符集</span><br><span class="line">alter database school charset gbk;</span><br><span class="line">-- 丢弃数据库</span><br><span class="line">drop database if exists school;</span><br><span class="line"></span><br><span class="line">-- 创建表：</span><br><span class="line">1）全新方式建表：</span><br><span class="line">	create table if not exists 表名（</span><br><span class="line">		列名1 数据类型（长度） 其它选项（列级约束）,</span><br><span class="line">		列名2 数据类型（长度） 其它选项（列级约束）,</span><br><span class="line">		,,,</span><br><span class="line">		表级约束1,</span><br><span class="line">		表级约束2,</span><br><span class="line">		...</span><br><span class="line">	）engine 引擎 charset 字符集</span><br><span class="line">2）基于子查询建表：复制的新表不包含原表的约束</span><br><span class="line">	create table country2 as select * from country;</span><br><span class="line">3）完全复制表结构的建表，包含约束，但是没有数据</span><br><span class="line">	create table 新表 like 已有表;</span><br><span class="line"></span><br><span class="line">-- 修改表 alter table 表名 支持若干子句</span><br><span class="line">-- 添加新列</span><br><span class="line">alter table 表名</span><br><span class="line">add column 新列 数据类型（长度） 其它选项；</span><br><span class="line">alter table teacher</span><br><span class="line">add column phone char(11) not null;--在最后添加列</span><br><span class="line">alter table teacher</span><br><span class="line">add column gender enum(&#39;男&#39;,&#39;女&#39;)default &#39;男&#39; after name;--在指定列后面添加新列</span><br><span class="line">alter table teacher</span><br><span class="line">add column person_id varchar(50) first;--在最前面添加新列</span><br><span class="line"></span><br><span class="line">-- 修改列（列名和其它）</span><br><span class="line">alter table 表名</span><br><span class="line">change 老列名 新列名  新数据类型（长度） 新其它选项</span><br><span class="line"></span><br><span class="line">alter table teacher</span><br><span class="line">change phone mobile varchar(50) not null;</span><br><span class="line"></span><br><span class="line">-- 丢弃列</span><br><span class="line">alter table 表名</span><br><span class="line">drop column 列名;</span><br><span class="line">alter table teacher</span><br><span class="line">drop column person_id;</span><br><span class="line"></span><br><span class="line">-- 修改表名</span><br><span class="line">alter table 表名</span><br><span class="line">rename to 新表名;</span><br><span class="line">alter table student rename to students;</span><br><span class="line"></span><br><span class="line">-- 丢弃表</span><br><span class="line">drop table if exists &#39;表名1&#39;,&#39;表名2&#39;...;</span><br><span class="line">drop table if exists country1,country2;</span><br><span class="line">-- 清空表</span><br><span class="line">truncate table 表名;</span><br><span class="line">delete from table 表名 --可以后悔，所有的操作都会记日志...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 插入数据</span><br><span class="line">1）全新方式插入</span><br><span class="line">insert into  表名(列1，列2...)values(),()...;</span><br><span class="line">insert into  student(id,name)values(1,&#39;jack&#39;),(2,&#39;susan&#39;);</span><br><span class="line">2）基于子查询插入数据</span><br><span class="line">insert into 表名(列1，列2...)select 列1，列2...from 表名 </span><br><span class="line">insert into student(id,name)select id,name from students;</span><br></pre></td></tr></table></figure>

<h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  数据库事物是访问并可能操作各种数据项的一个数据库序列集合，这些操作要么全部执行， 要么全部不执行，是一个不可分割的工作单位。事物由事物开始与事物结束之间的全部数据库操作组成。</span><br><span class="line">  </span><br><span class="line">  启动事务：</span><br><span class="line">  	set autocommit &#x3D; false;-- 如果默认开启事物的话，那每一条语句就独立组成了事务</span><br><span class="line">  事物组成：</span><br><span class="line">  	若干的DML语句</span><br><span class="line">  事物结束：</span><br><span class="line">  	commit（成功）</span><br><span class="line">  	rollback(失败)，回滚到事物前</span><br><span class="line">  	ddl(成功)</span><br><span class="line">  	会话正常结束（成功）</span><br><span class="line">  	异常结束（失败）</span><br><span class="line">  还原设置：</span><br><span class="line">  	set autocommit &#x3D; true;</span><br><span class="line">  数据库事物的四大特性：</span><br><span class="line">  A atomic 原子性：事物中的所有DML语句是一个原子操作，要么全部执行成功，要么全部不执行</span><br><span class="line">  C consistency 一致性：事物保证了数据库从一个有效（正确）状态转移到另一个有效状态</span><br><span class="line">  I isolation 独立性：多个会话之间数据是独立的，一个事物不会读到另一个事物未提交的数据，如果多个会话同时修改数据是不允许的,会上锁</span><br><span class="line">  D duration  持久性：事物提交后，结果才写入硬盘，数据永久生效，并释放锁</span><br><span class="line">  </span><br><span class="line">-- 测试</span><br><span class="line">-- 在事务中删除表中所有数据, 在另外一个客户端中查看数据</span><br><span class="line">-- 回滚事务, 数据还在吗?</span><br><span class="line">-- 提交事务, 会发生什么?</span><br></pre></td></tr></table></figure>

<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySQL服务器支持预处理语句。当想要执行多个查询，而每个查询之间只有很小的差别时，可以把sql编成一个可以执行的执行体，执行的时候去调用这个执行体，而不需要重新输入sql，预编译的sql只在当前会话中有效，会话结束后就销毁。</span><br><span class="line"></span><br><span class="line">-- 格式</span><br><span class="line">prepare 预编译体名 from &#39;SQL&#39;;</span><br><span class="line">prepare p1 from &#39;</span><br><span class="line">	select * from teachers</span><br><span class="line">&#39;;</span><br><span class="line">-- 执行</span><br><span class="line">execute p1;</span><br><span class="line">-- 丢弃</span><br><span class="line">drop prepare p1;</span><br><span class="line"></span><br><span class="line">prepare p2 from &#39;</span><br><span class="line">	insert into user(</span><br><span class="line">		id,</span><br><span class="line">		name</span><br><span class="line">	)values(</span><br><span class="line">		?,</span><br><span class="line">		?</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">&#39;;</span><br><span class="line"></span><br><span class="line">-- 必须使用用户变量进行传参</span><br><span class="line">set @id &#x3D; 1,@name &#x3D; &#39;jack&#39;;-- 定义用户变量@id,@name并赋值</span><br><span class="line"></span><br><span class="line">-- 执行时</span><br><span class="line">execute p2 using @id,@name;</span><br><span class="line"></span><br><span class="line">prepare p3 from &#39;</span><br><span class="line">	delete from user where id &#x3D; ?</span><br><span class="line">&#39;;</span><br><span class="line">set @id &#x3D; 1;</span><br><span class="line">execute p3 using @id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 如果sql中有&#39;&#39;,必须用&#39;&#39;进行转义</span><br><span class="line"></span><br><span class="line">prepare p4 from &#39;</span><br><span class="line">	insert into classes(</span><br><span class="line">		name,</span><br><span class="line">		begin_date,</span><br><span class="line">		master,</span><br><span class="line">		room</span><br><span class="line">	)values(</span><br><span class="line">		?,</span><br><span class="line">		now(),</span><br><span class="line">		?,</span><br><span class="line">		&#39;&#39;303&#39;&#39;</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	约束时保证数据完整性的表级的强制性要求</span><br><span class="line">not null</span><br><span class="line">unique 唯一约束，允许使用null</span><br><span class="line">primary key 主键约束（非空且唯一）</span><br><span class="line">foreign key</span><br><span class="line">check mysql不支持</span><br><span class="line">default 默认值</span><br><span class="line"></span><br><span class="line">create table if not exists classes (</span><br><span class="line">	id int auto_increment,</span><br><span class="line">	name varchar(12) not null,</span><br><span class="line">	begindate date,</span><br><span class="line">	master int,</span><br><span class="line">	room char(3) default &#39;505&#39;,</span><br><span class="line">	primary key(id),</span><br><span class="line">	-- foreign key(本表外键列) references 父表(被引用的列(主键))</span><br><span class="line">	foreign key(master) references teachers(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 丢弃主键 因为一张表只有一个主键, 所以丢弃主键 不需要名字</span><br><span class="line">alter table 表名</span><br><span class="line">drop primary key;</span><br><span class="line"></span><br><span class="line">-- 丢弃外键 , 因为一张表可以有多个外键, 所以丢弃外键时必须指定名字</span><br><span class="line">alter table 表名 </span><br><span class="line">drop foreign key 外键约束名;</span><br><span class="line"></span><br><span class="line">-- 可以先通过 show create table 表名 查看外键名称</span><br><span class="line">alter table classes</span><br><span class="line">drop foreign key classes_ibfk_1;</span><br><span class="line"></span><br><span class="line">-- 添加外键</span><br><span class="line">on delete(是指删除父表中被字表引用的记录时的选项)有以下3种选项</span><br><span class="line">	1）do nothing 当删除父表中被引用的记录时，不允许删除（默认选项）</span><br><span class="line">	2）cascade 当删除父类中被引用的记录时，字表种所有引用该记录的所有记录都会被级联删除</span><br><span class="line">	3）set null 当删除父表中被引用的记录时，字表中所有引用该记录的所有记录的外键值全部置为null</span><br><span class="line"></span><br><span class="line">on update(是指更新父表中被字表引用的记录时的选项)有以下3种选项</span><br><span class="line">	1）do nothing</span><br><span class="line">	2）cascade</span><br><span class="line">	3）set null</span><br><span class="line">	</span><br><span class="line">alter table 表名</span><br><span class="line">add constraint 外键名 foreign key(本表外键列) references 父表(被引用的列) on delete cascade(级联) [do nothing, set null]</span><br><span class="line"></span><br><span class="line">alter table classes </span><br><span class="line">add constraint myfk foreign key(master) references teachers(id) on delete cascade;</span><br><span class="line">alter table classes </span><br><span class="line">add foreign key(master) references teachers(id) on delete set null;</span><br></pre></td></tr></table></figure>

<h3 id="limit-分页"><a href="#limit-分页" class="headerlink" title="limit 分页"></a>limit 分页</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">公式: (当前页数-1)*每页条数，每页条数</span><br><span class="line">select * from table limit (PageNo - 1) * PageSize,PageSize;</span><br><span class="line">注意：limit子句必须放在整个查询语句的最后</span><br><span class="line"></span><br><span class="line">-- 查询前10条记录</span><br><span class="line">	select * from table student 0,10;</span><br><span class="line">-- 查询第11至20条记录</span><br><span class="line">	select * from table student 10,10;-- 第一个参数表示skip前面10条记录，从11开始，第二个参数表示一共查询多少条记录</span><br></pre></td></tr></table></figure>



<h3 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a><code>SQL</code>分类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQL语句分为以下三种类型：</span><br><span class="line">DML: Data Manipulation language</span><br><span class="line">DDL: Data Definition language</span><br><span class="line">DCL: Data Control language</span><br><span class="line"></span><br><span class="line">DML 用于查询与修改数据记录，构造事物的主体（一个事物是由多个DML构成）,包括如下sql语句</span><br><span class="line">-- insert</span><br><span class="line">-- upate</span><br><span class="line">-- delete</span><br><span class="line">-- select</span><br><span class="line"></span><br><span class="line">DDL用于定义数据库的结构，比如创建，修改或删除数据库对象，非正规事物终结者,包括如下SQL语句：</span><br><span class="line">-- create table</span><br><span class="line">-- alter table</span><br><span class="line">-- drop table</span><br><span class="line">-- create index</span><br><span class="line">-- drop index</span><br><span class="line"></span><br><span class="line">DCL 用来控制对数据库的访问，正规事物终结者，包括如下SQL语句</span><br><span class="line">-- grant 授予访问权限</span><br><span class="line">-- revoke 撤回访问权限</span><br><span class="line">-- commit </span><br><span class="line">-- rollback</span><br><span class="line">-- savapoint 设置保存点</span><br><span class="line">-- lock 对数据库的特定部分进行锁定</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式的七大原则-合成复用原则</title>
    <url>/2020/04/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原则是尽量使用合成&#x2F;聚合的方式，而不是使用继承</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>Stream</title>
    <url>/2020/04/26/Stream/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream API(java.util.stream)把真正的函数式编程风格引入到Java中，是目前为止对Java类最好的补充，可以放我们写出更加高效率，干净，简洁的代码。</span><br><span class="line">Stream是Java8处理集合的关键抽象概念，它可以指定我们希望对集合进行的操作，可以执行非常复杂的查找，过滤和映射数据等操作。使用Stream API对集合数据进行操作就类似于使用SQL执行的数据库查询。</span><br><span class="line"></span><br><span class="line">也可以使用Stream API来并行执行操作。简言之，Stream API提供了一种高效且易于使用的处理数据的方式。</span><br><span class="line"></span><br><span class="line">为什么要使用Stream呢？</span><br><span class="line">	实际开发中，项目中数据源多数来自于Mysql,Oracle等。但现在数据源众多，有MongoDB,Redis等，而这些NoSQL的数据就需要Java层面去处理。</span><br></pre></td></tr></table></figure>

<h3 id="1-Stream的特点"><a href="#1-Stream的特点" class="headerlink" title="1. Stream的特点"></a>1. Stream的特点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream不负责数据存储，只负责数据处理，基于集合或数组来处理</span><br><span class="line">特点如下：</span><br><span class="line">1.不是集合，不负责数据存储</span><br><span class="line">2.Stream处理过后，原始数据不会发生改变，相反，会产生持有新结果的新的Stream</span><br><span class="line">3.Stream是延迟执行的，只有当终止操作提交后，所有一系列的普通操作才真的执行</span><br><span class="line">4.Stream只能消费一次，处理一次就不能再用了，再继续用会会产生新的Stream</span><br><span class="line">5.Stream类似迭代器，处理数据也是一次性的，但是可以高并发，提高效率</span><br></pre></td></tr></table></figure>

<h3 id="2-操作Stream的步骤"><a href="#2-操作Stream的步骤" class="headerlink" title="2.操作Stream的步骤"></a>2.操作Stream的步骤</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.创建流</span><br><span class="line">Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：</span><br><span class="line">default Stream&lt;E&gt; stream() : 返回一个顺序流</span><br><span class="line">default Stream&lt;E&gt; parallelStream() : 返回一个并行流</span><br><span class="line"></span><br><span class="line">1)基于集合</span><br><span class="line">	集合对象.stream()</span><br><span class="line">2)基于数组</span><br><span class="line">	Arrays.stream(数组对象)</span><br><span class="line">3)基于散列数据</span><br><span class="line">	Stream.of(T... values)</span><br><span class="line">4)使用供给器</span><br><span class="line">	Stream.generate(供给器)，形成无限流...</span><br><span class="line">		</span><br><span class="line">2.对数据进行处理的中间操作,一系列的中间操作形成流水线</span><br><span class="line">	Stream filter(判定器)让流中的每个对象都经过判定器，判定结果为true的对象则留下，为false则抛弃</span><br><span class="line">	distinct(),根据对象的hashCode()和equals()去重</span><br><span class="line">	limit(long maxSize),截断流，使流中的对象个数不大于maxSize</span><br><span class="line">	skip(long n),处理的时候跳过前n个对象</span><br><span class="line">	map(转换器)映射，把流中每个对象转换为另一种类型的对象（Function&lt;T,R&gt;），新流中全是新类型的对象</span><br><span class="line">	sorted()自然排序</span><br><span class="line">	sorter(比较器)定制排序</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">3.终止操作（最终指令）</span><br><span class="line">	forEach(消费器)</span><br><span class="line">	findFirst()	返回第一个对象</span><br><span class="line">	findAny() 随便返回任意一个对象</span><br><span class="line">	long count() 计数</span><br><span class="line">	reduce(二元运算)缩小，规约，二元运算T test(T t1,T t2)</span><br><span class="line">		第一个对象和第二个对象进行二元运算，返回新的对象，新的对象再和后面的对象进行相同的二元运算，知道最后只有一个结果</span><br></pre></td></tr></table></figure>

<h4 id="3-并行流和串行流"><a href="#3-并行流和串行流" class="headerlink" title="3.并行流和串行流"></a>3.并行流和串行流</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">并行流就是可以把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流</span><br><span class="line">Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。</span><br></pre></td></tr></table></figure>

<h3 id="4-Optional类"><a href="#4-Optional类" class="headerlink" title="4. Optional类"></a>4. Optional类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Optional类的作用是为了最大化地减少空指针异常，Optional实际上是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</span><br><span class="line">常用方法：</span><br><span class="line">Optional.empty() : 创建一个空的 Optional 实例</span><br><span class="line">Optional.of(T t) : 创建一个 Optional 实例</span><br><span class="line">Optional.ofNullable(T t):若 t 不为 null,创建 Optional 实例,否则创建空实例</span><br><span class="line">isPresent() : 判断是否包含值</span><br><span class="line">T get(): 如果调用对象包含值，返回该值，否则抛异常</span><br><span class="line">orElse(T t) :  如果调用对象包含值，返回该值，否则返回t</span><br><span class="line">orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回 s 获取的值</span><br><span class="line">map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty()</span><br><span class="line">flatMap(Function mapper):与 map 类似，要求返回值必须是Optional</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test14</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 求全校总分</span></span><br><span class="line">        Optional&lt;Double&gt; reduce = StudentData.getList().parallelStream().distinct().map(t -&gt; t.getScore()).reduce((t1, t2) -&gt; t1 + t2);</span><br><span class="line">        Double aDouble = reduce.orElse(<span class="number">9999.9999</span>);</span><br><span class="line">        System.out.println(aDouble);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test13</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> count = StudentData.getList().stream().distinct().filter(t -&gt; t.getScore() &lt; <span class="number">60</span>).count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test12</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Optional&lt;Student&gt; first = StudentData.getList().stream().distinct().filter(t -&gt; t.getScore() &gt; <span class="number">96</span>).findFirst();</span><br><span class="line">        <span class="comment">//Student student = first.get(); // 如果内部指针为空, 直接抛异常, 提前暴露空指针!!!</span></span><br><span class="line">        <span class="comment">//System.out.println(student.getName()); // 真的出现空指针</span></span><br><span class="line">        Student student = first.orElse(<span class="keyword">new</span> Student());</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出3年级没有及格的同学,倒序显示前2个....</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exer3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StudentData.getList().stream().distinct()</span><br><span class="line">                .filter(t -&gt; t.getGrade() == <span class="number">3</span>).filter(t -&gt; t.getScore() &lt; <span class="number">60</span>)</span><br><span class="line">                .sorted((t1, t2) -&gt; -(<span class="keyword">int</span>)(t1.getScore() - t2.getScore()))</span><br><span class="line">                .limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StudentData.getList().stream().distinct().sorted((t1, t2) -&gt; -(t1.getGrade() - t2.getGrade())).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印输出所有学生的姓名</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exer2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StudentData.getList().stream().distinct().map(t -&gt; t.getName()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Stream&lt;Double&gt; doubleStream = StudentData.getList().stream().distinct().map(t -&gt; t.getScore());</span></span><br><span class="line">        <span class="comment">//doubleStream.forEach(System.out::println);</span></span><br><span class="line">        StudentData.getList().stream().distinct().map(t -&gt; t.getScore()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StudentData.getList().stream().distinct().skip(<span class="number">10</span>).limit(<span class="number">5</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StudentData.getList().stream().distinct().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找出五年级80分以上的同学</span></span><br><span class="line">        StudentData.getList().stream().filter(t -&gt; t.getGrade() == <span class="number">5</span>).filter(t -&gt; t.getScore() &gt; <span class="number">80</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出所有3年级同学..</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exer1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StudentData.getList().stream().filter(t -&gt; t.getGrade() == <span class="number">3</span>).forEach(t -&gt; System.out.println(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 所有操作都可以在一行完成.</span></span><br><span class="line">        StudentData.getList().stream().filter(t -&gt; t.getScore() &gt; <span class="number">90</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Student&gt; list = StudentData.getList();</span><br><span class="line">        Stream&lt;Student&gt; stream1 = list.stream();</span><br><span class="line">        Stream&lt;Student&gt; stream2 = stream1.filter(t -&gt; t.getScore() &gt; <span class="number">90</span>);</span><br><span class="line">        stream2.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.generate(() -&gt; (<span class="keyword">int</span>) (Math.random() * <span class="number">200</span>));<span class="comment">// 供给器, 无参有返回</span></span><br><span class="line">        stream.limit(<span class="number">100</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"a"</span>, <span class="string">"yy"</span>, <span class="string">"qq"</span>, <span class="string">"132"</span>, <span class="string">"bb"</span>, <span class="string">"99"</span>);</span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer[] arr = &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Stream&lt;Integer&gt; stream = Arrays.stream(arr);</span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Student&gt; list = StudentData.getList();</span><br><span class="line">        Stream&lt;Student&gt; stream = list.stream();</span><br><span class="line">        stream.forEach(System.out::println); <span class="comment">// 让流中的每个对象都经过消费器.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>java8新特性</title>
    <url>/2020/04/25/java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="1-interface扩展"><a href="#1-interface扩展" class="headerlink" title="1.interface扩展"></a>1.interface扩展</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java8以后支持接口中支持静态方法和缺省方法。可能有些接口（比如Collection）中的功能需要升级，但是又不能加抽象方法，因为如果加抽象方法，实现了这个接口的类都需要修改，去实现新加的抽象方法，所以java8之后对接口规范进行了调整，可以有静态方法和缺省方法。</span><br></pre></td></tr></table></figure>

<p>代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java8以后支持静态方法和缺省方法. 向抽象类靠拢</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test3()..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123; <span class="comment">// 为了升级接口的无奈之举.</span></span><br><span class="line">        System.out.println(<span class="string">"test2()...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-lambda表达式"><a href="#2-lambda表达式" class="headerlink" title="2.lambda表达式"></a>2.lambda表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lambbada表达式的作用是为了代替匿名内部类对象，使使用变得简单。</span><br><span class="line">前提：java中越来越成熟的推断机制</span><br><span class="line">省略了new I1()&#123;省略方法的修饰符，方法名&#125;，只留下了方法的输入（参数列表）和方法体</span><br><span class="line"></span><br><span class="line">方法参数列表中数据类型可以省，如果只有一个参数时，()也可以省略</span><br><span class="line">如果方法体中只有一行语句时，方法体的&#123;&#125;也可以省略</span><br><span class="line"></span><br><span class="line">只保留参数列表和方法体，lambda可以省略以上内容时因为编译器知道它的接口类型，可以通过接口来判断</span><br><span class="line"></span><br><span class="line">lambda只适用于接口中只有一个抽象方法的接口，大多数情况一般实现方法也就一条语句(当然也可以有多条语句)</span><br><span class="line"></span><br><span class="line">lambda的目的就是让使用者的关注焦点落在方法上，函数上</span><br><span class="line">函数y&#x3D;f(x),z&#x3D;f(x,y)，有输入有输出</span><br><span class="line">()-&gt;方法体</span><br><span class="line">参数：函数的输入</span><br><span class="line">方法体：函数的输出</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//void test2();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个接口, 包含一个抽象方法, void hello(String)</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(String string)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I3</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">test3</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">double</span> d, String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别使用匿名内部类和lambda完成实现, 并测试这个方法.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        I4 i41 = <span class="keyword">new</span> I4() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">double</span> d, String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"test4"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        I4 i42 = (n, d, s) -&gt; System.out.println(<span class="string">"test4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test32</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        I3 i31 = <span class="keyword">new</span> I3() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">test3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> String.valueOf(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        I3 i32 = n -&gt; String.valueOf(n);</span><br><span class="line"></span><br><span class="line">        String s = i32.test3(<span class="number">200</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        I3 i31 = <span class="keyword">new</span> I3() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">test3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> String.valueOf(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        I3 i32 = (<span class="keyword">int</span> n) -&gt; &#123;<span class="keyword">return</span> String.valueOf(n);&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test22</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        I2 i21 = <span class="keyword">new</span> I2() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">                System.out.println(string);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        i21.hello(<span class="string">"我是字符串"</span>);</span><br><span class="line"></span><br><span class="line">        I2 i22 = str -&gt; System.out.println(str); <span class="comment">// 参数列表中数据类型可以省, 如果方法体中只有一行语句时, 方法体的&#123;&#125;也可以省略</span></span><br><span class="line">        i22.hello(<span class="string">"我也是字符串"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        I2 i21 = <span class="keyword">new</span> I2() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">                System.out.println(string);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        i21.hello(<span class="string">"我是字符串"</span>);</span><br><span class="line"></span><br><span class="line">        I2 i22 = (String str) -&gt; &#123;System.out.println(str);&#125;;</span><br><span class="line">        i22.hello(<span class="string">"我也是字符串"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        I1 i1 = <span class="keyword">new</span> I1() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"匿名内部类实现"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(i1.test());</span><br><span class="line">        I1 i2 = () -&gt; &#123;<span class="keyword">return</span> <span class="string">"我是lambda实现"</span>;&#125;;</span><br><span class="line">        System.out.println(i2.test());</span><br><span class="line">        <span class="comment">//List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); // 右面的泛型可以省略,因为可以推断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1函数式接口"><a href="#2-1函数式接口" class="headerlink" title="2.1函数式接口"></a>2.1函数式接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">只包含一个抽象方法的接口，称为函数式接口(比如Runnable接口，里面只有一个抽象run()方法，Runnable接口就是一个函数式接口)。</span><br><span class="line">可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。</span><br><span class="line">我们可以在一个接口上使用 <span class="meta">@FunctionalInterface</span> 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</span><br><span class="line">在java.util.function包下定义了java <span class="number">8</span> 的丰富的函数式接口</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Java内置的四大核心函数式（关注点：是否有输入，是否有输出）"><a href="#Java内置的四大核心函数式（关注点：是否有输入，是否有输出）" class="headerlink" title="Java内置的四大核心函数式（关注点：是否有输入，是否有输出）"></a>Java内置的四大核心函数式（关注点：是否有输入，是否有输出）</h5><table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer<T>消费型接口</td>
<td>T</td>
<td>void</td>
<td>对类型为T的对象进行操作（消费掉），没有返回值，包含方法： void accept(T t)     比如System.out.println(“”)就是一种典型的消费方法，有输入，没有输出</td>
</tr>
<tr>
<td>Supplier<T>供给型接口</td>
<td>无</td>
<td>T</td>
<td>返回类型为T的对象，包含方法T get()   比如从对象工厂中获取对象实例的时候就属于供给型，无输入有输出</td>
</tr>
<tr>
<td>Function&lt;T,R&gt;函数型接口</td>
<td>T</td>
<td>R</td>
<td>对类型T的对象操作，并返回结果，结果是类型为R的对象。包含方法R apple(T t)  比如Integer.parseInt(“”)方法</td>
</tr>
<tr>
<td>Predicate<T>断定型接口</td>
<td>T</td>
<td>boolean</td>
<td>确定T类型的对象是否满足某约束，并返回boolean值，包含方法boolean test(T t)  比如equals()</td>
</tr>
</tbody></table>
<p>这些是比较常用的。</p>
<p>代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * 函数式接口 : 只有一个抽象方法的接口</span><br><span class="line"> * 关注方法的模式, 是否有输入 , 是否有输出</span><br><span class="line"> *</span><br><span class="line"> * Consumer&lt;T&gt; : 消费器, 消费一个T类型的对象, 没有返回.</span><br><span class="line"> *      <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> 有参无返回.</span></span><br><span class="line"><span class="function"> *</span></span><br><span class="line"><span class="function"> * Supplier&lt;T&gt; : 供给器, 供给一个T类型的对象, 不需要任何输入</span></span><br><span class="line"><span class="function"> *      T <span class="title">get</span><span class="params">()</span> 无参有返回</span></span><br><span class="line"><span class="function"> *</span></span><br><span class="line"><span class="function"> * Function&lt;T, R&gt; : 转换器, 把输入的T类型对象经过处理返回成一个R类型对象</span></span><br><span class="line"><span class="function"> *      R <span class="title">apply</span><span class="params">(T t)</span> 有参有返回</span></span><br><span class="line"><span class="function"> *</span></span><br><span class="line"><span class="function"> * Predicate&lt;T&gt; : 判定器, 判定输入的T对象是否满足某条件, 如果满足返回 <span class="keyword">true</span>, 不满足返回<span class="keyword">false</span></span></span><br><span class="line"><span class="function"> *     <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span> 有参固定返回布尔</span></span><br><span class="line"><span class="function"> *</span></span><br><span class="line"><span class="function"> * 方法引用 : 进一步简化lambda的写法</span></span><br><span class="line"><span class="function"> *      如果实现接口的lambda体中调用的别的方法的模式和接口中的方法模式一致时, 就可以使用方法引用</span></span><br><span class="line"><span class="function"> *      类 :: 方法名</span></span><br><span class="line"><span class="function"> *      对象 :: 方法名</span></span><br><span class="line"><span class="function"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class FunctionalInterfaceTest </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用匿名内部类和lambda分别完成一个判定器, 判断一个学生对象是否是3年级.</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exer4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">"小花"</span>, <span class="number">3</span>, <span class="number">50</span>);</span><br><span class="line">        Predicate&lt;Student&gt; predicate1 = <span class="keyword">new</span> Predicate&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> student.getGrade() == <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(predicate1.test(s));</span><br><span class="line">        Predicate&lt;Student&gt; predicate2 = t -&gt; t.getGrade() == <span class="number">3</span>;</span><br><span class="line">        System.out.println(predicate2.test(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Predicate&lt;String&gt; predicate1 = <span class="keyword">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s.endsWith(<span class="string">".java"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">boolean</span> abc = predicate1.test(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(abc);</span><br><span class="line">        Predicate&lt;String&gt; predicate2 = s -&gt; s.endsWith(<span class="string">".java"</span>);</span><br><span class="line">        System.out.println(predicate2.test(<span class="string">"asfj.java"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用匿名内部类和lambda分别完成一个转换器, 把一个学生对象转换成Double对象.</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exer3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="number">3</span>, <span class="string">"小刚"</span>, <span class="number">5</span>, <span class="number">80</span>);</span><br><span class="line">        Function&lt;Student, Double&gt; function1 = <span class="keyword">new</span> Function&lt;Student, Double&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Double <span class="title">apply</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> student.getScore();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Double apply = function1.apply(s1);</span><br><span class="line">        System.out.println(apply);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Function&lt;Student, Double&gt; function2 = t -&gt; t.getScore();</span></span><br><span class="line">        Function&lt;Student, Double&gt; function2 = Student::getScore;</span><br><span class="line">        System.out.println(function2.apply(s1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Function&lt;String, Integer&gt; function1 = <span class="keyword">new</span> Function&lt;String, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.valueOf(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Integer apply = function1.apply(<span class="string">"239"</span>);</span><br><span class="line">        System.out.println(apply);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Function&lt;String, Integer&gt; function2 = s -&gt; Integer.valueOf(s);</span></span><br><span class="line">        Function&lt;String, Integer&gt; function2 = Integer::valueOf;</span><br><span class="line">        Integer apply1 = function2.apply(<span class="string">"2983"</span>);</span><br><span class="line">        System.out.println(apply1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用匿名内部类和lambda分别完成一个供给器, 供给一个学生对象.</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exer2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Supplier&lt;Student&gt; supplier1 = <span class="keyword">new</span> Supplier&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"小黑"</span>, <span class="number">2</span>, <span class="number">80</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Student student = supplier1.get();</span><br><span class="line">        System.out.println(student);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Supplier&lt;Student&gt; supplier2 = () -&gt; new Student();</span></span><br><span class="line">        Supplier&lt;Student&gt; supplier2 = Student::<span class="keyword">new</span>; <span class="comment">// 引用无参构造器</span></span><br><span class="line">        System.out.println(supplier2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Supplier&lt;Integer&gt; supplier1 = <span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(supplier1.get());</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Integer&gt; supplier2 = () -&gt; (<span class="keyword">int</span>)(Math.random() * <span class="number">100</span>);</span><br><span class="line">        System.out.println(supplier2.get());</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Double&gt; supplier3 = () -&gt; Math.random();</span><br><span class="line">        Supplier&lt;Double&gt; supplier4 = Math::random; <span class="comment">// 和上面一回事</span></span><br><span class="line">        System.out.println(supplier3.get());</span><br><span class="line">        System.out.println(supplier4.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 练习 : 分别写一个消费器, 消费一个Student类型的对象.</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exer1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Consumer&lt;Student&gt; consumer1 = <span class="keyword">new</span> Consumer&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">                System.out.println(student);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Consumer&lt;Student&gt; consumer2 = t -&gt; System.out.println(t);</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"小爱"</span>, <span class="number">5</span>, <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">        consumer1.accept(s1);</span><br><span class="line">        consumer2.accept(s1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; consumer1 = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        consumer1.accept(<span class="string">"alskjdflkajsdf"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Consumer&lt;String&gt; consumer2 = t -&gt; System.out.println(t);</span></span><br><span class="line">        Consumer&lt;String&gt; consumer2 = System.out::println; <span class="comment">// 方法引用, 语法糖</span></span><br><span class="line">        consumer2.accept(<span class="string">"汉字中楞中"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-方法引用和构造器引用"><a href="#2-2-方法引用和构造器引用" class="headerlink" title="2.2 方法引用和构造器引用"></a>2.2 方法引用和构造器引用</h4><h5 id="2-2-1方法引用"><a href="#2-2-1方法引用" class="headerlink" title="2.2.1方法引用"></a>2.2.1方法引用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法引用 : 进一步简化lambda的写法</span><br><span class="line">如果实现接口的lambda体中调用的别的方法的模式和接口中的方法模式一致时, 就可以使用方法引用</span><br><span class="line">类 :: 方法名</span><br><span class="line">对象 :: 方法名</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer = s-&gt;System.out.println(s);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Consumer&lt;String&gt; consumer = System.out::println;</span><br><span class="line"></span><br><span class="line">Comparator&lt;Integer&gt; com = (x,y)-&gt;Integer.compare(x,y);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Comparator&lt;Integer&gt; com = Integer::compare;</span><br><span class="line"><span class="keyword">int</span> value = com.compare(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：当函数式接口方法第一个参数是需要引用方法的调用者，并且第二个参数是需要引用方法的参数（或无参时）：ClassName::methodName;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line">BiPredicate&lt;String,String&gt; bp = (x,y)-&gt;x.equals(y);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">BIpredicate&lt;String,String&gt; bp = String::equals;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-构造器引用"><a href="#2-2-2-构造器引用" class="headerlink" title="2.2.2  构造器引用"></a>2.2.2  构造器引用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：ClassName::new</span><br><span class="line">要求:构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。</span><br></pre></td></tr></table></figure>

<p>代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer,MyClass&gt; fun = n-&gt;<span class="keyword">new</span> MyClass(n);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Function&lt;Integer,MyClass&gt; fun = MyClass::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组引用   type[]::new</span></span><br><span class="line"></span><br><span class="line">Function&lt;Integer,Integer[]&gt; fun = n-&gt;<span class="keyword">new</span> Integer[n];</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Function&lt;Integer,Integer[]&gt; fun = Integer[]::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>类加载器</title>
    <url>/2020/04/24/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引导类加载器：BootStrapClassLoader是由C++编写，负责最核心的类的加载，包括的就是JDK&#x2F;jre&#x2F;lib目录下的jar文件的加载</span><br><span class="line">扩展类加载器：ExtendClassLoader负责加载JDK&#x2F;jre&#x2F;lib&#x2F;ext目录下的jar</span><br><span class="line">系统类加载器(应用程序加载器)：负责加载-classpath环境变量中的类，包括导入的jar和src目录自己写的Java文件</span><br></pre></td></tr></table></figure>

<h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">系统类加载器会把所有类加载的任务先委派给扩展类加载器和引导类加载器，扩展类加载器和引导类加载器发现此类不该它们加载时，则拒绝加载，最后由系统类加载器加载。如果要加载的类是核心敏感类，双亲当仁不让，直接加载。</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// 最底层的是BootstrapClassLoader是由C++编写,负责最核心 的类的加载, 包括的就是JDK/jre/lib目录下的jar文件的加载</span></span><br><span class="line">       <span class="comment">// BootstrapClassLoader的上层是扩展类ExtClassLoader, 负责加载JDK/jre/lib/ext目录中的jar</span></span><br><span class="line">       <span class="comment">// ExtClassLoader的上层是系统类加载或应用程序类加载器, 负责加载 -classpath环境变量中的类, 包括导入的jar和src目录</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 双亲委派 : 系统类加载器会把所有类加载的任务先委派扩展类加载器和引导类加载器</span></span><br><span class="line">       <span class="comment">// 扩展类加载器和引导类加载器发现此类不该我加载, 拒绝, 请求驳回, 最后由系统类加载器加载</span></span><br><span class="line">       <span class="comment">// 如果要加载的类是核心敏感类, 双亲当仁不让, 直接加载, 系统类加载器就不加了.</span></span><br><span class="line">       ClassLoader classLoader1 = ClassLoader.getSystemClassLoader();</span><br><span class="line">       System.out.println(classLoader1);</span><br><span class="line">       ClassLoader classLoader2 = classLoader1.getParent();</span><br><span class="line">       System.out.println(classLoader2);</span><br><span class="line">       ClassLoader classLoader3 = classLoader2.getParent();<span class="comment">// 获取引导类加载器</span></span><br><span class="line">       System.out.println(classLoader3);</span><br><span class="line"></span><br><span class="line">       ClassLoader classLoader = Teacher<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">       System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">       ClassLoader classLoader4 = String<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>; <span class="comment">// 引导类加载器加载</span></span><br><span class="line">       System.out.println(classLoader4);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过类加载器加载资源文件"><a href="#通过类加载器加载资源文件" class="headerlink" title="通过类加载器加载资源文件"></a>通过类加载器加载资源文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 加载类路径中的资源文件 classpath</span></span><br><span class="line">        InputStream input = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">"com/sun/corba/se/impl/logging/LogStrings.properties"</span>);</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(input);</span><br><span class="line"></span><br><span class="line">        Enumeration&lt;?&gt; enumeration = properties.propertyNames();</span><br><span class="line">        <span class="keyword">while</span> (enumeration.hasMoreElements()) &#123;</span><br><span class="line">            Object name = enumeration.nextElement();</span><br><span class="line">            Object value = properties.get(name);</span><br><span class="line">            System.out.println(name + <span class="string">" &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; "</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2020/04/24/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h3 id="1-什么是反射？"><a href="#1-什么是反射？" class="headerlink" title="1. 什么是反射？"></a>1. 什么是反射？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反射被视为动态语言的关键，反射机制允许程序在执行期借助Reflection API来取得任意类的内部信息，并能直接操作任意的对象的内部属性和方法。</span><br></pre></td></tr></table></figure>



<h3 id="2-反射有什么用？"><a href="#2-反射有什么用？" class="headerlink" title="2. 反射有什么用？"></a>2. 反射有什么用？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	反射机制提供了以下功能：</span><br><span class="line">1）在运行时判断任意一个对象的所属类</span><br><span class="line">2）在运行时构建任意一个类的对象</span><br><span class="line">3）在运行时可以获取任意一个类的成员变量和方法</span><br><span class="line">4）在运行时调用任意一个类的成员变量和方法</span><br><span class="line">5）生成动态代理</span><br></pre></td></tr></table></figure>



<h3 id="3-反射主要的API"><a href="#3-反射主要的API" class="headerlink" title="3. 反射主要的API"></a>3. 反射主要的API</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.Class:代表一个类</span><br><span class="line">java.lang.reflect.Method:类的方法</span><br><span class="line">java.lang.reflect.Field:类的成员变量</span><br><span class="line">java.lang.reflect.Constructor:类的构造方法</span><br></pre></td></tr></table></figure>

<h3 id="4-Class类"><a href="#4-Class类" class="headerlink" title="4. Class类"></a>4. Class类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Obejct类中有一个方法public final Class getClass()，Class类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射出类的名称</span><br><span class="line">正常方式：引入需要的“包类”名称--&gt;通过new实例化--&gt;取得实例化结果</span><br><span class="line">反射方式：实例化对象--&gt;getClass()方法--&gt;得到完整的“包类”名称</span><br><span class="line">可以从获取到的Class类对象中得知某个类的属性，方法和构造器以及这个类实现了哪些接口。</span><br><span class="line">Class对象只能由系统建立对象</span><br><span class="line">一个类在JVM中只会有一个Class实例</span><br><span class="line">一个Class对象对应的是一个加载到JVM中的.class文件</span><br><span class="line">每个类的实例都会记得自己是由哪个Class实例所生成的</span><br><span class="line">通过Class可以完成地得到一个类中的完整结构</span><br></pre></td></tr></table></figure>

<h3 id="5-Class类的常用方法"><a href="#5-Class类的常用方法" class="headerlink" title="5. Class类的常用方法"></a>5. Class类的常用方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static Class forName(String name)</span><br><span class="line">Object newInstance()</span><br><span class="line">String getName()</span><br><span class="line">Class[] getInterfaces()</span><br><span class="line">ClassLoader getClassLoader()</span><br><span class="line">Class getSuperClass()</span><br><span class="line">Constructor[] getConstructors()</span><br><span class="line">Field[] getDeclaredFields()</span><br><span class="line">Method getMethod(String name,Class...paramTypes)&#x2F;&#x2F;获取本类以及父类中的所有public方法，这里的父类，指的是继承层次中的所有父类。比如说，A继承B，B继承C，那么B和C都属于A的父类。</span><br><span class="line">Method getDeclaredMethod(String name,Class...paramTypes)&#x2F;&#x2F;获取当前类的所有声明的方法，包括public、protected和private修饰的方法。需要注意的是，这些方法一定是在当前类中声明的，从父类中继承的不算，实现接口的方法由于有声明所以包括在内。</span><br></pre></td></tr></table></figure>

<h3 id="6-实例化Class类对象的四种方法"><a href="#6-实例化Class类对象的四种方法" class="headerlink" title="6. 实例化Class类对象的四种方法"></a>6. 实例化Class类对象的四种方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）前提：若已知具体的类，通过类的<span class="class"><span class="keyword">class</span>属性获取，该方法最为安全可靠，程序性能最高</span></span><br><span class="line"><span class="class">       实例：<span class="title">Class</span> <span class="title">clazz</span> </span>= String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="number">2</span>）前提：已知某个类的实例，调用该实例的getClass()方法获取Class对象</span><br><span class="line">       实例：Class clazz = “www.atguigu.com”.getClass();</span><br><span class="line"><span class="number">3</span>）前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException</span><br><span class="line">       实例：Class clazz = Class.forName(“java.lang.String”);</span><br><span class="line"><span class="number">4</span>）其他方式(不做要求)</span><br><span class="line">ClassLoader cl = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">Class clazz4 = cl.loadClass(“类的全类名”);</span><br></pre></td></tr></table></figure>

<h3 id="7-示例代码"><a href="#7-示例代码" class="headerlink" title="7. 示例代码"></a>7. 示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.javase.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射 : 先获取到类模板, 再从类模板展开, 进一步使用对象.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 获取类模板对象的方式 :</span></span><br><span class="line"><span class="comment"> *      1) 已知类, 使用类的静态属性.class来获取, 这种方式最安全,高效..  属于硬编码</span></span><br><span class="line"><span class="comment"> *          Class clazz = Teacher.class;</span></span><br><span class="line"><span class="comment"> *          String.class, int.class, double.class,</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      2) 已经对象, 通过对象的getClass()获取相应的类模板对象. 安全,高效, 硬编码</span></span><br><span class="line"><span class="comment"> *          Class clazz = new Teacher().getClass();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      3) Class clazz = Class.forName("类的全限定名称"); 这是反射的基础, 属性软编码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      4) 通过类加载器对象.loadClass("类的全限定名称")</span></span><br><span class="line"><span class="comment"> *          Class clazz = this.getClass().getClassLoader().loadClass("类的全名");</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) <span class="comment">// 停留期必须到运行时..</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> 10</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "缺省值"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnnotation</span>(<span class="string">"我是一个值"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">ArrayList</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Serializable</span>, <span class="title">Callable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String school = <span class="string">"atguigu"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name, <span class="keyword">int</span> age, String gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Teacher&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", gender='"</span> + gender + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lesson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lesson</span><span class="params">(String content, <span class="keyword">int</span> hours)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" 老师在上["</span> + content + <span class="string">"]课, 共上了["</span> + hours + <span class="string">"]小时"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"我是一个无端的错误"</span>);</span><br><span class="line">        <span class="comment">//return "上课OK";</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test12</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.atguigu.javase.reflect.Teacher"</span>);</span><br><span class="line">        <span class="comment">// 只能反射能处理注解, 并且注解必须停留到Runtime</span></span><br><span class="line">        MyAnnotation annotation = (MyAnnotation)clazz.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(annotation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 静态成员的访问不需要this目标对象.</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.atguigu.javase.reflect.Teacher"</span>);</span><br><span class="line">        Field school = clazz.getField(<span class="string">"school"</span>);</span><br><span class="line">        Object o = school.get(<span class="keyword">null</span>); <span class="comment">// ? 会不会抛出空指针 ?? 静态属性的访问完全忽略参数</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">        Method test = clazz.getMethod(<span class="string">"test"</span>);</span><br><span class="line">        test.invoke(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">"com.atguigu.javase.reflect.Teacher"</span>);</span><br><span class="line">            Object object = clazz.newInstance();</span><br><span class="line">            <span class="comment">// getMethod获取的是本类及从父类继承的所有公共方法</span></span><br><span class="line">            <span class="comment">//Method method = clazz.getMethod("lesson", String.class, int.class);</span></span><br><span class="line">            <span class="comment">// getDeclaredMethod可以获取本类声明的任意方法, 包括私有的.</span></span><br><span class="line">            Method method = clazz.getDeclaredMethod(<span class="string">"lesson"</span>, String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>); <span class="comment">// 突破封装</span></span><br><span class="line">            Object ret = method.invoke(object, <span class="string">"MyBatis"</span>, (<span class="keyword">short</span>)<span class="number">5</span>);</span><br><span class="line">            <span class="comment">//System.out.println(ret);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123; <span class="comment">// 访问私有成员</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123; <span class="comment">// 创建对象时出异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123; <span class="comment">// 方法定位失败</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;<span class="comment">// 调用的目标方法出现异常时</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">"com.atguigu.javase.reflect.Teacher"</span>);</span><br><span class="line">            <span class="comment">//Object o = clazz.newInstance(); // 没有无参构造器时出错</span></span><br><span class="line">            <span class="comment">//public Teacher(String name, int age, String gender) &#123;</span></span><br><span class="line">            Constructor constructor = clazz.getConstructor(Class.forName(<span class="string">"java.lang.String"</span>), <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;<span class="comment">// 形参类型列表</span></span><br><span class="line">            Object obj = constructor.newInstance(<span class="string">"佟刚"</span>, <span class="number">40</span>, <span class="string">"男"</span>); <span class="comment">// 需要实参列表</span></span><br><span class="line">            System.out.println(obj);</span><br><span class="line">            <span class="comment">// 先获取方法对象, 再配合目标this</span></span><br><span class="line">            <span class="comment">//public String lesson(String content, int hours) &#123;</span></span><br><span class="line">            Method lessonMethod = clazz.getMethod(<span class="string">"lesson"</span>, String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span> )</span>;<span class="comment">// 第一个参数是方法名, 后面是形参类型列表</span></span><br><span class="line">            Object retValue = lessonMethod.invoke(obj, <span class="string">"JavaWEB"</span>, <span class="number">3</span>);<span class="comment">//等效于 obj.lesson("javaWeb", 3);</span></span><br><span class="line">            System.out.println(retValue); <span class="comment">// 如果实际调用的方法没有返回值, 这里的返回值就是null</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 加载类路径中的资源文件 classpath</span></span><br><span class="line">        InputStream input = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">"com/sun/corba/se/impl/logging/LogStrings.properties"</span>);</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(input);</span><br><span class="line"></span><br><span class="line">        Enumeration&lt;?&gt; enumeration = properties.propertyNames();</span><br><span class="line">        <span class="keyword">while</span> (enumeration.hasMoreElements()) &#123;</span><br><span class="line">            Object name = enumeration.nextElement();</span><br><span class="line">            Object value = properties.get(name);</span><br><span class="line">            System.out.println(name + <span class="string">" &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; "</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 最底层的是BootstrapClassLoader是由C++编写,负责最核心 的类的加载, 包括的就是JDK/jre/lib目录下的jar文件的加载</span></span><br><span class="line">        <span class="comment">// BootstrapClassLoader的上层是扩展类ExtClassLoader, 负责加载JDK/jre/lib/ext目录中的jar</span></span><br><span class="line">        <span class="comment">// ExtClassLoader的上层是系统类加载或应用程序类加载器, 负责加载 -classpath环境变量中的类, 包括导入的jar和src目录</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双亲委派 : 系统类加载器会把所有类加载的任务先委派扩展类加载器和引导类加载器</span></span><br><span class="line">        <span class="comment">// 扩展类加载器和引导类加载器发现此类不该我加载, 拒绝, 请求驳回, 最后由系统类加载器加载</span></span><br><span class="line">        <span class="comment">// 如果要加载的类是核心敏感类, 双亲当仁不让, 直接加载, 系统类加载器就不加了.</span></span><br><span class="line">        ClassLoader classLoader1 = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(classLoader1);</span><br><span class="line">        ClassLoader classLoader2 = classLoader1.getParent();</span><br><span class="line">        System.out.println(classLoader2);</span><br><span class="line">        ClassLoader classLoader3 = classLoader2.getParent();<span class="comment">// 获取引导类加载器</span></span><br><span class="line">        System.out.println(classLoader3);</span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader = Teacher<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader4 = String<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>; <span class="comment">// 引导类加载器加载</span></span><br><span class="line">        System.out.println(classLoader4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazzI = Integer<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Class clazzi = <span class="keyword">int</span><span class="class">.<span class="keyword">class</span></span>; <span class="comment">// 只要是数据类型, 一定有相应的类模板对象.</span></span><br><span class="line">        System.out.println(clazzI == clazzi); <span class="comment">// 包装类型和基本类型不是同一类型</span></span><br><span class="line">        <span class="comment">//clazzi.newInstance(); // 什么都不能做, 唯一能做的事情就是作为一个标识, 表明它是int类型</span></span><br><span class="line">        System.out.println(clazzi.isPrimitive()); <span class="comment">// 判断类模板表示的类型是否是基本型</span></span><br><span class="line">        System.out.println(clazzI.isPrimitive());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"**************************************************"</span>);</span><br><span class="line"></span><br><span class="line">        Class clazz1 = Teacher<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Class clazz2 = <span class="keyword">new</span> Teacher(<span class="string">"a"</span>, <span class="number">2</span>, <span class="string">"b"</span>).getClass();</span><br><span class="line">        System.out.println(clazz1 == clazz2);</span><br><span class="line">        Class clazz3 = Class.forName(<span class="string">"com.atguigu.javase.reflect.Teacher"</span>);</span><br><span class="line">        System.out.println(clazz1 == clazz3);</span><br><span class="line">        ClassLoader classLoader = <span class="keyword">this</span>.getClass().getClassLoader(); <span class="comment">// 了解</span></span><br><span class="line">        Class clazz4 = classLoader.loadClass(<span class="string">"com.atguigu.javase.reflect.Teacher"</span>);</span><br><span class="line">        System.out.println(clazz3 == clazz4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 有了类模板, 可以获取和这个类相关的所有信息</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.atguigu.javase.reflect.Teacher"</span>);</span><br><span class="line">        Class&lt;?&gt; superclass = clazz.getSuperclass();<span class="comment">// 获取父类类型</span></span><br><span class="line">        System.out.println(superclass);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt;[] interfaces = clazz.getInterfaces();<span class="comment">// 获取实现的所有接口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">            System.out.println(interfaces[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader = clazz.getClassLoader();<span class="comment">// 当前加载类模板的类加器对象</span></span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">"com.atguigu.javase.reflect.Teacher"</span>);</span><br><span class="line">            Object object1 = clazz.newInstance();</span><br><span class="line">            System.out.println(object1);</span><br><span class="line">            <span class="comment">// getField无法获取私有属性定义, 其实它只能获取公共的属性定义, 包括本类的和父类继承的.</span></span><br><span class="line">            <span class="comment">//Field nameField = clazz.getField("name");</span></span><br><span class="line">            Field nameField = clazz.getDeclaredField(<span class="string">"name"</span>); <span class="comment">// 获取本类中声明的任意属性, 当然也包括私有的.</span></span><br><span class="line">            nameField.setAccessible(<span class="keyword">true</span>); <span class="comment">// 设置为可访问, 就可以访问了. 暴力反射!!! 强烈不建议. 突破封装性.</span></span><br><span class="line">            nameField.set(object1, <span class="string">"佟刚"</span>);</span><br><span class="line"></span><br><span class="line">            Field ageField = clazz.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">            ageField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            ageField.set(object1, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">            Field genderField = clazz.getDeclaredField(<span class="string">"gender"</span>);</span><br><span class="line">            genderField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            genderField.set(object1, <span class="string">"男"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(object1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; <span class="comment">// 类名错误或类真的不存在</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123; <span class="comment">// 访问了没有访问权限的成员. 比如访问了私有成员.</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123; <span class="comment">// 在创建对象时构造器定位失败.</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123; <span class="comment">// 查找属性定义时, 属性名错误或属性定义不存在</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">"com.atguigu.javase.reflect.Teacher"</span>);</span><br><span class="line">            Object object1 = clazz.newInstance();</span><br><span class="line">            System.out.println(object1);</span><br><span class="line">            <span class="comment">//((Teacher)object1).name = "佟刚"; // 之前的方式</span></span><br><span class="line">            <span class="comment">// 先找到属性定义对象, 再配合this对象, 完成属性访问</span></span><br><span class="line">            Field nameField = clazz.getField(<span class="string">"name"</span>); <span class="comment">// Field就是属性定义对象</span></span><br><span class="line">            nameField.set(object1, <span class="string">"佟刚"</span>); <span class="comment">// object1.name = "佟刚", 对象属性必须配合this对象, 才能完成访问</span></span><br><span class="line">            System.out.println(nameField.get(object1)); <span class="comment">// 获取属性值 System.out.println(object1.name);</span></span><br><span class="line">            Field ageField = clazz.getField(<span class="string">"age"</span>);</span><br><span class="line">            ageField.set(object1, <span class="number">40</span>);<span class="comment">// 修改age属性</span></span><br><span class="line">            Field genderField = clazz.getField(<span class="string">"gender"</span>);<span class="comment">// 修改gender属性</span></span><br><span class="line">            genderField.set(object1, <span class="string">"男"</span>); <span class="comment">// object.gender = "男"</span></span><br><span class="line">            System.out.println(object1);</span><br><span class="line"></span><br><span class="line">            Object object2 = clazz.newInstance();</span><br><span class="line">            <span class="comment">// 属性定义就一个</span></span><br><span class="line">            nameField.set(object2, <span class="string">"宁姐"</span>); <span class="comment">//object2.name = "宁姐";</span></span><br><span class="line">            ageField.set(object2, <span class="number">20</span>);</span><br><span class="line">            genderField.set(object2, <span class="string">"女"</span>);</span><br><span class="line">            System.out.println(object2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; <span class="comment">// 类名错误或类真的不存在</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123; <span class="comment">// 访问了没有访问权限的成员. 比如访问了私有成员.</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123; <span class="comment">// 在创建对象时构造器定位失败.</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123; <span class="comment">// 查找属性定义时, 属性名错误或属性定义不存在</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 干预类的加载</span></span><br><span class="line">        <span class="comment">//Class clazz = Class.forName("类的全限定名称"); // 结果就是类模板对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 手工加载类模板, 结果就是获取到了类模板对象, 根据类名加载类模板. 动态加载类</span></span><br><span class="line">            <span class="comment">// 编译时不检查, 运行时出问题, 推迟到了运行时, 称为软编码, 类的提供的时机可以延迟到运行时.</span></span><br><span class="line">            Class clazz = Class.forName(<span class="string">"com.atguigu.javase.reflect.Teacher"</span>); <span class="comment">// 结果就是类模板对象, 参数中的类名必须全限定</span></span><br><span class="line">            <span class="comment">// 依据类模板创建对象, 通过方法来创建, 像工厂, 调用了无参构造器创建对象.</span></span><br><span class="line">            Object object1 = clazz.newInstance(); <span class="comment">// clazz是Teacher类模板, 所以创建出来的对象就是Teacher对象</span></span><br><span class="line">            System.out.println(object1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; <span class="comment">// 类名错误或类真的不存在</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123; <span class="comment">// 访问了没有访问权限的成员. 比如访问了私有成员.</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123; <span class="comment">// 在创建对象时构造器定位失败.</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Teacher t1 = new Teacher();// 无参构造方法, 问题暴露在编译时, 对Teacher是一种强依赖, 硬编码..</span></span><br><span class="line">        <span class="comment">//t1.name = "佟刚"; // set</span></span><br><span class="line">        <span class="comment">//t1.age = 40;</span></span><br><span class="line">        <span class="comment">//t1.gender = "男";</span></span><br><span class="line">        <span class="comment">//System.out.println(t1.name); // get</span></span><br><span class="line">        <span class="comment">//System.out.println(t1.age);</span></span><br><span class="line">        <span class="comment">//System.out.println(t1.gender);</span></span><br><span class="line">        <span class="comment">//System.out.println(t1);</span></span><br><span class="line"></span><br><span class="line">        Teacher t2 = <span class="keyword">new</span> Teacher(<span class="string">"宁姐"</span>, <span class="number">20</span>, <span class="string">"女"</span>);</span><br><span class="line">        System.out.println(t2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2020/04/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序：硬盘上保存的可以执行的文件</span><br><span class="line"></span><br><span class="line">进程：运行中的程序，体现多任务，进程之间无法直接传递数据</span><br><span class="line"></span><br><span class="line">线程：进程中的子任务，线程之间可以直接通讯，线程是可以直接由CPU调度的</span><br></pre></td></tr></table></figure>

<h3 id="什么时候需要用到多线程"><a href="#什么时候需要用到多线程" class="headerlink" title="什么时候需要用到多线程"></a>什么时候需要用到多线程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序需要同时执行两个或多个任务。</span><br><span class="line">程序需要实现一些需要等待的任务时，如用户的输入、文件读写操作、网络操作、搜索等。</span><br><span class="line">需要一些后台运行的程序时。</span><br></pre></td></tr></table></figure>

<h3 id="线程的创建和使用"><a href="#线程的创建和使用" class="headerlink" title="线程的创建和使用"></a><em>线程的创建和使用</em></h3><p>创建线程的方式有以下四种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.直接继承Thread类，重写Thread类的run()方法</span><br><span class="line">2.实现Runnable接口，实现run()方法，生成一个Runnable实现类的对象runner,生成一个Thread对象，实参为runner</span><br></pre></td></tr></table></figure>

<p>第一种方式示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">"子线程"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方式示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">200</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="string">""</span>)&#123;<span class="comment">//任意对象都可以做锁对象，但必须是所有线程共享的同一个对象，互斥锁,用全局常量即可</span></span><br><span class="line">               counter -= <span class="number">2</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">10</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.print(Thread.currentThread().getName() + <span class="string">":"</span> + counter + <span class="string">" "</span>);</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">10</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Counter counter = <span class="keyword">new</span> Counter();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(counter);</span><br><span class="line">        thread1.setName(<span class="string">"线程1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(counter);</span><br><span class="line">        thread2.setName(<span class="string">"线程2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这两种方法创建线程执行run()方法是没有返回值的，不知道具体的执行情况，下面两种是可以获取到返回值的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.实现Callable接口</span><br><span class="line">1)写一个具体类实现Callable接口，并实现方法call()</span><br><span class="line">2)创建一个FutureTask对象，关联Callable，FutureTask也实现了Runnable接口，相当于Runnable对象	</span><br><span class="line">3）再以FutureTask对象为实参，创建Thread对象</span><br><span class="line">4）调用Thread的start()方法</span><br></pre></td></tr></table></figure>

<p>第三种方式示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Callable callable = <span class="keyword">new</span> Callable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span> + ((<span class="keyword">int</span>) (Math.random() * <span class="number">100</span> + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask(callable);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String s = futureTask.get();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.使用线程池：统一调度线程的创建和使用。Executor，ExecutorService</span><br><span class="line">1)写一个具体类实现Callable接口，实现call()方法</span><br><span class="line">2)通过工具类Executors.newXxx来创建线程池</span><br><span class="line">3)把具体的Callable对象提交给线程池，并获取相应的task对象，用于获取将来的值</span><br><span class="line">4)调用线程的shutdown方法</span><br><span class="line">5)依次从task对象获取将来的值（线程执行后的返回值）</span><br></pre></td></tr></table></figure>

<p>第四种方式示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//1.写一个具体类实现Callable接口</span></span><br><span class="line">      Callable callable = <span class="keyword">new</span> Callable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">":"</span> + ((<span class="keyword">int</span>) (Math.random() * <span class="number">100</span> + <span class="number">1</span>));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">//2.通过工具类Executors获取线程池对象</span></span><br><span class="line">      ExecutorService executorService = Executors.newCachedThreadPool();<span class="comment">//自动缓冲的线程池</span></span><br><span class="line">      <span class="comment">// ExecutorService executorService = Executors.newFixedThreadPool(30);// 固定个数的线程池, 不太好用</span></span><br><span class="line">      <span class="comment">// ExecutorService executorService = Executors.newWorkStealingPool();// 工作窃取线程池, 最好用的.</span></span><br><span class="line">      <span class="comment">//3.把具体的callable对象交给线程池，并获取相应的task对象，用于获取将来的值</span></span><br><span class="line">      List&lt;Future&lt;String&gt;&gt; futureList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">          Future future = executorService.submit(callable);</span><br><span class="line">          futureList.add(future);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.调用线程池的shutdown()方法</span></span><br><span class="line">      executorService.shutdown();<span class="comment">//发出通知，线程池不再添加新任务了，执行当前所有任务后就结束</span></span><br><span class="line">      <span class="comment">//5.依次从future对象中获取将来的值</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; futureList.size(); i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              String s = futureList.get(i).get();<span class="comment">//get()方法是个阻塞方法，可通过下面的代码提高效率</span></span><br><span class="line">              System.out.println(s);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//上面for()的优化</span></span><br><span class="line">      <span class="comment">/*while(futureList.size() &gt; 0)&#123;//任务列表不为空，则一直寻找已经完成的任务</span></span><br><span class="line"><span class="comment">          for (int i = 0; i &lt; futureList.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">              if(futureList.get(i).isDone())&#123;</span></span><br><span class="line"><span class="comment">                  //遍历的作用是优先获取已经完成的任务</span></span><br><span class="line"><span class="comment">                  //表示当前的线程任务已完成，可获取返回值了</span></span><br><span class="line"><span class="comment">                  try &#123;</span></span><br><span class="line"><span class="comment">                      String s = futureList.get(i).get();</span></span><br><span class="line"><span class="comment">                      System.out.println(s);</span></span><br><span class="line"><span class="comment">                  &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                      e.printStackTrace();</span></span><br><span class="line"><span class="comment">                  &#125; catch (ExecutionException e) &#123;</span></span><br><span class="line"><span class="comment">                      e.printStackTrace();</span></span><br><span class="line"><span class="comment">                  &#125;</span></span><br><span class="line"><span class="comment">                  futureList.remove(i);//以访问到返回值，删除减少任务列表</span></span><br><span class="line"><span class="comment">                  break;</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">      &#125;*/</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程池和自己创建线程对比"><a href="#线程池和自己创建线程对比" class="headerlink" title="线程池和自己创建线程对比"></a>线程池和自己创建线程对比</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Thread的弊端</span><br><span class="line">1）线程缺乏统一管理，可能无限制新建线程，相互之间竞争，有可能占用过多系统资源导致死机或者oom</span><br><span class="line">2）功能过于单一，如没有定时执行，定期执行，线程中断</span><br><span class="line"></span><br><span class="line">相比new Thread，线程池的好处：</span><br><span class="line">1）重用存在的线程，减少对象的创建，消亡的开销</span><br><span class="line">2）可有效控制最大最大并发线程数，提高系统资源的利用率，同时避免过多资源竞争，避免堵塞</span><br><span class="line">3）提供定时执行，定期执行，并发控制等功能</span><br></pre></td></tr></table></figure>







<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程有以下5个状态：</span><br><span class="line">1）新建：当一个Thread类或其子类对象被创建时，新生的线程对象处于新建状态</span><br><span class="line">2）就绪：处于新建状态的线程被start()后，将进入线程等待cpu时间片，此时除于就绪状态</span><br><span class="line">3）运行：当就绪的线程被调度并获得处理器资源时，此时线程进入了运行状态，run()方法定义了线程的操作和功能</span><br><span class="line">4）阻塞：在某些特殊情况下，比如执行wait()方法，以及Thread.sleep()方法，以及等待输入输出时，线程会临时终止自己的运行,这个时候就进入了阻塞状态</span><br><span class="line">5）死亡：线程完成了它的全部工作或线程提前被强制性终止</span><br></pre></td></tr></table></figure>

<p>下面是线程状态的转换图</p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt=""></p>
<h3 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a><em>线程的同步</em></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多个线程之间是不能直接传递数据交互的，它们之间的交互需要通过共享变量来实现。多个线程执行的不确定性会引起结果执行的不稳定。所以需要对共享变量的操作包装为原子性操作。可以通过synchronized关键字实现。synchronized修饰静态方法时，锁为当前类对象；synchronized修饰非静态方法时，锁为this对象；synchronized修饰代码块时为同步代码块，可以指定任意对象为锁,最好以常量对象作为锁，比如&quot;&quot;。</span><br><span class="line">每个对象都对应一个可称为“互斥锁”的标记，这个标记用来保证某一时刻，只能有某一线程访问某个对象。</span><br></pre></td></tr></table></figure>

<h3 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wait()与notify()和notifyAll()</span><br><span class="line">wait():令当前线程挂起并释放CPU，等待同步资源，释放锁对象，使别的线程可访问并修改共享数据，需要等待被其它共用同一把锁的线程唤醒</span><br><span class="line">notify():唤醒正在排队等待同步资源的线程中优先级最高者结束等待</span><br><span class="line">notifyAll():唤醒正在排队等待资源的所有线程结束等待</span><br><span class="line"></span><br><span class="line">因为任意对象都可以作为锁对象，所以这3个方法使定义在Java.lang.Object中。这3个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.illegalMonitorStateException.</span><br><span class="line"></span><br><span class="line">调用方式为:锁对象.wait(),锁对象.notify(),锁对象.notifyAll()</span><br></pre></td></tr></table></figure>

<p>线程的同步通信代码示例，下面以存款取款两个线程为例</p>
<p>1.定义账户Account类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String name,<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.定义存钱和取钱的类（均实现了Runnable接口）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deposit</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">private</span> Runnable withdraw;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Deposit</span><span class="params">(Account account,Runnable withdraw)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.withdraw = withdraw;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="string">""</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> money = (<span class="keyword">int</span>)(Math.random()*<span class="number">2000</span> + <span class="number">1</span>);</span><br><span class="line">                account.setMoney(account.getMoney() + money);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"存钱"</span> + money + <span class="string">",余额为："</span> + account.getMoney());</span><br><span class="line">                <span class="keyword">if</span>(((Withdraw)withdraw).getMoney() &lt; account.getMoney())&#123;</span><br><span class="line">                    <span class="comment">//这里是判断账户中的钱是否够取，够则唤醒取钱线程，其实也可以取钱线程那只要钱不够取就循环wait也可以，这里直接notify就不用加判断条件了</span></span><br><span class="line">                    <span class="string">""</span>.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Withdraw</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Withdraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Withdraw</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                 money = ((<span class="keyword">int</span>)(Math.random()*<span class="number">3000</span>)) + <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">synchronized</span> (<span class="string">""</span>)&#123;</span><br><span class="line">                     <span class="keyword">if</span>(money &gt; account.getMoney())&#123;</span><br><span class="line">                         <span class="keyword">try</span> &#123;</span><br><span class="line">                             System.out.println(<span class="string">"余额为"</span> + account.getMoney()  + <span class="string">"，想取"</span> + money +<span class="string">",钱不够取，进入等待状态"</span>);</span><br><span class="line">                             <span class="string">""</span>.wait();</span><br><span class="line">                         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                             e.printStackTrace();</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                         account.setMoney(account.getMoney() - money);</span><br><span class="line">                         System.out.println(Thread.currentThread().getName() + <span class="string">"取钱"</span> + money + <span class="string">",余额为："</span> + account.getMoney());</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main函数如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 让取钱线程每次取随机的钱, 存钱线程也存入随机的钱</span></span><br><span class="line"><span class="comment">保证账号不要负数...</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account(<span class="string">"jack"</span>,<span class="number">5000</span>);</span><br><span class="line">        Withdraw withdraw = <span class="keyword">new</span> Withdraw(account);</span><br><span class="line">        Deposit deposit = <span class="keyword">new</span> Deposit(account,withdraw);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(withdraw);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(deposit);</span><br><span class="line">        thread1.setName(<span class="string">"取钱线程"</span>);</span><br><span class="line">        thread2.setName(<span class="string">"存钱线程"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>树</title>
    <url>/2020/04/19/%E6%A0%91/</url>
    <content><![CDATA[<h3 id="一、二叉树"><a href="#一、二叉树" class="headerlink" title="一、二叉树"></a>一、二叉树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二叉树是每个节点最多有两个子树的树结构。它有5种基本形态：</span><br><span class="line">1.空二叉树</span><br><span class="line">2.只有根节点，没有左右子树</span><br><span class="line">3.只有左子树</span><br><span class="line">4.只有右子树</span><br><span class="line">5.有左子树跟右子树</span><br></pre></td></tr></table></figure>

<p><img src="http://q7s8mko1o.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%845%E7%A7%8D%E5%BD%A2%E6%80%81.png" alt="二叉树基本形态"></p>
<h4 id="二叉树的基本性质"><a href="#二叉树的基本性质" class="headerlink" title="二叉树的基本性质"></a>二叉树的基本性质</h4><ul>
<li><input disabled="" type="checkbox"> <table>
<thead>
<tr>
<th align="left">性质1</th>
<th>非空二叉树上叶子节点数等于双分支节点数加1</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>性质2</strong></td>
<td>二叉树的第i层最多有2^(i-1)个节点</td>
</tr>
<tr>
<td align="left"><strong>性质3</strong></td>
<td>高度为k的二叉树最多有2^k - 1个节点</td>
</tr>
<tr>
<td align="left"><strong>性质4</strong></td>
<td>给定n个节点，能构成h(n)种不同的二叉树，h(n) = C_{2n}^{n}/n+1</td>
</tr>
<tr>
<td align="left"><strong>性质5</strong></td>
<td>具有n个节点的完全二叉树的高度为<code>【log2n】</code>(向下取整)+ 1</td>
</tr>
</tbody></table>
</li>
</ul>
<p>两个特别的二叉树：完全二叉树，满二叉树</p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt=""></p>
<h4 id="二叉树常见的存储方法"><a href="#二叉树常见的存储方法" class="headerlink" title="二叉树常见的存储方法"></a>二叉树常见的存储方法</h4><p>1.通过数组存储</p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8.png" alt=""></p>
<p>2.通过链表存储</p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.png" alt=""></p>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>1.先序遍历</p>
<p>2.中序遍历</p>
<p>3.后序遍历</p>
<p>4.层次遍历</p>
<h3 id="二、二叉排序树"><a href="#二、二叉排序树" class="headerlink" title="二、二叉排序树"></a>二、二叉排序树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二叉排序树又称为二叉查找树、二叉搜索树。它或者是一颗空树，或者是一颗具有如下性质的二叉树：</span><br><span class="line">1）若左子树不空，则左子树上的所有结点的值均小于根结点的值</span><br><span class="line">2）若右子树不空，则右子树的所有结点的值均大于它的根结点的值</span><br><span class="line">3）左右子树也分别为二叉排序树</span><br></pre></td></tr></table></figure>

<p><img src="http://q7s8mko1o.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91.png" alt=""></p>
<p>其高度和结点的个数n为对数关系，检索的时间跟高度为线性关系，故时间复杂度为O(logn)，但是也有可能检索的时间变成线性的情况</p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/%E7%BA%BF%E6%80%A7%E6%83%85%E5%86%B5.png" alt=""></p>
<h3 id="三、哈夫曼树"><a href="#三、哈夫曼树" class="headerlink" title="三、哈夫曼树"></a>三、哈夫曼树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">哈夫曼树也叫最优二叉树，一种带权路径长度（WPL）最短的二叉树。</span><br><span class="line">树的带权路径长度：树中所有的叶子结点的带权路径（权值乘于其到根结点的路径长度）之和</span><br></pre></td></tr></table></figure>

<p>如何构造哈夫曼树</p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.png" alt=""></p>
<h3 id="四、平衡二叉树"><a href="#四、平衡二叉树" class="headerlink" title="四、平衡二叉树"></a>四、平衡二叉树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二叉树排序树由于可能会出现线性的情况，会大大降低数据的检索效率，所以要避免这种情况的发生，从而发明了平衡二叉排序树，又叫AVL树。</span><br><span class="line">平衡二叉树是一种特殊的二叉排序树，它或者为空树，或者左右子数均为平衡二叉树，而且其左右子数的高度差绝对值不大于1。为了保证平衡性，每次插入元素时都会检查平衡是否被破坏掉了，如果是，则要进行相应的旋转。</span><br></pre></td></tr></table></figure>

<p>平衡因子：左子树高度减去右子树高度的差（-1,0,1）</p>
<h4 id="1-平衡二叉树和非平衡二叉树"><a href="#1-平衡二叉树和非平衡二叉树" class="headerlink" title="1.平衡二叉树和非平衡二叉树"></a>1.平衡二叉树和非平衡二叉树</h4><p><img src="http://q7s8mko1o.bkt.clouddn.com/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%9D%9E%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt=""></p>
<h4 id="2-平衡调整"><a href="#2-平衡调整" class="headerlink" title="2.平衡调整"></a>2.平衡调整</h4><p>​    假定向平衡二叉树中插入一个新结点后破坏了平衡二叉树的平衡性，则首先要找出插入新结点后失去平衡的最小子树，然后再调整这棵子树，使之称为平衡子树。值得注意的是，当失去平衡的最小子树被调整为平衡子树后，无须调整原有其它所有的不平衡子树，整个二叉排序树就会称为一棵平衡二叉树。所谓失去平衡的最小子树是以距离插入结点最近，且以平衡因子绝对值大于1的结点作为根的子树，又称为<strong>最小不平衡子树</strong>。</p>
<ul>
<li><p><strong>LL调整</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如下图所示，因为在A的左孩子的左孩子处插入新的结点，导致A的平衡因子从1变成2，不满足平衡的条件，所以要通过旋转。按照大小的关系，结点B应该作为新的根结点。其余两个结点分为作为B的左右子节点才能维持平衡，看起来是A结点绕B结点顺时针旋转一样。</span><br></pre></td></tr></table></figure>

<p><img src="http://q7s8mko1o.bkt.clouddn.com/LL%E5%9E%8B%E8%B0%83%E6%95%B4.png" alt=""></p>
<p>下图中，当在结点5的左子树中插入结点的时候导致不平衡。这种情况调整如下:首先将元素5的左孩子2提升为新的根结点；然后将原来的根结点作为元素2的右孩子；其它各子树按大小关系连接</p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/LL2.png" alt=""></p>
</li>
<li><p><strong>RR调整</strong></p>
<p> 如下图，因为在元素5的右孩子的右孩子插入新的节点，导致元素5的平衡因子从-1变为-2，不满足平衡特性，所以需要通过旋转。按照大小关系，结点元素7应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡，这样看来，就好像节点元素5绕结点元素7逆时针旋转一样。 </p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/RR1.png" alt=""></p>
<p> RR型调整的一般形式如下图所示，表示节点元素4的右子树5(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡( h 表示子树的深度)。这种情况调整如下： </p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/RR2.png" alt=""></p>
</li>
</ul>
<ul>
<li><p>LR调整</p>
<p> 由于节点元素5的左孩子的右子树上插入新节点，导致不平衡。此时元素5的平衡因子由1变为2。第一张图是LR型的最简单形式。显然，按照大小关系，元素3应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡。 </p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/LR1.png" alt=""></p>
<p> 由于节点元素6增加一个左孩子，导致元素4变得不平衡。先顺时针旋转元素7再逆时针旋转4元素达到平衡。 </p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/LR2.png" alt=""></p>
</li>
<li><p>RL调整</p>
<p> 当在元素5的右孩子的左子树增加一个节点7的时候，会造成不平衡的情况。先逆时针旋转成RR情况，再将元素5顺时针旋转。 </p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/RL1.png" alt=""></p>
<p> 第二种情况方法类似，看起来会复杂一点。当在元素7得左孩子6增加左孩子元素5得时候，导致元素4变得不平衡。那么先顺时针调整元素7，再逆时针调整元素4 </p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/RL2.png" alt=""></p>
</li>
</ul>
<h3 id="五、B树和B-树"><a href="#五、B树和B-树" class="headerlink" title="五、B树和B+树"></a>五、B树和B+树</h3><h4 id="1-B树"><a href="#1-B树" class="headerlink" title="1. B树"></a>1. B树</h4><p>B树又称多路平衡查找树，B树中所有结点的<strong><em>孩子结点数</em></strong>的最大值称为B树的阶</p>
<p>一棵m阶B树或为空树，或为满足如下特性的m叉树：<br>1）树中每个结点最多有m棵子树（即至多含有m-1个关键字）<br>2）若根结点不是叶子节点，则至少有两棵子树<br>3）除根结点外的所有非叶结点至少有[m/2]（向上取整）棵子树（即[m/2]-1个关键字）</p>
<p>4）有n个分支的结点有n-1个关键字，它们按递增顺序排列。</p>
<p>5）每个结点的结构为：</p>
<table>
<thead>
<tr>
<th align="center">n</th>
<th align="center"><code>k1</code></th>
<th align="center"><code>k2</code></th>
<th align="center">…</th>
<th align="center"><code>kn</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>p0</code></td>
<td align="center"><code>p1</code></td>
<td align="center"><code>p2</code></td>
<td align="center">…</td>
<td align="center"><code>pn</code></td>
</tr>
</tbody></table>
<p>其中n为该节点中关键字的个数；ki（1≤i≤n）为该结点的关键字，且满足ki&lt;ki+1,pi为该结点的孩子结点指针且满足pi(0≤i≤n)所指结点上的关键字大于ki小于ki+1，p0所指结点上的关键字小于k1，pn所指结点上的关键字大于kn</p>
<p>6）结点内各关键字互不相等，且按从小到大的顺序排列</p>
<p>7）叶节点除于同一层，并不带任何信息；可以用空指针表示，是查找失败到达的位置</p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/B%E6%A0%91.png" alt=""></p>
<p> 那么在查找搜索的过程中，是怎样的访问过程呢？假设查找元素7 </p>
<ul>
<li><p>与根节点比较，得到指针p1</p>
</li>
<li><p>根据p1来到磁盘2，关键字为(9,15),发现小于9，得到指针p1</p>
</li>
<li><p>根据p1来到磁盘5，关键字为(7,8),发现正好有7</p>
</li>
</ul>
<h4 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2. B+树"></a>2. B+树</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	B+树是对B树的升级，特点如下：</span><br><span class="line">1.B+树的所有非叶子结点只存索引数据</span><br><span class="line">2.B+树的叶子结点包含所有的索引值，并且指向数据</span><br><span class="line">3.B+树的所有关键字都包含在叶子结点中，叶子结点构成有序链表，关键字从小到大或从大到小顺序连接</span><br><span class="line">4.有m个孩子的结点就有m个关键字</span><br></pre></td></tr></table></figure>

<p><img src="http://q7s8mko1o.bkt.clouddn.com/B%2B%E6%A0%91.png" alt=""></p>
<h4 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.因为B+树中间结点没有关键字，所以同样大小的磁盘页可以容纳更多的结点元素，也就是说在相同的情况下，B+树更加的矮胖，这样的话，IO次数就比较少。</span><br><span class="line">2.B+树的查询相比B树更加稳定，因为B+树的查询必须到叶子结点，而B树可能在中间结点，也可能在非中间结点。</span><br><span class="line">3.B+树叶子结点形成了有序链表，更加有利于范围的查询</span><br></pre></td></tr></table></figure>

<h4 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以查询元素13为例：</span><br><span class="line"></span><br><span class="line">1.首先与根节点的关键字(10,18,40)比较，13在10和18之间，此时得到P1指针</span><br><span class="line"></span><br><span class="line">2.磁盘2中的关键字为(10,12,15),这时15大于13，所有磁盘6</span><br><span class="line"></span><br><span class="line">3.关键字为(12,13)，找到13</span><br></pre></td></tr></table></figure>



<h3 id="六、红黑树（自平衡二叉搜索树）"><a href="#六、红黑树（自平衡二叉搜索树）" class="headerlink" title="六、红黑树（自平衡二叉搜索树）"></a>六、红黑树（自平衡二叉搜索树）</h3><h4 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.结点要么是红色，要么是黑色</span><br><span class="line">2.根结点是黑色的</span><br><span class="line">3.每个叶子结点是黑色的且不存储数据</span><br><span class="line">4.每个红色结点的两个子节点一定都是黑色</span><br><span class="line">5.对于任一结点，从该结点到可达的叶子结点的所有路径，其黑色结点的数目相同</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>IO流</title>
    <url>/2020/04/18/IO%E6%B5%81/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IO流用来处理设备之间的数据传输。</span><br><span class="line"></span><br><span class="line">Java程序中，对于数据的输入&#x2F;输出操作以”流(stream)” 的方式进行。是指从源节点到目标节点的数据流动</span><br><span class="line"></span><br><span class="line">源节点和目标节点可以是文件、网络、内存、键盘、显示器等等。</span><br><span class="line"></span><br><span class="line">java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。</span><br></pre></td></tr></table></figure>

<h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><ul>
<li>按操所<strong><em>数据单位</em></strong>不同分为字节流(<code>8bit</code>)和字符流(<code>16bit</code>)</li>
<li>按数据流的流向分为输入流和输出流</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td><code>InputStream(基类)</code></td>
<td>Reader(基类)</td>
</tr>
<tr>
<td>输出流</td>
<td><code>OutputStream(基类)</code></td>
<td>Writer(基类)</td>
</tr>
<tr>
<td>流中的数据</td>
<td>二进制字节（8位）</td>
<td>Unicode字符（16位）</td>
</tr>
</tbody></table>
<p>Java中的IO流共涉及40多个类，实际上非常规则，都是从这四个抽象基类派生的</p>
<p>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀</p>
<h3 id="读文件步骤"><a href="#读文件步骤" class="headerlink" title="读文件步骤"></a>读文件步骤</h3><p>无论读取文件是二进制文件还是文本文件，当需要读文件数据时，需要完成以下步骤：</p>
<p>1.使用文件输入流打开指定的文件：</p>
<p>​    对于文本文件，应该使用字符输入流<code>FileReader</code>流</p>
<p>​    对于二进制文件，应该使用字节输入流<code>FileInputStream</code>流</p>
<p>2.读取数据</p>
<p>3.关闭输入流</p>
<h3 id="写文件步骤"><a href="#写文件步骤" class="headerlink" title="写文件步骤"></a>写文件步骤</h3><p>无论是文本文件还是二进制文件，当需要将数据写入文件时，需要完成以下步骤：</p>
<p>1.使用文件输出流打开指定文件：</p>
<p>​    对于文本文件，应该使用字符输出流<code>FileWriter</code>流</p>
<p>​    对于二进制文件，应该使用字节输出流<code>FileOutputStream</code>流</p>
<p>2.将数据写入文件</p>
<p>3.关闭输出流</p>
<p>在打开一个现有文件的输出流以准备写入数据时，有两种方式可供选择</p>
<ul>
<li>以清空方式打开</li>
<li>以添加方式打开</li>
</ul>
<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组,缓冲流要套接在节点流上，即内部关联了节点流</span><br><span class="line">根据数据操作单位，可分为：</span><br><span class="line">BufferedInputStream和BufferedOutputStream</span><br><span class="line">BufferedReader和BufferedWriter</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 包装就是对象关联</span></span><br><span class="line">            fileReader = <span class="keyword">new</span> FileReader(<span class="string">"HashMap.java.bak"</span>);</span><br><span class="line">            bufferedReader = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">            String line; <span class="comment">// readLine()方法是最有价值方法！！！！！</span></span><br><span class="line">            <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123; <span class="comment">// 直接从输入 流中读一行字符串</span></span><br><span class="line">                System.out.println(line); <span class="comment">// line中没有了换行。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 只需要关闭高级流， 因为在关闭高级流时，会自动地顺带把低级流关闭了</span></span><br><span class="line">            <span class="keyword">if</span> (bufferedReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bufferedReader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileWriter fileWriter = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter bufferedWriter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileWriter = <span class="keyword">new</span> FileWriter(<span class="string">"使用缓冲流写文本"</span>);</span><br><span class="line">            bufferedWriter = <span class="keyword">new</span> BufferedWriter(fileWriter);</span><br><span class="line">            <span class="comment">// 处理数据</span></span><br><span class="line">            String[] content = &#123;</span><br><span class="line">                                <span class="string">"我是一些内容的字符串1"</span>,</span><br><span class="line">                                <span class="string">"我是一些内容的字符串2"</span>,</span><br><span class="line">                                <span class="string">"我是一些内容的字符串3"</span>,</span><br><span class="line">                                <span class="string">"我是一些内容的字符串4"</span>,</span><br><span class="line">                                <span class="string">"我是一些内容的字符串5"</span>,</span><br><span class="line">                                <span class="string">"我是一些内容的字符串6"</span>,</span><br><span class="line">                                <span class="string">"我是一些内容的字符串7"</span>,</span><br><span class="line">                                <span class="string">"我是一些内容的字符串8"</span>,</span><br><span class="line">                                <span class="string">"213424982374982374892734234"</span>,</span><br><span class="line">                                <span class="string">"falksdflakslskajflkajsdfkljasdf"</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; content.length; i++) &#123;</span><br><span class="line">                bufferedWriter.write(content[i]);</span><br><span class="line">                bufferedWriter.newLine(); <span class="comment">// 写跨平台的换行， 这是最有价值方法***</span></span><br><span class="line">                <span class="comment">/* 使用上面的方法代替</span></span><br><span class="line"><span class="comment">                bufferedWriter.write(13);</span></span><br><span class="line"><span class="comment">                bufferedWriter.write(10);</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bufferedWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bufferedWriter.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectInputStream和ObjectOutputStream.用于存储和读取对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</span><br></pre></td></tr></table></figure>

<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">       BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 二进制文件中保存的数据通常是内存数据的副本。</span></span><br><span class="line">       ObjectOutputStream oos = <span class="keyword">null</span>; <span class="comment">// 字节流一定是处理二进制文件。</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"二进制文件"</span>);</span><br><span class="line">           bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">           oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">           oos.writeInt(<span class="number">10</span>); <span class="comment">// 写4个字节数据</span></span><br><span class="line">           oos.writeBoolean(<span class="keyword">true</span>); <span class="comment">// 写1个字节数据</span></span><br><span class="line">           oos.writeBoolean(<span class="keyword">false</span>);</span><br><span class="line">           oos.writeLong(<span class="number">20</span>); <span class="comment">// 写8字节</span></span><br><span class="line">           oos.writeDouble(<span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">           oos.writeUTF(<span class="string">"abc我和你qqq"</span>); <span class="comment">// UTF8格式的字符串</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (oos != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   oos.close();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">       BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">       ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           fis = <span class="keyword">new</span> FileInputStream(<span class="string">"二进制文件"</span>);</span><br><span class="line">           bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">           ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> i = ois.readInt();</span><br><span class="line">           System.out.println(i);</span><br><span class="line">           <span class="keyword">boolean</span> b1 = ois.readBoolean();</span><br><span class="line">           <span class="keyword">boolean</span> b2 = ois.readBoolean();</span><br><span class="line">           System.out.println(b1);</span><br><span class="line">           System.out.println(b2);</span><br><span class="line">           <span class="keyword">long</span> l = ois.readLong();</span><br><span class="line">           System.out.println(l);</span><br><span class="line">           <span class="keyword">double</span> v = ois.readDouble();</span><br><span class="line">           System.out.println(v);</span><br><span class="line"></span><br><span class="line">           String s = ois.readUTF();</span><br><span class="line">           System.out.println(s);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (ois != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   ois.close();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">转换流：InputStreamReader和OutputStreamWriter</span><br><span class="line">特点：</span><br><span class="line">1.是字符流和字节流之间的桥梁</span><br><span class="line">2.可以用指点的编码方式对字符数据进行读取</span><br></pre></td></tr></table></figure>

<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test20</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//FileReader fileReader = null; // 这个类太烂了, 不能处理其他编码</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        InputStreamReader isr = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader buf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">"ArrayList.java"</span>);</span><br><span class="line">            <span class="comment">//isr = new InputStreamReader(fis); // 使用的还是项目默认编码方式</span></span><br><span class="line">            isr = <span class="keyword">new</span> InputStreamReader(fis, <span class="string">"gbk"</span>); <span class="comment">// 指定编码方式</span></span><br><span class="line">            buf = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">            String s;</span><br><span class="line">            <span class="keyword">while</span> ((s = buf.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (buf != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buf.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test21</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter buf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"转换流写文本"</span>);</span><br><span class="line">            <span class="comment">//osw = new OutputStreamWriter(fos); // 转换时以默认编码方式</span></span><br><span class="line">            osw = <span class="keyword">new</span> OutputStreamWriter(fos, <span class="string">"gbk"</span>); <span class="comment">// 转换时以gbk编码</span></span><br><span class="line">            buf = <span class="keyword">new</span> BufferedWriter(osw);</span><br><span class="line"></span><br><span class="line">            buf.write(<span class="string">"alsdkjfalksjfdlkajsdf"</span>);</span><br><span class="line">            buf.newLine();</span><br><span class="line">            buf.write(<span class="string">"来一些汉字"</span>);</span><br><span class="line">            buf.newLine();</span><br><span class="line">            buf.write(<span class="string">"134234234234234"</span>);</span><br><span class="line">            buf.newLine();</span><br><span class="line">            buf.write(<span class="string">"来一些汉字2"</span>);</span><br><span class="line">            buf.newLine();</span><br><span class="line">            buf.write(<span class="string">"来一些汉字3"</span>);</span><br><span class="line">            buf.newLine();</span><br><span class="line">            buf.write(<span class="string">"来一些汉字4"</span>);</span><br><span class="line">            buf.newLine();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (buf != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buf.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.in是一个输入流</span><br><span class="line">System.out是打印流，也是输出流，但是它可以自动flush</span><br></pre></td></tr></table></figure>

<h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">// 和迭代器一样</span></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123; <span class="comment">// 以行为单位</span></span><br><span class="line">            <span class="keyword">if</span> (scanner.hasNextInt()) &#123;</span><br><span class="line">                <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">                System.out.println(<span class="string">"整数: "</span> + n);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scanner.hasNextDouble()) &#123;</span><br><span class="line">                <span class="keyword">double</span> d = scanner.nextDouble();</span><br><span class="line">                System.out.println(<span class="string">"浮点数 : "</span> + d);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                String next = scanner.nextLine();</span><br><span class="line">                System.out.println(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main2</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream in = System.in;<span class="comment">// 对应的是键盘</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader buf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">            buf = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = buf.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (line.equals(<span class="string">"exit"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (buf != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buf.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="序列化跟反序列化"><a href="#序列化跟反序列化" class="headerlink" title="序列化跟反序列化"></a>序列化跟反序列化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对象的序列化：把对象在GC区中的数据写入输出流ObjectOutputStream WriteObject()，任何想要序列化的对象的类必须实现Serializable接口（标记接口，里面什么方法都没有）。静态属性（类的版本号serialVersionID除外）和transient修饰的成员不能被序列化</span><br><span class="line">对象的反序列化：把输入流中的数据还原成对象</span><br></pre></td></tr></table></figure>

<h4 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.javase.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String school = <span class="string">"atguigu"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">double</span> score; <span class="comment">// 短暂的. 不能被序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> grade, <span class="keyword">double</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", grade="</span> + grade +</span><br><span class="line">                <span class="string">", score="</span> + score +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getGrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGrade</span><span class="params">(<span class="keyword">int</span> grade)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">double</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 对象序列化,其中对象数组和集合都是作为writeObject的参数的</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"对象序列化"</span>);</span><br><span class="line">            objectOutputStream  = <span class="keyword">new</span> ObjectOutputStream(fileOutputStream);</span><br><span class="line">            Student a = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"小明"</span>, <span class="number">1</span>, <span class="number">99</span>);</span><br><span class="line">            Student b = <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">"小红"</span>, <span class="number">1</span>, <span class="number">99</span>);</span><br><span class="line">            Student[] arr = &#123;a,b&#125;;</span><br><span class="line">            objectOutputStream.writeObject(arr);</span><br><span class="line">            <span class="comment">//objectOutputStream.writeObject(a);</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(objectOutputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectOutputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 对象反序列化</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"对象序列化"</span>));</span><br><span class="line">            <span class="comment">//Object o = objectInputStream.readObject();</span></span><br><span class="line">            Student[] students = (Student[])objectInputStream.readObject();</span><br><span class="line">            <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">                System.out.println(student);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(objectInputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectInputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>泛型和通配符</title>
    <url>/2020/04/18/%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?是泛型通配符，表示类型未知</span><br></pre></td></tr></table></figure>

<h3 id="使用类型通配符"><a href="#使用类型通配符" class="headerlink" title="使用类型通配符"></a>使用类型通配符</h3><p>1）无限制的类型通配符</p>
<p>比如：List<?>,Map<?,?>   List&lt;?&gt;中的？表示未知类型，所以是不能往里面添加具体的类型对象的，只有null的类型未知，所以是可以添加null的；但是可以读取元素的，因为无论集合里面的真实类型是什么，都可以用Object接收，代码实例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//List&lt;Number&gt; list = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line">        <span class="comment">// 左面的list可以保存Number及其子类对象, 如果添加Double是可以的</span></span><br><span class="line">        <span class="comment">// 右面的List只能保存Integer， 但是右面实际不允许</span></span><br><span class="line">        <span class="comment">// 所以泛型不能直接多态</span></span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            list1.add((<span class="keyword">int</span>)(Math.random() * <span class="number">20</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">        <span class="comment">// ?是泛型通配符， 表示类型未知。</span></span><br><span class="line">        List&lt;?&gt; list2 = list1; <span class="comment">// ?表示未知。</span></span><br><span class="line">        <span class="comment">// list2中保存未知类型的对象</span></span><br><span class="line">        <span class="comment">//list2.add(200); // 不能添加， 因为200是已知类型</span></span><br><span class="line">        <span class="comment">//list2.add("abc") 添加时类型确定的不能添加</span></span><br><span class="line">        list2.add(<span class="keyword">null</span>); <span class="comment">// 因为null类型不确定。</span></span><br><span class="line">        Object obj = list2.get(<span class="number">0</span>); <span class="comment">// 可以获取元素，但是都是Object类型</span></span><br><span class="line">        List&lt;?&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<p><strong><em>所以对于List&lt;?&gt;只能读，不能写（null除外）</em></strong></p>
<p>2）有限制的类型通配符</p>
<p>&lt;? super Number&gt;//有限的通配符?表示未知，super表示父dan类，即表示Number和其<strong><em>未知</em></strong>父类类型，此类型一定可以兼容Number，下限是Number，可以添加元素，但是只能添加Number及其子类（适用于添加元素，但是不适合获取元素）实例代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 有限的通配符 ? 表示未知 super表示父类</span></span><br><span class="line">      <span class="comment">// Number及其未知父类类型， 此类型一定可以兼容Number</span></span><br><span class="line">      <span class="comment">// 下限是Number, 上限未知。</span></span><br><span class="line">      <span class="comment">// &lt;? super Number&gt; 适用于添加元素，但是不适合取元素</span></span><br><span class="line">      List&lt;? <span class="keyword">super</span> Number&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 可以添加元素，但是只能添加Number及其子类。</span></span><br><span class="line">      list1.add(<span class="number">200</span>); <span class="comment">// 200可以被Number及未知父类兼容</span></span><br><span class="line">      list1.add(<span class="number">3.22</span>);</span><br><span class="line">      <span class="comment">//list1.add(new Object()); Object对象不能添加，因为它是已知父类</span></span><br><span class="line">      Object object = list1.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>&lt;? extends Number&gt;//有限的通配符?表示未知，extends表示子类，即表示Number和其<strong><em>未知</em></strong>子类类型，上限是Number，下限未知（适用于获取元素，但是不适合添加元素）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Number及其未知子类类型</span></span><br><span class="line">    <span class="comment">// 上限是Number下限未知</span></span><br><span class="line">    <span class="comment">// &lt;? extends Number&gt; 不适用于添加元素, 适用于获取元素</span></span><br><span class="line">    List&lt;? extends Number&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//list2.add(200); // 200是已知子类， 不能添加</span></span><br><span class="line">    <span class="comment">//list2.add(3.22); // 3.22也是已知子类，集合要求的是未知子类</span></span><br><span class="line">    Number number = list2.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="通配符使用示例代码"><a href="#通配符使用示例代码" class="headerlink" title="通配符使用示例代码"></a>通配符使用示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Comparable <span class="title">max</span><span class="params">(Collection&lt;? extends Comparable&gt; collection)</span> </span>&#123;</span><br><span class="line">       Iterator&lt;? extends Comparable&gt; iterator = collection.iterator();</span><br><span class="line">       <span class="keyword">if</span> (!iterator.hasNext()) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       Comparable max = iterator.next(); <span class="comment">// 假设第一个元素最大</span></span><br><span class="line">       <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">           Comparable next = iterator.next();</span><br><span class="line">           <span class="keyword">if</span> (next.compareTo(max) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               max = next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           list1.add((<span class="keyword">int</span>) (Math.random() * <span class="number">20</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(list1);</span><br><span class="line">       System.out.println(max(list1));</span><br><span class="line">       List&lt;Double&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           list2.add((Math.random() * <span class="number">20</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(list2);</span><br><span class="line">       System.out.println(max(list2));</span><br><span class="line">       Set&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           set1.add((<span class="keyword">int</span>)(Math.random() *<span class="number">30</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(set1);</span><br><span class="line">       System.out.println(max(set1));</span><br><span class="line"></span><br><span class="line">       Set&lt;String&gt; set2 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">       set2.add(<span class="string">"aaa"</span>);</span><br><span class="line">       set2.add(<span class="string">"cc"</span>);</span><br><span class="line">       set2.add(<span class="string">"113"</span>);</span><br><span class="line">       set2.add(<span class="string">"qqq"</span>);</span><br><span class="line">       set2.add(<span class="string">"32084923"</span>);</span><br><span class="line">       set2.add(<span class="string">"汉字"</span>);</span><br><span class="line">       set2.add(<span class="string">"QQQ"</span>);</span><br><span class="line">       System.out.println(max(set2));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2020/04/18/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	泛型时JDK1.5新加入的，解决数据类型的安全性问题。其主要原理是在类声明时通过一个标识标识类中某个属性的类型或者方法的返回值及参数类型。这样在类声明或实例化时只要指定要具体的类型即可。Java泛型可以保证代码如果代码在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时代码更加简洁健壮。</span><br><span class="line">1.为什么要有泛型？</span><br><span class="line">	1）解决元素存储的安全性问题</span><br><span class="line">	2）解决获取数据元素时，需要类型强转的问题</span><br></pre></td></tr></table></figure>



<h3 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h3><p>​    1）自定义泛型类Person，然后在测试类中使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//&lt;T&gt;表示某种类型，泛型参数，是隶属于对象的，待创建对象时才会确定具体的数据类型</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> T  info;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, T info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(T info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在测试类中使用泛型类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Person&lt;Integer&gt; person = <span class="keyword">new</span> Person&lt;Integer&gt;(<span class="string">"张三"</span>,<span class="number">123</span>);<span class="comment">//泛型属性在创建对象时指定为Interger类型</span></span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="string">"adf"</span>);<span class="comment">//不用泛型也可以，即泛型兼容Object</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类声明签名中指定的泛型是属于对象的，等到生成具体的实例时才能确定，所以static方法中是不能用的，但是可以声明泛型方法，泛型方法声明示例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span></span>&#123;</span><br><span class="line">    <span class="comment">//泛型方法</span></span><br><span class="line">    <span class="comment">//泛型方法一定要有参数，用于确定泛型类型</span></span><br><span class="line">    <span class="keyword">public</span> &lt;B&gt; <span class="function">B <span class="title">test2</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">        <span class="comment">//B是局部泛型，只能在本方法中用</span></span><br><span class="line">        B b1 = b;</span><br><span class="line">        <span class="keyword">return</span> b1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在测试类中使用泛型方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        GenericMethod genericMethod = <span class="keyword">new</span> GenericMethod();</span><br><span class="line">        String s = genericMethod.test2(<span class="string">"123"</span>);<span class="comment">//调用泛型方法test2()传入类型为String，所以编译器就感知到了返回类型就是String</span></span><br><span class="line">        Object o = genericMethod.test2(<span class="keyword">null</span>);<span class="comment">//null是没有数据类型的，传null无法让方法感知类型，只能用Object接收</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型结合继承"><a href="#泛型结合继承" class="headerlink" title="泛型结合继承"></a>泛型结合继承</h3><p>父类代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T field;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setField</span><span class="params">(T field)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.field = field;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类在继承有泛型的父类时写法有以下三种</p>
<p>1）子类不理会父类的泛型（不推荐这种写法,父类的泛型未得到利用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub1</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>2）指定特定的泛型。泛型是固定的，不会变，缺点是当需要指定不同的类型时，就需要多写几个子类，推荐使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub21</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">String</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub22</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>3）下面的写法最灵活，因为子类的泛型也不固定,也推荐使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub3</span>&lt;<span class="title">A</span>&gt; <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">A</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2020/04/17/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java集合类可以用于存储数量不等的多个对象。可以将它简单地看作是一个可变长度的Object数组</span><br></pre></td></tr></table></figure>

<h4 id="Java集合可分为Collection和Map两种体系"><a href="#Java集合可分为Collection和Map两种体系" class="headerlink" title="Java集合可分为Collection和Map两种体系"></a>Java集合可分为Collection和Map两种体系</h4><ul>
<li><h4 id="Collection接口：表示不按添加顺序存放对象的集合，集合内元素可以重复，即无序可重复集合"><a href="#Collection接口：表示不按添加顺序存放对象的集合，集合内元素可以重复，即无序可重复集合" class="headerlink" title="Collection接口：表示不按添加顺序存放对象的集合，集合内元素可以重复，即无序可重复集合"></a>Collection接口：表示不按添加顺序存放对象的集合，集合内元素可以重复，即无序可重复集合</h4><ul>
<li><h5 id="Set接口：元素无序，不可重复的集合"><a href="#Set接口：元素无序，不可重复的集合" class="headerlink" title="Set接口：元素无序，不可重复的集合"></a>Set接口：元素无序，不可重复的集合</h5><ul>
<li><p>Hashset：基于数组,链表使用哈希算法实现</p>
<p>​    优点：检索插入删除性能都好</p>
</li>
<li><p>TreeSet：基于二叉搜索树（红黑树）实现，适用于大量的检索场景</p>
<p>​    优点：对内存要求低，检索速度快</p>
<p>​    缺点：插入和删除速度慢</p>
</li>
</ul>
</li>
<li><h5 id="List接口：元素有序，可重复的集合"><a href="#List接口：元素有序，可重复的集合" class="headerlink" title="List接口：元素有序，可重复的集合"></a>List接口：元素有序，可重复的集合</h5><ul>
<li><p>ArrayList:基于数组实现：适用于存档数据，检索操作多的情况</p>
<p>​    优点：检索速度快，末端插入数据快</p>
<p>​    缺点：对内存要求高，要求连续，非末端删除和插入速度很慢</p>
</li>
<li><p>LinkedList:基于链表实现：适用于频繁修改的情况</p>
<p>​    优点：对内存要求低，不要求连续，插入删除速度快</p>
<p>​    缺点：检索速度慢</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="Map接口：具有映射关系”key-value对”的集合"><a href="#Map接口：具有映射关系”key-value对”的集合" class="headerlink" title="Map接口：具有映射关系”key value对”的集合"></a>Map接口：具有映射关系”key value对”的集合</h4></li>
</ul>
<h3 id="Collction接口继承树"><a href="#Collction接口继承树" class="headerlink" title="Collction接口继承树"></a><code>Collction</code>接口继承树</h3><p>  <img src="http://q7s8mko1o.bkt.clouddn.com/collction%E7%BB%A7%E6%89%BF%E6%A0%91.png?imageView2/2/w/308/h/210/interlace/1/q/100&last_modify=15871067981604308" alt="collction继承树"></p>
<p>  类图</p>
<p>  <img src="http://q7s8mko1o.bkt.clouddn.com/collction%E6%A1%86%E6%9E%B6%E7%B1%BB%E5%9B%BE.png?imageView2/2/w/308/h/210/interlace/1/q/100&last_modify=15871070818640616" alt=""></p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>









































]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>包装类</title>
    <url>/2020/04/15/%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">所有的数据类型都有对应包装类型</span><br></pre></td></tr></table></figure>

<h3 id="Integer包装类的经典试题"><a href="#Integer包装类的经典试题" class="headerlink" title="Integer包装类的经典试题"></a>Integer包装类的经典试题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Integer m = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">       Integer n = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">       System.out.println(m == n);<span class="comment">//false</span></span><br><span class="line">       Integer x = <span class="number">1</span>;</span><br><span class="line">       Integer y = <span class="number">1</span>;</span><br><span class="line">       System.out.println(x == y);<span class="comment">//true</span></span><br><span class="line">       Integer a = <span class="number">128</span>;</span><br><span class="line">       Integer b = <span class="number">128</span>;</span><br><span class="line">       System.out.println(a == b);<span class="comment">//false</span></span><br><span class="line">       System.out.println(<span class="number">128</span> == a);<span class="comment">//true,常量跟变量比较，变量自动拆箱，这里其实就是比较128==128</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>分析如下：</p>
<p>​    1）m和n分别指向堆中两个不同的对象，显然m==n是false</p>
<p>​    2）Integer x = 1；Integer y = 1;是一个自动装箱的过程，只要被装箱的数i符合-128&lt;= i &lt;127,则返回Integer内部的一个缓存数组中的值，不会新生产对象，所以x==y是true</p>
<p>​    3）Integer x = 128；128不在-128~127的范围内，会生成新的对象，所以a==b是false</p>
<p>Integer自动装箱的源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">          <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>IntegerCache</code>类的属性定义代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cache[]的初始化如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">h = <span class="number">127</span>;</span><br><span class="line">high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br></pre></td></tr></table></figure>

<p>其它的包装类跟Integer类似</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>String,StringBuilder,StringBuffer</title>
    <url>/2020/04/14/String,StringBuffer,StringBuilder/</url>
    <content><![CDATA[<h3 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h3><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String字面量是不允许修改的，String类型的字符串拼接只要有变量参与，则拼接运算就是在GC区中进行的，拼接过程中会在GC区中开辟空间存储新的字符串。如果是多个字面量进行拼接，如&quot;a&quot; + &quot;b&quot;,在编译过程中会直接拼接为&quot;ab&quot;，结果存在常量池中。</span><br></pre></td></tr></table></figure>

<h3 id="2-常用方法介绍"><a href="#2-常用方法介绍" class="headerlink" title="2.常用方法介绍"></a>2.常用方法介绍</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String 字符串 : 内容不可改变的Unicode字符的序列. 内部使用char[]来保存所有字符</span></span><br><span class="line"><span class="comment"> * String s = "abc"; s 指向一个字符串对象</span></span><br><span class="line"><span class="comment"> * s += 200;  // 用原来的内拼接200, 拼接的结果是一个新的字符串对象, 再把新对象地址刷回给s</span></span><br><span class="line"><span class="comment"> * 字符串的任何修改都会产生一个新对象. 对象使用很安全. 缺点是会产生大量对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 字符串常量(字面量)保存在内存中的常量区(jdk8以前常量区是方法区的一部分)</span></span><br><span class="line"><span class="comment"> * 拼接中只要有变量参与, 拼接的新串就一定在GC区.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * String str = new String("abc");</span></span><br><span class="line"><span class="comment"> * "abc"本身在常量区, 内部的char[] 也在常量区</span></span><br><span class="line"><span class="comment"> * str引用指向的String对象在GC区, 对象的属性value指向的char[]在常量区</span></span><br><span class="line"><span class="comment"> *                  0 2  5     11   16       21        27       33    38</span></span><br><span class="line"><span class="comment"> * String string = "  abcABCqq 1234 我喜欢你,你喜欢我吗?我不喜欢你 YYzz  ";</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * public int length() 获取字符串长度, string.length() =&gt; 39</span></span><br><span class="line"><span class="comment"> * public char charAt(int index),获取参数指定下标处的字符, string.charAt(17) =&gt; '喜', string.charAt(3) =&gt; 'b'</span></span><br><span class="line"><span class="comment"> * public char[] toCharArray() 返回字符串内部字符数组的复制品</span></span><br><span class="line"><span class="comment"> *      System.arraycopy(value, 0, result, 0, value.length); 数组的复制</span></span><br><span class="line"><span class="comment"> *      // 第1个参数是源数组对象, 第2个参数是源数组的开始下标, 第3个参数是目标数组对象, 第4个参数是目标数组的开始下标, 第5个参数是复制的元素个数</span></span><br><span class="line"><span class="comment"> * public boolean equals(Object anObject)</span></span><br><span class="line"><span class="comment"> * public int compareTo(String anotherString) // 以字符的Unicode为比较依据</span></span><br><span class="line"><span class="comment"> * public int indexOf(String s) 获取参数中的子串s在当前字符串中首次出现的下标索引</span></span><br><span class="line"><span class="comment"> *          string.indexOf("喜欢") =&gt; 17</span></span><br><span class="line"><span class="comment"> *          string.indexOf("讨厌") =&gt; -1 表示子串不存在.</span></span><br><span class="line"><span class="comment"> * public int indexOf(String s ,int startpoint) // 从第二个参数指定的下标开始搜索子串出现的下标</span></span><br><span class="line"><span class="comment"> *          string.indexOf("喜欢", 18) =&gt; 22</span></span><br><span class="line"><span class="comment"> *          string.indexOf("喜欢", 23) =&gt; 29</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * public int lastIndexOf(String s) 从右向左搜索子串首次出现的下标</span></span><br><span class="line"><span class="comment"> *          string.lastIndexOf("喜欢") =&gt; 29</span></span><br><span class="line"><span class="comment"> * public int lastIndexOf(String s ,int startpoint)</span></span><br><span class="line"><span class="comment"> *          string.lastIndexOf("喜欢", 28) =&gt; 22</span></span><br><span class="line"><span class="comment"> *          string.lastIndexOf("喜欢", 21) =&gt; 17</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * public boolean startsWith(String prefix) 判断当前串是否以参数中的子串为开始</span></span><br><span class="line"><span class="comment"> *          string.startsWith("  abc") =&gt; true</span></span><br><span class="line"><span class="comment"> * public boolean endsWith(String suffix)判断当前串是否以参数中的子串为结束</span></span><br><span class="line"><span class="comment"> *          string.endsWith("YYzz") =&gt; false;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * public String substring(int start,int end) 从当前字符串中截取子串, 以start为开始索引(包含), 以end为结束索引(不包含)</span></span><br><span class="line"><span class="comment"> *          string.substring(16, 20) =&gt; "我喜欢你"</span></span><br><span class="line"><span class="comment"> * public String substring(int startpoint) 从startpoint到最后取子串</span></span><br><span class="line"><span class="comment"> *          string.substring(21) 等价于 string.substring(21, string.length());</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * public String replace(char oldChar,char newChar) 把当前串中的所有的oldChar全部替换为newChar, 返回新串</span></span><br><span class="line"><span class="comment"> *          string.replace(' ', '#');</span></span><br><span class="line"><span class="comment"> * public String replaceAll(String old,String new)</span></span><br><span class="line"><span class="comment"> *          string.replaceAll(" ", "#");</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * public String trim() 修剪字符串首尾的空白字符.(码值小于等于32的都是空白字符)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * public String concat(String str)</span></span><br><span class="line"><span class="comment"> * public String toUpperCase() 变成大写</span></span><br><span class="line"><span class="comment"> * public String toLowerCase() 变成小写</span></span><br><span class="line"><span class="comment"> * public String[] split(String regex) 把字符串切割成多个部分, 参数中的子串为切割器, 切割的结果中不包含切割器</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="StringBuffer类和StringBuilder类"><a href="#StringBuffer类和StringBuilder类" class="headerlink" title="StringBuffer类和StringBuilder类"></a>StringBuffer类和StringBuilder类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">内容可以改变的Unicode字符序列, 内部仍然使用char[]保存字符序列, 可以添加和删除的, 对它的修改不会产生新对象,StringBuffer和StringBuilder类常用方法类似，StringBuilder是最新的替代StringBuffer,速度更快，但是线程不安全；StringBuffer是老的API，速度慢，线程安全。</span><br></pre></td></tr></table></figure>

<p>常用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">append</span><span class="params">(...)</span> <span class="comment">//可以在当前串后面追加任意数据</span></span></span><br><span class="line"><span class="function">StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, ....)</span> <span class="comment">//在指定下标处插入新内容</span></span></span><br><span class="line"><span class="function">StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> <span class="comment">//删除一个区间</span></span></span><br><span class="line"><span class="function">StringBuffer <span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span> ch)</span></span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>异常</title>
    <url>/2020/04/11/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h3 id="1-异常类型分类"><a href="#1-异常类型分类" class="headerlink" title="1.异常类型分类"></a>1.异常类型分类</h3><p>异常按照类型分为两大类：</p>
<ul>
<li><p>受检异常</p>
<p>受检异常是指程序中必须检查和处理的异常，由Exception类表示（RuntimeException除外）</p>
</li>
<li><p>非受检异常</p>
<p>非受检异常是程序中可以不接受检查和处理（轻微的异常可以不处理），或致命性的异常（致命异常没法处理）</p>
</li>
</ul>
<p>分类如下图所示</p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/%E5%BC%82%E5%B8%B8.png" alt="异常分类"></p>
<h3 id="2-异常捕获"><a href="#2-异常捕获" class="headerlink" title="2.异常捕获"></a>2.异常捕获</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//GC只能释放GC区中的资源，finally中释放的是不在GC区中的资源，通常是像OS申请的硬件资源</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>finally中的代码不管try中是否异常都会执行，当try中有return语句时，会先将return的值保存在临时变量中，然后执行finally代码块，如果finally中有return语句，则以finally中的返回语句为主，否则执行try中的return</p>
<p>实例代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//因为有finally代码块，所以这里会将n的值放到临时空间中，然后去执行finally语句块的代码</span></span><br><span class="line">            <span class="comment">//如果finally有return,则直接return，没有则从try中的return路径返回</span></span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            ++n;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(test());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>



<h3 id="3-异常抛出"><a href="#3-异常抛出" class="headerlink" title="3.异常抛出"></a>3.异常抛出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）在方法签名中使用throws 异常类型   发出异常警告表明方法中可能会抛出某种异常，受检异常一定要在方法签名发出异常警告，RuntimeException这种非受检异常则可以也可以不用通过throws发出异常警告。 </span><br><span class="line">2）在方法中使用throw将异常抛出。</span><br><span class="line">3）也可以捕获后对异常进行包装再抛出，项目中一般都是捕获后包装为自定义异常。</span><br></pre></td></tr></table></figure>

<h3 id="4-自定义异常"><a href="#4-自定义异常" class="headerlink" title="4.自定义异常"></a>4.自定义异常</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）继承Exception</span><br><span class="line">2）提供两个构造器，一个String参数，一个Throwable参数</span><br></pre></td></tr></table></figure>



<h3 id="5-什么时候捕获异常，什么时候捕获异常呢？"><a href="#5-什么时候捕获异常，什么时候捕获异常呢？" class="headerlink" title="5.什么时候捕获异常，什么时候捕获异常呢？"></a>5.什么时候捕获异常，什么时候捕获异常呢？</h3><p>​    当存在异常时，被调用的方法应该抛出异常（它出问题时对栈的影响不大），目的是给调用者一个出问题的信号；入口方法（main）应该捕获异常，因为它一旦抛出异常。会导致栈作废</p>
<h3 id="6-补充"><a href="#6-补充" class="headerlink" title="6.补充"></a>6.补充</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法重写，覆盖的条件</span><br><span class="line">1）方法签名一致：返回值类型（子类返回值类型可以小于等于父类的），方法名，参数列表一致</span><br><span class="line">2）子类方法的访问修饰符要大于等于父类的</span><br><span class="line">3）被覆盖的方法不能由private,static,final修饰</span><br><span class="line">4）子类抛出的异常类型必须小于等于父类的异常类型</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2020/04/10/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="代理模式简述"><a href="#代理模式简述" class="headerlink" title="代理模式简述"></a>代理模式简述</h3><p>代理模式其实就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。一般下面两种情况会使用到代理模式</p>
<p>1）使用者无法直接使用到被代理的对象，比如在大城市租房，几乎是没法找到直接房东的，只好找中介代理</p>
<p>2）没法去修改被代理对象的功能，但需要对其中的业务方法进行升级，所以就需要通过代理对象和被代理对象关联起来，进而实现业务方法的增强</p>
<p>以租房代码举例</p>
<p>租房接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HouseRent</span> </span>&#123;</span><br><span class="line">    <span class="comment">//租房</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现租房接口的房东(具备房源)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Landlord</span> <span class="keyword">implements</span> <span class="title">HouseRent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是房东爸爸，月租100，想租请联系12435325"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span> <span class="keyword">implements</span> <span class="title">HouseRent</span> </span>&#123;</span><br><span class="line">    HouseRent landlord = <span class="keyword">new</span> Landlord();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是租房中介：押二付一"</span>);</span><br><span class="line">        landlord.rent();</span><br><span class="line">        System.out.println(<span class="string">"租房完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>租房的测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Landlord</span> <span class="keyword">implements</span> <span class="title">HouseRent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是房东爸爸，月租100，想租请联系12435325"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>枚举</title>
    <url>/2020/04/10/%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>枚举类型是Java5中新增特性的一部分，它是一种特殊的数据类型，之所以特殊是因为它即是一种类类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性，安全性和便捷性。</p>
<h3 id="简单的枚举定义"><a href="#简单的枚举定义" class="headerlink" title="简单的枚举定义"></a>简单的枚举定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Week&#123;</span><br><span class="line">    MON,TUE,WED,THU,FRI,SAT,SUN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.直接访问</span></span><br><span class="line">        System.out.println(Week.MON);</span><br><span class="line">        <span class="keyword">int</span> i = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//访问枚举对象数组</span></span><br><span class="line">        Week[] weeks = Week.values();</span><br><span class="line">        System.out.println(weeks[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举实现原理"><a href="#枚举实现原理" class="headerlink" title="枚举实现原理"></a>枚举实现原理</h3><p>​    实际上在使用关键字<code>enum</code>创建枚举类型并编译后，编译器会为我们生成一个相关的类，这个类继承了Java API中的<code>java.lang.Enum</code>类，也就是说通过关键字<code>enum</code>创建枚举类型在编译后事实也是一个类类型而且该类继承了<code>java.lang.Enum</code>类。在编译后，会生成对应的<code>Week.class</code>文件，通过<code>xjad</code>工具进行反编译，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.</span></span><br><span class="line"><span class="comment">// Jad home page: http://www.kpdus.com/jad.html</span></span><br><span class="line"><span class="comment">// Decompiler options: packimports(3) fieldsfirst ansi space </span></span><br><span class="line"><span class="comment">// Source File Name:   EnumTest.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.javase.enumtest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Week</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week MON;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week TUE;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week WED;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week THU;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week FRI;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week SAT;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week SUN;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Week $VALUES[];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Week[] values()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (Week[])$VALUES.clone();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Week <span class="title">valueOf</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (Week)Enum.valueOf(com/atguigu/javase/enumtest/Week, name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Week</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(s, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> </span><br><span class="line">	&#123;</span><br><span class="line">		MON = <span class="keyword">new</span> Week(<span class="string">"MON"</span>, <span class="number">0</span>);</span><br><span class="line">		TUE = <span class="keyword">new</span> Week(<span class="string">"TUE"</span>, <span class="number">1</span>);</span><br><span class="line">		WED = <span class="keyword">new</span> Week(<span class="string">"WED"</span>, <span class="number">2</span>);</span><br><span class="line">		THU = <span class="keyword">new</span> Week(<span class="string">"THU"</span>, <span class="number">3</span>);</span><br><span class="line">		FRI = <span class="keyword">new</span> Week(<span class="string">"FRI"</span>, <span class="number">4</span>);</span><br><span class="line">		SAT = <span class="keyword">new</span> Week(<span class="string">"SAT"</span>, <span class="number">5</span>);</span><br><span class="line">		SUN = <span class="keyword">new</span> Week(<span class="string">"SUN"</span>, <span class="number">6</span>);</span><br><span class="line">		$VALUES = (<span class="keyword">new</span> Week[] &#123;</span><br><span class="line">			MON, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看出枚举类型就是实实在在的类，且里面定义的都是静态常量对象，可以直接通过类名访问，也可以通过<code>valueof(),values()</code>访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//1.直接访问</span></span><br><span class="line">       System.out.println(Week.MON);</span><br><span class="line">       <span class="keyword">int</span> i = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">       <span class="comment">//访问枚举对象数组</span></span><br><span class="line">       Week[] weeks = Week.values();</span><br><span class="line">       Week mon = Week.valueOf(<span class="string">"MON"</span>);</span><br><span class="line">       System.out.println(mon);</span><br><span class="line">       System.out.println(weeks[i]);</span><br><span class="line">       <span class="comment">//printWeek(weeks[i]);</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>还可以在枚举中自定义属性，自定义构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Week&#123;</span><br><span class="line">    MON(<span class="string">"红色"</span>),TUE(<span class="string">"橙色"</span>),WED(<span class="string">"黄色"</span>),THU(<span class="string">"绿色"</span>),FRI(<span class="string">"青色"</span>),SAT(<span class="string">"蓝色"</span>),SUN(<span class="string">"紫色"</span>);</span><br><span class="line">    String color;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Week</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Week</span><span class="params">(String color)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">",color:"</span> + color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Week[] values = Week.values();</span><br><span class="line">        <span class="keyword">for</span> (Week value : values) &#123;</span><br><span class="line">            System.out.println(value.toString());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MON,color:红色</span><br><span class="line">TUE,color:橙色</span><br><span class="line">WED,color:黄色</span><br><span class="line">THU,color:绿色</span><br><span class="line">FRI,color:青色</span><br><span class="line">SAT,color:蓝色</span><br><span class="line">SUN,color:紫色</span><br></pre></td></tr></table></figure>

<p>默认的无参构造会在编译后变成两个参数(<strong>*String参数s对应的是常量枚举对象的字符串表示，int参数i对应的是常量枚举对象在数组中的顺序</strong>)的构造方法，一个参数的构造方法在编译后会变成三个参数的构造方法，如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.javase.enumtest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Week</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week MON;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week TUE;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week WED;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week THU;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week FRI;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week SAT;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week SUN;</span><br><span class="line">	String color;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Week $VALUES[];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Week[] values()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (Week[])$VALUES.clone();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Week <span class="title">valueOf</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (Week)Enum.valueOf(com/atguigu/javase/enumtest/Week, name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Week</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(s, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Week</span><span class="params">(String s, <span class="keyword">int</span> i, String color)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(s, i);</span><br><span class="line">		<span class="keyword">this</span>.color = color;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">new</span> StringBuilder()).append(<span class="keyword">super</span>.toString()).append(<span class="string">",color:"</span>).append(color).toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> </span><br><span class="line">	&#123;</span><br><span class="line">		MON = <span class="keyword">new</span> Week(<span class="string">"MON"</span>, <span class="number">0</span>, <span class="string">"红色"</span>);</span><br><span class="line">		TUE = <span class="keyword">new</span> Week(<span class="string">"TUE"</span>, <span class="number">1</span>, <span class="string">"橙色"</span>);</span><br><span class="line">		WED = <span class="keyword">new</span> Week(<span class="string">"WED"</span>, <span class="number">2</span>, <span class="string">"黄色"</span>);</span><br><span class="line">		THU = <span class="keyword">new</span> Week(<span class="string">"THU"</span>, <span class="number">3</span>, <span class="string">"绿色"</span>);</span><br><span class="line">		FRI = <span class="keyword">new</span> Week(<span class="string">"FRI"</span>, <span class="number">4</span>, <span class="string">"青色"</span>);</span><br><span class="line">		SAT = <span class="keyword">new</span> Week(<span class="string">"SAT"</span>, <span class="number">5</span>, <span class="string">"蓝色"</span>);</span><br><span class="line">		SUN = <span class="keyword">new</span> Week(<span class="string">"SUN"</span>, <span class="number">6</span>, <span class="string">"紫色"</span>);</span><br><span class="line">		$VALUES = (<span class="keyword">new</span> Week[] &#123;</span><br><span class="line">			MON, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2020/04/10/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">内部类：在类中再定义其它类</span><br></pre></td></tr></table></figure>

<h3 id="1-内部类分类"><a href="#1-内部类分类" class="headerlink" title="1.内部类分类"></a>1.内部类分类</h3><p>​    1）成员内部类：声明在类中方法外的内部类</p>
<ul>
<li><p>普通成员内部类：没有static修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner1</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//普通成员内部类是隶属于外部类对象的,在内部类当中可以随意的访问外部类成员</span></span><br><span class="line">        <span class="comment">//普通的成员内部类中不能由static属性，因为是隶属于外部对象的</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inner1Test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"成员内部类的属性："</span> + Inner1.<span class="keyword">this</span>.num);</span><br><span class="line">            System.out.println(<span class="string">"成员内部类访问外部类的属性："</span> + Outer.<span class="keyword">this</span>.num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outerTest1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类方法"</span>);</span><br><span class="line">        Inner1 inner = <span class="keyword">this</span>.<span class="keyword">new</span> Inner1();</span><br><span class="line">        inner.inner1Test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">outerTest2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类的私有方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在外部想要生成一个内部类对象的话代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">       <span class="comment">//直接在测试类中new一个内部类的对象,需要先生成一个外部类的对象，因为非静态内部类是属于外部类对象的</span></span><br><span class="line">       Outer.Inner1 outerInner = outer.<span class="keyword">new</span> Inner1();</span><br><span class="line">       outerInner.inner1Test1();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>静态成员内部类，被static修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//静态成员内部类，加static修饰，本质上和外部类平行的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner2</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outerTest1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类方法"</span>);</span><br><span class="line">        Inner1 inner = <span class="keyword">this</span>.<span class="keyword">new</span> Inner1();</span><br><span class="line">        inner.inner1Test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">outerTest2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"外部类的私有方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在外部生成静态成员内部类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer.Inner2 inner2 = <span class="keyword">new</span> Outer.Inner2();</span><br><span class="line">        System.out.println(inner2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>​         </p>
<p>​    2）局部内部类：声明在方法中的内部类</p>
<ul>
<li><p>普通局部内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 普通局部内部类, 类的定义写在方法中, 不可以加访问控制修饰</span></span><br><span class="line">        <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner3</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Inner3&#123;"</span> +</span><br><span class="line">                        <span class="string">"id="</span> + id +</span><br><span class="line">                        <span class="string">'&#125;'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Inner3 inner3 = <span class="keyword">new</span> Inner3();</span><br><span class="line">        inner3.id = <span class="number">200</span>;</span><br><span class="line">        System.out.println(inner3);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><h4 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a><strong><em>匿名内部类（重点）</em></strong></h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerclassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 匿名内部类，不能后期创建对象，在声明的同时必须创建唯一对象</span></span><br><span class="line">        <span class="comment">//匿名内部类通常就是和接口配合，接口中的方法通常也不多</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * new 父类|接口（）&#123;</span></span><br><span class="line"><span class="comment">        *   类体部分，类体相当于new后面的父类或者接口的实现子类</span></span><br><span class="line"><span class="comment">        * &#125;</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        MyInterface myInterface = <span class="keyword">new</span> MyInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"我是匿名内部类的方法体"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(myInterface.getInfo());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>简单工厂模式</title>
    <url>/2020/04/09/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>1）简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式。</p>
<p>2）简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为。</p>
<p>3）在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用工厂模式</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>注解概述</title>
    <url>/2020/04/09/%E6%B3%A8%E8%A7%A3%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h3><p>自<code>Java5.0</code>版本引入注解之后，它就成为了Java中非常重要的一部分，下面介绍的内容包含以下几个部分：<br>1）什么是注解<br>2）为什么要引入注解<br>3）注解是如何工作的<br>4）如何编写自定义注解？什么时候可以用注解以及<code>ADF</code>（应用开发框架）</p>
<h3 id="1-什么是注解"><a href="#1-什么是注解" class="headerlink" title="1. 什么是注解"></a>1. 什么是注解</h3><p>  用一个词就可以描述注解，那就是元数据，即一种描述数据的数据。所以，可以说注解就是源代码的元数据。比如，下面这段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"This is String Representation of current object."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在这段代码中，用到@Override注解，@Override告诉编译器这个方法是一个重写方法，如果父类方法中不存在这个方法，编译器则会报错，提示该方法没有重写父类中的方法。<br>Annotation是一种应用于类，方法，参数，变量，构造器及包声明中的特殊修饰符。它是一种由JSR-175标准选择用来描述元数据的一种工具</p>
<h3 id="2-为什么要引入注解"><a href="#2-为什么要引入注解" class="headerlink" title="2. 为什么要引入注解"></a>2. 为什么要引入注解</h3><p>​    使用Annotation之前（甚至在使用之后），XML被广泛地应用于描述元数据。不知何时开发一些应用开发人员和架构师发现XML的维护越来越糟糕了。他们希望使用一些代码紧耦合的东西，而不是像XML那样和代码是松耦合的（在某些情况下甚至是完全分离的）代码描述。如果你在Google中搜索“XML vs annotations”,会看到许多关于问题的辩论。最有趣的是XML配置其实就是为了分离代码和配置而引入的。上述两种观点可能会让你很疑惑，但皆有利弊。下面通过一个例子来理解这个二者的区别。<br>​    假如你想为应用设置很多的常量或参数，这种情况下，XML是一个很好的选择，因为它不会痛特定的代码相连。如果你想把某个方法声明为服务，那么使用Annotation会更好一些，因为这种情况下需要注解和方法紧密耦合起来，开发人员也必须认识到这点。<br>​    另一个重要的因素是Annotation定义了一种标准的描述元数据的方式，在这之前，开发人员通常使用他们自己的方式定义元数据。例如，使用标记interfaces,注释，transient关键字等待。每个程序员按照自己的方式定义元数据，而不想Annotation这种标注你的方式。<br>​    目前，许多框架将XML和Annotation两种方式结合使用，平衡两者之间的利弊。</p>
<ul>
<li><p><strong><em>Annotation是如何工作的？怎么编写自定义的Annotation？</em></strong></p>
<p>在讲述这部分之前，建议首先下载Annotation的示例代码<code>AnnotationSample.zip</code>放到<code>IDE</code>中进行理解。<br>编写Annotation非常简单，可以将Annotation的定义同接口的定义进行比较。下面看两个例子：一个是标标准的@Override，另一个是用户自定义注解<code>@Todo</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于@Override注释你可能有些疑问，它什么都没做，那它是如何检查在父类中有一个同名的函数呢。@Override注解的定义不仅仅只有这么一点代码。这部分内容很重要，不得不再次重复：Annotations仅仅是元数据，和业务逻辑无关。理解起来有点困难，但就是这样。如果Annotations不包含业务逻辑，那么必须有人来实现这些逻辑。元数据的用户来做这些事情。<strong><em>Annotations仅仅提供它定义的属性（类/方法/包/域）的信息。Annotations的用户（同样是一些代码）来读取这些信息并实现必要的逻辑。</em></strong><br>当我们使用Java的标注Annotations（例如@Override）时，<code>JVM</code>就是一个用户，它在字节码层面工作。到这里，应用开发人员还不能控制也不能使用自定义的注解。因此，讲解一下如何编写自定义的Annotations。<br>下面将逐个讲述编写自定义Annotations的要点。上面的例子中，你看到一些注解应用在注解上。</p>
<p><code>J2SE5.0</code>版本在<code>java.lang.annotation</code>提供了四种元注解，专门注解其它的注解：</p>
<pre><code>@Documented -注解是否将包含在`JavaDoc`中
@Retention -什么时候使用该注解
@Target -注解用于什么地方
@Inherited -是否允许子类继承该注解</code></pre><p>@Documented -一个简单的Annotations标记注解，表示是否将注解信息添加在Java文档中。<br>@Retention -定义该注解的生命周期</p>
<pre><code>`RetentionPolicy.SOURCE` -在编译阶段丢弃。这些注解只停留在源码，在编译结束之后就不再有意义，所以他们不会写入字节码。`@Override，@SuppressWarnings`都属于这类注解
`RetentionPolicy.CLASS` -在类加载的时候丢弃。在字节码文件的处理中有用，注解默认使用这种方式。
`RetentionPolicy.RUNTIME` -始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式</code></pre><p>@Target -表示该注解用于什么地方。如果不明确指出，该注解可以放在任何地方。以下是一些可用的参数。需要寿命的是：属性的注解是兼容的，如果你想给6个属性都添加注解，仅仅排除一个属性，那么你需要在定义target包含所有的属性。</p>
<pre><code>`ElementTYpe.TYPE`:用于描述类，接口或`enum`声明
`ElementTYpe.FIELD`:用于描述实例变量
`ElementTYpe.METHOD`</code></pre><p>   <code>ElementTYpe.PARAMETER</code><br>   <code>ElementTYpe.CONSTRUCTOR</code><br>   <code>ElementTYpe.LOCAL_VARIABLE</code></p>
<p>   <code>ElementTYpe.ANNOCATION_TYPE</code>另一个注释<br>   <code>ElementTYpe.PACKAGE</code> 用于记录Java文件的package信息<br>@Inherited -定义该注释和子类的关系</p>
<p>那么，注解的内部到底是如何定义的呢？Annotations只支持基本类型、String、枚举类型。注释中所有的属性被定义成方法，并允许提供默认值。</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> Todo &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Priority &#123;LOW, MEDIUM, HIGH&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Status &#123;STARTED, NOT_STARTED&#125;</span><br><span class="line">    <span class="function">String <span class="title">author</span><span class="params">()</span> <span class="keyword">default</span> "Yash"</span>;</span><br><span class="line">    <span class="function">Priority <span class="title">priority</span><span class="params">()</span> <span class="keyword">default</span> Priority.LOW</span>;</span><br><span class="line">    <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">default</span> Status.NOT_STARTED</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    下面的例子演示了如何使用上面的注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Todo</span>(priority = Todo.Priority.MEDIUM, author = <span class="string">"Yashwant"</span>, status = Todo.Status.STARTED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incompleteMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//Some business logic is written</span></span><br><span class="line"><span class="comment">//But it’s not complete yet</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    但目前为止一切看起来都还不错。我们定义了自己的注解并将其应用在业务逻辑的方法上。现在我们需要写一个用户程序调用我们的注解。这里我们需要使用反射机制。如果你熟悉反射代码，就会知道反射可以提供类名、方法和实例变量对象。所有这些对象都有<code>getAnnotation()</code>这个方法用来返回注解信息。我们需要把这个对象转换为我们自定义的注释(使用 <code>instanceOf()</code>检查之后)，同时也可以调用自定义注释里面的方法。看看以下的实例代码，使用了上面的注解:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class businessLogicClass = BusinessLogic<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="keyword">for</span>(Method method : businessLogicClass.getMethods()) &#123;</span><br><span class="line">        Todo todoAnnotation = (Todo)method.getAnnotation(Todo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span>(todoAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">" Method Name : "</span> + method.getName());</span><br><span class="line">        System.out.println(<span class="string">" Author : "</span> + todoAnnotation.author());</span><br><span class="line">        System.out.println(<span class="string">" Priority : "</span> + todoAnnotation.priority());</span><br><span class="line">        System.out.println(<span class="string">" Status : "</span> + todoAnnotation.status());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-注解用例"><a href="#3-注解用例" class="headerlink" title="3. 注解用例"></a>3. 注解用例</h3><p>  注解的功能很强大，Spring和<code>Hebernate</code>这些框架在日志和有效性中大量使用了注解功能。注解可以应用在使用标记接口的地方。不同的是标记接口用来定义完整的类，但你可以为单个的方法定义注释，例如是否将一个方法暴露为服务。</p>
<p>  在最新的<code>servlet3.0</code>中引入了很多新的注解，尤其是和<code>servlet</code>安全相关的注解。</p>
<p>  <code>HandlesTypes</code> –该注解用来表示一组传递给<code>ServletContainerInitializer</code>的应用类。</p>
<p>  <code>HttpConstraint</code> – 该注解代表所有HTTP方法的应用请求的安全约束，和<code>ServletSecurity</code>注释中定义的<code>HttpMethodConstraint</code>安全约束不同。</p>
<p>  <code>HttpMethodConstraint</code> – 指明不同类型请求的安全约束，和<code>ServletSecurity</code>注解中描述HTTP协议方法类型的注释不同。</p>
<p>  <code>MultipartConfig</code> –该注解标注在<code>Servlet</code>上面，表示该<code>Servlet</code>希望处理的请求的 MIME 类型是 <code>multipart/form-data</code>。</p>
<p> <code>ServletSecurity</code> 该注解标注在<code>Servlet</code>继承类上面，强制该HTTP协议请求遵循安全约束。</p>
<p>  <code>WebFilter</code> – 该注解用来声明一个<code>Server</code>过滤器；</p>
<p> <code>WebInitParam</code> – 该注解用来声明<code>Servlet</code>或是过滤器的中的初始化参数，通常配合 <code>@WebServlet</code>或者 <code>@WebFilter</code>使用。</p>
<p> <code>WebListener</code> –该注解为Web应用程序上下文中不同类型的事件声明监听器。</p>
<p> <code>WebServlet</code> –该注解用来声明一个<code>Servlet</code>的配置。</p>
<h3 id="4-ADF（应用程序开发框架）和-注解"><a href="#4-ADF（应用程序开发框架）和-注解" class="headerlink" title="4. ADF（应用程序开发框架）和 注解"></a>4. <code>ADF</code>（应用程序开发框架）和 注解</h3><p>  现在我们开始讨论文章的最后一部分了。应用程序框架，被称为<code>ADF</code>，由Oracle开发用来创建Oracle融合应用。我们已经了解了注解的优缺点，也知道如何编写自定义的注解，但我们应该将注解应用在<code>ADF</code>的哪部分呢？<code>ADF</code>是否提供了一些朴素的注解？很好的问题，确实在<code>ADF</code>中大量使用注解有一些限制。之前提到的应用框架如Spring和Hibernate使用<code>AOP</code>(面向侧面的程序设计)。在<code>AOP</code>中，框架提供了一种机制，在事件的预处理和后续处理中注入代码。例如：你有一个钩子用来在方法执行之前和之后添加代码，所以你可以在这些地方编写你的用户代码。<code>ADF</code>不使用<code>AOP</code>。如果我们有任何注解的用例可用，我们可能需要通过继承的方式实现。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2020/04/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单例模式即某个类中只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。</span><br></pre></td></tr></table></figure>

<h3 id="2-单例模式实现的8种方式"><a href="#2-单例模式实现的8种方式" class="headerlink" title="2.单例模式实现的8种方式"></a>2.单例模式实现的8种方式</h3><ul>
<li><p>2.1.1<strong><em>饿汉式</em></strong>（静态常量）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 饿汉式（静态变量）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  不会造成多线程的同步问题，但是对象是在类加载的时候就初始化了，如果不用就会造成浪费，最好是确</span></span><br><span class="line"><span class="comment">* *定要用到再去生成实例，但是如果确定这个对象会使用，这种方式也是可以使用的</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>2.1.2  <strong><em>饿汉式</em></strong>（静态代码块）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 饿汉式（静态代码块）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//跟上面的是一样的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2.2.1 <strong><em>懒汉式</em></strong>（线程不安全）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 懒汉式（线程不安全）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1）起到了懒加载的效果，但是只能在单线程下使用</span></span><br><span class="line"><span class="comment">* 2）但是在多线程下，如果线程1进入了if(instance == null)语句块，还未来得及往下执行，另一个线程2也通过了这个判断语句，这个时候则会产生多个实例，所以多线程下不可以使用这种方式。</span></span><br><span class="line"><span class="comment">* 3）综上，开发过程中不能使用这种方式</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2.2.2 <strong><em>懒汉式</em></strong>（线程安全,同步问题）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 懒汉式（线程安全，同步方法）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供一个静态的共有方法，加入同步处理的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1）解决了线程不安全问题</span></span><br><span class="line"><span class="comment"> * 2）效率太低了，每个线程在想获得类的实例的时候，执行getInstance()都要同步，而其实这个方法只执行   *一次实例化代码就够了，后面的想要获得该实例，直接return就可以了。</span></span><br><span class="line"><span class="comment">   3）效率太低，不推荐使用	</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2.3.1 双重检查（保证线程安全并且懒加载）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 双重检查</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1）代码中进行了两次if(instance == null)检查，这样可以保证线程安全	</span></span><br><span class="line"><span class="comment">* 2）这样实例化代码只会执行一次，后面再次访问时，判断if(instance == null)，直接return实例化对象，也避免反复进行方法同步</span></span><br><span class="line"><span class="comment">* 3）线程安全；延迟加载；效率较高</span></span><br><span class="line"><span class="comment">* 4）结论：在实际开发过程中，推荐使用这种单例模式</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2.4.1 使用静态内部类完成单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *通过静态内部类实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">   <span class="comment">//写一个静态内部类额，该类中有一个静态属性Singleton</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//提供一个静态的共有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1）外部类在加载的时候，内部的静态内部类是不会加载的，从而保证了懒加载</span></span><br><span class="line"><span class="comment">* 2）当调用getInstance()获取INSTANCE时，会触发静态内部类Singleton Instance的加载，而类的静态属性只会在第一次加载类的时候初始化，</span></span><br><span class="line"><span class="comment">* JVM在加载类的时候是线程安全的，在类初始化的时候别的线程是无法进入的，所以保证了线程安全的</span></span><br><span class="line"><span class="comment">* 3）推荐使用</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2.5.1 枚举</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    INSTANCE;<span class="comment">//属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.INSTANCE;</span><br><span class="line">        Singleton instance2 = Singleton.INSTANCE;</span><br><span class="line">        System.out.println(instance == instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 1）这借助JDK1.5添加的枚举来实现单例模式，不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象</span></span><br><span class="line"><span class="comment"> *  2）这种方式是Effective Java作者Josh Bloch提倡的方式</span></span><br><span class="line"><span class="comment"> *  3）结论：推荐使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="在JDK中，java-lang-Runtime就是经典的单例模式"><a href="#在JDK中，java-lang-Runtime就是经典的单例模式" class="headerlink" title="在JDK中，java.lang.Runtime就是经典的单例模式"></a><strong><em>在<code>JDK</code>中，<code>java.lang.Runtime</code>就是经典的单例模式</em></strong></h3><h3 id="3-单例模式注意事项和细节说明"><a href="#3-单例模式注意事项和细节说明" class="headerlink" title="3.单例模式注意事项和细节说明"></a>3.单例模式注意事项和细节说明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。</span><br><span class="line">2）当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new</span><br><span class="line">3）单例模式使用的场景：需要频繁进行创建和销毁的对象，创建对象时耗时过多或耗费资源过多（即：重量级对象）但又经常用到的对象，工具类对象，频繁访问数据库或文件的对象（比如数据源，session工厂等）</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>接口</title>
    <url>/2020/04/08/%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h3 id="1-接口的用途是用来定义现实世界不同类型事物的共同行为特征"><a href="#1-接口的用途是用来定义现实世界不同类型事物的共同行为特征" class="headerlink" title="1.接口的用途是用来定义现实世界不同类型事物的共同行为特征"></a>1.接口的用途是用来定义现实世界<strong><em>不同类型事物</em></strong>的共同行为特征</h3><p>接口关注的是行为特征，比如：<br>1）飞行特征（包括起飞，飞行，着陆等行为）是鸟和飞机所共有的。鸟和飞机的共同行为特征可被定义在接口中</p>
<h3 id="2-接口中的所有方法都是抽象方法，接口是没有构造器的"><a href="#2-接口中的所有方法都是抽象方法，接口是没有构造器的" class="headerlink" title="2.接口中的所有方法都是抽象方法，接口是没有构造器的"></a>2.接口中的所有方法都是抽象方法，接口是没有构造器的</h3><h3 id="3-接口中的所有属性必然是全局常量（public-static-final），只能读不能改，这样才能为实现接口的对象提供一个统一的属性"><a href="#3-接口中的所有属性必然是全局常量（public-static-final），只能读不能改，这样才能为实现接口的对象提供一个统一的属性" class="headerlink" title="3. 接口中的所有属性必然是全局常量（public static final），只能读不能改，这样才能为实现接口的对象提供一个统一的属性"></a>3. 接口中的所有属性必然是全局常量（public static final），只能读不能改，这样才能为实现接口的对象提供一个统一的属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通俗的讲，只要是认为会变化的东西，就放在我们的是实现中，不能放到接口里面去。对修改关闭，对扩展开放（不同的implements），接口是对开闭原则的一种体现。接口表达的是一种能力或某种标准规范，通常用形容词来命名接口。</span><br></pre></td></tr></table></figure>

<h3 id="4-接口中成员变量的默认修饰符是public-static-final，成员方法的默认修饰符是public-abstract"><a href="#4-接口中成员变量的默认修饰符是public-static-final，成员方法的默认修饰符是public-abstract" class="headerlink" title="4.接口中成员变量的默认修饰符是public static final，成员方法的默认修饰符是public abstract"></a>4.接口中成员变量的默认修饰符是public static final，成员方法的默认修饰符是public abstract</h3><h3 id="5-接口为什么可以多继承呢？因为接口中的都是抽象方法，没有方法体，没法压栈执行，具体的实现还得看具体的子类"><a href="#5-接口为什么可以多继承呢？因为接口中的都是抽象方法，没有方法体，没法压栈执行，具体的实现还得看具体的子类" class="headerlink" title="5.接口为什么可以多继承呢？因为接口中的都是抽象方法，没有方法体，没法压栈执行，具体的实现还得看具体的子类"></a>5.接口为什么可以多继承呢？因为接口中的都是抽象方法，没有方法体，没法压栈执行，具体的实现还得看具体的子类</h3>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式的七大原则-迪米特法则</title>
    <url>/2020/04/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</url>
    <content><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>1）一个对象应该对其它对象保持最少的了解。</p>
<p>2）类与类关系越密切，耦合度越大。</p>
<p>3）<strong><em>迪米特法则（Demeter Principle）又叫最少知道原则</em></strong>，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多复杂，都尽量将逻辑封装在类的内部。对外除了提供public方法，不对外泄露任何信息。</p>
<p>4）<strong><em>迪米特法则还有个更简单的定义：只与直接的朋友通信。</em></strong></p>
<p>5）直接的朋友：只要两个对象之间有耦合关系，我们就说这两个对象是朋友关系。耦合的方法有很多：依赖，关联，组合，聚合等。<strong><em>其中我们称成员变量，方法参数，方法返回值中的类为直接朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</em></strong></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>1）迪米特法则的核心是降低类之间的耦合。</p>
<p>2）但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完全没有依赖关系。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>Object中的主要方法</title>
    <url>/2020/04/06/Object%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Object中的主要方法（没有属性）"><a href="#Object中的主要方法（没有属性）" class="headerlink" title="Object中的主要方法（没有属性）"></a>Object中的主要方法（没有属性）</h1><h3 id="1-public-boolean-equals-Object-obj-判断this对象和obj对象内容是否相等"><a href="#1-public-boolean-equals-Object-obj-判断this对象和obj对象内容是否相等" class="headerlink" title="1. public boolean equals(Object obj),判断this对象和obj对象内容是否相等"></a>1. <code>public boolean equals(Object obj)</code>,判断<code>this</code>对象和<code>obj</code>对象内容是否相等</h3><h3 id="2-public-int-hashCode-获得对象的Hash码"><a href="#2-public-int-hashCode-获得对象的Hash码" class="headerlink" title="2. public int hashCode()获得对象的Hash码"></a>2. <code>public int hashCode()</code>获得对象的Hash码</h3><p>​    2.1 哈希码：也称之为散列码，是为了使对象在内存不要重叠，尽量散开；对象的哈希码是通过哈希函数计算而得到的，但不同的对象可能会得到相同的哈希值，所以会存在哈希冲突（散列冲突），如果哈希值相同的对象不是很多，会将这些哈希码相同的对象放在一个单链表中进行存储，如果超过8则会通过红黑树进行存储。所以<strong><em>如果两个对象的<code>hashCode</code>不相同,则它们equals肯定是false,如果equals为true，则<code>hashCode</code>一定相同.</em></strong></p>
<p>​    2.2 <code>hashCode()</code>和<code>equals()</code>方法的作用其实一样，在<code>Java</code>里都是用来对比两个对象是否相等一致，那么既然equals()方法能够实现对比功能了，为什么还要<code>hashCode()</code>呢？</p>
<p>​    因为重写的equals()里一般比较得比较全面复杂，这样使用的时候效率就很低，而利用<code>hashCode()</code>方法进行对比，只要生成一个hash值就可以，效率很高。在<code>equals()</code>方法中一般就会先判断hash值是否相等，如果<code>hash</code>值不相等，则这两个对象肯定不一致，直接返回<code>false</code>；如果<code>hash</code>值相等，则继续进行更加详细的判断。</p>
<p>  所以<code>hashCode</code>方法和<code>equals</code>方法必须同时重写。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>继承考点</title>
    <url>/2020/04/06/%E7%BB%A7%E6%89%BF%E8%80%83%E7%82%B9/</url>
    <content><![CDATA[<h3 id="1-为什么父类又被称之为基类或超类？"><a href="#1-为什么父类又被称之为基类或超类？" class="headerlink" title="1.为什么父类又被称之为基类或超类？"></a>1.为什么父类又被称之为基类或超类？</h3><p>​    基类：因为子类是在父类的基础上进行扩展（extends）</p>
<p>​    超类：因为在子类中使用关键字super标识从父类继承的成员</p>
<h3 id="2-什么是方法覆盖？方法覆盖有什么条件？"><a href="#2-什么是方法覆盖？方法覆盖有什么条件？" class="headerlink" title="2.什么是方法覆盖？方法覆盖有什么条件？"></a>2.什么是方法覆盖？方法覆盖有什么条件？</h3><p>​    子类根据需求对父类的方法进行重写，改造，对父类方法的不满</p>
<p>​    要求：</p>
<p>​            1）方法的签名一致，返回值类型，方法名，参数列表（参数类型，顺序，个数）</p>
<p>​            2）子类的覆盖方法的访问控制修饰符要大于等于父类的</p>
<h3 id="3-如果A类被B类继承，B类又被C类继承，在A-B-C类中都包含test-，创建C类对象，调用test-方法，执行的是哪个类的方法？在C类中有几个test-方法？"><a href="#3-如果A类被B类继承，B类又被C类继承，在A-B-C类中都包含test-，创建C类对象，调用test-方法，执行的是哪个类的方法？在C类中有几个test-方法？" class="headerlink" title="3.如果A类被B类继承，B类又被C类继承，在A B C类中都包含test()，创建C类对象，调用test()方法，执行的是哪个类的方法？在C类中有几个test()方法？"></a>3.如果A类被B类继承，B类又被C类继承，在A B C类中都包含test()，创建C类对象，调用test()方法，执行的是哪个类的方法？在C类中有几个test()方法？</h3><p>​    执行的是C类中的test()方法</p>
<p>​    1个方法：从测试类的角度去看，C类中只有一个test()方法，但是C类中保存了父类模板的标记，可以通过标记去访问父类的test方法</p>
<h3 id="4-子类能继承父类的私有成员嘛？如何处理呢？"><a href="#4-子类能继承父类的私有成员嘛？如何处理呢？" class="headerlink" title="4.子类能继承父类的私有成员嘛？如何处理呢？"></a>4.子类能继承父类的私有成员嘛？如何处理呢？</h3><p>​    子类能继承父类的所有成员（构造器除外），包括私有成员。</p>
<p>​    虽然能继承父类的私有成员，但是不可以直接访问，必须通过从父类继承的公共方法间接访问</p>
<h3 id="5-关于构造器"><a href="#5-关于构造器" class="headerlink" title="5.关于构造器"></a>5.关于构造器</h3><p>​    1）所有的类必须有构造器，如果类中没有提供任何构造器，那编译器会自动添加一个默认的构造器</p>
<p>​    2）所有类的构造器中都必须先有对父类构造器的调用，如何体现“先”，强制第一行</p>
<p>​        （1）所有类的构造器中默认第一行是super()</p>
<p>​        （2）所有类的第一行要么是this(…),要么是super(…)，不能同时存在</p>
<p>​          super的作用是直接调用父类构造器</p>
<p>​          this(…)作用的调用其它的重载构造器</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式七大原则-开闭原则</title>
    <url>/2020/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h1>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式的七大原则-里氏替换原则</title>
    <url>/2020/04/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h1><p>​    1）里氏替换原则（<code>**Liskov Substitution Principle**</code>）在1988年，由麻省理工学院是一位姓里的女士提出的。</p>
<p>​    2）如果对每个类型为<code>T1</code>的对象<code>o1</code>，都有类型为<code>T2</code>的对象<code>o2</code>，使得以<code>T1</code>定义的所有程序P在所有的对象<code>o1</code>都替换成<code>o2</code>时，程序p的行为没有发生变化，那么类型<code>T2</code>时类型<code>T1</code>的子类型，<strong><em>换句话说，所有引用基类的地方必须能透明地使用其子类的对象</em></strong>。</p>
<p>​    3）<strong><em>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法</em></strong>。</p>
<p>​    4）里氏替换原则告诉我们，<strong><em>继承实际上让两个类的耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题,或者让原来的父类和和子类都继承一个更通俗的基类，原有的关系去掉。</em></strong></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式的七大原则-依赖倒转原则</title>
    <url>/2020/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h1><p>​    依赖倒转原则（Dependence Inversion Principle）是指：</p>
<p>1）高层模块不应依赖于低层模块，二者都应该依赖于抽象</p>
<p>2）抽象不应该依赖细节，细节应该依赖抽象</p>
<p>3）<strong>依赖倒转原则的中心思想是面向接口编程</strong></p>
<p>4）依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构以细节为基础搭建的架要稳定的多。在Java中，抽象指的是接口或抽象类，细节就是具体的实现类</p>
<p>5）使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式的七大原则-接口隔离原则</title>
    <url>/2020/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h1><p>1）一个类对另外一个类的依赖应该建立在最小的接口上。</p>
<p>例：类A通过<code>interface1</code>依赖类B，但是A只用到了B中的<code>operation1</code>和<code>operation2</code>方法，C通过<code>interface1</code>依赖类D，但是C只用到了D中的<code>operation1</code>和<code>operation3</code>方法，<strong>这样对于A类对B类的依赖以及C类对D类的依赖都没有建立在最小的接口上，</strong>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(Interface1 i)</span></span>&#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">        i.operation2();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        operation(<span class="keyword">new</span> B());<span class="comment">//A类通过Interface1使用了B类</span></span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        c.operation(<span class="keyword">new</span> D());<span class="comment">//C类通过Interface1使用了D类</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(Interface1 i)</span></span>&#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">        i.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>A类对B类的依赖以及C类对D类的依赖都没有建立在最小的接口上，违反了<em>接口隔离原则。</em></strong></p>
<p>应该对接口Interface1进行拆分如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(Interface1 i)</span></span>&#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">        i.operation2();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        operation(<span class="keyword">new</span> B());<span class="comment">//A类通过Interface1,Interface2使用了B类</span></span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        c.operation(<span class="keyword">new</span> D());<span class="comment">//C类通过Interface1,Interface3使用了D类</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(Interface1 i)</span></span>&#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">        i.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span>,<span class="title">Interface2</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    D<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span>,<span class="title">Interface3</span></span>&#123;</span><br><span class="line">     <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这样将<code>Interface1</code>进行拆分，A类通过<code>Interface1，Interface2</code>使用B类，C类通过<code>Interface1，Interface3</code>使用D类都建立在最小的接口上进行调用，接口中都没有多余的动能，这样就遵守了接口隔离原则。</strong></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>UML类图中的关系</title>
    <url>/2020/04/02/UML%E7%B1%BB%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><code>UML（unified modeling language）</code>是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果。其中类图中的关系中元素之间的关系有：依赖，泛化，实现，关联，聚合，组合等。</p>
<h1 id="1-依赖关系（Dependency）"><a href="#1-依赖关系（Dependency）" class="headerlink" title="1.依赖关系（Dependency）"></a>1.依赖关系（Dependency）</h1><p>​    依赖关系是一种使用关系，即在一个类中使用使用另一个类。在代码中的体现有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）类的成员变量</span><br><span class="line">2）方法的返回值</span><br><span class="line">3）方法接收的参数类型</span><br><span class="line">4）方法中使用到</span><br></pre></td></tr></table></figure>


<p>如程序员依赖（使用）计算机，则在UML类图中表现为程序员——-&gt;计算机</p>
<p><img src="https://imgedu.lagou.com/e29f0cb85f60465db8654eaf35e16bfc.jpg" alt="依赖关系"></p>
<h1 id="2-泛化关系（继承）"><a href="#2-泛化关系（继承）" class="headerlink" title="2.泛化关系（继承）"></a>2.泛化关系（继承）</h1><p> 【箭头指向】：带三角箭头的实线，箭头指向父类 </p>
<h1 id="3-实现关系"><a href="#3-实现关系" class="headerlink" title="3.实现关系"></a>3.实现关系</h1><p> 【箭头指向】：带三角箭头的虚线，箭头指向接口.(有些画法接口为一个圈，实现的类之间是一条直接) </p>
<h1 id="4-关联关系（Association）"><a href="#4-关联关系（Association）" class="headerlink" title="4. 关联关系（Association）"></a>4. 关联关系（Association）</h1><p>​       【关联关系】：是一种拥有的关系，它是依赖关系的特例，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。<br>　　【代码体现】：成员变量<br>　　【箭头及指向】：带普通箭头的实心线，指向被拥有者 </p>
<h1 id="5-聚合关系（Aggregation）"><a href="#5-聚合关系（Aggregation）" class="headerlink" title="5. 聚合关系（Aggregation）"></a>5. 聚合关系（Aggregation）</h1><p>​     【聚合关系】：是整体与部分，是“contains-a”关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。<br>　　聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。<br>　 【箭头及指向】：带空心菱形的实心线，菱形指向整体</p>
<h1 id="6-组合关系（composition）"><a href="#6-组合关系（composition）" class="headerlink" title="6. 组合关系（composition）"></a>6. 组合关系（composition）</h1><p>​       组合关系】：是整体与部分，是“has-a”关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。<br>　　组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。<br>　  【箭头及指向】：带实心菱形的实线，菱形指向整体</p>
]]></content>
      <categories>
        <category>UML</category>
        <category>类图</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式的七大原则-单一职责原则</title>
    <url>/2020/04/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1. 单一职责原则"></a>1. 单一职责原则</h1><p>​    对类来说，即一个类应该只负责一项职责。</p>
<h1 id="2-单一职责原则注意事项和细节"><a href="#2-单一职责原则注意事项和细节" class="headerlink" title="2. 单一职责原则注意事项和细节"></a>2. 单一职责原则注意事项和细节</h1><ul>
<li>1）降低类的复杂度，一个类只负责一项职责</li>
<li>2）提高类的可读性，可维护性</li>
<li>3）降低变更引起的风险</li>
<li>4）通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级别上违反单一职责原则，只有在类中方法数量足够少，可以在方法级别保持单一职责原则</li>
</ul>
<h1 id="3-代码举例"><a href="#3-代码举例" class="headerlink" title="3.代码举例"></a>3.代码举例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">        vehicle.run(<span class="string">"飞机"</span>);</span><br><span class="line">        vehicle.run(<span class="string">"汽车"</span>);</span><br><span class="line">        vehicle.run(<span class="string">"火车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交通工具类</span></span><br><span class="line"><span class="comment">//1.在方式1的run方法中违反了单一职责原则</span></span><br><span class="line"><span class="comment">//2.解决的办法非常简单，根据交通工具运行方法不同，分解成不同的类即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在公路上运行"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RoadVehicle roadVehicle = <span class="keyword">new</span> RoadVehicle();</span><br><span class="line">        roadVehicle.run(<span class="string">"摩托车"</span>);</span><br><span class="line">        AirVehicle airVehicle = <span class="keyword">new</span> AirVehicle();</span><br><span class="line">        airVehicle.run(<span class="string">"飞机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 方案2的分析</span></span><br><span class="line"><span class="comment">* 1.遵守单一职责原则</span></span><br><span class="line"><span class="comment">* 2.但是这样做的改动很大，直接将类分解了</span></span><br><span class="line"><span class="comment">* 3.改进，直接修改Vehicle类，这样改动的代码会比较少-》方案3</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadVehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在公路上运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirVehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在天空中运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterVehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在水中运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vehicle2 vehicle2 = <span class="keyword">new</span> Vehicle2();</span><br><span class="line">        vehicle2.run(<span class="string">"摩托"</span>);</span><br><span class="line">        vehicle2.runAir(<span class="string">"飞机"</span>);</span><br><span class="line">        vehicle2.runWater(<span class="string">"游艇"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 方式3的分析</span></span><br><span class="line"><span class="comment">* 1.这种修改方法对原来的类没有作大的修改，只是增加了方法</span></span><br><span class="line"><span class="comment">* 2.这里虽然没有在类的级别上遵守单一职责原则，但是在方法上，仍然是遵守了单一职责原则</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在公路上运行"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAir</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在天上运行"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runWater</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"在水运行"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式概述</title>
    <url>/2020/04/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="1-什么是设计模式"><a href="#1-什么是设计模式" class="headerlink" title="1. 什么是设计模式"></a>1. 什么是设计模式</h1><p>​    软件工程中，设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。设计模式这个术语是1990年代从建筑领域中引入到计算机科学的。</p>
<h1 id="2-设计模式出现在软件设计过程中的哪些阶段？"><a href="#2-设计模式出现在软件设计过程中的哪些阶段？" class="headerlink" title="2.设计模式出现在软件设计过程中的哪些阶段？"></a>2.设计模式出现在软件设计过程中的哪些阶段？</h1><p>​    面向对象-&gt;<strong>功能模块[设计模式+数据结构+算法]</strong>-&gt;<strong>框架[使用多种设计模式]</strong>-&gt;架构[服务器集群]。</p>
<p>由此可见，开发过程中设计模式的使用大多数是在开发功能模块或者使用的某些框架中，所以很多面试的时候面试官都会问在某个项目的功能模块中使用了哪些设计模式或者哪个框架中的哪部分代码使用了什么设计模式。</p>
<h1 id="3-设计模式的目的"><a href="#3-设计模式的目的" class="headerlink" title="3. 设计模式的目的"></a>3. 设计模式的目的</h1><p> 1）代码重用性（即相同功能的代码，不用重复编写）<br> 2）可读性（即编程规范性，便于其它程序员阅读和理解）<br> 3）可扩展性（即当需要增加新的功能时，非常的方便）<br> 4）可靠性（即当增加新的功能后，对原来的功能没有影响）<br> 5）使程序呈现高内聚，低耦合的特性</p>
<h1 id="4-设计模式的原则"><a href="#4-设计模式的原则" class="headerlink" title="4.设计模式的原则"></a>4.设计模式的原则</h1><p>​    设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础（即设计模式为什么这么设计的依据）</p>
<p>​    <strong>设计模式常用的七大设计原则有：</strong></p>
<ul>
<li><p>1.单一职责原则</p>
</li>
<li><p>2.接口隔离原则</p>
</li>
<li><p>3.依赖倒转原则</p>
</li>
<li><p>4.里氏替换原则</p>
</li>
<li><p>5.开闭原则</p>
</li>
<li><p>6.迪米特原则</p>
</li>
<li><p>7.合成复用原则</p>
</li>
</ul>
<h1 id="5-掌握设计模式的层次"><a href="#5-掌握设计模式的层次" class="headerlink" title="5.掌握设计模式的层次"></a>5.掌握设计模式的层次</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）第1层：刚开始学编程不久，听说过什么是设计模式。</span><br><span class="line">2）第2层：有很长时间的编程经验，自己写了很多代码，其中用到了设计模式，但自己不知道。</span><br><span class="line">3）第3层：学习了设计模式，发现自己已经在使用了，并且发现了一些新的模式挺好用的。</span><br><span class="line">4）第4层：阅读了很多别人写的源码和框架，在其中看到别人设计模式，并且能够领会到设计模式的精妙和带来的好处。</span><br><span class="line">5）第5层：代码写着写着，自己都没有意识到使用了设计模式，并且熟练的写了出来。</span><br></pre></td></tr></table></figure>

<h1 id="6-设计模式分类"><a href="#6-设计模式分类" class="headerlink" title="6.设计模式分类"></a>6.设计模式分类</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）创建型模式（强调的是创建对象时应该怎么去设计我们的代码）：单例模式，抽象工厂模式，原型模式，建造者模式，工厂模式。</span><br><span class="line">2）结构型模式（站在软件结构的角度来思考的，怎么让软件更加具有扩展性，伸缩性）：适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式。</span><br><span class="line">3）行为型模式（站在方法的角度来思考和设计的，怎么让方法的设计和调度更合理）：模板方法模式，命令模式，访问者模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式，状态模式，策略模式，职责链模式（责任链模式）。</span><br><span class="line">不同的书籍对分类和名称略有差别。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>对象的创建过程分析</title>
    <url>/2020/03/27/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<ul>
<li>示例代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"jack"</span>,<span class="number">19</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name: "</span> + name + <span class="string">",age: "</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Teacher t1 = <span class="keyword">new</span> Teacher(<span class="string">"susan"</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(t1.say());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分析如下</li>
</ul>
<ol>
<li>首先将main()压入虚拟机栈中，在主方法的栈帧中（包含局部变量表，操作数栈，动态连接和方法返回地址等信息）生成一个<code>Teacher</code>对象的引用<code>t1</code></li>
<li>在方法区中检查要创建的对象的类模板信息是否已经加载（<code>Teacher.class</code>），如果未加载，则由类加载器将其加载到方法区中，若已加载则进行第3步</li>
<li>根据类模板中所有属性的定义信息（修饰符 数据类型 变量名）在<code>GC</code>堆中开辟一块适当的空间</li>
<li>为所有的属性隐式初始化为零值</li>
<li>若属性有显示初始化赋值，则执行</li>
<li>执行构造方法</li>
<li>把对象的内存地址返回给创建者</li>
</ol>
<ul>
<li><p>图解如下</p>
<p><img src="http://q7s8mko1o.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.png" alt="对象创建"></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>类的加载过程</title>
    <url>/2020/03/23/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h1><p>1.通过一个类的全限定名获取定义此类的二进制字节流<br>2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br>3.在内存中生成一个代表这个类的Java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>1.<strong>验证</strong>：目的在于确保class文件的字节流中包含信息符合当前虚拟机的要求，保证被加载的类的正确性，不会危害虚拟机自身安全，主要包括文件格式验证，元数据验证，字节码验证，符号引用验证  </p>
<p>2.<strong>准备</strong>：为<strong>类变量（由static修饰的变量）</strong>分配内存并且设置变量的默认初始值（零值），这里不包含使用final修饰的static变量，由final修饰的static变量会在准备阶段就初始化为指定的值，这里也不会为实例变量分配内存初始化，类变量会先分配在方法区中，而实例变量是会随着对象一起分配到Java堆中<br>3.<strong>解析</strong>：将常量池内的符号引用转换为直接引用的过程  </p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><ul>
<li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</li>
<li>此方法不需要定义，是Javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</li>
<li>构造器方法指令按语句在源文件中出现的顺序执行</li>
<li><code>&lt;clinit&gt;()</code>不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;()</code>）</li>
<li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>,已经执行完毕</li>
<li>虚拟机必须保证一个类的<code>&lt;clinit&gt;（）</code>方法在多线程条件下被同步</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>hexo博客搭建交由github托管的基本步骤</title>
    <url>/2020/03/21/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<p>1.hexo博客框架是基于nodejs实现的，所以首先到<a href="https://nodejs.org/下载nodejs，下载完安装，然后在cmd终端中输入node" target="_blank" rel="noopener">https://nodejs.org/下载nodejs，下载完安装，然后在cmd终端中输入node</a> -v和npm -v分别查看nodejs的版本和npm的版本，确认安装成功再进行下面的操作</p>
<p>2.由于node安装插件是从国外服务器下载，受网络影响大，速度慢且可能出现异常。所以如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队（阿里巴巴旗下业务阿里云）干了这事，所以输入 npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org就可以使用阿里定制的cnpm来代替npm了" target="_blank" rel="noopener">https://registry.npm.taobao.org就可以使用阿里定制的cnpm来代替npm了</a></p>
<p>3.输入cnpm -v检查cnpm是否成功安装，成功则继续下面的步骤</p>
<p>4.输入cnpm install -g hexo-cli安装hexo博客框架</p>
<p>5.输入hexo -v检查hexo是否成功安装，成功则继续下面的步骤</p>
<p>6.建立一个空的文件夹作为后面博客输出话的目录，比如md blog</p>
<p>7.然后进入blog目录 cd blog</p>
<p>8.位于blog目录后，输入hexo init初始化博客，这样blog就成为了一个博客目录，所以如果后面出错了直接把blog删除重来就可以</p>
<p>9.输入hexo s命令即可启动hexo服务，然后通过localhost:4000可在本地访问静态博客，对于hexo的基本使用可以参考网址<a href="https://hexo.io/zh-cn/docs/index.html，写博客是基于markdown形式的，markdown的基本使用可参考网址https://www.runoob.com/markdown/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/index.html，写博客是基于markdown形式的，markdown的基本使用可参考网址https://www.runoob.com/markdown/</a></p>
<p>10.后面将博客部署到github上，首先进入个人github新建一个仓库，命名为name.github.io</p>
<p>11.在cmd中输入cnpm install  hexo-deployer-git –save安装git部署的插件，warning提示可忽略不管</p>
<p>12.然后打开博客主目录下的<em>config.yml文件进行配置，在底部deploy字段下面配置3个属性</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: git</span><br><span class="line">repo: 刚新建的github仓库的地址</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>

<p>13.然后输入hexo d命令将博客部署到github即可</p>
<p>14.最后通过在浏览器中输入name.github.io可访问博客</p>
<p>15.如果不喜欢样式主题，可进行更换，以next主题为例</p>
<p>16.首先进入blog路径，在终端中输入git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next 将next主题克隆到blog/theme/next目录下</p>
<p>17.然后修改blog目录下的_config.yml文件，将theme的value值配置为next 即：<br> <code>theme: next</code></p>
<p>18.然后重新通过hexo clean清理本地博客，hexo g生成本地静态博客，hexo s开启服务即可通过localhost:4000访问</p>
<p>19.通过hexo d重新将博客部署到github上</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
  </entry>
  <entry>
    <title>java小知识点</title>
    <url>/2020/03/21/java%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="1-n和n-的区别"><a href="#1-n和n-的区别" class="headerlink" title="1.++n和n++的区别?"></a>1.++n和n++的区别?</h1><p>​    ++n 先加后用，不需要临时空间，效率高；n++ 先用后加，需要一个临时空间保存未++操作之前的值（也就是要用的值），然后再进行++操作。</p>
<h1 id="2-switch中的穿透，如果case或者default语句中不加break-由上往下执行的时候如果匹配正确一次的，那么switch这个匹配表达式生命周期就结束了，如果没有break-后面的case将不再做匹配判断，直接运行case下的代码"><a href="#2-switch中的穿透，如果case或者default语句中不加break-由上往下执行的时候如果匹配正确一次的，那么switch这个匹配表达式生命周期就结束了，如果没有break-后面的case将不再做匹配判断，直接运行case下的代码" class="headerlink" title="2.switch中的穿透，如果case或者default语句中不加break,由上往下执行的时候如果匹配正确一次的，那么switch这个匹配表达式生命周期就结束了，如果没有break,后面的case将不再做匹配判断，直接运行case下的代码"></a>2.switch中的穿透，如果case或者default语句中不加break,由上往下执行的时候如果匹配正确一次的，那么switch这个匹配表达式生命周期就结束了，如果没有break,后面的case将不再做匹配判断，直接运行case下的代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例代码<span class="number">1</span>：</span><br><span class="line">```</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(a &lt; <span class="number">5</span>)&#123;</span><br><span class="line">		<span class="keyword">switch</span>(a)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>: a = a + <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>: a = a + <span class="number">3</span>;</span><br><span class="line">			<span class="keyword">default</span>: a = a + <span class="number">5</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(a);</span><br><span class="line">```</span><br><span class="line">代码的输出结果是<span class="number">10</span>,<span class="keyword">case</span> <span class="number">0</span>匹配后，没有<span class="keyword">break</span>,后面的<span class="keyword">case</span> <span class="number">3</span>,<span class="keyword">case</span> <span class="number">1</span>,<span class="keyword">case</span> <span class="number">2</span>,<span class="keyword">default</span>就不会再判断是否匹配了，会直接执行<span class="keyword">case</span>下的语句</span><br><span class="line">示例代码<span class="number">2</span></span><br><span class="line">```</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">2</span>,y = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">switch</span>(x)&#123;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			y++；</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			y++;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			y++;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(y);</span><br><span class="line">```</span><br><span class="line">最后输出结果为<span class="number">6</span>，道理同上，<span class="keyword">default</span>分支条件成立，后面则不会再判断是否成立了，直接执行分支后的语句，所以y累加<span class="number">3</span>次，最后结果为<span class="number">6</span></span><br></pre></td></tr></table></figure>



<h1 id="3-方法重写（override）"><a href="#3-方法重写（override）" class="headerlink" title="3.方法重写（override）"></a>3.方法重写（override）</h1><p>子类对父类方法的重写，需要遵守一下几点</p>
<p> 1）子类的覆盖方法和父类的被覆盖方法的方法签名完全一致（返回值类型，方法名，参数列表）</p>
<p> 2）子类的覆盖方法的访问权限修饰要大于等于父类的方法的访问权限修饰</p>
<h1 id="4-属性不具备多态性，只有方法具备多态性"><a href="#4-属性不具备多态性，只有方法具备多态性" class="headerlink" title="4.属性不具备多态性，只有方法具备多态性"></a>4.属性不具备多态性，只有方法具备多态性</h1><h3 id="5-外部类只可以用public-和-default访问修饰符修饰，那为什么外部类不能用private-protected修饰呢？"><a href="#5-外部类只可以用public-和-default访问修饰符修饰，那为什么外部类不能用private-protected修饰呢？" class="headerlink" title="5. 外部类只可以用public 和 default访问修饰符修饰，那为什么外部类不能用private,protected修饰呢？"></a>5. 外部类只可以用public 和 default访问修饰符修饰，那为什么外部类不能用private,protected修饰呢？</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java的外部类为什么不能使用private、protected进行修饰 ... 因为外部类的上一单元是包，所以外部类只有两个作用域：同包，任何位置。 因此，只需要两种控制权限：包控制权限和公开访问权限，也就对应两种控制修饰符：public和默认(default)。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java基本认识</title>
    <url>/2020/03/20/Java%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<ul>
<li><h1 id="Java的8大特性"><a href="#Java的8大特性" class="headerlink" title="Java的8大特性"></a>Java的8大特性</h1>  1）跨平台：执行class文件的JVM是跨平台的（跨操作系统），不同的平台有不同的虚拟机<br>  2）面向对象：Java是面向对象的，和面向过程相对，关注点是解决问题的抽象而非具体的过程<br>  3）简单：相对c/c++简单<br>  4）安全：在将class文件加载到jvm中执行时，会先对class文件进行检查看是否符合class文件的规范<br>  5）健壮：Java语言是强类型的（所有的数据必须要有唯一的确定的数据类型），而且拥有完善的异常处理机制和垃圾回收机制，并且对指针进行了安全化（引用），这些都为健壮性提供了保障<br>  6）效率高：Java是编译型语言，将源文件编译为class文件后由类加载器加载到jvm中执行即可，相对解释型语言解释一行执行一行效率要更高<br>  7）分布式：Java可基于网络实现多主机协作<br>  8）多线程：提高单位时间内在网络上传输的数据（吞吐量），提高CPU的利用率</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
</search>
