<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
      
    
    
  <script src="true"></script>
  <link href="/lib/pace/pace-theme-center-atom.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Flink," />










<meta name="description" content="1.课程内容主要讲解Flink的源码编写中涉及到的一些比较重要的工作组件和机制。主题内容大纲如下： 12345671.Flink RPC机制详解2.Flink RPC中的重要组件 RpcEndpoint的工作机制3.Flink应用程序抽象4.Flink on YARN的三种job运行模式5.Flink的选举和监听机制6.Flink的心跳机制7.Flink源码中用到的Java8 异步编程  2.Fl">
<meta property="og:type" content="article">
<meta property="og:title" content="1.FlinkRPC">
<meta property="og:url" content="http://yoursite.com/2021/04/20/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/Flink/%E6%BA%90%E7%A0%81/1.FlinkRPC/index.html">
<meta property="og:site_name" content="00后">
<meta property="og:description" content="1.课程内容主要讲解Flink的源码编写中涉及到的一些比较重要的工作组件和机制。主题内容大纲如下： 12345671.Flink RPC机制详解2.Flink RPC中的重要组件 RpcEndpoint的工作机制3.Flink应用程序抽象4.Flink on YARN的三种job运行模式5.Flink的选举和监听机制6.Flink的心跳机制7.Flink源码中用到的Java8 异步编程  2.Fl">
<meta property="og:image" content="https://i.loli.net/2021/04/20/mcI5Jq68KVhpQxs.png">
<meta property="og:image" content="https://i.loli.net/2021/04/20/WkvMUEhydpGiAJ2.png">
<meta property="og:image" content="https://i.loli.net/2021/04/20/HrlKSGmFV21aJBM.png">
<meta property="og:image" content="https://i.loli.net/2021/04/20/T8gtyI5Rmqb3hjz.png">
<meta property="og:image" content="https://i.loli.net/2021/04/20/K3tNrjxz6GnfUqX.png">
<meta property="og:image" content="https://i.loli.net/2021/04/20/dKCgyGZs8T7npxD.png">
<meta property="og:image" content="https://i.loli.net/2021/04/21/SpT8XcglsY3yh2n.png">
<meta property="og:image" content="https://i.loli.net/2021/04/21/sgxGUfTNdo625rD.png">
<meta property="og:image" content="https://i.loli.net/2021/04/21/vXjLFqhz276B3Id.png">
<meta property="og:image" content="https://i.loli.net/2021/04/21/yYL9xQZjR7qwetF.png">
<meta property="og:image" content="https://i.loli.net/2021/04/21/QX5ovFq8mfZgSJO.png">
<meta property="og:image" content="https://i.loli.net/2021/04/21/ucxqQPZ28hpO15R.png">
<meta property="og:image" content="https://i.loli.net/2021/04/21/ASRJFPhwul52GHr.png">
<meta property="og:image" content="https://i.loli.net/2021/04/21/w1UxBtvzQjRCh2f.png">
<meta property="og:image" content="https://i.loli.net/2021/04/21/WXuNZDaiGkESzbx.png">
<meta property="og:image" content="https://i.loli.net/2021/04/21/TOBy4hHkbMnjDVq.png">
<meta property="og:image" content="https://i.loli.net/2021/04/21/RShFfKnvpVrDbge.png">
<meta property="og:image" content="https://i.loli.net/2021/04/21/biHU64McFSBoKsl.png">
<meta property="og:image" content="https://i.loli.net/2021/04/21/qpKQuaJn8WseBwE.png">
<meta property="og:image" content="https://i.loli.net/2021/04/21/pmQMfIGVk4Nnuwg.png">
<meta property="og:image" content="c:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210421145408451.png">
<meta property="article:published_time" content="2021-04-20T02:43:23.000Z">
<meta property="article:modified_time" content="2021-04-21T07:18:04.615Z">
<meta property="article:author" content="00后">
<meta property="article:tag" content="Flink">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/04/20/mcI5Jq68KVhpQxs.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/04/20/奈学教育/Flink/源码/1.FlinkRPC/"/>





  <title>1.FlinkRPC | 00后</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	<a href="https://github.com/zhanghanting" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">00后</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/20/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/Flink/%E6%BA%90%E7%A0%81/1.FlinkRPC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="00后">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2021/01/06/UpLEnikCWguPrz1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="00后">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">1.FlinkRPC</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-20T10:43:23+08:00">
                2021-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/" itemprop="url" rel="index">
                    <span itemprop="name">奈学教育</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/Flink/" itemprop="url" rel="index">
                    <span itemprop="name">Flink</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/Flink/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">源码</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/04/20/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/Flink/%E6%BA%90%E7%A0%81/1.FlinkRPC/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/04/20/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/Flink/%E6%BA%90%E7%A0%81/1.FlinkRPC/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,843
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  19
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1-课程内容"><a href="#1-课程内容" class="headerlink" title="1.课程内容"></a>1.课程内容</h1><p>主要讲解Flink的源码编写中涉及到的一些比较重要的工作组件和机制。主题内容大纲如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.Flink RPC机制详解</span><br><span class="line">2.Flink RPC中的重要组件 RpcEndpoint的工作机制</span><br><span class="line">3.Flink应用程序抽象</span><br><span class="line">4.Flink on YARN的三种job运行模式</span><br><span class="line">5.Flink的选举和监听机制</span><br><span class="line">6.Flink的心跳机制</span><br><span class="line">7.Flink源码中用到的Java8 异步编程</span><br></pre></td></tr></table></figure>

<h1 id="2-Flink重要组件源码原理讲解"><a href="#2-Flink重要组件源码原理讲解" class="headerlink" title="2.Flink重要组件源码原理讲解"></a>2.Flink重要组件源码原理讲解</h1><h2 id="2-1-Flink-RPC"><a href="#2-1-Flink-RPC" class="headerlink" title="2.1 Flink RPC"></a>2.1 Flink RPC</h2><p>大数据技术栈中的技术组件非常丰富，大致总结一下各大常见组件的 RPC 实现技术：</p>
<p>技术组件         RPC 实现 </p>
<p>Hadoop         NIO + Protobuf</p>
<p>HBase            HBase-2.x 以前：NIO + ProtoBuf HBase-2.x 以后：Netty </p>
<p>ZooKeeper    BIO + NIO + Netty       </p>
<p> Spark            Spark-1.x 基于 Akka Spark-2.x 基于 Netty Flink Akka + Netty</p>
<h3 id="2-1-1-Flink-RPC的底层实现：Akka"><a href="#2-1-1-Flink-RPC的底层实现：Akka" class="headerlink" title="2.1.1 Flink RPC的底层实现：Akka"></a>2.1.1 Flink RPC的底层实现：Akka</h3><p>Flink的RPC实现是基于scala的网络编程库akka，akka的特点如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.akka对并发编程模型进行了更高的抽象</span><br><span class="line">2.akka是异步，非阻塞高性能的事件驱动编程模型</span><br><span class="line">3.akka是轻量级处理（1GB 内存可容纳百万级别个actor）</span><br></pre></td></tr></table></figure>

<p>几个重要的akka知识：ActorSystem和Actor的理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.ActorSystem是管理actor声明周期的组件，actor是负责进行通信的组件</span><br><span class="line">2.每个actor都有一个mailbox，别的actor发给他的消息都首先存储在mailbox中，通过这种方式就实现了异步通信</span><br><span class="line">3.每个actor是单线程的处理方式，不断的从mailbox中拉取消息进行处理，所以对于actor的消息处理，不适合调用会阻塞的处理方法</span><br><span class="line">4.actor可以改变自身的状态，可以发消息也可以接收信息，并且actor可以生成新的actor</span><br><span class="line">5.每一个actorSystem和actor在启动的时候都会被指定一个name，如果要获取一个actorSystem的一个actor，则通过以下的方式进行actor的获取：</span><br><span class="line">akka:tcp:&#x2F;&#x2F;actorsystem_name@bigdata02:9527&#x2F;user&#x2F;actor_name&#x2F;来进行定位</span><br><span class="line"></span><br><span class="line">6.如果一个actor需要和另外一个actor进行通信，则必须先获取对方actor的actorRef，然后通过该对象发送消息即可</span><br><span class="line">7.通过tell发送异步消息，不接受响应，通过ask发送异步消息，得到future返回，通过异步回到返回处理结果</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/04/20/mcI5Jq68KVhpQxs.png" alt="image-20210420110320537"></p>
<h3 id="2-1-2-使用akka模拟实现Flink-standalone"><a href="#2-1-2-使用akka模拟实现Flink-standalone" class="headerlink" title="2.1.2 使用akka模拟实现Flink standalone"></a>2.1.2 使用akka模拟实现Flink standalone</h3><p>详情见使用akka模拟实现FlinkStandalone文档</p>
<h3 id="2-1-3-深入理解Flink-RPC"><a href="#2-1-3-深入理解Flink-RPC" class="headerlink" title="2.1.3  深入理解Flink RPC"></a>2.1.3  深入理解Flink RPC</h3><p>关于其它技术组件中和actor类似的概念</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、HDFS ： proxy</span><br><span class="line">2、Akka ： ActorRef</span><br><span class="line">3、Flink ： XXXGateway： JobManager（ResourceManager） TaskManager（TaskExecutor） 在 TaskExecutor 的内部，持有</span><br><span class="line">ResourceManager的一个 Gateway 对象</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p><strong>Flink中的RPCEndpoint，在作用上，等同于akka中的actor</strong></p>
<p><strong>akka的 actorRef等同于Flink 的xxxGateWay</strong></p>
<p>在阅读flink源码过程中，如果出现下面这种类型的代码，其实就是在发送RPC请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resourceManagerGateway 就可以理解成： 当前节点中，对于 ResourceManager 代理对象的封装</span></span><br><span class="line">resourceManagerGateway.requestSlot();</span><br><span class="line"><span class="comment">// 代码跳转到：resourceManager.requestSlot();</span></span><br></pre></td></tr></table></figure>



<p>Spark 的 RPC 实现虽然是为了替换 Akka 而诞生的，但是它实际上可以看成一个简化版的 Akka，仍然遵循许多 Actor Model 的抽象。例如 </p>
<p>RpcEndpoint 对应 Actor </p>
<p>RpcEndpointRef（被包装在 Gateway 对象的内部） 对应 ActorRef </p>
<p>RpcEnv 对应 ActorSystem</p>
<p>Flink 中的 RPC 实现主要在 flink-runtime 模块下的 org.apache.flink.runtime.rpc 包中，涉及到的最重要的 API 主要是以下这四个：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>RPCGateWay</td>
<td><strong>用于远程调用的代理接口</strong>。 RpcGateway 提供了获取其所代理的 RpcEndpoint 的地址的方法。在实现一个提供 RPC 调用的组件 时，通常需要先定一个接口，该接口继承 RpcGateway 并约定好提供的远程调用的方法。</td>
</tr>
<tr>
<td>RpcServer</td>
<td>相当于 RpcEndpoint 自身的的代理对象（self gateway)。RpcServer 是 RpcService 在启动了 RpcEndpoint 之后返回的对象，每 一个 RpcEndpoint 对象内部都有一个 RpcServer 的成员变量，通过 getSelfGateway 方法就可以获得自身的代理，然后调用该 Endpoint 提供的服务。</td>
</tr>
<tr>
<td>RpcEndpoint</td>
<td>对 RPC 框架中提供具体服务的实体的抽象，所有提供远程调用方法的组件都需要继承该抽象类。另外，对于同一个 RpcEndpoint 的所有 RPC 调用都会在同一个线程（RpcEndpoint 的“主线程”）中执行，因此无需担心并发执行的线程安全问题。</td>
</tr>
<tr>
<td>RpcService</td>
<td>是 RpcEndpoint 的运行时环境，RpcService 提供了启动 RpcEndpoint , 连接到远端 RpcEndpoint 并返回远端 RpcEndpoint 的代 理对象等方法。此外，RpcService 还提供了某些异步任务或者周期性调度任务的方法。<strong>内部包装了 ActorSystem</strong></td>
</tr>
</tbody></table>
<p><img src="https://i.loli.net/2021/04/20/WkvMUEhydpGiAJ2.png" alt="image-20210420173623454"></p>
<p><strong>这里的resourceManager不是yarn里面的概念，它是flink主节点中的一个组件，如果从主从架构的角度来说，ResourceManager是主节点，TaskExecutor是从节点 。</strong></p>
<p><strong>JobMaster类似于yarn中的ApplicationMaster</strong></p>
<p>如果当前的RpcEndpoint组件需要跟其它的RPCEndpoint组件进行通信，需要获取对方的代理对象，获取方式是通过图中的虚线方式通过代理模式获取代理对象的</p>
<p>总结：RPCEndpoint下面有四个比较重要的子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.TaskExecutor 集群中从节点中最重要的角色，负责资源管理</span><br><span class="line">2.Dispatcher  主节点中的一个工作角色，负责job调度执行</span><br><span class="line">3.JobMaster  应用程序中的主控程序，类似于spark中的driver的作用，或者MapReduce中的ApplicationMaster</span><br><span class="line">4.ResourceManager 集群中的主节点 JobManager中的负责资源管理的角色，和TaskExecutor一起构成资源管理的主从架构</span><br></pre></td></tr></table></figure>

<p>当在任意地方发现要创建这四个组件的任何一个组件的实例对象的时候，创建成功之后，都会要调用start()去启动这个RPCEndpoint，然后就会去执行它的RPCEndpoint的onStart()方法，一般来说，对应的RPCEndpoint组件都会重写，在这些RpcEndpoint组件启动的时候，一些重要的逻辑，都有可能被放在这个onStart()生命周期方法里。</p>
<p>在rpcEndpoint内部包装了一个AkkaRpcActor：如果这个rpcEndpoint接收到START控制消息，则这个RPCEndpoint的onStart()会被调用</p>
<h3 id="2-1-4-Flink-RPC实例"><a href="#2-1-4-Flink-RPC实例" class="headerlink" title="2.1.4 Flink RPC实例"></a>2.1.4 Flink RPC实例</h3><p>代码实现：</p>
<h2 id="2-2-RPCEndpoint"><a href="#2-2-RPCEndpoint" class="headerlink" title="2.2 RPCEndpoint"></a>2.2 RPCEndpoint</h2><h3 id="2-2-1-JobManager的ResourceManager"><a href="#2-2-1-JobManager的ResourceManager" class="headerlink" title="2.2.1 JobManager的ResourceManager"></a>2.2.1 JobManager的ResourceManager</h3><p>Flink Standalone集群是一个主从架构，主节点叫做JobManager，从节点叫做TaskManager，在JobManager（这只是逻辑上的概念，在代码中其实没有相应的实现）内部，其实有三大组件</p>
<p><img src="https://i.loli.net/2021/04/20/HrlKSGmFV21aJBM.png" alt="image-20210420180609540"></p>
<p>其中</p>
<p>standaloneResouceManager 负责管理资源</p>
<p>DispatcherRunner 调度分派job,具体点就是启动JobMaster</p>
<p>DispatcherRestEndpoint负责接收客户端发送的job的数据</p>
<p>其中，ResourceManger的职责就是帮助主节点JobManager完成从节点TaskManager的管理和资源的管理和分配工作</p>
<p><img src="https://i.loli.net/2021/04/20/T8gtyI5Rmqb3hjz.png" alt="image-20210420180736381"></p>
<h3 id="2-2-2-TaskManager的TaskExecutor"><a href="#2-2-2-TaskManager的TaskExecutor" class="headerlink" title="2.2.2 TaskManager的TaskExecutor"></a>2.2.2 TaskManager的TaskExecutor</h3><p>Flink Standalone 集群是一个主从架构，主节点叫做 JobManager，从节点叫做 TaskManager</p>
<p><img src="https://i.loli.net/2021/04/20/K3tNrjxz6GnfUqX.png" alt="image-20210420180831484"></p>
<p>这个TaskExecutor是存在于TaskManager的内部，真正完成资源提供和分配，接收任务和执行等相关工作。这个角色的意义等同于spark中多个worker，YARN集群中的NodeManager</p>
<h2 id="2-3-Flink应用程序抽象"><a href="#2-3-Flink应用程序抽象" class="headerlink" title="2.3 Flink应用程序抽象"></a>2.3 Flink应用程序抽象</h2><p>当程序员写好Flink Job程序之后，Flink Client提交一个Job之后：整个这个Job的概念会发生3次改变生成4个概念</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.提交到JobManager之前，会从Flink code生成StreamGraph，JobGraph</span><br><span class="line">2.客户端其实是提交JobGraph给服务端，还要转换为ExecutionGraph，然后再转换为物理task，去申请slot资源，部署task执行</span><br></pre></td></tr></table></figure>

<p>几个基础概念</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.Function</span><br><span class="line">2.StreamOperator</span><br><span class="line">3.Transformation</span><br><span class="line">4.StreamNode</span><br><span class="line"></span><br><span class="line">Function --&gt;StreamOperator --&gt;Transformation --&gt; StreamNode</span><br><span class="line">其中每一个operator转换为transformation后会加入到env环境的transformations集合中，在调用env.execute()的时候，会遍历transformations集合，在遍历的时候会将transformation转换为streamNode，根据里面的streamNode构建StreamGraph</span><br><span class="line"></span><br><span class="line">也就是说我们的一个算子加上里面我们传的function参数会先编程StreamOperator，然后再变成Transformation，然后最终再变成一个StreamNode，最后根据整个程序的StreamNode就构建成了程序的StreamGraph。也就是说在我们的StreamGraph中每一个顶点就对应一个算子形成的StreamNode，里面会存储计算逻辑和并行度。StreamGraph中连接算子顶点（StreamNode）的叫做边（StreamEdge）</span><br></pre></td></tr></table></figure>

<p>Flink的一个Job，最终归根结底，还是构建一个高效率的用于分布式并行执行的DAG执行图</p>
<p>Flink中的Job被抽象成graph进行管理，执行图graph可以分为4层：streamGraph ==》JobGraph  ==》 ExecutionGraph  ==》物理执行图</p>
<p><strong>StreamGraph</strong>：根据用户通过stream api编写的代码生成的最初的图，用于表示程序的拓扑结构</p>
<p><strong>JobGraph</strong>：StreamGraph经过优化后生成了JobGraph，提交给JobManager的数据结构。主要的优化为：将多个符合条件的节点chain在一起作为一个节点，这样可以减少数据在节点之间流动所需要的序列化反序列化传输消耗</p>
<p><strong>ExecutionGraph</strong>：JobManager根据JobGraph生成ExecutionGraph。ExecutionGraph是JobGraph的并行化版本，是调度层最核心的数据结构</p>
<p><strong>物理执行图</strong>：JobManger根据ExecutionGraph对Job进行调度后，在各个TaskManager上部署task后形成的图，并不是一个具体的数据结构</p>
<p>关于这4层结构的演变，请看下图</p>
<p><img src="https://i.loli.net/2021/04/20/dKCgyGZs8T7npxD.png" alt="image-20210420184705028"></p>
<h3 id="2-3-1-StreamGraph"><a href="#2-3-1-StreamGraph" class="headerlink" title="2.3.1 StreamGraph"></a>2.3.1 StreamGraph</h3><p><img src="https://i.loli.net/2021/04/21/SpT8XcglsY3yh2n.png" alt="image-20210421103128221"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function --&gt;StreamOperator --&gt;Transformation --&gt; StreamNode</span><br><span class="line">其中每一个operator转换为transformation后会加入到env环境的transformations集合中，在调用env.execute()的时候，会遍历transformations集合，在遍历的时候会将transformation转换为streamNode，根据里面的streamNode构建StreamGraph</span><br><span class="line"></span><br><span class="line">也就是说我们的一个算子加上里面我们传的function参数会先编程StreamOperator，然后再变成Transformation，然后最终再变成一个StreamNode，最后根据整个程序的StreamNode就构建成了程序的StreamGraph。也就是说在我们的StreamGraph中每一个顶点就对应一个算子形成的StreamNode，里面会存储计算逻辑和并行度。StreamGraph中连接算子顶点（StreamNode）的叫做边（StreamEdge）</span><br></pre></td></tr></table></figure>

<p><strong>StreamEdge</strong></p>
<p><img src="https://i.loli.net/2021/04/21/sgxGUfTNdo625rD.png" alt="image-20210421103243739"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在StreamEdge类中，有两个对应上下游StreamNode的变量，其中sourceId就代表了上游顶点StreamNode，targetId就代表了下游顶点targetId。而对于StreamNode来说，作为输入的StreamEdge称之为入边，作为输出的StreamEdge称之为出边。</span><br></pre></td></tr></table></figure>



<h3 id="2-3-2-JobGraph"><a href="#2-3-2-JobGraph" class="headerlink" title="2.3.2 JobGraph"></a>2.3.2 JobGraph</h3><p><img src="https://i.loli.net/2021/04/21/vXjLFqhz276B3Id.png" alt="image-20210421103705490"></p>
<p>JobGraph：StreamGraph 经过优化后生成了 JobGraph，提交给 JobManager 的数据结构 </p>
<p>它包含的主要抽象概念有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、JobVertex：经过优化后符合条件的多个 StreamNode 可能会 chain 在一起生成一个 JobVertex，即一个JobVertex 包含一个或多个 operator，</span><br><span class="line">JobVertex 的输入是 JobEdge，输出是 IntermediateDataSet。</span><br><span class="line">2、IntermediateDataSet：表示 JobVertex 的输出，即经过 operator 处理产生的数据集。producer 是JobVertex，consumer 是 JobEdge。</span><br><span class="line">3、JobEdge：代表了job graph中的一条数据传输通道。source 是 IntermediateDataSet，target 是 JobVertex。即数据通过JobEdge由</span><br><span class="line">IntermediateDataSet传递给目标JobVertex。</span><br></pre></td></tr></table></figure>



<p>由StreamGraph转换为JobGraph过程中，最重要的是对StreamGraph进行了优化，优化的内容是：判断相邻的两个顶点是否满足一定的条件（有9个），如果满足一定的条件会合并为一个顶点。</p>
<p>原来的顶点叫做StreamNode，在JobGraph中顶点称之为JobVertex，边叫做JobEdge，其中JobEdge的下游是顶点，上游是Intermediate DataSet</p>
<p><strong>JobEdge</strong></p>
<p><img src="https://i.loli.net/2021/04/21/yYL9xQZjR7qwetF.png" alt="image-20210421104524080"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JobEdge的上游是IntermediateDataSet，也就是说IntermediateDataSet是JobEdge的生产者，下游是顶点JobVertex</span><br></pre></td></tr></table></figure>



<p><strong>JobVertex</strong></p>
<p><img src="https://i.loli.net/2021/04/21/QX5ovFq8mfZgSJO.png" alt="image-20210421104745418"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JobVertex的输入是JobEdge的集合inputs，输出是IntermediateDataSet的集合results,那一个JobVertex到底有多少个JobEdge和IntermediateDataSet呢，JobEdge的个数取决于有多少个输入流，输入流有多少个就有多少个JobEdge，输出流有多少个就有多少个IntermediateDataSet。大部分情况下，这两个集合的长度都是1</span><br></pre></td></tr></table></figure>



<p>然后客户端将生成的JobGraph提交给服务端</p>
<h3 id="2-3-3-ExecutionGraph"><a href="#2-3-3-ExecutionGraph" class="headerlink" title="2.3.3 ExecutionGraph"></a>2.3.3 ExecutionGraph</h3><p><img src="https://i.loli.net/2021/04/21/ucxqQPZ28hpO15R.png" alt="image-20210421105536739"></p>
<p>ExecutionGraph：JobManager(JobMaster) 根据 JobGraph 生成 ExecutionGraph。ExecutionGraph 是JobGraph 的并行化版本，是调度层最核心的数 据结构。 它包含的主要抽象概念有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、ExecutionJobVertex：和JobGraph中的JobVertex一一对应。每一个ExecutionJobVertex都有和并发度一样多的 ExecutionVertex。</span><br><span class="line">2、ExecutionVertex：表示ExecutionJobVertex的其中一个并发子任务，输入是ExecutionEdge，输出是IntermediateResultPartition。</span><br><span class="line">3、IntermediateResult：和JobGraph中的IntermediateDataSet一一对应。一个IntermediateResult包含多个IntermediateResultPartition，</span><br><span class="line">其个数等于该operator的并发度。</span><br><span class="line">4、IntermediateResultPartition：表示ExecutionVertex的一个输出分区，producer是ExecutionVertex，consumer是若干个ExecutionEdge。</span><br><span class="line">5、ExecutionEdge：表示ExecutionVertex的输入，source是IntermediateResultPartition，target是ExecutionVertex。source和target都只</span><br><span class="line">能是一个。</span><br><span class="line">6、Execution：是执行一个 ExecutionVertex 的一次尝试。当发生故障或者数据需要重算的情况下 ExecutionVertex 可能会有多个</span><br><span class="line">ExecutionAttemptID。一个 Execution 通过 ExecutionAttemptID 来唯一标识。JM和TM之间关于 task 的部署和 task status 的更新都是通过</span><br><span class="line">ExecutionAttemptID 来确定消息接受者。</span><br></pre></td></tr></table></figure>



<h3 id="2-3-4-物理执行图"><a href="#2-3-4-物理执行图" class="headerlink" title="2.3.4 物理执行图"></a>2.3.4 物理执行图</h3><p><img src="https://i.loli.net/2021/04/21/ASRJFPhwul52GHr.png" alt="image-20210421111138602"></p>
<p>物理执行图：JobManager 根据 ExecutionGraph 对 Job 进行调度后，在各个TaskManager 上部署 Task 后形成的“图”，并不是一个具体的数据结构。 它包含的主要抽象概念有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、Task：Execution 被调度后在分配的 TaskManager 中启动对应的 Task。Task 包裹了具有用户执行逻辑的 operator。</span><br><span class="line">2、ResultPartition：代表由一个 Task 的生成的数据，和 ExecutionGraph 中的 IntermediateResultPartition 一一对应。</span><br><span class="line">3、ResultSubpartition：是 ResultPartition 的一个子分区。每个 ResultPartition 包含多个 ResultSubpartition，其数目要由下游消费 Task数和 DistributionPattern 来决定。</span><br><span class="line">4、InputGate：代表 Task 的输入封装，和 JobGraph 中 JobEdge 一一对应。每个 InputGate 消费了一个或多个的 ResultPartition。</span><br><span class="line">5、InputChannel：每个 InputGate 会包含一个以上的 InputChannel，和 ExecutionGraph 中的 ExecutionEdge一一对应，也和</span><br><span class="line">ResultSubpartition 一对一地相连，即一个 InputChannel 接收一个 ResultSubpartition 的输出。</span><br></pre></td></tr></table></figure>





<h2 id="2-4-Flink-Job-3种运行模式"><a href="#2-4-Flink-Job-3种运行模式" class="headerlink" title="2.4 Flink Job 3种运行模式"></a>2.4 Flink Job 3种运行模式</h2><p>如果是flink standalone集群：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/flink run --target <span class="built_in">local</span> <span class="comment"># Local submission using a MiniCluster in Session Mode</span></span><br><span class="line">./bin/flink run --target remote <span class="comment"># Submission to an already running Flink cluster</span></span><br></pre></td></tr></table></figure>

<p>Flink 的 Job 部署模式有多种，支持 YARN、Kubernetes、Mesos，这里我们重点探讨 Flink On YARN</p>
<p><img src="https://i.loli.net/2021/04/21/w1UxBtvzQjRCh2f.png" alt="image-20210421113803870"></p>
<p>在图中可以看出，Flink 与 YARN 的关系与 MapReduce 和 YARN 的关系是一样的。Flink 通过 YARN 的接口实现了自己的 AppMaster。当在 YARN 中部 署了Flink，YARN 就会用自己的 Container 来启动 Flink 的 JobManager（也就是 AppMaster）和 TaskManager。 </p>
<p>Flink On YARN 有三种模式：</p>
<p>application模式时flink1.11后推出的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./bin/flink run --target yarn-session <span class="comment"># Submission to an already running Flink on YARN cluster</span></span><br><span class="line">./bin/flink run --target yarn-per-job <span class="comment"># Submission spinning up a Flink on YARN cluster in Per-Job</span></span><br><span class="line">Mode</span><br><span class="line">./bin/flink run-application --target yarn-application <span class="comment"># Submission spinning up Flink on YARN cluster in</span></span><br><span class="line">Application Mode</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/04/21/WXuNZDaiGkESzbx.png" alt="image-20210421114143530"></p>
<p>Session 模式：在 YARN 中初始化一个 Flink 集群，开辟指定的资源，之后我们提交的 Flink Jon 都在这个 Flink yarn-session 中，也就是说不管提交 多少个job，这些 job 都会共用开始时在 YARN 中申请的资源。这个 Flink集群会常驻在 YARN 集群中，除非手动停止。</p>
<p> Per-Job 模式：在 YARN 中，每次提交 job 都会创建一个新的 Flink 集群，任务之间相互独立，互不影响并且方便管理。任务执行完成之后创建的集 群也会消失。 所以每个 Job 执行完毕，Flink 集群关闭，释放资源。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>优点</th>
<th>缺点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Session模式</td>
<td>一次资源分配，多次 job 执行，充分利用 资源，Job 启动快</td>
<td>一直占据资源，可能导致连锁重启， JobManager负载大</td>
<td>小规模短时间运行的作业</td>
</tr>
<tr>
<td>Per-Job模式</td>
<td>资源分配粒度更细，方便单个 Job 的管理</td>
<td>当提交 Job 的 Client 集中的时候，会加重负载 （带宽和CPU消耗）</td>
<td>大规模长时间运行的作业</td>
</tr>
<tr>
<td>Application模式</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>具体可以参考官网：<a href="https://ci.apache.org/projects/flink/flink-docs-stable/deployment/cli.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-stable/deployment/cli.html</a></p>
<p> <a href="https://ci.apache.org/projects/flink/flink-docs-stable/deployment/cli.html#advanced-cli" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-stable/deployment/cli.html#advanced-cli</a></p>
<p> <a href="https://ci.apache.org/projects/flink/flink-docs-stable/deployment/resource-providers/yarn.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-stable/deployment/resource-providers/yarn.html</a> </p>
<p>Flink On YARN 不同的模式，其实入口是不一样的，总的来说是：ClusterEntryPoint，ClusterEntryPoint 是 Flink 集群模式的入口基类，它有三种实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.apache.flink.runtime.entrypoint.SessionClusterEntrypoint</span><br><span class="line">org.apache.flink.runtime.entrypoint.JobClusterEntrypoint</span><br><span class="line">org.apache.flink.client.deployment.application.ApplicationClusterEntryPoint</span><br></pre></td></tr></table></figure>

<p>其中 SessionClusterEntrypoint 又有四种实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.apache.flink.runtime.entrypoint.StandaloneSessionClusterEntrypoint</span><br><span class="line">org.apache.flink.mesos.entrypoint.MesosSessionClusterEntrypoint</span><br><span class="line">org.apache.flink.mesos.entrypoint.YarnSessionClusterEntrypoint</span><br><span class="line">org.apache.flink.mesos.entrypoint.KubernetesSessionClusterEntrypoint</span><br></pre></td></tr></table></figure>





<h2 id="2-5-Flink-选举和监听机制"><a href="#2-5-Flink-选举和监听机制" class="headerlink" title="2.5 Flink 选举和监听机制"></a>2.5 Flink 选举和监听机制</h2><p>Flink 的选举和监听机制，都是依托于 Curator 框架的 API 进行封装提供了的实现，具体涉及到的实现类包括：LeaderContender 和 LeaderElectionService 和 LeaderRetrievalService。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、LeaderContender 参选者 竞选者 （namenode1 namenoode2）</span><br><span class="line">2、LeaderElectionService 选举服务</span><br><span class="line">3、LeaderRetrievalService 监听服务</span><br></pre></td></tr></table></figure>

<p>在 Flink 中，封装了一个选举服务叫做：LeaderElectionService， 接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LeaderElectionService</span> </span>&#123;</span><br><span class="line"><span class="comment">// 启动选举，启动方法将竞争者作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(LeaderContender contender)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// 停止</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// 确认</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">confirmLeadership</span><span class="params">(UUID leaderSessionID, String leaderAddress)</span></span>;</span><br><span class="line"><span class="comment">// 判断是否拥有指定session下的leadership</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasLeadership</span><span class="params">(@Nonnull UUID leaderSessionId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LeaderContender 是 LeaderElectionService 中的参与选举的竞选者。它有四种实现：</p>
<p><img src="https://i.loli.net/2021/04/21/TOBy4hHkbMnjDVq.png" alt="image-20210421143410305"></p>
<p>这四个竞选者类中，都有一个 LeaderElectionService 的选举服务实例对象！完整的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、初始化选举对象 X，X 的内部拥有一个 LeaderElectionService 选举服务实例</span><br><span class="line">2、X 会在某个时机调用：leaderElectionService.start(this); 执行选举，此时 X &#x3D; this</span><br><span class="line">3、如果竞选成功，则会回调：LeaderContender.grantLeadership(sessionID) 方法</span><br><span class="line">4、正常来说，会有很多的服务应该是竞选成功才启动或者执行某些操作，这些业务代码，都在 grantLeadership 方法中进行定义</span><br></pre></td></tr></table></figure>

<p>LeaderElectionService 的默认实现是基于 ZooKeeper 的 DefaultLeaderElectionService。在 DefaultLeaderElectionService 的内部封装了一个 ZooKeeperLeaderElectionDriver 来执行选举和监听。ZooKeeperLeaderElectionDriver 是 FLink-1.12 版本的一个改进，优化了代码的阅读。但是整体 逻辑没变。当 ZooKeeperLeaderElectionDriver 去选举的时候，由内部的基于 Curator 的 LeaderLatch 来执行选举，并且注册了监听。实质上，当 Drvier 竞选成功了，则会执行监听回调：Driver.isLeader() 方法，否则回调 Driver.notLeader() 方法。 在 Driver.isLeader() 方法的内部，其实是在调用 LeaderContender.grantLeadership(sessionID) 方法！ </p>
<p>ZooKeeperLeaderRetrievalDriver 是 Flink 封装出来用来实现 ZooKeeper 监听功能的一个组件。请先看它的接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LeaderRetrievalService</span> </span>&#123;</span><br><span class="line"><span class="comment">// 开启监听</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(LeaderRetrievalListener listener)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// 结束监听</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 ZooKeeper 来说，监听的类型有三种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZooKeeper.getData(..., watcher) 注册 监听znode 节点变化的监听</span><br><span class="line">ZooKeeper.exists(...., watcher) 注册 监听znode 创建删除的监听</span><br><span class="line">ZooKeeper.getChildren(....., watcher) 注册 监听znode 子节点个数变化 的监听</span><br></pre></td></tr></table></figure>

<p>但是 Flink 并没有直接使用 ZooKeeper 的 API ，而是使用了 ZooKeeper 的一个 API 框架：Curator 去实现的：对应的监听是：</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>NodeCache</td>
<td>监听节点对应增，删，改操作</td>
</tr>
<tr>
<td>PathChildrenCache</td>
<td>监听节点下一级子节点的增，删，改操作</td>
</tr>
<tr>
<td>TreeCache</td>
<td>可以将指定的路径节点作为根节点，对其所有的子节点操作进行监听，呈现树形目录的监听</td>
</tr>
</tbody></table>
<p>如果 LeaderRetrievalService 通过 start(LeaderRetrievalListener ) 方法开启监听，则当发生事件响应的时候，会回调 start() 方法参数实例 LeaderRetrievalListener 的 notifyLeaderAddress() 方法。详细请看 LeaderRetrievalListener 的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LeaderRetrievalListener</span> </span>&#123;</span><br><span class="line"><span class="comment">// 监听回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyLeaderAddress</span><span class="params">(@Nullable String leaderAddress, @Nullable UUID leaderSessionID)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleError</span><span class="params">(Exception exception)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/04/21/RShFfKnvpVrDbge.png" alt="image-20210421145057181"></p>
<h3 id="2-5-1-JobManagerRunnerImpl"><a href="#2-5-1-JobManagerRunnerImpl" class="headerlink" title="2.5.1 JobManagerRunnerImpl"></a>2.5.1 JobManagerRunnerImpl</h3><p><img src="https://i.loli.net/2021/04/21/biHU64McFSBoKsl.png" alt="image-20210421145225469"></p>
<h3 id="2-5-2-WebMonitorEndpoint"><a href="#2-5-2-WebMonitorEndpoint" class="headerlink" title="2.5.2 WebMonitorEndpoint"></a>2.5.2 WebMonitorEndpoint</h3><p><img src="https://i.loli.net/2021/04/21/qpKQuaJn8WseBwE.png" alt="image-20210421145257616"></p>
<h3 id="2-5-3-JobManager的ResourceManager"><a href="#2-5-3-JobManager的ResourceManager" class="headerlink" title="2.5.3 JobManager的ResourceManager"></a>2.5.3 JobManager的ResourceManager</h3><p><img src="https://i.loli.net/2021/04/21/pmQMfIGVk4Nnuwg.png" alt="image-20210421145332752"></p>
<h3 id="2-5-4-DefaultDispatcherRunner"><a href="#2-5-4-DefaultDispatcherRunner" class="headerlink" title="2.5.4 DefaultDispatcherRunner"></a>2.5.4 DefaultDispatcherRunner</h3><p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210421145408451.png" alt="image-20210421145408451"></p>
<h2 id="2-6-HeartbeatMonitor和HeartbeatTarget"><a href="#2-6-HeartbeatMonitor和HeartbeatTarget" class="headerlink" title="2.6 HeartbeatMonitor和HeartbeatTarget"></a>2.6 HeartbeatMonitor和HeartbeatTarget</h2>
      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>Donate comment here</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="https://i.loli.net/2021/01/22/2p8ZleOfkJqT75w.png" alt="00后 微信支付"/>
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Flink/" rel="tag"># Flink</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/04/19/%E5%B0%9A%E5%BF%86%E6%95%99%E8%82%B2/%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB/10.%E9%80%9F%E8%AF%BB%E4%B8%8E%E5%9B%9E%E5%BF%86%E6%8F%90%E5%8D%87%E5%8F%8A%E6%8F%90%E5%8D%87%E8%A1%8C%E5%8A%A8%E5%8A%9B%E8%AE%B2%E8%A7%A3%E5%92%8C%E8%AE%AD%E7%BB%83/" rel="next" title="速读与回忆提升及提升行动力讲解和训练">
                <i class="fa fa-chevron-left"></i> 速读与回忆提升及提升行动力讲解和训练
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/04/20/%E5%A5%88%E5%AD%A6%E6%95%99%E8%82%B2/Flink/%E6%BA%90%E7%A0%81/1.1%E4%BD%BF%E7%94%A8Akka%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0FlinkStandalone%E9%9B%86%E7%BE%A4/" rel="prev" title="1.1使用Akka模拟实现FlinkStandalone集群">
                1.1使用Akka模拟实现FlinkStandalone集群 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://i.loli.net/2021/01/06/UpLEnikCWguPrz1.jpg"
                alt="00后" />
            
              <p class="site-author-name" itemprop="name">00后</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives%7C%7Carchive">
              
                  <span class="site-state-item-count">145</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zhanghanting" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/" target="_blank" title="weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>weibo</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://baidu.com/" title="百度" target="_blank">百度</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-课程内容"><span class="nav-number">1.</span> <span class="nav-text">1.课程内容</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Flink重要组件源码原理讲解"><span class="nav-number">2.</span> <span class="nav-text">2.Flink重要组件源码原理讲解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-Flink-RPC"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 Flink RPC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-Flink-RPC的底层实现：Akka"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1 Flink RPC的底层实现：Akka</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-使用akka模拟实现Flink-standalone"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2 使用akka模拟实现Flink standalone</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-深入理解Flink-RPC"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.3  深入理解Flink RPC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-4-Flink-RPC实例"><span class="nav-number">2.1.4.</span> <span class="nav-text">2.1.4 Flink RPC实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-RPCEndpoint"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 RPCEndpoint</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-JobManager的ResourceManager"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 JobManager的ResourceManager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-TaskManager的TaskExecutor"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2 TaskManager的TaskExecutor</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-Flink应用程序抽象"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 Flink应用程序抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-StreamGraph"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1 StreamGraph</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-JobGraph"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2 JobGraph</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-ExecutionGraph"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3.3 ExecutionGraph</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4-物理执行图"><span class="nav-number">2.3.4.</span> <span class="nav-text">2.3.4 物理执行图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-Flink-Job-3种运行模式"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 Flink Job 3种运行模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-Flink-选举和监听机制"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 Flink 选举和监听机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-JobManagerRunnerImpl"><span class="nav-number">2.5.1.</span> <span class="nav-text">2.5.1 JobManagerRunnerImpl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-WebMonitorEndpoint"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.5.2 WebMonitorEndpoint</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-3-JobManager的ResourceManager"><span class="nav-number">2.5.3.</span> <span class="nav-text">2.5.3 JobManager的ResourceManager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-4-DefaultDispatcherRunner"><span class="nav-number">2.5.4.</span> <span class="nav-text">2.5.4 DefaultDispatcherRunner</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-HeartbeatMonitor和HeartbeatTarget"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 HeartbeatMonitor和HeartbeatTarget</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">00后</span>

  
</div>

<!--
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>
-->



        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: '7HjF3J8nerPuC6IIPSTD2MyU-gzGzoHsz',
        appKey: 'HON17u5VRHg6TQoMXv4qzkYT',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  <!-- 动态背景-->
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
